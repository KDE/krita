Krita 2.0 -- A Technical Overview

<p>This document describes the architecture of Krita for prospective developers
and plugin writers. It is intended to become part of our manual, just like the
plugin howto was part of the 1.x manual.</p>

<p>Note that while the architecture of Krita 2.0 is reasonably stable by now
and development has gone into finish-the-features-release-the-bally-thing mode,
the nature of software development, especially free and open source software
development is such that documentation will of necessity lag behind a moving
target. If you have questions not answered by this document or notice errors
or anachronisms, please contact the Krita developers, either through our
website, our mailing list or contact us on irc:</p>

<p>http://www.krita.org</p>
<p>kimageshop-devel@kde.org</p>
<p>#koffice on irc.freenode.org</p>

<p>(Historical note: Krita started life as KImageShop, was renamed to Krayon
and then, for legal reasons, renamed again to Krita</p>

<h1>Seagull's Overview</h1>

<p>Krita is a raster graphics application built on the Qt, KDE and KOffice
platform libraries. The design goals of Krita are as follows:</p>

<ul>
<li>Enable the user to work with layered raster graphics of any sizei</li>
<li>Enable the user to create original art</li>
<li>Enable the user to work in any colorspace</li>
<li>Be flexible and extensible for developers</li>
<li>Be fun to hack on for developers</li>
</ul>

<p>Krita depends on two essential KOffice libraries:</>

<ul>
<li>Pigment (koffice/libs/pigment): handles colorspaces
<li>Flake (koffice/libs/flake): handles tools and user interaction and integrates 
fine-grained objects such as vector graphics or rich text in Krita.</li>
</ul>

<p>Most functionality in Krita is extensible through plugins:</p>

<ul>
<li>Colorspaces (through pigment): for example, grayscale, rgb, lms, cmyk, lab, xyz
<li>Content objects (through flake): for example: text, vector, charts
<li>Tools (krita/plugins/tools): for example: freehand filter, select-by-color, fill tool
<li>Brush engines (krita/plugins/paintops): for example: soft brush, chinese brush, smudge
<li>Filters (krita/plugins/filters): for example: sharpen, unsharp mask
<li>Generators (krita/plugins/generators): for example: fractal, solid color, pattern
<li>User interface additions (krita/plugins/viewplugins): for example: rescale, scripting
</ul>

<p>(Note that the painterly framework plugin (krita/plugins/painterlyframework) 
is a meta-plugin that contains plugins of many types. Also note that brush-type
plugins (as opposed to brush engine plugins) are a work-in-progress and part of
research into making resource types plugins.)</p>

<p>Krita itself consists of two libraries: the core functionality in krita/image
and the user interface in krita/ui.</p>

<h2>KritaImage</h2>

<p>KritaImage provides Krita with its core functionality: a paint system, paint devices,
a plugin system to load various plugins, metadata support and code to handle several kinds 
of image manipulations such as transforms.</p>

<h3>Paint Devices and Painters</h3>

<p>A paint device (KisPaintDevice) is a rectangular area of pixels. A paint device
is autoextending: it starts very small (64x64 pixels) and grows whenever pixels outside
its original area are written to. A paint device has a certain colorspace, such as
rgba, graya or laba.</p>

<p>You can change the contents of a paint device in four ways:</p>

<ul>
<li>By reading bytes in from a .kra file: KisPaintDevice::read()
<li>By reading in a chunk of memory that can be interpreted as pixels: KisPaintDevice::fill()
or KisPaintDevice::readBytes()
<li>By opening a non-const iterator or accessor: KisPaintDevice::createRectIterator() and similar
<li>Through KisPainter, KisFillPainter, KisGradientPainter or KisConvolutionPainter (these
use iterators/accessors themselves
</ul>

<h3>Tile System</h3>

<p><tt>koffice/krita/image/tiles</tt></p>

<p>The tile system is the core of Krita. The tile system is responsible for:</p>

<ul>
<li>storing the pixel data of a paint device in memory or in a swap file if memory is 
being exhausted.
<li>retrieving the pixel data of a paint device
<li>store undo data for a paint device
</ul>

<p>Tile systems are not plugins: the overhead of calling virtual methods for all
pixel access is prohibitive. There are currently two tile systems available: the 1.6
one (which is still default) and a new tile system that should give better performance
and more thread-safety. In theory, it should be possible to develop a tile system that
doesn't use tiles at all, but scanlines or a single memory buffer. However, implementing
the autogrowing feature of paint devices when using scanlines or a single memory
buffer would entail lots and lots of memory allocating and copying.</p>

<p>The current tile backends store image data in tiles of 64x64 pixels. The tiles
can optionally be compressed when not used for some time and stored in a swap file
when Krita is running out of memory. The undo system stores copies of entire tiles.</p>

<p>The main interface of the tile system is <a href="http://websvn.kde.org/trunk/koffice/krita/image/kis_datamanager.h?view=markup">KisDataManager</a>. Additionally, iterators and accessors
are defined: <a href="http://websvn.kde.org/trunk/koffice/krita/image/kis_iterator.h?view=markup">kis_iterator.h</a> and <a href="http://websvn.kde.org/trunk/koffice/krita/image/kis_random_accessor.h?view=markup">kis_random_accessor.h</a>. Undo data is exposed through <a href="http://websvn.kde.org/trunk/koffice/krita/image/tiles/kis_memento.h?revision=703546&view=markup">KisMemento</a>.</p>


<h3>Images and Nodes</h3>


<h3>Resources</h3>

<h3>Registries</h3>

<h3>Metadata</h3>



<h2>KritaUi</h2>


<h1>Changes Compared to Krita 1.6</h1>

<h1>Plugins</h1>


<h2>Colorspaces</h2>
<h2>Content objects</h2>
<h2>Tools</h2>
<h2>Brush Engines</h2>
<h2>Pixel Processors</h2>
<h3>Filters</h3>
<h3>Generators</h3>
<h2>User Interface Add-ons</h2>
<h2>Resource type plugins</h2>
