From f31141eb0636b94ebe90ae60a6c0b07a771769cd Mon Sep 17 00:00:00 2001
From: Dmitry Kazakov <dimula73@gmail.com>
Date: Thu, 3 Sep 2020 15:19:59 +0300
Subject: [PATCH 27/47] Pass proper dirty rect in paint event to QOpenGLWidget
 with partial updates

When QOpenGLWidget has partial updates enabled, there is no reason to
render entire scene on every frame. Instead, the widget may rerender
only a portion of it. All the data has been cached by Qt in the internal
framebuffer object. This limiting is necessary when rendering a complex
scene on 4k display. See https://bugs.kde.org/show_bug.cgi?id=413504

The patch adds a special flag into QWidgetPrivate to notify
QWidgetBackingStore that this widget needs proper tracking of
the dirty region.

Theoretically, flushing of the textures could also be limited to
the dirty region, but it is a different task.
---
 src/widgets/kernel/qopenglwidget.cpp       |  1 +
 src/widgets/kernel/qwidget.cpp             |  1 +
 src/widgets/kernel/qwidget_p.h             |  1 +
 src/widgets/kernel/qwidgetbackingstore.cpp | 34 +++++++++++++++++-----
 4 files changed, 29 insertions(+), 8 deletions(-)

diff --git a/src/widgets/kernel/qopenglwidget.cpp b/src/widgets/kernel/qopenglwidget.cpp
index 36eae9f9db..7a0f4f2440 100644
--- a/src/widgets/kernel/qopenglwidget.cpp
+++ b/src/widgets/kernel/qopenglwidget.cpp
@@ -1036,6 +1036,7 @@ void QOpenGLWidget::setUpdateBehavior(UpdateBehavior updateBehavior)
 {
     Q_D(QOpenGLWidget);
     d->updateBehavior = updateBehavior;
+    d->renderToTextureWithPartialUpdates = updateBehavior == PartialUpdate;
 }
 
 /*!
diff --git a/src/widgets/kernel/qwidget.cpp b/src/widgets/kernel/qwidget.cpp
index 85fa2ffe39..79be7a1f88 100644
--- a/src/widgets/kernel/qwidget.cpp
+++ b/src/widgets/kernel/qwidget.cpp
@@ -271,6 +271,7 @@ QWidgetPrivate::QWidgetPrivate(int version)
       , usesDoubleBufferedGLContext(0)
       , mustHaveWindowHandle(0)
       , renderToTexture(0)
+      , renderToTextureWithPartialUpdates(0)
       , textureChildSeen(0)
 #ifndef QT_NO_IM
       , inheritsInputMethodHints(0)
diff --git a/src/widgets/kernel/qwidget_p.h b/src/widgets/kernel/qwidget_p.h
index e541cb70e4..8c3bd88ddf 100644
--- a/src/widgets/kernel/qwidget_p.h
+++ b/src/widgets/kernel/qwidget_p.h
@@ -772,6 +772,7 @@ public:
     uint usesDoubleBufferedGLContext : 1;
     uint mustHaveWindowHandle : 1;
     uint renderToTexture : 1;
+    uint renderToTextureWithPartialUpdates : 1;
     uint textureChildSeen : 1;
 #ifndef QT_NO_IM
     uint inheritsInputMethodHints : 1;
diff --git a/src/widgets/kernel/qwidgetbackingstore.cpp b/src/widgets/kernel/qwidgetbackingstore.cpp
index d5b613a4e5..8b29a4edeb 100644
--- a/src/widgets/kernel/qwidgetbackingstore.cpp
+++ b/src/widgets/kernel/qwidgetbackingstore.cpp
@@ -557,8 +557,14 @@ void QWidgetBackingStore::markDirty(const QRegion &rgn, QWidget *widget,
     const QPoint offset = widget->mapTo(tlw, QPoint());
 
     if (QWidgetPrivate::get(widget)->renderToTexture) {
-        if (!widget->d_func()->inDirtyList)
+        if (!widget->d_func()->inDirtyList) {
             addDirtyRenderToTextureWidget(widget);
+            if (QWidgetPrivate::get(widget)->renderToTextureWithPartialUpdates)
+                widget->d_func()->dirty = rgn;
+        } else if (QWidgetPrivate::get(widget)->renderToTextureWithPartialUpdates) {
+                widget->d_func()->dirty += rgn;
+        }
+
         if (!updateRequestSent || updateTime == UpdateNow)
             sendUpdateRequest(tlw, updateTime);
         return;
@@ -646,16 +652,24 @@ void QWidgetBackingStore::markDirty(const QRect &rect, QWidget *widget,
         return;
     }
 
+    const QRect widgetRect = widget->d_func()->effectiveRectFor(rect);
+
     if (QWidgetPrivate::get(widget)->renderToTexture) {
-        if (!widget->d_func()->inDirtyList)
+        if (!widget->d_func()->inDirtyList) {
             addDirtyRenderToTextureWidget(widget);
+            if (QWidgetPrivate::get(widget)->renderToTextureWithPartialUpdates)
+                widget->d_func()->dirty = widgetRect;
+        } else if (QWidgetPrivate::get(widget)->renderToTextureWithPartialUpdates &&
+                   !qt_region_strictContains(widget->d_func()->dirty, widgetRect)) {
+
+                widget->d_func()->dirty += widgetRect;
+        }
+
         if (!updateRequestSent || updateTime == UpdateNow)
             sendUpdateRequest(tlw, updateTime);
         return;
     }
 
-
-    const QRect widgetRect = widget->d_func()->effectiveRectFor(rect);
     QRect translatedRect = widgetRect;
     if (widget != tlw)
         translatedRect.translate(widget->mapTo(tlw, QPoint()));
@@ -1321,18 +1335,22 @@ void QWidgetBackingStore::doSync()
         // prevent triggering unnecessary backingstore painting when only the
         // OpenGL content changes. Check if we have such widgets in the special
         // dirty list.
-        QVarLengthArray<QWidget *, 16> paintPending;
+        QVarLengthArray<QPair<QWidget *, QRegion>, 16> paintPending;
         const int numPaintPending = dirtyRenderToTextureWidgets.count();
         paintPending.reserve(numPaintPending);
         for (int i = 0; i < numPaintPending; ++i) {
             QWidget *w = dirtyRenderToTextureWidgets.at(i);
-            paintPending << w;
+            paintPending << qMakePair(w,  w->d_func()->dirty);
             resetWidget(w);
         }
         dirtyRenderToTextureWidgets.clear();
         for (int i = 0; i < numPaintPending; ++i) {
-            QWidget *w = paintPending[i];
-            w->d_func()->sendPaintEvent(w->rect());
+            QWidget *w = paintPending[i].first;
+            const QRegion dirtyRegion = paintPending[i].second.isEmpty() ? QRegion(w->rect()) : paintPending[i].second;
+
+            w->d_func()->sendPaintEvent(dirtyRegion);
+
+
             if (w != tlw) {
                 QWidget *npw = w->nativeParentWidget();
                 if (hasPlatformWindow(w) || (npw && npw != tlw)) {
-- 
2.20.1.windows.1

