#@gmic
#
#  File        : gmic_def.gmic
#                ( G'MIC commands file )
#
#  Description : Define the set of standard G'MIC commands, as well as
#                the filters for the G'MIC plug-in for GIMP, and for the
#                web service G'MIC Online.
#                ( http://gmic.eu )
#                This file is also a part of the CImg Library project.
#                ( http://cimg.sourceforge.net )
#
#  Copyright   : David Tschumperle
#                ( http://tschumperle.users.greyc.fr/ )
#
#  License     : CeCILL v2.0
#                ( http://www.cecill.info/licences/Licence_CeCILL_V2-en.html )
#
#  This software is governed by the CeCILL  license under French law and
#  abiding by the rules of distribution of free software.  You can  use,
#  modify and/ or redistribute the software under the terms of the CeCILL
#  license as circulated by CEA, CNRS and INRIA at the following URL
#  "http://www.cecill.info".
#
#  As a counterpart to the access to the source code and  rights to copy,
#  modify and redistribute granted by the license, users are provided only
#  with a limited warranty  and the software's author,  the holder of the
#  economic rights,  and the successive licensors  have only  limited
#  liability.
#
#  In this respect, the user's attention is drawn to the risks associated
#  with loading,  using,  modifying and/or developing or reproducing the
#  software by the user in light of its specific status of free software,
#  that may mean  that it is complicated to manipulate,  and  that  also
#  therefore means  that it is reserved for developers  and  experienced
#  professionals having in-depth computer knowledge. Users are therefore
#  encouraged to load and test the software's suitability as regards their
#  requirements in conditions enabling the security of their systems and/or
#  data to be ensured and,  more generally, to use and operate it in the
#  same conditions as regards security.
#
#  The fact that you are presently reading this means that you have had
#  knowledge of the CeCILL license and that you accept its terms.
#

#------ Syntax rules for a G'MIC command file :
#
#*** General syntax :
#
# - Each line starting with 'command_name :' starts a new definition of the G'MIC custom command '-command_name'.
# - Each line starting with '#' is a comment line.
# - Any other line is considered as the continuation of a previously started G'MIC custom command.
#
#*** Specific rules for 'gmic' (command-line interpreter) :
#
# - A comment line starting with '#@gmic' will be parsed by 'gmic' in order to display help for
#    G'MIC custom commands (when invoked with option '-h'). More precisely :
#
#      _ '#@gmic :: subsection' defines a new command subsection in the displayed help.
#      _ '#@gmic command_name : arguments_format1 : arguments_format2 : ... : (qualifier)'
#        starts a new command description.
#      _ '#@gmic : description' add a new description line to the current command description.
#
#*** Specific rules for 'gmic_gimp' (plug-in for GIMP) :
#
# - A comment line starting with '#@gimp' will be parsed by the GIMP plug-in to define the filters tree.
# - A comment line starting with '#@gimp_xx' will define a filter only for a specific language 'xx'
#    (e.g. 'en','fr'...).
# - More precisely, the syntax of a '#@gimp' comment line is :
#
#    '#@gimp Folder name'
#
# or
#
#    '#@gimp Command name : command, preview_command, parameter = typedef, parameter2 = typedef'
#    '#@gimp : parameter3 = typedef, parameter4 = typedef ...., parameterN = typedef'
#
#   where :
#
#      'command' is the G'MIC command name called to process the image.
#
#      'preview_command' is the G'MIC command name called to process the preview.
#
#           Note that you can optionally specify a float-valued factor>=0 between parentheses at the end of
#           the 'preview_command' to force the default zoom factor used by the GIMP preview for this filter.
#           Use (0) for a 1:1 preview, (1) for previewing the whole image, (2) for 1/2 image and so on...
#
#      'parameter = typedef' tells about the names, types and default values of the filter parameters.
#
#           'typedef' can be :
#
#      _ 'bool(default_value={ 0 | 1 | false | true })'   : Add a boolean parameter (0 or 1) (as a checkbutton).
#      _ 'button(_alignment)'                             : Add a boolean parameter (0 or 1) (as a button).
#      _ 'choice(_default_indice,Choice0,..,ChoiceN)'     : Add a integer parameter (as a combobox).
#      _ 'color(defaultR,defaultG,defaultB,_defaultA)'    : Add R,G,B[,A] parameters (as a colorchooser).
#      _ 'const(value)'                                   : Add a constant parameter (not displayed).
#      _ 'file(_default_filename)'                        : Add a filename parameter (as a filechooser).
#      _ 'float(default_value,min_value,max_value)'       : Add a float-valued parameter (as a float slider).
#      _ 'folder(_default_foldername)'                    : Add a foldername parameter (as a folderchooser).
#      _ 'int(default_value,min_value,max_value)'         : Add a integer parameter (as an integer slider).
#      _ 'link(_alignment,_label,URL)'                    : Display a URL (do not add a parameter).
#      _ 'note(_label)'                                   : Display a label (do not add a parameter).
#      _ 'text(_is_multiline={ 0 | 1 },_default text)'    : Add a single or multi-line text parameter (as a text entry).
#      _ 'separator()'                                    : Display an horizontal separator (do not add a parameter).
#
#   Type separators '()' can be replaced by '[]' or '{}' if necessary (for instance if parentheses are required in
#   an argument of the typedef, e.g in a text). You can also replace 'typedef' by '_typedef' to tell the plug-in not
#   to update the image preview when the corresponding parameter is modified.
#
#   Use '_none_' as a special command or preview_command to tell the plug-in that the entry requires no G'MIC call.
#
#   A G'MIC command can return new values for each parameter of the filter, into the status (see command '-status').
#   To do so, the returned status must follow the syntax : {params1}{params2}{..}{paramsN} where N must be exactly
#   equal to the number of parameters for the current filter.
#
#   A G'MIC command can also specify the blending mode, the opacity and the position of each of the output image
#   (i.e. layer in the plug-in). To do so, set the image name to something like 'mode(grainmerge),opacity(50),pos(30,50)'.
#     - Blending mode name should be the same as the argument of the '-blend' command.
#     - Opacity is a float number in [0,100].
#     - X and Y positions are integers.
#
#*** Specific rules for 'gmicol' (G'MIC web service) :
#
# - Same rules as for 'gmic_gimp', except that comment lines start with '#@gmicol'.
#
#-----------------------------------------------------------------------------------------------------------------------

#---------------------------------
#
#@gmic :: Global options
#
#---------------------------------

# This command is run when the cli tool 'gmic' is invoked without arguments on the command line.
cli_noarg :
  -v + -version
  -e[] "[gmic] No commands, options or data provided (type 'gmic -h' to get help)."
  -if {@{!,u}>0} -e[] "[gmic] Running in demo mode." -v - -demo , -e[] ""
  -else -e[] "\n"
  -endif -v -

#@gmic debug : (+)
#@gmic : Activate debug mode.
#@gmic : When activated, the G'MIC interpreter becomes very verbose and outputs additionnal log
#@gmic : messages about its internal state on the standard output (stdout).
#@gmic : This option can be useful when debugging the execution of a custom command.

#@gmic h : eq. to '-help'.
h :
  -help $*

#@gmic help : command : (no arg)
#@gmic : Display help (optionally for specified command only) and exit.
#@gmic : (eq. to '-h').
help : -skip ${1=""},${2=1}
  -if {!@#} -return -endif
  -y -a y
  --_help $1,$2 -k[0]
  -if {narg(@{})} -_help[0] @{},0 -endif # In case of shortcut, display also help for shortcut command.
  -rm

_help : -skip ${1=""}
  -v -1 -use_vt100
  -if {!narg("$1")} _is_example=0 -__help ascii -v + -e[] "" -v - -rm -u "" -return -endif # Global help.
  ({'"$1"'}) -autocrop[-1] {'-'}
  -if {@{-1,100%}=={']'}" && "i!={'['}} -l[-1] -s -,{'['} -k[0] -endl -endif
  command=@{-1,t} -rm[-1]

  # Help requested for a specific command.
  ks0="0" ks1="-k[0]"
  -if $2 -__help_header_ascii[] -endif
  -r 1,{h+1},1,1,0,0,0,1
  -s +,{'"#@gmic "$command" :"'} -s +,{'"#@gmic "$command":"'} -s +,{'"#@gmic "$command"\n"'}
  -if {@#==1}
    -l[] -m "foo : -"$command # Detect command misspelling.
      -repeat 16 -uncommand $command -done # Be sure the specified command does not exist anymore !
      -foo -uncommand foo
    -onfail ({'@{}'}) -s -,{'" (did you mean "'} -if {@#>1} -s[1] -,39 -k[1] misspelling=@{-1,t} -endif -rm
    -endl
    -if {narg($misspelling)} misspelling=" (did you mean '"$misspelling"' ?)" -endif
    -v + -e[] "\n[gmic] Command '"$command"' has no description"$misspelling". Try 'gmic -h' for global help.\n\n" -v -
    -rm -u "" -return
  -endif
  -rm[0] -a y -s -,10
  stopflag=0
  _is_example=0
  -_document_gmic_header_ascii[] 0
  -repeat @# -l[$>] -if {h>7" && "{@{-1,0-5}'=='{'"#@gmic"'}}}
    -rows 7,100% -autocrop {'" "'}  # Discard '#@gmic'.
    -if {i!={':'}} # Command declaration.
      -s -,{'": "'} -autocrop {'" "'} -autocrop {':'} -autocrop {'" "'}
      -if {@{0,t}'=='$command}
        -_document_gmic_declaration_ascii
        -if $_shortcut  # Found shortcut command.
          -v + -e[] "\n    "$_gmic_m$_gmic_b"-"$command":"$_gmic_n$_gmic_m" Equivalent to '"$_gmic_b$_shortcutlink0$_gmic_n"'." -v -
          -u $_shortcutlink0 -return
        -endif
        -else stopflag=1
      -endif
    -else
      -rows 1,100% # Discard ':' char.
      -if {i=={':'}} stopflag=1 # Subsection
      -else
        _is_tutorial=
        -autocrop {'" "'}
        -if {i=={'$'}} # Example of use.
          -rows 1,100% -autocrop {'" "'} # Discard '$' character.
          -if {i=={'$'}} # Tutorial page.
             -v + -e[] "" -v -
             -if {h==1&&i=={'$'}} tuturl=http://gmic.eu/tutorial/_$command.shtml
             -else -autocrop {'$'} -autocrop {'" "'} tuturl=http://gmic.eu/tutorial/@{0,t}.shtml
             -endif
             -rm ({'$_gmic_c${_gmic_b}"Tutorial:"$_gmic_n$_gmic_c" "$tuturl'}) -y
             _is_tutorial=1
          -else # Regular example.
            -if $_is_example -i[0] ({'"         "'})
            -else -i[0] ({'"\n        "$_gmic_c${_gmic_b}"Example: "$_gmic_n$_gmic_c'}) _is_example=1 -endif
            -y[0] -a y
          -endif
        -endif
        -_document_gmic_description_ascii
      -endif
    -endif
  -else stopflag=1 -endif ${ks{@#!=0}} -endl -if $stopflag -break -endif -done
  -v + -e[] $_gmic_n"\n" -v - -rm
  -u ""

# Display global help.
__help :
  -m "_help_section : -_help_section_$1 \"$""1\""
  -m "_help_paragraph : -_help_paragraph_$1 \"$""1\""
  -_help_header_$1[]
  -_help_usage[]
  -s -,{'__help_end\ :'} -k[0] # Avoid parsing code for GIMP filters.
  -document_gmic $1,"img/",0
  -_help_examples[]
  -_help_footer_$1[]

# Command to write general usage (used by all types of output).
_help_usage :
  -m "GMIC : -u ${_gmic_g}G\47MIC$_gmic_n"
  g=$_gmic_g c=$_gmic_c n=$_gmic_n

  -_help_paragraph " "$c${b}"gmic [command1 [arg1_1,arg1_2,..]] .. [commandN [argN_1,argN_2,..]]"$n"
\n
\n '"${g}"gmic"$n"' is an open-source interpreter of the "@{-GMIC}" language, a script-based programming
\n  language dedicated to the design of "${g}"image processing pipelines"$n". It can be used to convert,
\n  manipulate, filter and visualize datasets made of one or several 1d/2d or 3d multi-
\n  spectral images.
\n
\n This documentation proposes a complete description of the "@{-GMIC}" language basics and rules."

  -_help_section "Overall context"

  -_help_paragraph "  - At any time, "@{-GMIC}" manages one list of numbered (and optionally named) pixel-based
\n     images, entirely stored in computer memory.
\n  - The first image of the list has indice '0' and is denoted by '"$c"[0]"$n"'. The second image of
\n     the list is denoted by '"$c"[1]"$n"', the third by '"$c"[2]"$n"' and so on.
\n  - Negative indices are treated in a periodic way: '"$c"[-1]"$n"' refers to the last image of the
\n     list, '"$c"[-2]"$n"' to the penultimate one, etc. Thus, if the list has 4 images, '"$c"[1]"$n"' and '"$c"[-3]"$n"'
\n     both designate the second image of the list.
\n  - A named image may be indicated by '"$c"[name]"$n"', if 'name' uses the characters set [a-zA-Z0-9_] and
\n     does not start with a number. Image names can be set or reassigned at any moment during
\n     the processing pipeline (see commands '"$c"-name"$n"' and '"$c"-input"$n"' for this purpose).
\n  - "@{-GMIC}" defines a set of various commands and substitution mechanisms to allow the design
\n     of complex pipelines managing this list of images, in a very flexible way:
\n     You can insert or remove images in the list, rearrange image indices, process images
\n     (individually or as a group), merge image data together and output image files.
\n  - Such a pipeline can be written itself as a custom "@{-GMIC}" command storable in a custom
\n     commands file, and can be re-used afterwards in another bigger pipeline if necessary."

  -_help_section "Image definition and terminology"

  -_help_paragraph "  - In "@{-GMIC}", an image is modeled as a 1d, 2d, 3d or 4d array of scalar values, uniformly
\n     discretized on a rectangular/parallelepipedic domain.
\n  - The four dimensions of these arrays are respectively denoted by:
\n    . '"${g}"width"$n"', the number of image columns (size along the "$g"'x'-axis"$n").
\n    . '"${g}"height"$n"', the number of image rows (size along the "$g"'y'-axis"$n").
\n    . '"${g}"depth"$n"', the number of image slices (size along the "$g"'z'-axis"$n").
\n        The depth is equal to 1 for usual 2d color or grayscale images.
\n    . '"${g}"spectrum"$n"', the number of image channels (size along the "$g"'c'-axis"$n").
\n        The spectrum is respectively equal to 3 and 4 for usual RGB and RGBA color images.
\n  - There are no limitations on the size of each image dimension. For instance, the number of image
\n     slices or channels can be of arbitrary size within the limits of available memory.
\n  - The "${g}"width, height"$n" and "${g}"depth"$n" of an image are considered as '"${g}"spatial"$n"' dimensions, while the
\n     "${g}"spectrum"$n" has a '"${g}"multi-spectral"$n"' meaning. Thus, a 4d image in "@{-GMIC}" should be most often
\n     regarded as a 3d dataset of multi-spectral voxels. Most of the "@{-GMIC}" commands will stick
\n     with this idea (e.g. command '-blur' will blur images only along the 'xyz' axes).
\n  - "@{-GMIC}" internally stores all its images as buffers of '"${g}"float"$n"' values (32 bits,
\n    value range "$g"[-3.4E38,+3.4E38]"$n"). It performs all its image processing operations with
\n    floating point numbers. Each image pixel is thus represented with 32bits/channel.
\n  - Considering '"${g}"float"$n"'-valued pixels ensure to keep the numerical precision when executing image
\n     processing pipelines. For image input/output operations, you may want to prescribe the image
\n     datatype to be different than '"${g}"float"$n"' (like '"${g}"bool"$n"', '"${g}"char"$n"', '"${g}"int"$n"', etc...).
\n     This is possible by specifying the desired datatype as a file option when using I/O commands."

  -_help_section "Items of a processing pipeline"

  -_help_paragraph "  - In "@{-GMIC}", an image processing pipeline is described as a "${g}"sequence of items"$n" separated by
\n     the space character ' '. Such items are interpreted and executed from the left to the
\n     right. For instance, the expression:
\n\n       "${c}"input.jpg -blur 3,0 -sharpen 10 -resize 200%,200% -output output.jpg"$n"\n
\n     defines a valid pipeline composed of nine "@{-GMIC}" items.
\n  - Each "@{-GMIC}" item is a string which represents either a command, a sequence of command arguments,
\n     a filename, or a special input string.
\n  - Escape characters '"$g"\\"$n"' and double quotes '"$g"\""$n"' can be used to define items containing
\n     spaces or special characters. For instance, the two strings
\n     '"${c}"single\\ item"$n"' and '"${c}"\"single item\""$n"' define the same item, with a space in it."

  -_help_section "Input data items"

  -_help_paragraph "  - If a specified "@{-GMIC}" item appears to be an existing "${g}"filename"$n", the corresponding image
\n     data are loaded and inserted at the end of the image list.
\n  - Special filenames '"$g"-"$n"' and '"$g"-.ext"$n"' stand for the standard input/output streams, optionally
\n     forced to be in a specific '"${g}"ext"$n"' file format (e.g. '"$c"-.jpg"$n"' or '"$c"-.png"$n"').
\n  - The following special input strings may be used as "@{-GMIC}" items to create and insert new
\n     images with prescribed values, at the end of the image list:
\n    . '"$g"[selection]"$n"' or '"$g"[selection]xN"$n"': Insert 1 or N copies of selected existing images.
\n       '"${g}"selection"$n"' may contain one or several images (see next section for details).
\n    . '"${g}"width[%],_height[%],_depth[%],_spectrum[%],_values"$n"': Insert a new image with
\n       specified size and values (adding '"$g"%"$n"' to a dimension means 'percentage of the size
\n       along the same axis, taken from the last image '"$g"[-1]"$n"''). Any specified dimension
\n       can be also written as '"$g"[image]"$n"', and is then set to the size (along the same axis)
\n       of the existing specified image "$g"[image]"$n". '"${g}"values"$n"' can be either a sequence of numbers
\n       separated by commas '"$g","$n"', or a mathematical expression, as e.g. in input item
\n       '"${c}"256,256,1,3,if(c==0,x,if(c==1,y,0))"$n"' which creates a 256x256 RGB color image with a
\n       spatial shading on the red and green channels.
\n    . '"$g"(v1,v2,..)"$n"': Insert a new image from specified prescribed values.
\n       Value separator inside parentheses can be '"$g","$n"' (column separator), '"$g";"$n"' (row sep.),
\n       '"$g"/"$n"' (slice sep.) or '"$g"^"$n"' (channel sep.). For instance, expression
\n       '"$c"(1,2,3;4,5,6;7,8,9)"$n"' creates a 3x3 matrix (scalar image), with values running from 1 to 9.
\n    . '"${g}"0"$n"': Insert a new 'empty' image, containing no pixel data. Empty images are used only
\n       in rare occasions.
\n  - Input item '"${g}"name=value"$n"' declares a new local or global variable '"${g}"name"$n"', or assign a new
\n     value to an existing variable. Variable names use characters set [a-zA-Z0-9_] and cannot
\n     start with a number. A variable definition is always local to the current command except
\n     when it starts by the underscore character '"${g}"_"$n"'. In that case, it becomes also accessible
\n     by any command invoked outside the current command scope (global variable).
\n  - If the name of a variable starts with two underscores '"${g}"__"$n"', the global variable is also shared
\n     among different threads and can be read/set by commands running in parallel (see command
\n     '-parallel'). Otherwise, it remains local to the thread that defined it."

  -_help_section "Command items and selections"

  -_help_paragraph "  - A "@{-GMIC}" item starting by '"$g"-"$n"' designates a "${g}"command"$n", most of the time. Generally, commands
\n     perform image processing operations on one or several available images of the list.
\n  - Very common commands have two equivalent names ("${g}"regular"$n" and "${g}"short"$n"). For instance, command
\n     names '"$c"-resize"$n"' and '"$c"-r"$n"' refer to the same image resizing action.
\n  - A "@{-GMIC}" command may have mandatory or optional "${g}"arguments"$n". Command arguments must be
\n     specified in the next item on the command line. Commas '"$g","$n"' are used to separate multiple
\n     arguments when required.
\n  - The execution of a "@{-GMIC}" command may be restricted only to a "${g}"subset"$n" of the image list, by
\n     appending '"$c"[selection]"$n"' to the command name. Examples of valid syntaxes for '"${g}"selection"$n"' are:
\n    . '"$c"-com[0,1,3]"$n"': Apply command only on images "$g"[0],[1]"$n" and "$g"[3]"$n".
\n    . '"$c"-com[3-5]"$n"': Apply command only on images "$g"[3]"$n" to "$g"[5]"$n" (i.e, "$g"[3],[4]"$n" and "$g"[5]"$n").
\n    . '"$c"-com[50%-100%]"$n"': Apply command only on the second half of the image list.
\n    . '"$c"-com[0,-4--1]"$n"': Apply command only on the first and the four latest images.
\n    . '"$c"-com[0-9:3]"$n"': Apply command only on images "$g"[0]"$n" to "$g"[9]"$n", with a step of 3
\n                      (i.e. on images "$g"[0], [3], [6]"$n" and "$g"[9]"$n").
\n    . '"$c"-com[0--1:2]"$n"': Apply command only on images of the list with even indices.
\n    . '"$c"-com[0,2-4,50%--1]"$n"': Apply command on images "$g"[0],[2],[3],[4]"$n" and on the second half
\n                             of the image list.
\n    . '"$c"-com[^0,1]"$n"': Apply command on all images except the first two.
\n    . '"$c"-com[name1,name2]"$n"': Apply command on named images '"${g}"name1"$n"' and '"${g}"name2"$n"'.
\n  - Indices in selections are always sorted in "${g}"increasing order"$n", and duplicate indices are
\n     discarded. For instance, selections '"$c"[3-1,1-3]"$n"' and '"$c"[1,1,1,3,2]"$n"' are both equivalent to
\n     '"$c"[1-3]"$n"'. If you want to repeat a single command multiple times on an image, use a
\n     '"$c"-repeat..-done"$n"' loop. Inverting the order of images for a command is achieved by
\n     explicitely inverting  the order of the images in the list, with command '"$c"-reverse[selection]"$n"'.
\n  - "@{-GMIC}" commands invoked without '"$c"[selection]"$n"' are applied on "${g}"all images"$n" of the list, i.e.
\n     default selection is '"$c"[0--1]"$n"' (except for command '"$c"-input"$n"' whose default selection is '"$c"[-1]"$n"').
\n  - A "@{-GMIC}" command starting with '"$g"--"$n"' instead of '"$g"-"$n"' does not act 'in-place' but inserts its
\n     result as one or several new images at the end of the image list.
\n  - There are two different types of commands that can be run by the "@{-GMIC}" interpreter:
\n    . "${g}"Native commands"$n", are hard-coded functionalities in the interpreter core.
\n       They are thus compiled as machine code and "${g}"run faster"$n", most of the time.
\n       Omitting an argument when invoking a native command is not permitted, except if all
\n       following arguments are also omitted. For instance, call to '"$c"-plasma 10,,5"$n"' is invalid
\n       but '"$c"-plasma 10"$n"' is correct.
\n    . "${g}"Custom commands"$n", are defined as "@{-GMIC}" pipelines of native or custom commands.
\n       They are interpreted by the "@{-GMIC}" interpreter, and thus "${g}"run a bit slower"$n" than native commands.
\n       But omitting arguments when invoking a custom command is permitted. For instance,
\n       expressions '"$c"-flower ,,,100,,2"$n"' or '"$c"-flower ,"$n"' are correct.
\n  - Most of the existing commands available in "@{-GMIC}" are actually "${g}"custom commands"$n".
\n  - A user may easily add its own custom commands to the "@{-GMIC}" interpreter (see section
\n     "${c}"'Adding custom commands"$n"'). Native commands cannot be added unless you modify the "@{-GMIC}"
\n     interpreter source code."

  -_help_section "Inputs/outputs properties"

  -_help_paragraph "  - "@{-GMIC}" is able to read/write most of the classical image file formats, including:
\n    . 2d grayscale/color files: "$g".png, .jpeg, .gif, .pnm, .tif, .bmp, .."$n"
\n    . 3d volumetric files: "$g".dcm, .hdr, .nii, .pan, .inr, .pnk, .."$n"
\n    . video files: "$g".mpeg, .avi, .mov, .ogg, .flv, .."$n"
\n    . Generic ascii or binary data files: "$g".gmz, .cimg, .cimgz, .dlm, .asc, .pfm, .raw, .txt, .h."$n"
\n    . 3d object files: "$g".off."$n"
\n  - When dealing with color images, "@{-GMIC}" generally reads, writes and displays data using the
\n     usual RGB color space.
\n  - "@{-GMIC}" is able to manage "${g}"3d objects"$n" that may be read from files or generated by "@{-GMIC}"
\n     commands. A 3d object is stored as a one-column scalar image containing the object data, in the
\n     following order: "$g"{ magic_number; sizes; vertices; primitives; colors; opacities }"$n".
\n     These 3d representations can be processed as regular images.
\n     (see command '"$c"-split3d"$n"' for accessing each of these 3d object data separately).
\n  - Be aware that usual file formats may be sometimes not adapted to store all the available
\n     image data, since "@{-GMIC}" consider float-valued image pixels. For instance, saving
\n     an image that was initially loaded as a 16bits/channel image, as a "$g".jpg"$n" file will result
\n     in loss of information. Use the "$g".gmz"$n" file extension to ensure that all data precision
\n     will be preserved when saving images.
\n  - File options can/must be set for these specific file formats:
\n    . "${g}"Video files:"$n" Only sub-frames of an image sequence may be loaded, using the input
\n       expression '"${c}"filename.ext,[first_frame[,last_frame[,step]]]"$n"'.
\n       Set 'last_frame==-1' to tell it must be the last frame of the video.
\n       Set 'step' to 0 to force an opened video file to be opened/closed.
\n       Output framerate and codec can be also set by using the output expression
\n       '"${c}"filename.avi,_fps,_codec,_keep_open={ 0 | 1 }"$n"'.
\n       'codec' is a 4-char string (see http://www.fourcc.org/codecs.php) or '0' for the default codec.
\n       'keep_open' tells if the output video file must be kept open for appending new frames afterwards.
\n    . "$g".cimg[z] files:"$n" Only crops and sub-images of .cimg files can be loaded, using the input
\n      expressions '"${c}"filename.cimg,N0,N1"$n"', '"${c}"filename.cimg,N0,N1,x0,x1"$n"',
\n      '"${c}"filename.cimg,N0,N1,x0,y0,x1,y1"$n"', '"${c}"filename.cimg,N0,N1,x0,y0,z0,x1,y1,z1"$n"' or
\n      '"${c}"filename.cimg,N0,N1,x0,y0,z0,c0,x1,y1,z1,c1"$n"'.
\n      Specifying '"${g}"-1"$n"' for one coordinates stands for the maximum possible value.
\n      Output expression '"${c}"filename.cimg[z][,datatype]"$n"' can be used to force the output pixel type.
\n      '"${c}"datatype"$n"' can be "$c"{ uchar | char | ushort | short | uint | int | ulong | long | float | double }"$n".
\n    . "$g".raw binary files:"$n" Image dimensions and input pixel type may be specified when loading
\n       "$g".raw"$n" files with input expresssion '"${c}"filename.raw[,datatype][,width][,height[,depth[,dim]]]]"$n"'.
\n       If no dimensions are specified, the resulting image is a one-column vector with
\n       maximum possible height. Pixel type can also be specified with the output
\n       expression '"${c}"filename.raw[,datatype]"$n"'.
\n       '"${c}"datatype"$n"' can be "$c"{ uchar | char | ushort | short | uint | int | ulong | long | float | double }"$n".
\n    . "$g".yuv files:"$n" Image dimensions must be specified, and only sub-frames of an image
\n       sequence may be loaded, using the input expression
\n      '"${c}"filename.yuv,width,height[,first_frame[,last_frame[,step]]]"$n"'.
\n    . "$g".tiff files:"$n" Only sub-images of multi-pages tiff files can be loaded, using the input
\n       expression '"${c}"filename.tif,[first_frame,[last_frame,[step]]]"$n"'.
\n       Output expression '"${c}"filename.tiff,[datatype[,compression[,force_multipage]]"$n"' can be used to specify the
\n       output pixel type, as well as the compression method. '"${c}"compression"$n"' can be "$c"{ none | lzw | jpeg }"$n"
\n       and '"${c}"force_multipage"$n" can be { 0=no | 1=yes }.
\n      '"${c}"datatype"$n"' can be "$c"{ uchar | char | ushort | short | uint | int | ulong | long | float | double }"$n".
\n    . "$g".gif files:"$n" Animated gif files can be saved, using the input expression
\n      '"${c}"filename.gif,fps,nb_loops"$n"'.
\n       Specify '"${c}"nb_loops=0"$n"' to get an infinite number of animation loops.
\n    . "$g".jpeg files:"$n" The output quality may be specified (in %), using the output expression
\n       '"${c}"filename.jpg,30"$n"' (here, to get a 30% quality output).
\n    . "$g".mnc files:"$n" The output header can set from another file, using the output expression
\n       '"${c}"filename.mnc,header_template.mnc"$n"'.
\n    . "$g".pan, .cpp, .hpp, .c and .h files:"$n" The output datatype can be selected with output expression
\n       '"${c}"filename[,datatype]"$n"'.
\n      '"${c}"datatype"$n"' can be "$c"{ uchar | char | ushort | short | uint | int | ulong | long | float | double }"$n".
\n    . "$g".gmic files:"$n" These filenames are assumed to be "@{-GMIC}" custom commands files. Loading
\n       such a file will add the commands it defines to the interpreter. Debug infos can be
\n       enabled/disabled by the input expression '"${c}"filename.gmic,add_debug_infos={ 0 | 1 }"$n"'.
\n    . Inserting '"${g}"ext:"$n"' on the beginning of a filename (e.g. '"${c}"jpg:filename"$n"') forces "@{-GMIC}" to
\n       read/write the file as it would have been done if it had the specified extension.
\n  - Some input/output formats and options may not be supported by your current version of
\n     '"${g}"gmic"$n"', depending on the configuration flags set during the build of the '"${g}"gmic"$n"' binaries."

  -_help_section "Substitution rules"

  -_help_paragraph "  - "@{-GMIC}" items containing '"$g"@"$n"', '"$g"$"$n"' or '"$g"{}"$n"' may be substituted before being interpreted. Use
\n     the substituting expressions below to access data from the interpreter environment:
\n    . '"$c"@#"$n"' is substituted by the current "${g}"number of images"$n" in the list.
\n    . '"$c"@*"$n"' is substituted by the number of "${g}"available cpus"$n".
\n    . '"$c"@."$n"' is substituted by the current "${g}"version number"$n" of the "@{-GMIC}" interpreter
\n    . '"$c"@^"$n"' is substituted by the current "${g}"verbosity level"$n".
\n    . '"$c"@%"$n"' is substituted by the "${g}"pid"$n" of the current process.
\n    . '"$c"@|"$n"' is substituted by the current value (expressed in seconds) of a "${g}"millisecond
\n       precision timer"$n".
\n    . '"$c"@/"$n"' is substituted by the current "${g}"number of levels in the command scope"$n".
\n    . '"$c"@{/}"$n"' or '"$c"@{/,subset}"$n"' are substituted by the content of the "${g}"global scope"$n", or a
\n       subset of it. If specified subset refers to multiple scope items, they are separated
\n       by slashes '"$g"/"$n"'.
\n    . '"$c"@>"$n"' and '"$c"@<"$n"' are equivalent. They are both substituted by "${g}"the number of nested
\n       'repeat-done' loops"$n" that are currently running.
\n    . '"$c"@{>}"$n"' or '"$c"@{>,subset}"$n"' are substituted by the indice values (or a subset of them) of
\n       the running 'repeat-done' loops, expressed in the ascending order, starting from 0.
\n       If specified subset refers to multiple indices, they are separated by commas '"$g","$n"'.
\n    . '"$c"@{<}"$n"' or '"$c"@{<,subset}"$n"' do the same but in descending order.
\n    . '"$c"@indice"$n"' or '"$c"@{indice,feature}"$n"' are substituted by the "${g}"list of pixel values"$n" of the
\n       image "$c"[indice]"$n" (separated by commas), or by a "${g}"specific feature (or subset)"$n" of it.
\n       '"${g}"indice"$n"' denotes either a numbered image indice or an image name. Requested '"${g}"feature"$n"' can be one of:
\n         . '"${g}"w"$n"': image width (number of image columns).
\n         . '"${g}"h"$n"': image height (number of image rows).
\n         . '"${g}"d"$n"': image depth (number of image slices).
\n         . '"${g}"s"$n"': image spectrum (number of image channels).
\n         . '"${g}"wh"$n"': image width x image height.
\n         . '"${g}"whd"$n"': image width x image height x image depth.
\n         . '"${g}"whds"$n"': image width x image height x image depth x image spectrum.
\n                   (i.e. number of values in the specified image, eq. to '#').
\n         . '"${g}"r"$n"': image shared state (1, if the pixel buffer is shared, 0 otherwise).
\n         . '"${g}"n"$n"': image name or filename (if the image has been read from a file).
\n         . '"${g}"b"$n"': image basename (i.e. filename without the folder path nor extension).
\n         . '"${g}"x"$n"': image extension (i.e last characters after the last '.' in the filename).
\n         . '"${g}"f"$n"': image folder name.
\n         . '"$g"#"$n"': number of image values (i.e. width x height x depth x spectrum).
\n         . '"$g"+"$n"': sum of all pixel values.
\n         . '"$g"-"$n"': difference of all pixel values.
\n         . '"$g"*"$n"': product of all pixel values.
\n         . '"$g"/"$n"': quotient of all pixel values.
\n         . '"${g}"m"$n"': minimum pixel value.
\n         . '"${g}"M"$n"': maximum pixel value.
\n         . '"${g}"a"$n"': average pixel value.
\n         . '"${g}"v"$n"': variance of pixel values.
\n         . '"${g}"t"$n"': text string built from the image values, regarded as ascii codes.
\n         . '"${g}"c"$n"': (x,y,z,c) coordinates of the minimum value, separated by commas ','.
\n         . '"${g}"C"$n"': (x,y,z,c) coordinates of the maximum value, separated by commas ','.
\n         . '"$g"(x[%],_y[%],_z[%],_c[%],_boundary)"$n"': pixel value at "$g"(x[%],y[%],z[%],c[%])"$n", with
\n            specified boundary conditions "$c"{ 0=dirichlet | 1=neumann | 2=periodic }"$n".
\n         . Any other '"${g}"feature"$n"' is considered either as a specified "${g}"subset of image values"$n", or
\n            as a "${g}"mathematical expression"$n" which is evaluated (associated to the selected image).
\n            For instance, '"$c"@{-1,0-50%}"$n"' is substituted by the sequence of numerical values
\n            coming from the first half data of the last image, separated by commas '"$g","$n"'.
\n            Expression '"$c"@{0,w+h}"$n"' is substituted by the sum of the width and height of the
\n            first image.
\n    . '"$c"@!"$n"' is substituted by the "${g}"visibility state"$n" of the instant display window "$c"[0]"$n"
\n       (can be "$c"{ 0=closed | 1=visible }"$n").
\n    . '"$c"@{!,feature}"$n"' or '"$c"@{!indice,feature}"$n"' is substituted by a "${g}"specific feature"$n" of the
\n       instant display window "$c"[0]"$n" (or "$c"[indice]"$n", if specified). Requested '"${g}"feature"$n"' can be:
\n         . '"${g}"w"$n"': display width (i.e. width of the display area managed by the window).
\n         . '"${g}"h"$n"': display height (i.e. height of the display area managed by the window).
\n         . '"${g}"wh"$n"': display width x display height.
\n         . '"${g}"d"$n"': window width (i.e. width of the window widget).
\n         . '"${g}"e"$n"': window height (i.e. height of the window widget).
\n         . '"${g}"de"$n"': window width x window height.
\n         . '"${g}"u"$n"': screen width (actually independent on the window size).
\n         .' "${g}"v"$n"': screen height (actually independent on the window size).
\n         . '"${g}"uv"$n"': screen width x screen height.
\n         . '"${g}"n"$n"': current normalization type of the instant display.
\n         . '"${g}"x"$n"': X-coordinate of the mouse position (or -1, if outside the display area).
\n         . '"${g}"y"$n"': Y-coordinate of the mouse position (or -1, if outside the display area).
\n         . '"${g}"b"$n"': state of the mouse buttons { 1=left-but. | 2=right-but. | 4=middle-but. }.
\n         . '"${g}"o"$n"': state of the mouse wheel.
\n         . '"${g}"k"$n"': decimal code of the pressed key if any, 0 otherwise.
\n         . '"${g}"c"$n"': boolean (0 or 1) telling if the instant display has been closed recently.
\n         . '"${g}"r"$n"': boolean telling if the instant display has been resized recently.
\n         . '"${g}"m"$n"': boolean telling if the instant display has been moved recently.
\n         . Any other '"${g}"feature"$n"' stands for a "${g}"keycode name"$n" (in capital letters), and is substi-
\n            tuted by a boolean describing the current key state "$c"{ 0=pressed | 1=released }"$n".
\n         . You can also prepend a dash '"$c"-"$n"' to a '"${g}"feature"$n"' (that supports it) to flush
\n            the corresponding event immediately after reading its state.
\n    . '"$c"@{\"command line\"}"$n"' is substituted by the "${g}"status value"$n" set by the execution of the
\n       specified command line (see command '"$c"-status"$n"' to learn more about status).
\n    . Expression '"$c"@{}"$n"' stands thus for the "${g}"current status value"$n".
\n  - '"$c"$name"$n"' and '"$c"${name}"$n"' are both substituted by the "${g}"value of the specified named variable"$n"
\n     (set previously by item '"${c}"name=value"$n"'), or by the current positive "${g}"indice of the named
\n     image '[name]'"$n", or by the value of the named "${g}"OS environment variable"$n" (evaluated in this order).
\n  - '"$c"$>"$n"' and '"$c"$<"$n"' (resp. '"$c"${>}"$n"' and '"$c"${<}"$n"') are shortcuts respectively for '"$c"@{>,-1}"$n"' and
\n     '"$c"@{<,-1}"$n"'. They refer to the "${g}"increasing/decreasing indice"$n" of the latest (currently running)
\n     '"${c}"repeat..done"$n"' loop.
\n  - Any other expression inside braces (as in '"$c"{expression}"$n"') is considered as a "${g}"mathematical
\n     expression"$n", and is evaluated, except for the three following cases:
\n    . If expression starts and ends by "${g}"single quotes"$n", it is substituted by the "${g}"sequence of
\n       ascii codes"$n" that composes the specified string, separated by commas '"$g","$n"'. For instance,
\n       item '"$c"{'foo'}"$n"' is substituted by '"${c}"102,111,111"$n"'.
\n    . If expression starts and ends with "${g}"backquotes"$n" '"$g"\47"$n"', it is substituted by the "${g}"string
\n       whose ascii codes are given by the list of values"$n" in between the backquotes.
\n       For instance, item '"$c"{`102,111,111`}"$n"' is substituted by '"${c}"foo"$n"'.
\n    . If expression contains operator '"$c"'=='"$n"' or '"$c"'!='"$n"', it is substituted by "${c}"0"$n" or "${c}"1"$n", whether
\n       the two strings beside the operator "${g}"are the same or not"$n" (case-sensitive). For instance,
\n       both items '"$c"{foo'=='foo}"$n"' and '"$c"{foo'!='FOO}"$n"' are substituted by '"${c}"1"$n"'.
\n    . If expression starts with an underscore '"$g"_"$n"', it is substituted by the mathematical
\n       evaluation of the expression, but "${g}"truncated to a readable format"$n". For instance,
\n       item '"$c"{_pi}"$n"' is substituted by '"${c}"3.14159"$n"' (while '"$c"{pi}"$n"' is '"${c}"3.141592653589793"$n"').
\n  - Item substitution is "${g}"never performed in items between double quotes"$n". One must break the quotes
\n    to enable substitution if needed, as in "$c"\"3+8 kg = \"{3+8}\" kg\""$n". Using double quotes
\n    is then a convenient way to "${g}"disable the substitutions mechanism"$n" in items, when necessary.
\n  - One can also disable the substitution mechanism on items outside double quotes, by
\n     "${g}"escaping"$n" the '"$g"@"$n"','"$g"{"$n"','"$g"}"$n"' or '"$g"$"$n"' characters, as in '"$c"\\{3+4\\}\\ doesn\47t\\ evaluate"$n"'."

  -_help_section "Mathematical expressions"

  -_help_paragraph "  - "@{-GMIC}" has an embedded "${g}"mathematical parser"$n". It is used to evaluate expressions inside
\n     braces '"$g"{}"$n"', or formulas in commands that may take one as an argument (e.g. '"$c"-fill"$n"').
\n  - When used as a command argument, a formula is evaluated "${g}"for each pixel"$n" of the selected images.
\n  - The mathematical parser understands the following set of functions, operators and variables:
\n    _ "${g}"Usual operators:"$n" "$c"||"$n" (logical or), "$c"&&"$n" (logical and), "$c"|"$n" (bitwise or), "$c"&"$n" (bitwise and),
\n       "$c"!=, ==, <=, >=, <, >, <<"$n" (left bitwise shift), "$c">>"$n" (right bitwise shift), "$c"-, +, *, /,
\n       %"$n" (modulo), "$c"^"$n" (power), "$c"!"$n" (logical not), "$c"~"$n" (bitwise not).
\n    _ "${g}"Usual functions:"$n" "${c}"sin(), cos(), tan(), asin(), acos(), atan(), sinh(), cosh(), tanh(),
\n       log(), log2(), log10(), exp(), sign(), abs(), atan2(), round(), narg(), arg(),
\n       isval(), isnan(), isinf(), isint(), isbool(), rol()"$n" (left bit rotation),
\n       "${c}"ror()"$n" (right bit rotation), "${c}"min(), max(), med(), kth(), sinc(), int()"$n".
\n       Function '"${c}"atan2()"$n"' is the version of '"${c}"atan()"$n"' with two arguments 'y' and 'x' (as in C/C++).
\n       Function '"${c}"narg()"$n"' returns the number of specified arguments.
\n       Function '"${c}"arg(i,a_1,..,a_n)"$n"' returns the ith argument a_i.
\n       Functions '"${c}"min()"$n"', '"${c}"max()"$n"', '"${c}"med()"$n"' and '"${c}"kth()"$n"' can be called with an arbitrary number of arguments.
\n       Functions '"${c}"isval()"$n"', '"${c}"isnan()"$n"', '"${c}"isinf()"$n"', '"${c}"isbool()"$n"' can be used to test the type of
\n       a given number or expression.
\n    _ "${g}"Variable names"$n" below are pre-defined. They can be overloaded.
\n         . '"${c}"w"$n"': width of the associated image, if any (0 otherwise).
\n         . '"${c}"h"$n"': height of the associated image, if any (0 otherwise).
\n         . '"${c}"d"$n"': depth of the associated image, if any (0 otherwise).
\n         . '"${c}"s"$n"': spectrum of the associated image, if any (0 otherwise).
\n         . '"${c}"x"$n"': current processed column of the associated image, if any (0 otherwise).
\n         . '"${c}"y"$n"': current processed row of the associated image, if any (0 otherwise).
\n         . '"${c}"z"$n"': current processed slice of the associated image, if any (0 otherwise).
\n         . '"${c}"c"$n"': current processed channel of the associated image, if any (0 otherwise).
\n         . '"${c}"e"$n"': value of e, i.e. 2.71828..
\n         . '"${c}"pi"$n"': value of pi, i.e. 3.1415926..
\n         . '"$c"?"$n"' or '"${c}"u"$n"': a random value between [0,1], following a uniform distribution.
\n         . '"${c}"g"$n"': a random value, following a gaussian distribution of variance 1
\n            (roughly in [-5,5]).
\n         . '"${c}"i"$n"': current processed pixel value (i.e. value located at (x,y,z,c)) of the
\n            associated image, if any (0 otherwise).
\n         . '"${c}"im"$n"','"${c}"iM"$n"','"${c}"ia"$n"','"${c}"iv"$n"': Respectively the minimum, maximum, average values and
\n            variance of the associated image, if any (0 otherwise).
\n         . '"${c}"xm"$n"','"${c}"ym"$n"','"${c}"zm"$n"','"${c}"cm"$n"': The pixel coordinates of the minimum value in the associated
\n            image, if any (0 otherwise).
\n         . '"${c}"xM"$n"','"${c}"yM"$n"','"${c}"zM"$n"','"${c}"cM"$n"': The pixel coordinates of the maximum value in the
\n            associated image, if any (0 otherwise).
\n    _ "${g}"Special operators"$n" can be used:
\n         . '"$c";"$n"': expression separator. The returned value is always the last encountered
\n            expression. For instance expression '"${c}"1;2;pi"$n"' is evaluated as '"${c}"pi"$n"'.
\n         . '"$c"="$n"': variable assignment. Variables in mathematical parser can only refer to.
\n            numerical values. Variable names are case-sensitive. Use this operator in
\n            conjunction with '"$c";"$n"' to define complex evaluable expressions, such as
\n             '"${c}"t=cos(x);3*t^2+2*t+1"$n"'.
\n            These variables remain "${g}"local to the mathematical parser"$n" and cannot be accessed
\n            outside the evaluated expression.
\n    _ The following "${g}"specific functions"$n" are also defined:
\n         . '"${c}"if(expr_cond,expr_then,expr_else)"$n"': return value of '"${c}"expr_then"$n"' or '"${c}"expr_else"$n"',
\n            depending on the value of '"${c}"expr_cond"$n"' "${g}"(0=false, other=true)"$n". For instance,
\n            "@{-GMIC}" command '"${c}"-fill if(x%10==0,255,i)"$n"' will draw blank vertical lines on every
\n            10th column of an image.
\n         . '"$c"?(max)"$n"' or '"$c"?(min,max)"$n"': return a random value between "$g"[0,max]"$n" or "$g"[min,max]"$n",
\n            following a uniform distribution. '"${c}"u(max)"$n"' and '"${c}"u(0,max)"$n"' mean the same.
\n         . '"${c}"i(_a,_b,_c,_d,_interpolation,_boundary)"$n"': return the value of the pixel located
\n            at position "$g"(a,b,c,d)"$n" in the associated image, if any (0 otherwise).
\n            Interpolation parameter can be "$c"{ 0=nearest neighbor | other=linear }"$n".
\n            Boundary conditions can be "$c"{ 0=dirichlet | 1=neumann | 2=periodic }"$n".
\n            Omitted coordinates are replaced by their default values which are respectively
\n            "${c}"x, y, z, c"$n" and "${c}"0"$n".
\n         . '"${c}"j(_dx,_dy,_dz,_dc,_interpolation,_boundary)"$n"': does the same for the pixel located
\n            at position "$g"(x+dx,y+dy,z+dz,c+dc)"$n".
\n         . '"${c}"i[offset]"$n"': return the value of the pixel located at "${g}"specified offset"$n" in the associated
\n            image buffer.
\n         . '"${c}"j[offset]"$n"': does the same for an offset relative to the current pixel "$g"(x,y,z,c)"$n".
\n            For instance command '"${c}"-fill 0.5*(i(x+1)-i(x-1))"$n"' will estimate the X-derivative
\n            of an image with a classical finite difference scheme.
\n         . If specified formula starts with '"$c">"$n"' or '"$c"<"$n"', the operators '"${c}"i(..)"$n"' and '"${c}"j(..)"$n"' will return
\n            values of the image currently being modified, in forward ('"$c">"$n"') or backward ('"$c"<"$n"') order.
\n  - The last image of the list is always associated to the evaluations of '"$c"{expressions}"$n"',
\n     e.g. "@{-GMIC}" sequence '"${c}"256,128 -f {w}"$n"' will create a 256x128 image filled with value 256."

  -_help_section "Image and data viewers"

  -_help_paragraph "  - "@{-GMIC}" has some very handy "${g}"embedded visualization modules"$n", for 1d signals
\n     (command '"$c"-plot"$n"'), 1d/2d/3d images (command '"$c"-display"$n"') and 3d objects
\n     (command '"$c"-display3d"$n"'). It enables an interactive view of the selected image data.
\n  - The following keyboard shortcuts are available in the interactive viewers:
\n    . "${g}"CTRL+D"$n": Increase window size.
\n    . "${g}"CTRL+C"$n": Decrease window size.
\n    . "${g}"CTRL+R"$n": Reset window size.
\n    . "${g}"CTRL+F"$n": Toggle fullscreen mode.
\n    . "${g}"CTRL+S"$n": Save current window snapshot as numbered file 'gmic_xxxx.bmp'.
\n    . "${g}"CTRL+O"$n": Save current instance of the viewed data, as numbered file 'gmic_xxxx.cimgz'.
\n  - Shortcuts specific to the 1d/2d/3d image viewer (command '"$c"-display"$n"') are:
\n    . "${g}"CTRL+A"$n": Switch cursor mode.
\n    . "${g}"CTRL+P"$n": Play z-stack of frames as a movie (for volumetric 3d images).
\n    . "${g}"CTRL+V"$n": Show/hide 3D view (for volumetric 3d images).
\n    . "${g}"CTRL+(mousewheel)"$n": Zoom in/out.
\n    . "${g}"SHIFT+(mousewheel)"$n": Go left/right.
\n    . "${g}"ALT+(mousewheel)"$n": Go up/down.
\n    . "${g}"Numeric PAD"$n": Zoom in/out (+/-) and move through zoomed image (digits).
\n    . "${g}"BACKSPACE"$n": Reset zoom scale.
\n  - Shortcuts specific to the 3d object viewer (command '"$c"-display3d"$n"') are:
\n    . "$g"(mouse)+(left mouse button)"$n": Rotate 3d object.
\n    . "$g"(mouse)+(right mouse button)"$n": Zoom 3d object.
\n    . "$g"(mouse)+(middle mouse button)"$n": Shift 3d object.
\n    . "$g"(mousewheel)"$n": Zoom in/out.
\n    . "${g}"CTRL+F1 .. CTRL+F6"$n": Toggle between different 3d rendering modes.
\n    . "${g}"CTRL+Z"$n": Enable/disable z-buffered rendering.
\n    . "${g}"CTRL+A"$n": Show/hide 3d axes.
\n    . "${g}"CTRL+G"$n": Save 3d object, as numbered file 'gmic_xxxx.off'.
\n    . "${g}"CTRL+T"$n": Switch between single/double-sided 3d modes."

  -_help_section "Adding custom commands"

  -_help_paragraph "  - Custom commands can be defined by a user, through the use of "@{-GMIC}" "${g}"custom commands files"$n".
\n  - A command file is a simple "${g}"ascii text file"$n", where each line starts either by
\n     '"${c}"command_name: command_definition"$n"' or '"${c}"command_definition (continuation)"$n"'.
\n  - At startup, "@{-GMIC}" automatically includes user's command file "$g"$HOME/.gmic"$n" (on Unix) or
\n     "$g"%APPDATA%/gmic"$n" (on Windows), and runs command '"${c}"-start"$n"' if defined.
\n  - Custom command names must use characters [a-zA-Z0-9_] and cannot start with a number.
\n  - Any '"$c" \# comment"$n"' expression found in a custom commands file is "${g}"discarded"$n" by the "@{-GMIC}"
\n     parser, wherever it is located in a line.
\n  - In a custom command, the following "$g"$-expressions"$n" are substituted:
\n    . '"$c"$""\*"$n"' is substituted by a copy of the specified string of arguments.
\n    . '"$c"$\"*\""$n"' is substituted by a copy of the specified string of arguments, each being double-quoted.
\n    . '"$c"$""\#"$n"' is substituted by the maximum indice of known arguments (either specified by the
\n       user or set to a default value in the custom command).
\n    . '"$c"$""?"$n"' is substituted by a string telling about the command subset restriction (only
\n       useful when custom commands need to output descriptive messages).
\n    . '"$c"$i"$n"' and '"$c"${i}"$n"' are both substituted by the i-th specified argument. Negative indices
\n       such as '"$c"${-j}"$n"' are allowed and refer to the j^th latest argument. '"$c"$""0"$n"' is substituted
\n       by the custom command name.
\n    . '"$c"${i=default}"$n"' is substituted by the value of $i (if defined) or by its new value set
\n        to '"${g}"default"$n"' otherwise ('"${g}"default"$n"' may be a $-expression as well).
\n    . '"$c"${subset}"$n"' is substituted by the arguments values (separated by commas '"$g","$n"') of a
\n       specified argument subset. For instance expression '"$c"$""{2--2}"$n"' is substitued by all
\n       specified arguments except the first and the last one. Expression '"$c"$""{^0}"$n"' is then
\n       substituted by all arguments of the invoked command (eq. to '"$c"$""*"$n"' if all specified
\n       arguments have indeed a value).
\n    . '"$c"$""=var"$n"' is substituted by the set of instructions that will assign each argument "$c"$i"$n"
\n       to the named variable '"${c}"var$i"$n"' (for i in "$g"[0..$""\#]"$n"). This is particularly useful when a
\n       custom command want to manage variable numbers of arguments. Variables names must
\n       use characters [a-zA-Z0-9_] and cannot start with a number.
\n  - These particular "$g"$-expressions"$n" are "${g}"always substituted"$n", even in double quoted items or
\n     when the dollar sign '"$g"$"$n"' is escaped with a backslash '"$g"\\"$n"'. To avoid substitution, place
\n     an empty double quoted string just after the '"$g"$"$n"' (as in '"$c"$\"\"1"$n"').
\n  - Specifying arguments may be skipped when invoking a custom command, by replacing them by
\n     commas '"$g","$n"' as in expression '"${c}"-flower ,,3"$n"'. Omitted arguments are set to their default
\n     values, which must be thus explicitly defined in the code of the corresponding custom
\n     command (using default argument expressions as '"$c"$""{1=default}"$n"').
\n  - If one numbered argument required by a custom command does not have a value, an error is
\n     thrown by the interpreter."

  -_help_section "List of commands"

  -_help_paragraph " All available "@{-GMIC}" commands are listed below, classified by themes.
\n When several choices of command arguments are possible, they appear separated by '"$g"|"$n"'.
\n An argument specified inside '"$g"[]"$n"' or starting by '"$g"_"$n"' is optional except when standing for an
\n existing image "$c"[image]"$n", where '"${g}"image'"$n"' can be either an indice number or an image name.
\n In this case, the '"$g"[]"$n"' characters are mandatory when writing the item.
\n A command marked with '"$g"(+)"$n"' is a "${g}"native"$n" command.
\n Note also that all images that serve as illustrations in this reference documentation are normalized
\n in "$g"[0,255]"$n" before being displayed. You may need to do this manually (command '"$c"-normalize 0,255"$n"') if you
\n want to save image files having the same aspect than those illustrated in the example codes."

_help_examples :
  g=$_gmic_g c=$_gmic_c n=$_gmic_n
  -_help_section "Examples of use"

  -_help_paragraph " '"${g}"gmic"$n"' is a generic image processing tool which can be used in a wide variety of situations.
\n The few examples below illustrate possible uses of this tool:
\n
\n  - View a list of images:
\n     "${c}"gmic file1.bmp file2.jpeg"$n"
\n
\n  - Convert an image file:
\n     "${c}"gmic input.bmp -o output.jpg"$n"
\n
\n  - Create a volumetric image from a movie sequence:
\n     "${c}"gmic input.mpg -a z -o output.hdr"$n"
\n
\n  - Compute image gradient norm:
\n     "${c}"gmic input.bmp -gradient_norm"$n"
\n
\n  - Denoise a color image:
\n     "${c}"gmic image.jpg -denoise 30,10 -o denoised.jpg"$n"
\n
\n  - Compose two images using overlay layer blending:
\n     "${c}"gmic image1.jpg image2.jpg -blend overlay -o blended.jpg"$n"
\n
\n  - Evaluate a mathematical expression:
\n     "${c}"gmic -e \"cos(pi/4)^2+sin(pi/4)^2={cos(pi/4)^2+sin(pi/4)^2}\""$n"
\n
\n  - Plot a 2d function:
\n     "${c}"gmic 1000,1,1,2 -f \"X=3*(x-500)/500;X^2*sin(3*X^2)+if(c==0,u(0,-1),cos(X*10))\" -plot"$n"
\n
\n  - Plot a 3d elevated function in random colors:
\n     "${c}"gmic 128,128,1,3,\"?(0,255)\" -plasma 10,3 -blur 4 -sharpen 10000 \\\
\n      -elevation3d[-1] \"'X=(x-64)/6;Y=(y-64)/6;100*exp(-(X^2+Y^2)/30)*abs(cos(X)*sin(Y))'\""$n"
\n
\n  - Plot the isosurface of a 3d volume:
\n     "${c}"gmic -m3d 5 -md3d 5 -db3d 0 -isosurface3d \"'x^2+y^2+abs(z)^abs(4*cos(x*y*z*3))'\",3"$n"
\n
\n  - Render a "@{-GMIC}" 3d logo:
\n     "${c}"gmic 0 -text G\\\47MIC,0,0,53,1,1,1,1 -expand_xy 10,0 -blur 1 -n 0,100 --plasma 0.4 -+ \\\
\n      -blur 1 -elevation3d -0.1 -md3d 4"$n"
\n
\n  - Generate a 3d ring of torii:
\n     "${c}"gmic -repeat 20 -torus3d 15,2 -color3d[-1] \"{?(60,255)},{?(60,255)},{?(60,255)}\" \\\
\n      -*3d[-1] 0.5,1 -if \"{$>%2}\" -r3d[-1] 0,1,0,90 -endif -+3d[-1] 70 -+3d \\\
\n      -r3d 0,0,1,18 -done -md3d 3 -m3d 5 -db3d 0"$n"
\n
\n  - Create a vase from a 3d isosurface:
\n     "${c}"gmic -md3d 4 -isosurface3d \"'x^2+2*abs(y/2)*sin(2*y)^2+z^2-3',0\" -sphere3d 1.5 \\\
\n      --3d[-1] 0,5 -plane3d 15,15 -r3d[-1] 1,0,0,90 -center3d[-1] -+3d[-1] 0,3.2 \\\
\n      -color3d[-1] 180,150,255 -color3d[-2] 128,255,0 -color3d[-3] 255,128,0 -+3d"$n"
\n
\n  - Display filtered webcam stream:
\n     "${c}"gmic -apply_camera \\\"--mirror x --mirror y -+ -/ 4\\\""$n"
\n
\n  - Launch a set of "@{-GMIC}" interactive demos:
\n     "${c}"gmic -demo"$n"
\n"

# Commands to output help in ascii format.
_help_header_ascii :
  -__help_header_ascii
  _section=0 _space1="" _space2=" "
  -_help_section "Usage"

__help_header_ascii :
  -if {narg($_gmic_is_beta)} strbeta=" (beta)" -else strbeta="" -endif
  -if {narg($_gmic_version)} strver=$_gmic_version -else strver=@{-strver} -endif
  -v +
  -e[] "
\n "${_gmic_b}"gmic: GREYC's Magic for Image Computing."$_gmic_n"
\n
\n        "$_gmic_r${_gmic_b}"Version "$strver$strbeta$_gmic_n", Copyright (c) 2008-2015, David Tschumperle.
\n        "$_gmic_r"(http://gmic.eu)"$_gmic_n
  -v -

_help_section_ascii :
  _section={$_section+1}
  {narg({'"$1"'})},1,1,1,{'-'}
  -v +
  -e[] "\n "$_gmic_m$_gmic_b$_section". $1"
  -e[] "    "${_space{narg({'$_section'})}}@{-1,t}$_gmic_n"\n"
  -v -
  -rm[-1]

_help_paragraph_ascii :
  -v +
  -e[] "$*"
  -v -

_help_footer_ascii :
  -v +
  -e[] " "$_gmic_r$_gmic_b"** G\47MIC comes with ABSOLUTELY NO WARRANTY; for details visit: http://gmic.eu **"$_gmic_n
  -v -

# Commands to output help in html format.
_help_header_html :
  _section=0
  -if {narg($_gmic_is_beta)} strbeta=" (beta)" -else strbeta="" -endif
  -if {narg($_gmic_version)} strver=$_gmic_version -else strver=@{-strver} -endif
  _gmic_n="</font></b>" _gmic_r="<b><font color=\"#900000\">" _gmic_g="<b><font color=\"#009000\">"
  _gmic_m="<b><font color=\"#900090\">" _gmic_c="<b><font color=\"#005090\">"

  -v +
-e[] "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">
\n<!--#include file=\"header.html\" -->
\n<link href=\"style.css\" rel=\"stylesheet\" type=\"text/css\">
\n<div id=\"bloc_option\">
\n<div id=\"top_rouge\"><div id=\"text_top\">Reference</div></div>
\n<div id=\"center\"><div id=\"text_centre_intro\">
\n<h2>Preamble</h2>
\n<ul>
\n<li>This document is distributed under the <a href=\"http://www.gnu.org/licenses/fdl-1.3.txt\">GNU Free Documentation License</a>, version 1.3.</li>
\n<li>A <a href=\"gmic_reference.pdf\">.pdf version</a> of this document is available.</li>
\n<li>We also suggest you read <a href=\"tutorial/index.shtml\">these tutorial pages</a> which provide a more user-friendly explanation of most of the G\47MIC basics.</li>
\n</ul>
\n<h2><a id=\"toc\">Table of contents</a></h2>
\n<ul>
\n<li><a href=\"#section0\">Version</a></li>
\n<li><a href=\"#section1\">Usage</a></li>
\n<ul>
\n<li><a href=\"#section2\">Overall context</a></li>
\n<li><a href=\"#section3\">Image definition and terminology</a></li>
\n<li><a href=\"#section4\">Items of a processing pipeline</a></li>
\n<li><a href=\"#section5\">Input data items</a></li>
\n<li><a href=\"#section6\">Command items and selections</a></li>
\n<li><a href=\"#section7\">Input/output properties</a></li>
\n<li><a href=\"#section8\">Substitution rules</a></li>
\n<li><a href=\"#section9\">Mathematical expressions</a></li>
\n<li><a href=\"#section10\">Image and data viewers</a></li>
\n<li><a href=\"#section11\">Adding custom commands</a></li>
\n</ul>
\n<li><a href=\"#section12\">List of commands</a></li>
\n<ul>
\n<li><a href=\"#subsection1\">Global options</a></li>
\n<li><a href=\"#subsection2\">Inputs/outputs</a></li>
\n<li><a href=\"#subsection3\">List manipulation</a></li>
\n<li><a href=\"#subsection4\">Mathematical operators</a></li>
\n<li><a href=\"#subsection5\">Values manipulation</a></li>
\n<li><a href=\"#subsection6\">Colors manipulation</a></li>
\n<li><a href=\"#subsection7\">Geometry manipulation</a></li>
\n<li><a href=\"#subsection8\">Filtering</a></li>
\n<li><a href=\"#subsection9\">Features extraction</a></li>
\n<li><a href=\"#subsection10\">Image drawing</a></li>
\n<li><a href=\"#subsection11\">Matrix computation</a></li>
\n<li><a href=\"#subsection12\">3d rendering</a></li>
\n<li><a href=\"#subsection13\">Program control</a></li>
\n<li><a href=\"#subsection14\">Arrays,tiles and frames</a></li>
\n<li><a href=\"#subsection15\">Artistic</a></li>
\n<li><a href=\"#subsection16\">Warpings</a></li>
\n<li><a href=\"#subsection17\">Degradations</a></li>
\n<li><a href=\"#subsection18\">Blending and fading</a></li>
\n<li><a href=\"#subsection19\">Image sequences and videos</a></li>
\n<li><a href=\"#subsection20\">PINK-library operators</a></li>
\n<li><a href=\"#subsection21\">Convenience functions</a></li>
\n<li><a href=\"#subsection22\">Other interactive commands</a></li>
\n<li><a href=\"#subsection23\">Commands shortcuts</a></li>
\n</ul>
\n<li><a href=\"#section13\">Examples of use</a></li>
\n</ul>
\n<a id=\"section0\"><h2>Version</h2></a>
\n<pre><font color=\"blue\"><b>gmic:</b> GREYC's Magic for Image Computing.</font>
\n
\n       Version <font color=\"brown\"><b>"$strver$strbeta"</b></font>, Copyright (c) 2008-2015, David Tschumperle
\n       (<a href=\"http://gmic.eu\">http://gmic.eu</a>)
\n</pre>
"
-v -
-_help_section "Usage"

_help_section_html :
  _section={$_section+1}
  -v +
  -e[] "<h2><a href=\"#toc\"><img src=\"img/back_top.png\"></img>&nbsp;&nbsp;</a><a id=\"section"$_section"\">$1</a></h2>"
  -v -

_help_paragraph_html :
  -v +
  -e[] "<pre>$*</pre>"
  -v -

_help_footer_html :
  -v +
  -e[] "
\n<br/><b><font color=\"brown\">** G\47MIC comes with ABSOLUTELY NO WARRANTY; for details visit: <a href=\"http://gmic.eu\">http://gmic.eu **</a></font></b>
\n</tt>
\n</div>
\n</div>
\n<div id=\"footer\"><img src=\"images/footer.jpg\" /></div>
\n</div>
\n<!--#include file=\"copyright.html\" -->
\n<!--#include file=\"footer.html\" -->
"
  -v -

# Commands to output help in latex format.
_help_header_latex :
  -if {narg($_gmic_is_beta)} strbeta=" (beta)" -else strbeta="" -endif
  -if {narg($_gmic_version)} strver=$_gmic_version -else strver=@{-strver} -endif
  -v + -e[] "\\documentclass[a4paper,11pt,twoside]{book}
\n\\usepackage{hyperref,fancyhdr,graphicx,amssymb,amsmath,times,makeidx,listings,color}
\n\\graphicspath{{img/}}
\n\\pagestyle{fancyplain}
\n\\lhead[\\fancyplain{}{\\textbf\\thepage}]{\\fancyplain{}{\\rightmark}}
\n\\rhead[\\fancyplain{}{\\leftmark}]{\\fancyplain{}{\\textbf\\thepage}}
\n\\cfoot{}
\n\\setlength{\\textwidth}{5.875in}
\n\\setlength{\\parindent}{0pc}
\n\\setlength{\\hoffset}{-0.8cm}
\n\\setcounter{tocdepth}{1}
\n\\sloppy{}
\n\\definecolor{ca}{rgb}{0.8,0,0}
\n\\definecolor{cb}{rgb}{0,0.2,0.6}
\n\\definecolor{cc}{rgb}{0,0.5,0}
\n\\definecolor{cd}{rgb}{0.6,0.6,0.6}
\n\\newcommand{\\Ca}[1]{\\textcolor{ca}{#1}}
\n\\newcommand{\\Cb}[1]{\\textcolor{cb}{#1}}
\n\\newcommand{\\Cc}[1]{\\textcolor{cc}{#1}}
\n\\newcommand{\\Cd}[1]{\\textcolor{cd}{#1}}
\n\\title{\\fbox{\\parbox{\\textwidth}{\\begin{center}\\vspace*{2cm}\\includegraphics[width=12cm]{logo3.jpg}\\\\\\vspace*{1cm}{\\Huge \\textbf{The Handbook}\\\\{\\small Version "$strver$strbeta"}\\\\\\vspace*{1cm}}\\end{center}}}}
\n\\author{\\Large \\bf David Tschumperl\\'e}
\n\\renewcommand\\indexname{Index of commands}
\n\\makeindex
\n\\lstset{columns=fullflexible,basicstyle=\\normalfont}
\n\\begin{document}
\n\\maketitle
\n\\tableofcontents
\n\\chapter*{Preamble}
\n\\section*{License}
\nThis document is distributed under the \\textbf{GNU Free Documentation License}, version 1.3.\\\\
\nRead the full license terms at \\texttt{http://www.gnu.org/licenses/fdl-1.3.txt}.\\\\~\\\\
\nAn online version of this documentation is available at:\\\\\\texttt{http://gmic.eu/reference.shtml}.
\n\\section*{Motivations}
\nG\47MIC is an open and full-featured framework for image processing, providing several different user interfaces to
\nconvert/manipulate/filter/visualize generic image datasets, from 1d scalar signales to 3d+t sequences of multi-spectral volumetric images.
\nTechnically speaking, what it does is:
\n\\begin{itemize}
\n\\item Define a lightweight but powerful script language (the G\47MIC language) dedicated to the design of image processing pipelines.
\n\\item Provide several user interfaces embedding the corresponding interpreter:
\n\\begin{itemize}
\n\\item A command-line executable 'gmic', to use the G\47MIC framework from a shell.
\nIn this setting, G\47MIC may be seen as a direct (and friendly) competitor of the ImageMagick or GraphicsMagick software suites.
\n\\item A plug-in 'gmic\\_gimp', to bring G\47MIC capabilities to the GIMP image retouching software.
\n\\item A web-service 'G\47MIC Online', to allow users applying image processing algorithms directly in a web brower.
\n\\item A Qt-based interface 'ZArt', for real-time manipulation of webcam images.
\n\\item A C++ library 'libgmic', to be linked with third-party applications.
\n\\end{itemize}
\n\\end{itemize}
\nG\47MIC is focused on the design of possibly complex pipelines for converting, manipulating, filtering and visualizing generic 1d/2d/3d multi-spectral image datasets. This includes of course color images, but also more complex data as image sequences or 3d(+t) volumetric float-valued datasets.\\\\
\n
\nG\47MIC is an open framework: the default language can be extended with custom G\47MIC-written commands, defining thus new available image filters or effects. By the way, G\47MIC already contains a substantial set of pre-defined image processing algorithms and pipelines (more than 1000).\\\\
\n
\nG\47MIC has been designed with portability in mind and runs on different platforms (Windows, Unix, MacOSX). It is distributed under the CeCILL license (GPL-compatible). Since 2008, it is developed in the Image Team of the GREYC laboratory, in Caen/France, by permanent researchers working in the field of image processing on a daily basis.
\n\\section*{Version}
\n
\n \\Ca{\\textbf{gmic:} GREYC's Magic for Image Computing.}\\\\
\n
\n        \\Cb{Version \\textbf{"$strver$strbeta"}, Copyright (c) 2008-2015, David Tschumperl\\'e}\\\\
\n        \\Cb{(http://gmic.eu)}
\n\\chapter{Usage}
"
  -v -

_help_section_latex : -skip "$1"
  -v +
  -e[] "\\section{$1}"
  -v -

_help_paragraph_latex : -skip "$1"
  -v +
  -e[] "\\small"
  -e[] "\\begin{lstlisting}"
  -e[] "$1"
  -e[] "\\end{lstlisting}"
  -e[] "\\normalsize"
  -v -

_help_footer_latex :
  -v +
  -e[] "
\n\\printindex
\n~\\\\$\\square$~End of document.
\n\n\\end{document}"
  -v -

# Commands to output help in man page format.
_help_header_man :
  -v + -e[] ".TH G\47MIC 1\n\
        .SH NAME\n\
        gmic \\- Perform generic image processing operations, through the G\47MIC language interpreter.\n\
        \n\
       .SH HELP\n" -v -
  _gmic_n="\\fR" _gmic_b="\\fB" _gmic_r="" _gmic_g="" _gmic_c="\\fB" _gmic_m=""
  _gmic_is_beta=
  -__help_header_ascii
  _gmic_n="__N" _gmic_b="__B" _gmic_r="__B" _gmic_c="__B"
  _section=0 _space1="" _space2=" "
  -_help_section "Usage"

_help_section_man :
  _section={$_section+1}
  {narg({'"$1"'})},1,1,1,{'-'}
  -v +
  -e[] "\n \\fB"$_section". $1"
  -e[] "    "${_space{narg({'$_section'})}}@{-1,t}"\\fR\n"
  -v -
  -rm[-1]

_help_paragraph_man :
  -l[] ({'"$*"'})
  -replace_str "\\fR","__N"
  -replace_str "\\fB","__B"
  -replace_str "\\","\\\\\\\\"
  -replace_str "__N","\\\\fR"
  -replace_str "__B","\\\\fB"
  -v +
  -e[] @{0,t}
  -v -
  -rm -endl

_help_footer_man :
  -_help_footer_ascii $"*"

# start
# This command is called each time the cli interface 'gmic' starts.
# Overload it in your local user command file if necessary.
start :

# use_vt100
# This command defines some global variables used to output colored text on VT100 terminals.
use_vt100 :
  -if {narg($_gmic_vt100)} -v -
    _gmic_n="\33[0;0;0m" _gmic_r="\33[0;31;59m" _gmic_g="\33[0;32;59m" _gmic_m="\33[0;35;59m"
    _gmic_c="\33[0;36;59m" _gmic_b="\33[1m"
   -v + -endif

#@gmic version
#@gmic : Display current version number.
version :
  -v - -__help_header_ascii[] -v +
  -e[] ""

v : # Allow 'gmic --v' to get the version number.
  -version

#-------------------------------
#
#@gmic :: Inputs/outputs
#
#-------------------------------

#@gmic camera : _camera_index>=0,_nb_frames>0,_skip_frames>=0,_capture_width>=0,_capture_height>=0 : (+)
#@gmic : Insert one or several frames from specified camera, with custom delay between frames (in ms).
#@gmic : When 'nb_frames==0', the camera stream is released instead of capturing new images.
#@gmic : Default values: 'camera_index=0' (default camera), 'nb_frames=1', 'skip_frames=0' and 'capture_width=capture_height=0' (default size).

#@gmic m : eq. to '-command'. : (+)

#@gmic command : _add_debug_info={ 0 | 1 },{ filename | http[s]://URL | "string" } : (+)
#@gmic : Import G'MIC custom commands from specified file, URL or string.
#@gmic : (eq. to '-m').
#@gmic : Imported commands are available directly after the '-command' invocation.
#@gmic : Default value: 'add_debug_info=1'.
#@gmic : $ image.jpg -command "foo : -mirror y -deform $""1" --foo[0] 5 --foo[0] 15

#@gmic cupid : _size>0
#@gmic : Input cupid binary mask with specified size.
#@gmic : $ -cupid ,
cupid : -check "${1=480}>=1"
  -e[^-1] "Input $1x$1 cupid binary mask." -v -
  -l[]
  (480,480,1,1,1)
  ({'"                                                                                                   -WHX         /ZL[         1\\N]         2k         2l         4m         4m         4m         4m      "\
     "   4m         4m         4m         3l         3k         2k         1i         0i         /g         .g         -e         +c         )a         (`         &^         $\\         !Y          NW       "\
     "   LU          IQ                                                                                                                                                                                       "\
     "                                :R>Z         9ZD^      8T  *^G`      :X@Q  ?`Ib      ;ZCS  AcMe      ;[FTAQ \"{      ;\\GTBS $}      ;\\JVBS $}      ;]LWBT %}      ;hBV (~P      ;gBXNT 0~P      ;hC^ 0~P "\
     "     GQEhC^ 0~P      KZKpK_ 0~P      M~TM_ 0~P      ~h 0~P     !~i 0~P     \"~j 0~P     \#~k 0~     \#~m 1~     $~n 0}     %~o 0|     %~q 1|     &~r 0{     \47~t 1z     (~w 1y     *~z 2x     +~| 2w     +~~"\
     " 2v     ,~~P 1t     ,~~\\ <t     -~~_ =r     -~~` <p     .~~d =n     /~~f =m     0~~i =l     0~~i <j     0~~j ;h     0~~j 9f     /~~a /d     /~~a -b   4U  ~~` *_   3V !~~_ (\\   2X \"~~^ &Z   1Z $~~^ %X "\
     "  0[ %~~^ \#U   /\\ &~~^     ,] \47~~^     ,^ (~~_     -_ )~~_     -` *~~_     -a +~~`     -a ,~~`     -c .~~a     -c /~~a     -d 0~~a     ,e 2~~b     -f 3~~b     ,f 4~~b     +f 5~~b     +h 8~~c     *i ;~"\
     "~d     *k =~~d     )l @~~e     )o D~~f     (p F~~f     \47q I~~g     &r K~~g     %t N~~g     %w\"~~g     $x$~~g     .UJz\47~~f     .YL|*~~f KP    3ZL~-~~f LR    5~b1~~f MS    5~e4~~f MR    4~g5~~d MS    4~"\
     "i8~~e MS    3~j:~~e MS    3~k;~~d LS    3~l<~~d LS    2~l=~~c KS    1~l>~~c LU    2~m?~~b KU    0~k?~~b KV    0~k@~~b KX    2~l@~~` KZ    2~k@~~` K[    1~j@~~_ LTKU   2U&~i?~~] LSHU   4X\47~i@~~] MTGT  "\
     " 5[\47~g@~~\\ MTET   6\\\47~f?~~[ MSCT   7]&~e@~~Z MTCU   8_1VL~dA~~Z MTAU   9a5~pA~~Z NU@T   9c7~pA~~Y MT>U   :d:~qB~~Y LS=V   ;f<~rC~~Y MT<V   <h>~rC~~Y NT:V   <i@~rC~~Y U9V   =j@~qC~~Y T8W   =kB~qC~~Z\"T6"\
     "V   <nD~oB~~Y\"T5V   =qF~oA~~X$T3U   <sH~n=~~T%T1U   ;vK~l:~~R\47T/U   <~~h9~~Q(U.U   <~~g8~~P(T-V   <~~g8~~P*T+U   ;~~f8~~P+U*U   ;~~e7~~+T(T   ;~~e6~|+T\47U   :~~d7~|+T&U   :~~c7~|,T%V   ;~~c6~{,S\#U   9~"\
     "~b7~z-U\#V   9~~a7~z-T!U   7~~_7~y-U T   5~~^8~y.U NU   ?RH~~]8~x-T LU   BXK~~\\9~y.U LU   C~~k:~y/U JU   E~~l;~y.T IU   E~~l<~y.U HU   F~~m>~z/U GU   F~~m>~y.T FV   G~~m?~y.T DU   G~~m@~y.U DU   G~~n@~"\
     "w-T BU   G~~m@UH~i-T AU   F~~m*~^-U AU   E~~l*~]-U ?U   E~~l*~Z+T >U   C~~l,~Y+U >U   B~~t5~X+U =V   A~~v9~W+U ;U   @~~w;~W+U ;U   >~~y@~W+U :U   <~~zC~W+T 9V   ;~~zF~W+U 9V   8~~yH~W,U 7U   5~~xL~X+U"\
     " 7U   3~~~~S,U 6U   ?~~~~^,U 5U   @~~~~^+U 5V   B~~~~QIV+U 4V   C~~~~Q MU 3V   C~~~~P LT 2V   C~~~~ LU 2V   C~~~~ MU 1V   C~~~} MU 0V   B~~~| MT /V   A~~~{ NU /V   @~~~y NU /W   >~~~w NU /V   :~~~t U "\
     ".V   8~~~r!U -V   4~~~o\"U -V   .~~~j$U -W   1~~~r*V -V   3~~~y/V ,V   4~~~|1U ,W   5~~~~3V ,W   6~~~~R6V +V   5~~~~T8U +W   4~~~~U:T *W   4~~~~Z@U +W   3~~~~]DU +W   1~~~~^FT *W   0~~~~^HT *W   -~~~~^"\
     "KT *X   +~~~~^NU +X   \"~~~~\\ +X   !~~~~\\ ,X    ~~~~[ +W    ~~~~\\ ,W    N~~~~\\ -W    N~~~~] .X    N~~~~] /X    M~~~~] 0Y    L~~~~] 1X    J~~~~\\ 2X    G~~~~[ 4X    @~~~~V 6Y    >~~~~U 7X    >~~~~X :X   "\
     " >~~~~Z <Y    >~~~~] @Z    >~~~~t)Z    >~~~~{0[    =~~~~}4\\    =~~~~~Q9^    ;~~~~~R>a    4~~~~~Fd    4~~~~~n    5~~~~~o*S   1~~~~~q-X   4~~~~~y6Z   5~~~~~~UB]   7~~~~~~[J`   6~~~~~~p   /~~~~~hEu   /~~"\
     "~~~f=o   0~~~~~f2d   /~~~~~e1c   /~~~~~e0a   ,~~~~~c/^   \#~~~~~\\.\\   !~~~~~[-Y    N~~~~~Z*T    K~~~~~Z    !~~~~~Z     ~~~~~X     K~~~~~T     C~~~~{     B~~~~y     @~~~~x     >~~~~v     =~~~~v     ;~~~"\
     "~s     3~~~~l     1~~~~[M\\     0~~kKX:vGZ     .~~hHT4oDZ     ,TK`L~xGR\47_?Y     !]I~vGQ 5Y      ZG~vFP 4Y      NWF~vFP 4Y      =~wGQ 5Y      =~wGQ 5Y      =~wGQ 4X      >~xFP 4X      ?~zGQ 5X      @~{G"\
     "Q 5Y      D~~GQ 4X      F~~QGR 5X      G~~RFQ 5X      H~~SFQ 4X      J~~TFR 5X      K~~UEQ 4W      L~~VEQ 4X      N~~WEQ 4X      ~~XER 4W      ~~XDQ 4X     \"~~YDQ 4X     \#~~ZDQ 3W     $~~[DR 4X     %~"\
     "~[DR 4X     &~~\\CQ 4X     &~~\\CQ 4X     &~~\\CQ 4X     \47~~]CR 5X     \47~~]BQ 5X     \47~~\\AQ 5X     \47~~\\AQ 5X     (~~]AR 6X     (~~]@Q 6X     (~~]@Q 7Y     )~~]?Q 7X    LV 2~~]?R 8X   !] 5~~]>Q 8X   \#a 7~"\
     "~]>Q 9Y   %d 8~~\\=R :X   &g 9~~\\=R :X   )k :~~\\<Q ;Y   7y :~~\\<Q ;X   8| ;~~[;R <X   9} ;~~[;R =Y   :~ ;~~[;R =X   :~Q <~~Z9Q >Y   ;~R <~~Z9R ?X   :~R <~~Y8R @Y   ;~S <~~X6Q @X   :~S <~~X6Q AY   ;~T ="\
     "~~X5R BX   :~T >~~X4R CX   9~U B~~Z2Q CX   9~U F~~]1Q DX   8~V I~~_1Q EX   7~X L~~^/R GY   7~d*~~_/R HY   5~f/~~a.Q HX   4~h2~~a-Q IX   1TJ~_7~~c-R KY   $~^;~~e-R LY   \"~^=~~f,Q MY    ~_@~~h-Q NY    K"\
     "~]B~~i-R!Y    H~[C~~k.R\"Y    B~WE~~l-Q\#Y    =~TG~~m-R%Y    ;~TH~~n.R\47Z    9~TJ~~p/R(Z    7~TL~~q.Q)Z    5~~~x.R,[    3~~~x/R-[    1~~~w/R.Z    /~~~w.Q0[    -~~~v.Q2\\    +~~~v/R4[    (~~~u/R6[    &~~~u"\
     ".Q8\\    $~~~t.Q9\\    \"~~~s.Q;\\     N~~~s/R>]     L~~~r.Q@]     I~~~q.QB^     G~~~p.QC]     D~~~p.QF\\     @~~~o.QH\\     =~~~n.RK\\     :~~~m.b     8~~~l.`     5~~~k.]     1~~~j.Y     +~~~h.W     (~~~g.U"\
     "     &~~~g.T     \#~~~e.S     !~~VJ~X.S      N~~RF~V.R      L~~PD~U.R      J~{A~U/Q      G~w>~T      \#~s;~S      !~m6~R       N~i3~Q       J~a.~P       G~Z)~       E~ M}       Ds C|       Cf 6{       A"\
     "a 2z       @] .z       ?Y +y       <S (y         C| 1R       :~R BVHX       ?~T CYKZ       A~U D[N]       C~V El       E~W El       G~X Dl       H~Y En       J~Z En       J~Y Dn       L~[ Dn       L~Z"\
     " Cm       L~Z Al       M~Z @l       M~Z @l       N~Z ?k       M~Y =j       N~Y <i       M~X :h       N~W 8g       M~V 6e       M~V 4c       M~U 1a       L~T 0a       M~T ._       M~T ,]       M~S )[  "\
     "     N~S %W       L~Q \"U       N~S  S       ~S         L~T         K~T         L~T         K~S         J~S         J~Q         G~P         G~         E|         Cz         Ax         ?v         =t    "\
     "     ;r         9p         7p         6n         5n         4n         5n         4m         3l         2k         1j         0i         .g         -f         -f         ,e         ,e         ,f      "\
     "   -f         ,e         ,f         -g         .g         .h         .g         .h         -f         -f         +c         \47`         \#Y                                                               "\
     "                                            2"'})
  --[-1] {47+32} -a x -y -uncompress_rle -r $1,$1,1,1,5 -if {$1>480} -b[-1] 0.2% -endif ->= 40%
  -nm "[Cupid binary mask]"
  -endl -v +

#@gmic cursor : _mode = { 0=hide | 1=show } : (+)
#@gmic : Show or hide mouse cursor for selected instant windows.
#@gmic : Command selection (if any) stands for instant window indices instead of image indices.
#@gmic : Default value: 'mode=1'.

#@gmic d : eq. to '-display'. : (+)

#@gmic display : _X,_Y,_Z : (+)
#@gmic : Display selected images in an interactive viewer (use the instant window [0] if opened).
#@gmic : Arguments 'X','Y','Z' determine the initial selection view, for 3d volumetric images.
#@gmic : (eq. to '-d').
#@gmic : $$

#@gmic d0 : eq. to '-display0'.
d0 :
  -_display0

#@gmic display0
#@gmic : Display selected images without value normalization.
#@gmic : (eq. to '-d0').
display0 :
  -_$0

_display0 :
  -v -
  w=0 h=0 d=0 s=0
  -repeat @# -l[$>] w={$w+w} h={max($h,h)} d={max($d,d)} s={max($s,s)} -endl -done
  -if {@#==1} -w -1,-1,0,0,-1,-1,@{0,n}\ ($wx$hx$dx$s)
  -elif {@#==2} -w -1,-1,0,0,-1,-1,@{0,n},@{-1,n}\ ($wx$hx$dx$s)
  -else -w -1,-1,0,0,-1,-1,@{0,n},..,@{-1,n}\ ($wx$hx$dx$s)
  -endif
  -v + -d
  -v - -w[] 0 -v +

#@gmic d3d : eq. to '-display3d'. : (+)

#@gmic display3d : _[background_image] : (+)
#@gmic : Display selected 3d objects in an interactive viewer (use the instant window [0] if opened).
#@gmic : (eq. to '-d3d').
#@gmic : Default value: '[background_image]=(default)'.

#@gmic da : eq. to '-display_array'.
da :
  -v - _gmic_s="$?" -v +
  -_display_array $*

#@gmic display_array : _width>0,_height>0
#@gmic : Display images in interactive windows where pixel neighborhoods can be explored.
#@gmic : Default values: 'width=13' and 'height=width'.
display_array :
  -v - _gmic_s="$?" -v +
  -_$0 $*

_display_array : -check ${1=13}>0" && "${2=$1}>0
  -e[0--3] "Display $1x$2 array of pixel values for image"$_gmic_s"."
  -v -
  dxb={round($1/2,1,1)} dxf={$1-1-$dxb}
  dyb={round($2/2,1,1)} dyf={$2-1-$dyb}

  -repeat @# -l[$>]
    -if {w<128" && "h<128} -r 128,128,100%,100%,0,0,0.5,0.5 -endif    # Manage cases of small and large images.
    x0=0 y0=0 w={w} h={h}
    wmax={0.9*@{!,u}} hmax={0.9*@{!,v}}
    -do
      -if {w>=$wmax||h>=$hmax}
        n=@{-1,n} -nm[-1] "Image "'@{-1,b}.@{-1,x}'" is too large, please select a sub-image."
        --select[-1] 2 x0={i[0]} y0={i[1]} w={1+i[3]-i[0]} h={1+i[4]-i[1]}
        -rm[-1] -nm[-1] $n
      -endif
      --z[-1] $x0,$y0,0,{$x0+$w-1},{$y0+$h-1},0 -round[-1] 1 -n[-1] 0,255
    -while {w>=$wmax||h>=$hmax}

    x1=-1 y1=-1 c1=0 ox1=-1 oy1=-1 oc1=-1
    x2=-1 y2=-1 c2=0 ox2=-1 oy2=-1 oc2=-1
    x3=-1 y3=-1 c3=0 ox3=-1 oy3=-1 oc3=-1
    c0=0 oxm=-1 oym=-1
    -w[-1] -1,-1,0,0,-1,-1,@{-2,b}.@{-2,x}
    -do  # Enter event loop.

      # Manage user interactions.
      -wait[0-3]
      oc0=$c0
      -repeat 4
        -if {$>" && "!@{!$>}" && "${x$>}>=0} -w$> 0 x$>=-1 y$>=-1 c$>=0 -endif
        -if @{!$>,o} c$>={(${c$>}+sign(@{!$>,o}))%s} -wait[$>] -1 -endif
        -if {@{!$>,SPACE}" || "@{!$>,ENTER}" || "@{!$>,ARROWRIGHT}" || "@{!$>,ARROWDOWN}} c$>={(${c$>}+1)%s} -wait[$>] -1 -endif
        -if {@{!$>,BACKSPACE}" || "@{!$>,ARROWLEFT}" || "@{!$>,ARROWUP}} c$>={(${c$>}-1)%s} -wait[$>] -1 -endif
      -done
      -if {$oc0!=$c0} c1=$c0 c2=$c0 c3=$c0 -endif
      xm=@{!,x} ym=@{!,y}
      -if {$xm>=0" && "@{!,b}&1} x1=$xm y1=$ym -endif
      -if {$xm>=0" && "@{!,b}&2} x2=$xm y2=$ym -endif
      -if {$xm>=0" && "@{!,b}&4} x3=$xm y3=$ym -endif

      # Generate main image view.
      -if {$xm>=0" && "($oxm!=$xm" || "$oym!=$ym)} -w[] -1,-1,-1,-1,-1,-1,@{-2,b}.@{-2,x}" - ("$xm,$ym")" -endif
      -if {$x1!=$ox1" || "$y1!=$oy1" || "$x2!=$ox2" || "$y2!=$oy2" || "$x3!=$ox3" || "$y3!=$oy3}
        [-1]
        -if {$x1>=0}
          xb={$x1-$dxb} yb={$y1-$dyb} xe={$x1+$dxf} ye={$y1+$dyf}
          -rectangle[-1] $xb,$yb,$xe,$ye,0.2,0,255,255
          -rectangle[-1] $xb,$yb,$xe,$ye,1,0xFFFFFFFF,0,255,255
        -endif
        -if {$x2>=0}
          xb={$x2-$dxb} yb={$y2-$dyb} xe={$x2+$dxf} ye={$y2+$dyf}
          -rectangle[-1] $xb,$yb,$xe,$ye,0.2,255,32,255
          -rectangle[-1] $xb,$yb,$xe,$ye,1,0xFFFFFFFF,255,32,255
        -endif
        -if {$x3>=0}
          xb={$x3-$dxb} yb={$y3-$dyb} xe={$x3+$dxf} ye={$y3+$dyf}
          -rectangle[-1] $xb,$yb,$xe,$ye,0.2,255,255,0
          -rectangle[-1] $xb,$yb,$xe,$ye,1,0xFFFFFFFF,255,255,0
        -endif
        -w[-1] @{-2,w},@{-2,h} -rm[-1] oxm=$xm oym=$ym
      -endif

      # Generate zoomed views.
      -if {$x1>=0" && "($ox1!=$x1" || "$oy1!=$y1" || "$oc1!=$c1)}
        --z[-2] {$x1-$dxb},{$y1-$dyb},0,$c1,{$x1+$dxf},{$y1+$dyf},0,$c1
        --z[-2] {$x1-$dxb},{$y1-$dyb},0,{$x1+$dxf},{$y1+$dyf},0
        -__display_array[-2,-1] $1,$2,0,255,255
        -w1[-1] {w},{h},0,0,-1,-1,@{-3,b}" - ("$x1,$y1,c=$c1")"
        -rm[-1] ox1=$x1 oy1=$y1 oc1=$c1
      -endif
      -if {$x2>=0" && "($ox2!=$x2" || "$oy2!=$y2" || "$oc2!=$c2)}
        --z[-2] {$x2-$dxb},{$y2-$dyb},0,$c2,{$x2+$dxf},{$y2+$dyf},0,$c2
        --z[-2] {$x2-$dxb},{$y2-$dyb},0,{$x2+$dxf},{$y2+$dyf},0
        -__display_array[-2,-1] $1,$2,255,32,255
        -w2[-1] {w},{h},0,0,-1,-1,@{-3,b}" - ("$x2,$y2,c=$c2")"
        -rm[-1] ox2=$x2 oy2=$y2 oc2=$c2
      -endif
      -if {$x3>=0" && "($ox3!=$x3" || "$oy3!=$y3" || "$oc3!=$c3)}
        --z[-2] {$x3-$dxb},{$y3-$dyb},0,$c3,{$x3+$dxf},{$y3+$dyf},0,$c3
        --z[-2] {$x3-$dxb},{$y3-$dyb},0,{$x3+$dxf},{$y3+$dyf},0
        -__display_array[-2,-1] $1,$2,255,255,0
        -w3[-1] {w},{h},0,0,-1,-1,@{-3,b}" - ("$x3,$y3,c=$c3")"
        -rm[-1] ox3=$x3 oy3=$y3 oc3=$c3
      -endif
    -while {@!" && "\
            !@{!,ESC}" && "!@{!,Q}" && "\
            !@{!1,ESC}" && "!@{!1,Q}" && "\
            !@{!2,ESC}" && "!@{!2,Q}" && "\
            !@{!3,ESC}" && "!@{!3,Q}}
    -k[0] -w 0 -w1 0 -w2 0 -w3 0
  -endl -done -v +

__display_array :
  -round[-2] 1 -c[-2] 0,999 -r[-1] 100%,100%,1,3,{if(s==1,1,0)}
  --luminance[-1] -r[-2] {$1*24},{$2*24} -grid[-2] {100/$1}%,{100/$2}%,0,0,1,0
  xb={24*int($1/2)} yb={24*int($2/2)} xe={$xb+24} ye={$yb+24}
  -rectangle[-2] $xb,$yb,$xe,$ye,1,0xFFFFFFFF,$3,$4,$5
  -repeat $2 yg=$>
    -repeat $1 xg=$>
      -t[-2] @{-3,($xg,$yg)},{5+$xg*24},{5+$yg*24},13,0.8,{if(@{-1,($xg,$yg)}>128,0,255)}
    -done
  -done
  -rm[-3,-1]

#@gmic dfft : eq. to '-display_fft'.
dfft :
  -_display_fft

#@gmic display_fft
#@gmic : Display fourier transform of selected images, with centered log-module and argument.
#@gmic : (eq. to '-dfft').
#@gmic : $ image.jpg --display_fft
display_fft :
  -_$0

_display_fft :
  -e[0--3] "Render fourier transform of image$? with centered log-module and argument."
  -v - -repeat @# -l[$>] -fftpolar -+[-2] 1 -log[-2] -n 0,255 -a x -endl -done -s x,2 -v +

#@gmic dg : eq. to '-display_graph'.
dg : -check "${1=640}>32 && ${2=480}>32" -skip ${3=1},${4=0},${5=0},${6=0},${7=0},${8=0},"${9=x-axis}","${10=y-axis}"
  -_display_graph ${1-8},"$9","$10"

#@gmic display_graph : _width>32,_height>32,_plot_type,_vertex_type,_xmin,_xmax,_ymin,_ymax,_xlabel,_ylabel
#@gmic : Render graph plot from selected image data.
#@gmic : Default values: 'width=640', 'height=480', 'plot_type=1', 'vertex_type=1', 'xmin=xmax=ymin=ymax=0', 'xlabel="x-axis"' and 'ylabel="y-axis"'.
#@gmic : $ 128,1,1,1,'cos(x/10+?)' --display_graph 400,300,3
display_graph : -check "${1=640}>32 && ${2=480}>32" -skip ${3=1},${4=0},${5=0},${6=0},${7=0},${8=0},"${9=x-axis}","${10=y-axis}"
  -_display_graph ${1-8},"$9","$10"

_display_graph : -check "${1=640}>32 && ${2=480}>32" -skip ${3=1},${4=0},${5=0},${6=0},${7=0},${8=0},"${9=x-axis}","${10=y-axis}"
  -e[0--3] "Render $1x$2 graph plot from data of image$?."
  -v - -repeat @# -l[$>] nm=@{0,n}

    # Determine xmin,xmax/ymin,ymax.
    one={$3!=3} siz={w*h*d}
    -if {$5==$6} xmin=0 xmax={$siz-$one} -else xmin={min($5,$6)} xmax={max($5,$6)} -endif
    -if {$7==$8} ymin={im-(iM-im)/20} ymax={iM+(iM-im)/20} -else ymin={min($7,$8)} ymax={max($7,$8)} -endif

    # Create plot canvas.
    gw={$1-32} gh={$2-32} gg={($gw-$one)/($siz-$one)}
    $gw,$gh,1,3,255
    -if {$siz<32} -grid[-1] $gg,$gg,0,0,0.25,0xCCCCCCCC,0
    -else -grid[-1] 10%,10%,0,0,0.25,0xCCCCCCCC,0
    -endif

    # Define color palette for curves.
    -if {@{-2,s}==1} (120,120,200)
    -elif {@{-2,s}<=3} (220,10,10;10,220,10;10,10,220)
    -else
      (0,255) -r[-1] 256,1,1,1,3 -map[-1] 2 -z[-1] 2,100% -permute[-1] cxyz -r[-1] 3,{max(3,@{-3,s})},1,1,0,2
      -sh[-1] 0,2,0,0 -f[-1] 255,0,0,0,255,0,0,0,255 -rm[-1]
    -endif

    # Draw plot for each channel.
    -repeat @{-3,s} -sh[-3] $>,$> -graph[-3] [-1],$3,$4,$ymax,$ymin,1,@{-2,0-2} -rm[-1] -shift[-1] 0,-1 -done
    -rm[-3,-1]
    -line[-1] 0,0,100%,0,1,110 -line[-1] 100%,0,100%,100%,1,110
    -line[-1] 100%,100%,0,100%,1,255 -line[-1] 0,100%,0,0,1,255

    100%,100%,1,1,255
    xmax_={$xmin+($xmax-$xmin)*($siz-$one)/($siz-1)}
    -axes[-1] $xmin,$xmax_,$ymax,$ymin,13,1,0
    -if {$xmin>0} -axes[-1] 0,0,$ymax,$ymin,13,1,160 -endif
    -if {$xmax<0} -axes[-1] {w-1},{w-1},$ymax,$ymin,13,1,160 -endif
    -if {$ymin>0} -axes[-1] $xmin,$xmax_,{h-1},{h-1},13,1,160 -endif
    -if {$ymax<0} -axes[-1] $xmin,$xmax_,0,0,13,1,160 -endif
    --erode[-1] 3 -!=[-1] 255 -r[-2] 100%,100%,1,3 -j[-3] [-2],0,0,0,0,1,[-1],1 -rm[-2,-1]
    -frame[-1] 16,16,220
    0 -t[-1] "$9",0,0,13,1,-220,-220,-220 -j[-2] [-1],{(@{-2,w}-w)/2},{@{-2,h}-16},0,0,-1 -rm[-1]
    0 -t[-1] "$10",0,0,13,1,-220,-220,-220 -rotate[-1] -90 -j[-2] [-1],2,{(@{-2,h}-h)/2},0,0,-1 -rm[-1]

  -nm $nm,1 -endl -done -c 0,255 -v +

#@gmic dh : eq. to '-display_histogram'.
dh :
  -v - _gmic_s="$?" -v +
  -_display_histogram $"*"

#@gmic display_histogram : _width>0,_height>0,_clusters>0,_min_value[%],_max_value[%],_show_axes={ 0 | 1 },_expression.
#@gmic : Render a channel-by-channel histogram.
#@gmic : If selected image has several slices, the rendering is performed for all input slices.
#@gmic : 'expression' is a mathematical expression used to transform the histogram data for visualization purpose.
#@gmic : (eq. to '-dh').
#@gmic : Default values: 'width=512', 'height=300', 'clusters=256', 'min_value=0%', 'max_value=100%', 'show_axes=1' and 'expression=i'.
#@gmic : $ image.jpg --display_histogram 512,300
display_histogram :
  -v - _gmic_s="$?" -v +
  -_$0 $"*"

_display_histogram : -check "${1=512}>0 && ${2=300}>0 && ${3=256}>0" -skip ${4=0%},${5=100%},${6=1},"${7=i}"
  -e[0--3] "Render $1x$2 channel-by-channel histogram of image"$_gmic_s", with $3 clusters, minimum value $4 and maximum value $5."
  -v - -repeat @# -l[$>] nm=@{0,n}
    -if @{-is_percent\ $4} m={im+(iM-im)*$4} -else m=$4 -endif
    -if @{-is_percent\ $5} M={im+(iM-im)*$5} -else M=$5 -endif
    s={s} -s c
    -repeat $s -l[{-1-$>}] -s z -histogram $3,$m,$M -a z -endl -done
    -a c -f '"$7"' vM={iM} -s z
    -repeat @# -l[$>]
      $1,$2,1,{s},-255
      -repeat {s} -sh[-2,-1] $>,$> -graph[-1] [-2],3,0,$vM,0,1,0 -rm[-2,-1] -done
      -rm[-2] -+ 255
      -if $6 100%,100% -axes[-1] $m,$M,$vM,0,13,1,255 --dilate[-1] 3 -r[-2] [-3] -j[-3] [-2],0,0,0,0,1,[-1],255 -rm[-2,-1] -endif
    -endl -done
    -a z -nm $nm,1
  -endl -done -v +

#@gmic display_parametric : _width>0,_height>0,_outline_opacity,_vertex_radius>=0,_is_antialiased={ 0 | 1 },_is_decorated={ 0 | 1 },_xlabel,_ylabel
#@gmic : Render 2d or 3d parametric curve or point clouds from selected image data.
#@gmic : Curve points are defined as pixels of a 2 or 3-channel image.
#@gmic : If the point image contains more than 3 channels, additional channels define the (R,G,B) color for each vertex.
#@gmic : If 'outline_opacity>1', the outline is colored according to the specified vertex colors and 'outline_opacity-1' is used
#@gmic : as the actual drawing opacity.
#@gmic : Default values: 'width=512', 'height=width', 'outline_opacity=3', 'vertex_radius=0', 'is_antialiased=1', 'is_decorated=1', 'xlabel="x-axis"' and 'ylabel="y-axis"'.
#@gmic : $ 1024,1,1,2,'t=x/40;if(c==0,sin(t),cos(t))*(exp(cos(t))-2*cos(4*t)-sin(t/12)^5)' -display_parametric 512,512
#@gmic : $ 1000,1,1,2,?(-100,100) -quantize 4,1 -noise 12 -channels 0,2 --normalize 0,255 -append c -display_parametric 512,512,0.1,8
display_parametric : -check "${1=512}>0 && ${2=$1}>0 && ${4=0}>=0" -skip ${3=3},${5=1},${6=1},"${7=x-axis}","${8=y-axis}"
  -v - s0="no " s1="" o0="" o1="colored "
  -v + -e[^-1] "Render $1x$2 parametric graph plot from data of image$?, with "${o{$3>1}}"outline opacity "{if($3>1,$3-1,$3)}\
               ", vertex radius $4, "${s{$5!=0}}"antialiasing and "${s{$6!=0}}"decoration." -v -
  -repeat @# -l[$>]
    nm=@{0,n} N={w*h*d}
    -i[0] ({'CImg3d'}) -+[0] 0.5 -i[1] ($N;$N)  # Header + nb of vertices/primitives.

    # Calibrate colors of vertices.
    -if {s==4} --channels[-1] 3,3 -r[-1] 100%,100%,1,2 -a[-2,-1] c is_grayscale=1
    -else is_grayscale={s<4} -channels[-1] 0,5
    -endif

    # Manage coordinates of vertices.
    -sh[-1] 0,0 xm={im} xM={iM} -rm[-1]
    -sh[-1] 1,1 ym={im} yM={iM} -rm[-1]
    -sh[-1] 2,2 zm={im} zM={iM} -rm[-1]
    -permute[-1] cxyz -s[-1] x,2
    -i[-2] (1,0;1,{$N-1}) -r[-2] 2,$N,1,1,3 -round[-2] 1,$N,1,1,1 # Primitives, colors and opacities.
    -y -a y -c3d -n3d -*3d 1,-1,1

    {if($6,max(1,$1-32),$1)},{if($6,max(1,$2-32),$2)},1,{if($is_grayscale,1,3)},255
    -*3d[0] {0.96*min(w,h)}
    -if $6 L={0.1*max($1,$2)} -grid[1] $L,$L,0,0,0.25,0xCCCCCCCC,0 -endif

    -if $5 # Anti-aliased.
      -r[1] 200%,200%,1,100%,1 -*3d[0] 2
      -if $4 --circles3d[0] {2*$4} -j3d[1] [2],50%,50%,0,1,3,0,0 -rm[2] -endif
    -elif $4 # Aliased.
      --circles3d[0] $4 -j3d[1] [2],50%,50%,0,1,3,0,0 -rm[2]
    -endif

    -if $3 -l[0] -s3d -f[1] 'i-y' -rm[3] -i[3] (2,0,1;2,{$N-2},{$N-1}) -r[3] 3,{$N-1},1,1,3 -round[3]  # Convert point cloud to connected segments.
      -r[5] 1,{h-1},1,1,0
      -if {$3>1} -r[4] 3,@{4,h/3},1,1,-1 -r[4] 3,@{4,h-1},1,1,2 -else -rm[4] -i[4] 3,{$N-1} -endif
      -y -a y -endl -j3d[1] [0],50%,50%,0,{if($3>1,$3-1,$3)},2,0,0
    -endif

    -rm[0]
    -if $5 -r[-1] 50%,50%,1,100%,2 -endif

    -if $6 # Add decoration.
      xc={0.5*($xm+$xM)} yc={0.5*($ym+$yM)} dx={0.5*($xM-$xm)/0.96} dy={0.5*($yM-$ym)/0.96}
      xm={$xc-$dx} xM={$xc+$dx} ym={$yc-$dy} yM={$yc+$dy}
      100%,100% -axes[-1] $xm,$xM,$yM,$ym,13,1,1
      -if {$xm>0} -axes[-1] 0,0,$yM,$ym,13,1,160 -endif
      -if {$xM<0} -axes[-1] {w-1},{w-1},$yM,$ym,13,1,160 -endif
      -if {$ym>0} -axes[-1] $xm,$xM,{h-1},{h-1},13,1,160 -endif
      -if {$yM<0} -axes[-1] $xm,$xM,0,0,13,1,160 -endif
      --dilate[-1] 3 --[-1] [-2] -*[-1] 200 -==[-2] 0
      -*[-3,-2] -+[-2,-1] -c[-1] 0,255
      -frame 1,1,128 -frame 15,15,220
      0 -t[-1] "$7",0,0,13,1,-220,-220,-220 -j[-2] [-1],{(@{-2,w}-w)/2},{@{-2,h}-16},0,0,-1 -rm[-1]
      0 -t[-1] "$8",0,0,13,1,-220,-220,-220 -rotate[-1] -90 -j[-2] [-1],2,{(@{-2,h}-h)/2},0,0,-1 -rm[-1]
    -endif
    -nm[-1] $nm,1
  -endl -done -v +

#@gmic dp : eq. to '-display_polar'.
dp :
  -v - _gmic_s="$?" -v +
  -_display_polar $*

#@gmic display_polar : _width>32,_height>32,_outline_type,_fill_R,_fill_G,_fill_B,_theta_start,_theta_end,_xlabel,_ylabel
#@gmic : Render polar curve from selected image data.
#@gmic : (eq. to '-dp').
#@gmic : 'outline_type' can be { r<0=dots with radius -r | 0=no outline | r>0=lines+dots with radius r }.
#@gmic : 'fill_color' can be { -1=no fill | R,G,B=fill with specified color }.
#@gmic : Default values: 'width=500', 'height=width', 'outline_type=1', 'fill_R=fill_G=fill_B=200', 'theta_start=0', 'theta_end=360', 'xlabel="x-axis"' and 'ylabel="y-axis"'.
#@gmic : $ 300,1,1,1,'0.3+abs(cos(10*pi*x/w))+?(0.4)' -display_polar 512,512,4,200,255,200
#@gmic : $ 3000,1,1,1,'x^3/1e10' -display_polar 400,400,1,-1,,,0,{15*360}
display_polar :
  -v - _gmic_s="$?" -v +
  -_$0 $*

_display_polar : -check "${1=500}>32 && ${2=$1}>32" -skip ${3=1},${4=200},${5=$4},${6=$5},${7=0},${8=360},"${9=x-axis}","${10=y-axis}"
  -e[0--3] "Render $1x$2 polar graph plot from data of image"$_gmic_s", with outline $4 and fill color ($4,$5,$6)."
  -v - -repeat @# -l[$>] nm=@{0,n}

    # Compute (x,y) coordinates of the polar curve points.
    M={max(abs(iM),abs(im))}
    -* {0.48*min($1,$2)/$M}
    -y ({$7*pi/180};{-$8*pi/180}) -r[-1] 1,[-2],1,1,3
    --sin[-1] -cos[-2] -*[-1] [-3] -*[-3,-2]
    -a[-2,-1] x N={h}
    -nm[-1] coords

    # Generate 3d object for curve outline.
    -if $3
      ({'CImg3d'}) -+[-1] 0.5 ($N,$N)
      --z[coords] 0,2
      1,$N,1,1,2 1,$N,1,1,'y' --+[-1] 1 -a[-3--1] x -=[-1] 0,2,100%
      3,$N,1,1,0 1,$N,1,1,1 -y[-6--1] -a[-6--1] y
      -nm[-1] _plot_polar_outline
    -endif

    # Generate 3d object for filling.
    -if {"$4>=0 && $5>=0 && $6>=0"}
      ({'CImg3d'}) -+[-1] 0.5 ({$N+1},$N)
      --z[coords] 0,-1,2,100% -z[-1] 0,2
      1,$N,1,1,3 1,$N 1,$N,1,1,'1+y' --+[-1] 1 -a[-4--1] x -=[-1] 1,3,100%
      3,$N,1,1,$4,$5,$6 1,$N,1,1,1
      -y[-6--1] -a[-6--1] y
      -nm[-1] _plot_polar_fill
    -endif
    -rm[coords]  # Remove original curve coordinates.

    # Render graph image.
    {$1-32},{$2-32},1,3,255
    L={0.1*max($1,$2)} -grid[-1] $L,$L,0,0,0.25,0xCCCCCCCC,0  # Draw background grid.
    -if {"$4>=0 && $5>=0 && $6>=0"}                           # Draw curve filling.
      -j3d[-1] [_plot_polar_fill],50%,50%,0,1,2,1,0
      -rm[_plot_polar_fill]
    -endif
    -if $3
      -if {$3>=0}                                             # Draw curve outline.
        -j3d[-1] [_plot_polar_outline],50%,50%,0,1,1,0,0
      -endif
      -if {$3!=0}                                             # Draw curve vertices.
        -if {abs($3)>1} -circles3d[_plot_polar_outline] {abs($3)} -endif
        -j3d[-1] [_plot_polar_outline],50%,50%,0,0.2,2,0,0
      -endif
      -rm[_plot_polar_outline]
    -endif

    # Draw axes and frame.
    nM={$M/0.96}
    100%,100% -axes[-1] {-$nM},$nM,$nM,{-$nM},13,1,1
    --dilate[-1] 3 --[-1] [-2] -*[-1] 200 -==[-2] 0
    -*[-3,-2] -+[-2,-1] -c[-1] 0,255
    -frame[-1] 1,1,128 -frame[-1] 15,15,220
    0 -t[-1] "$9",0,0,13,1,-220,-220,-220 -j[-2] [-1],{(@{-2,w}-w)/2},{@{-2,h}-16},0,0,-1 -rm[-1]
    0 -t[-1] "$10",0,0,13,1,-220,-220,-220 -rotate[-1] -90 -j[-2] [-1],2,{(@{-2,h}-h)/2},0,0,-1 -rm[-1]

  -nm $nm,1 -endl -done -v +

#@gmic drgba : eq. to '-display_rgba'.
drgba :
  -_display_rgba

#@gmic display_rgba
#@gmic : Render selected RGBA images over a checkerboard background.
#@gmic : (eq. to '-drgba').
#@gmic : $ image.jpg --norm -threshold[-1] 40% -blur[-1] 3 -normalize[-1] 0,255 -append c -display_rgba
display_rgba :
  -_$0

_display_rgba :
  -e[0--3] "Render RGBA image$? over a checkerboard background."
  -v - -to_a -repeat @# -l[$>]
    -i[0] (160,128;128,160) -nm[0] @{1,n} -r[0] 16,16 -r[0] [1],[1],1,{s-1},0,2 -blend alpha
  -endl -done -v +

#@gmic dt : eq. to '-display_tensors'.
dt :
  -v - _gmic_s="$?" -v +
  -_display_tensors $*

#@gmic display_tensors : _size_factor>0,_ellipse_factor>=0,_colored_mode={ 0 | 1 }
#@gmic : Render selected mask field of 2x2 tensors with ellipses.
#@gmic : (eq. to '-dt').
#@gmic : Default values: 'size_factor=16', 'ellipse_factor=0.92', 'color_mode=1'.
#@gmic : $ image.jpg -diffusiontensors 0.7,0.6 -crop 60,10,90,30 --display_tensors ,
#@gmic : $$
display_tensors :
  -v - _gmic_s="$?" -v +
  -_$0 $*

_display_tensors : -check "${1=16}>0 && ${2=0.92}>=0" -skip "${3=1}"
  -e[0--3] "Render field of 2x2 tensors from image"$_gmic_s", with size factor $1, ellipse factor $2 in "@{-arg\ 1+!$3,colored,masked}" mode."
  -v -
  -if {$3} -repeat @# -l[$>]
    --_display_tensors $1,$2,0
    -s[0] c --min[0,2] -*[1] -1 -+[1,-1] -a[0-2] c
    -r[0] [-1],[-1] -n[0] 0,255 -*
  -endl -done -else -repeat @# -l[$>]
    w={w} h={h}
    -* {($2*$1/2)^2/max(abs(im),abs(iM))}     # Normalize tensor values.
    -s c -i[-2] [-2] -a c -s yx -r 2,2,1,1,-1 # Decompose field into list of 2x2 matrices.
    (0.5,0;0,0.5) -+[^-1] [-1] -rm[-1]        # Add 0.5*Id to ensure tensor positivity.
    -invert -y c -r $1,$1                     # Optimized code for ellipses drawing.
    $1,$1,1,1,'x' --[-1] {w/2}
    $1,$1,1,1,'y' --[-1] {h/2}
    --sqr[-1] -*[-2] [-3] -sqr[-3] -i[-2] [-2] -a[-4--1] c
    -*[^-1] [-1] -rm[-1] -compose_channels + -<= 1
    -append_tiles $w,$h                       # Recompose ellipses as a tensor field.
  -endl -done -endif
  -v +

#@gmic dw : eq. to '-display_warp'.
dw :
  -v - _gmic_s="$?" -v +
  -_display_warp $*

#@gmic display_warp : _cell_size>0
#@gmic : Render selected 2d warping fields.
#@gmic : (eq. to '-dw').
#@gmic : Default value: 'cell_size=15'.
#@gmic : $ image.jpg -luminance -blur 5 -gradient -append c -display_warp ,
display_warp :
  -v - _gmic_s="$?" -v +
  -_$0 $*

_display_warp : -check "${1=15}>0"
  -e[0--3] "Render 2d warping field"$_gmic_s", with cell size $1."
  -v - -repeat @# -l[$>]
    -if {d!=1||s!=2}
      -error[0--3] "Command '-display_warp': Invalid image ["{@#-$>-1}"]: Dimensions "{w}","{h}","{d}","{s}" does not represent a 2d field of 2d vectors."
    -endif
    -i[0] 100%,100%,1,1,1 -grid[0] $1,$1 -nm[0] @{1,n}
    -warp[0] [1],1,1,0 -rm[1]
  -endl -done -* 255 -v +

#@gmic document_gmic : _format={ ascii | bash | html | images | latex },_image_path,_write_wrapper={ 0 | 1 }
#@gmic : Create documentation of .gmic command files (loaded as raw 'uchar' images), in specified format.
#@gmic : Default values: 'format=ascii', 'image_path=""' and 'write_wrapper=1'.\n
#@gmic : Example(s) : raw:filename.gmic,char -document_gmic html,img
document_gmic : -skip ${1="ascii"},${2=""},${3=1}
  -if {!@#} -return -endif
  -v -1

  # Concatenate command data and split them into lines.
  _name=@{0,b} # Basename for the commands definition file.
  -if {@#>1} -i[1--2] (10) -endif -a y -m @{-1,t} -s -,10

  # Output header.
  -_document_gmic_header_$1[] $3

  # Define parsing variables.
  _subsection=0                              # Indice of current subsection.
  _example=0                                 # Indice of current example.
  _command=0                                 # Indice of current command.
  _is_example=0                              # Boolean telling if current line is an example.
  _path="$2"                                 # Path of example images.
  ks0="0" ks1="-k[0]"

  # Parse lines of the commands file.
  -repeat @# -l[$>] -if {h>7" && "{@{-1,0-5}'=='{'"#@gmic"'}}" && "(i[6]=={'" "'}" || "i[6]=={':'})} # Process only lines starting with '#@gmic'.
    -rows 7,100% -autocrop {'" "'}  # Discard '#@gmic'.
    _is_example=0
    -if {i!={':'}}

      # Reached line as '#@gmic Command : Arguments_line1 : Arguments_line2 : (qualifier)'.
      _command={$_command+1}
      -s -,{'": "'} -autocrop {'" "'}
      -_document_gmic_declaration_$1

    -else
      -rows 1,100% # Discard ':' char.
      -if {i=={':'}}

        # Reached line as '#@gmic :: Subsection name'.
        _subsection={$_subsection+1}
        -rows 1,100% -autocrop {'" "'} # Discard ':' character.
        -_document_gmic_subsection_$1

      -else
        -autocrop {'" "'}
        -if {i=={'$'}}

          # Reached line as '#@gmic : $ Example of use'.
          -rows 1,100% -autocrop {'" "'} # Discard '$' character.
          _is_example=1
          -if {i!={'$'}} _example={$_example+1} -endif # Reached '#@gmic : $$' for announcing available tutorial page.
          _filename=$_path$_name$_example.jpg
          -_document_gmic_example_$1

        -else

          # Reached line as '#@gmic : description.'
          -_document_gmic_description_$1
        -endif
      -endif
    -endif
  -endif ${ks{@#!=0}} -endl -done
  -rm
  -_document_gmic_footer_$1[] $3

# Define document_gmic commands for ascii output.
_document_gmic_header_ascii : -skip $1
  _shortcut=0

_document_gmic_subsection_ascii :
  -v +
  -e[] "\n "$_gmic_r$_gmic_b"** "@{0,t}":"$_gmic_n
  -v -

_document_gmic_declaration_ascii :
  -if {@{-1,t}'=='"(+)"} qualifier=" "@{-1,t} -rm[-1] -else qualifier="" -endif
  -if {@#>1" && "{@{-1,0-6}'=='{'"eq. to "'}}}  # Declaration of a shortcut command.
    -rows[-1] 7,100% -autocrop[-1] {'.'} -autocrop[-1] {'" "'} -autocrop[-1] 39
    _shortcut$_shortcut=@{0,t}
    _shortcutlink$_shortcut=@{-1,t}
    _shortcutqualifier$_shortcut=$qualifier
    _shortcut={$_shortcut+1}
  -else                                         # Declaration of a regular command.
    -v + -e[] "\n    "$_gmic_m${_gmic_b}"-"@{0,t}${qualifier}":"$_gmic_n -v - -rm[0]
    -if @#
      s="                        "
      -y x
      -repeat {@#-1} ({'" |"'}) -a[$>,-1] x -done  # Insert ' |'.
      -repeat @# -l[$>] -_document_gmic_split_ascii 80,0
        -repeat {@#-1} ({'\n$s"  "'}) -a[$>,-1] x -done
        -a x -v + -e[] $_gmic_g$s@{0,t}$_gmic_n -v -
      -endl -done
    -endif
    -v + -e[] "" -v -
  -endif

_document_gmic_description_ascii :
  s="        " bs0="\n" bs1="\\\\\n         "
  -y x -if {!narg($_is_tutorial)} -_document_gmic_split_ascii 96 -endif
  -if {@#==1" && "{@{0,0-7}'=='{'"(eq. to "'}}} -i[0] ({'${_gmic_b}'}) ({'${_gmic_n}\n'}) -a x -endif
  -repeat {@#-1} ({'${bs$_is_example}$s"  "'}) -a[$>,-1] x -done -a x
  -if {narg($_gmic_vt100)}
    -replace_str "Default values:","\n"$s${_gmic_b}"Default values:"$_gmic_n
    -replace_str "Default value:","\n"$s${_gmic_b}"Default value:"$_gmic_n
  -endif
  -v + -repeat @# -e[] $s@{$>,t} -v - -done

_document_gmic_example_ascii :

_document_gmic_footer_ascii : -skip $1
  -if $_shortcut # Document shortcuts.
    ({'"Commands shortcuts"'}) -_document_gmic_subsection_ascii[-1] -v + -e[] "" -v - -rm[-1]
    -v + -repeat $_shortcut
      -e[] "    "$_gmic_m$_gmic_b"-"${_shortcut$>}" "${_shortcutqualifier$>}":"$_gmic_n" eq. to '"$_gmic_g${_shortcutlink$>}$_gmic_n"'."
    -done -v -
  -endif
  -v + -e[] "\n   "$_gmic_c"[ Total number of commands: "$_command" ]"$_gmic_n -v -

_document_gmic_split_ascii :
  -do -if {w>$1}
    i={$1-1}
    -repeat {$1/2} -if {C=i($1-1-$>);C==32||C==38||C==42||C==43||C==44||C==46||C==47||C==58||C==59||C==63||C==92||C==124} i={$1-1-$>} -break
    -endif -done
    --z[-1] {$i+1},100% -z[-2] 0,$i
  -endif -while {w>$1}

# Define document_gmic commands for bash auto-completion script output.
_document_gmic_header_bash : -skip $1
  -v +
  -e[] "\#
\n\#  Bash completion rules for 'gmic'.
\n\#
\n\# This file has been generated automatically.
\n\# Do not edit!
\n\#
\n\# This file should be copied/renamed in '/etc/bash_completion.d/gmic'.
\n\#
\n
\n_"$_name"()
\n{
\n\tlocal cur prev opts coms
\n\tCOMPREPLY=()
\n\tcur=\"${COMP_WORDS[COMP_CWORD]}\"
\n\tprev=\"${COMP_WORDS[COMP_CWORD-1]}\"
"
  -v -
  _opts=
  _coms=
  _argcommand=0
  _shortcut=0
  _nbopts=0
  _nbcoms=0

_document_gmic_subsection_bash :
_document_gmic_description_bash :
_document_gmic_example_bash :

_document_gmic_declaration_bash :
  _opts$_nbopts=-@{0,t}" "--@{0,t}
  _nbopts={$_nbopts+1}

  _coms$_nbcoms=@{0,t}
  _nbcoms={$_nbcoms+1}

  -if {{@{0,t}'=='"input"}" || "{@{0,t}'=='"i"}" || "\ # Manage special commands (remove arguments).
       {@{0,t}'=='"output"}" || "{@{0,t}'=='"o"}" || "\
       {@{0,t}'=='"command"}" || "{@{0,t}'=='"m"}} -return -endif
  -repeat @# -if {@{$<,t}'=='"(+)"} -rm[$<] -endif -done # Discard '(+)' qualifier.
  -if {@#==2" && "{@{-1,0-6}'=='{'"eq. to "'}}} # Command is a shortcut.
    -rows[-1] 7,100% -autocrop[-1] {'.'} -autocrop[-1] {'" "'} -autocrop[-1] 39 -autocrop[-1] {'-'}
    _shortcut$_shortcut=@{0,t}
    _shortcutlink$_shortcut=@{-str2hex\ @{1,t}}
    -rm[-1]
    _shortcut={$_shortcut+1}
  -elif {@#>1} # Command is regular and has arguments.
    _command$_argcommand=@{0,t}
    -if {@{0,t}'=='"help"} _argument$_argcommand="$coms\" -- \"$cur"  # Manage help command.
    -else
      -if {@#==2} ({'>'}) -endif # Add shadow parameter when single argument.
      -discard[^0] {'" "'} -i[2--2] ({'" "'}) -a[^0] y
      _argument$_argcommand=@{1,t}
    -endif
    _argumentlink@{-str2hex\ @{0,t}}=${_argument$_argcommand}
    _argcommand={$_argcommand+1}
  -endif

_document_gmic_footer_bash : -skip $1
  -v +
  -e[] "\topts=\"\\" -repeat $_nbopts -e[] "\t      "${_opts$>}\\ -done -e[] "\t     \""
  -e[] "\n\tcoms=\"\\" -repeat $_nbcoms -e[] "\t      "${_coms$>}\\ -done -e[] "\t     \""
  -e[] "\n\tcase \"${prev}\" in"
  -repeat $_argcommand  # Regular commands with arguments.
    -e[] "\t\t\"-"${_command$>}"\" | \"--"${_command$>}"\")"
    -e[] "\t\tCOMPREPLY=( $(compgen -W \""${_argument$>}"\") )\n\t\treturn 0\n\t\t;;"
  -done
  -repeat $_shortcut # Shortcut commands (with arguments).
    -if {narg(${_argumentlink${_shortcutlink$>}})}
      -e[] "\t\t\"-"${_shortcut$>}"\" | \"--"${_shortcut$>}"\")"
      -e[] "\t\tCOMPREPLY=( $(compgen -W \""${_argumentlink${_shortcutlink$>}}"\") )\n\t\treturn 0\n\t\t;;"
    -endif
  -done
  -e[] "\tesac"
  -e[] "\n\tif [[ \"$cur\" == -* ]] ; then
\n\t\tCOMPREPLY=( $(compgen -W \"$opts\" -- \"$cur\") )
\n\telse
\n\t\t_filedir
\n\tfi
\n
\n}
\n
complete -F _"$_name" -o filenames gmic"
  -v -

# Define document_gmic commands for html output.
_document_gmic_header_html :
  -if $1 -v + -e[] "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">
\n<head>
\n<script type=\"text/javascript\" src=\"highslide/highslide.js\"></script>
\n<link rel=\"stylesheet\" type=\"text/css\" href=\"highslide/highslide.css\" />
\n<script type=\"text/javascript\">
\nhs.graphicsDir = 'highslide/graphics/';
\nhs.wrapperClassName = 'wide-border';
\n</script>
\n</head>
\n<body>
\n"
  -v - -endif
  -m "don : -_document_gmic_desc_on_html"
  -m "doff : -_document_gmic_desc_off_html"
  -m "eon : -_document_gmic_ex_on_html"
  -m "eoff : -_document_gmic_ex_off_html"
  _is_desc=0
  _is_ex=0
  _shortcut=0

_document_gmic_desc_on_html :
  -v -
  -if $_is_desc
    -u "<br/>"
  -else
    -u "<p style=\"margin-left:100px\"><tt>"
    _is_desc=1
  -endif
  -v +

_document_gmic_desc_off_html :
  -v -
  -if $_is_desc
    -u "</tt></p>"
    _is_desc=0
  -else -u ""
  -endif
  -v +

_document_gmic_ex_on_html :
  -v -
  -if $_is_ex
    -u ""
  -else
    -u "<br/><table style=\"margin-left:100px\" width=\"75%\" bgcolor=\"\#FFFFFF\" bordercolor=\"black\" border=\"1\" cellpadding=\"4\" cellspacing=\"0\">"\
       "<tr><td colspan=\"2\" bgcolor=\"#000000\"><font color=\"white\"><b>Example of use:</b></font></td></tr>"
    _is_ex=1
  -endif
  -v +

_document_gmic_ex_off_html :
  -v -
  -if $_is_ex
    -u "</table>"
    _is_ex=0
  -else
    -u ""
  -endif
  -v +

_document_gmic_subsection_html :
  -v +
  -e[] @{-eoff}@{-doff}"<br/><h2><a href=\"#toc\"><img src=\"img/back_top.png\"></img></a>&nbsp;&nbsp;"\
       "<a id=\"subsection"$_subsection"\"><font color=\"#B00000\">"@{0,t}"</font></a></h2>"
  -v -

_document_gmic_declaration_html :
  -if {@{-1,t}'=='"(+)"} qualifier=" "@{-1,t} -rm[-1] -else qualifier="" -endif
  s1="\n" s0=" |<br/>"
  -if {@#>1" && "{@{-1,0-6}'=='{'"eq. to "'}}}  # Declaration of a shortcut command.
    -rows[-1] 7,100% -autocrop[-1] {'.'} -autocrop[-1] {'" "'} -autocrop[-1] 39
    _shortcut$_shortcut=@{0,t}
    _shortcutlink$_shortcut=@{-1,t}
    _shortcutqualifier$_shortcut=$qualifier
    _shortcut={$_shortcut+1}
  -else                                         # Declaration of a regular command.
    _command_name=@{0,t}
    -v +
    -e[] @{-eoff}@{-doff}"<p style=\"margin-left:20px\"><a id=\""@{0,t}"\"><font color=\"#005090\">&nbsp;&nbsp;<b>-"@{0,t}$qualifier"</b>:</font></a>"
    -if {@#>1}
      -e[] "<p style=\"margin-left:120px\"><tt><i><font color=\"#900090\">"
      -repeat {@#-1} -l[{1+$>}]
        -if {h>48} -v - -replace_str ",",", " -v + -endif
        -e[] @{0,t}${s{$<==0}}
      -endl -done
      -e[] "</font></i></tt></p>"
    -else -e[] ""
    -endif
    -v -
  -endif

_document_gmic_description_html :
  -if {@{-1,0-12}'=='{'"Default value"'}}  # Reached line as '#@gmic : Default value(s) : ... '.
    -s +,{':'} -l[^0] -a y -endl -autocrop {':'} -autocrop {'" "'}
    -v +
    -if {@#>1} -e[] @{-don}"<br/><b>"@{0,t}"</b>: "@{-1,t}
    -else -e[] @{-don}"<br/>"@{0,t}
    -endif
    -v -

  -elif {@{-1,0-7}'=='{'"(eq. to "'}}      # Reached line as '#@gmic : (eq. to -shortcut)'.
    -v + -e[] @{-don}"<i><font color=\"blue\">"@{-1,t}"</font></i>" -v -

  -else                                    # Reached line as '#@gmic : description'.
    -if {(i<{'A'}" || "i>{'Z'})" && "i!=40" && "i!=39} -v + -e[] @{-don}"&nbsp;"@{-1,t} -v -
    -else -v + -e[] @{-don}@{-1,t} -v -
    -endif

  -endif

_document_gmic_example_html :
  -if {i=={'$'}} # Link to a tutorial page.
    -if {h==1&&i=={'$'}} tuturl=http://gmic.eu/tutorial/_$_command_name.shtml
    -else -autocrop {'$'} -autocrop {'" "'} tuturl=http://gmic.eu/tutorial/@{0,t}.shtml
    -endif
    -v +
    -e[] @{-eon}"<tr><td width=\"24\" align=\"center\"><a target=\"_blank\" href=\""$tuturl"\"><img src=\"img/moreinfos.png\"></img></td>"\
                "<td><a target=\"_blank\" href=\""$tuturl"\">A tutorial page exists for this command.</a></td></tr>"
    -v -
  -else # Regular example.
    -if $_filename -else # Generate picture only if the file doesn't yet exist.
       -m "foo : "@{-1,t}
       -l[] -v -99 -reset -foo -v -1 -_document_gmic -o $_filename,85 -rm -endl
       -uncommand foo
    -endif
    -v +
    -e[] @{-eon}"<tr><td width=\"24\" align=\"center\"><div><a href=\""$_filename"\" class=\"highslide\" onclick=\"return hs.expand(this)\">"\
         "<font color=\"blue\"><img src=\"img/zoom.png\"></img></font></a><div class=\"highslide-caption\">"@{-1,t}"</div></div></td><td><tt>"@{-1,t}"</tt></td></tr>"
    -v -
  -endif

_document_gmic_footer_html : -skip $1
  -if $_shortcut # Document shortcuts.
    _subsection={$_subsection+1}
    ({'"Commands shortcuts"'}) -_document_gmic_subsection_html[-1] -rm[-1]
    -v + -e[] "<p style=\"margin-left:20px\">"
    -repeat $_shortcut
      -e[] "<font color=\"green\"><b>&nbsp;&nbsp;-"${_shortcut$>}" "${_shortcutqualifier$>}"</b>:</font>"
      -e[] "<font color=\"blue\"><i>eq. to '"${_shortcutlink$>}"'</i></font><br/>"
    -done
    -e[] "</p>" -v -
  -endif
  -v +
  -e[] @{-eoff}@{-doff}"<p style=\"margin-left:100px\"><font color=\"blue\"><b>[ Total number of commands: "$_command" ]</b></font>"
  -v -
  -uncommand don,doff,eon,eoff

# Define document_gmic commands for images-only output.
_document_gmic_header_images : -skip $1
  -v +
  -e[] "\n - Generate example images from set of commands '"$_name"'.\n"
  -v -

_document_gmic_subsection_images :
  -v +
  -e[] "\n ** Section \#"$_subsection": "@{0,t}".\n"
  -v -
_document_gmic_declaration_images : _command_name=@{0,t}
_document_gmic_description_images :

_document_gmic_example_images :
  -if {i=={'$'}} -return -endif
  -v +
  -e[] "    ["$_example"] Command '-"$_command_name"': $ "@{-1,t}
  -v -
  -if $_filename -else # Generate picture only if the file doesn't yet exist.
    -m "foo"$_example" : "@{-1,t}
    -l[] -v -1 -reset -v -99 -foo$_example -v -1 -_document_gmic -o $_filename,85 -rm -endl
    -uncommand foo$_example
  -endif

_document_gmic_footer_images : -skip $1
  -v +
  -e[] "\n - [ All done! ]\n\n"
  -v -

# Define document_gmic commands for LateX output.
_document_gmic_header_latex :
  -if $1 -v +
    -e[] "\\documentclass[a4paper,10pt,twoside]{book}
\n\\usepackage{hyperref,fancyhdr,graphicx,amssymb,amsmath,times,makeidx,color}
\n\\graphicspath{{"$_path"}}
\n\\pagestyle{fancyplain}
\n\\lhead[\\fancyplain{}{\\textbf\\thepage}]{\\fancyplain{}{\\rightmark}}
\n\\rhead[\\fancyplain{}{\\leftmark}]{\\fancyplain{}{\\textbf\\thepage}}
\n\\cfoot{}
\n\\setlength{\\textwidth}{5.875in}
\n\\setlength{\\parindent}{0pc}
\n\\setlength{\\hoffset}{-0.8cm}
\n\\setcounter{tocdepth}{1}
\n\\sloppy{}
\n\\definecolor{ca}{rgb}{0.8,0,0}
\n\\definecolor{cb}{rgb}{0,0.2,0.6}
\n\\definecolor{cc}{rgb}{0,0.5,0}
\n\\definecolor{cd}{rgb}{0.6,0.6,0.6}
\n\\newcommand{\\Ca}[1]{\\textcolor{ca}{#1}}
\n\\newcommand{\\Cb}[1]{\\textcolor{cb}{#1}}
\n\\newcommand{\\Cc}[1]{\\textcolor{cc}{#1}}
\n\\newcommand{\\Cd}[1]{\\textcolor{cd}{#1}}
\n\\renewcommand\\indexname{Index of commands}
\n\\makeindex
\n\\begin{document}
\n\\tableofcontents"
  -v - -endif
  -v + -e[] "\n\\chapter{List of commands}" -v -
  -m "eon : -_document_gmic_ex_on_latex"
  -m "eoff : -_document_gmic_ex_off_latex"
  _is_desc=0
  _is_ex=0
  _shortcut=0

_document_gmic_ex_on_latex :
  -v -
  -if $_is_ex
    -u "\\\\"
  -else
    -u "\\begin{center}"
    _is_ex=1
  -endif
  -v +

_document_gmic_ex_off_latex :
  -v -
  -if $_is_ex
    -u "\\end{center}"
    _is_ex=0
  -else
    -u ""
  -endif
  -v +

_document_gmic_subsection_latex :
  _is_desc=0
  -_document_gmic_replace_latex
  -v + -e[] @{-eoff}"\n\\section{"@{0,t}"}" -v -

_document_gmic_declaration_latex :
  _is_desc=0
  -if {@{-1,t}'=='"(+)"} qualifier=@{-1,t} -rm[-1] -else qualifier="" -endif
  e1="\\\\~\\\\" e0="~~~$|$\\\\"
  s1="\\hspace*{2.2cm}" s0=""
  -if {@#>1" && "{@{-1,0-6}'=='{'"eq. to "'}}}  # Declaration of a shortcut command.
    -_document_gmic_replace_latex
    -rows[-1] 7,100% -autocrop[-1] {'.'} -autocrop[-1] {'" "'} -autocrop[-1] 39
    _shortcut$_shortcut=@{0,t}
    _shortcutlink$_shortcut=@{-1,t}
    _shortcutqualifier$_shortcut=$qualifier
    _shortcut={$_shortcut+1}
  -else                                         # Declaration of a regular command.
    -_document_gmic_replace_latex[0]
    _command_name=@{0,t}
    -v + -e[] @{-eoff}"\n\n\\subsection{\\emph{-"@{0,t}"\\index{-"@{0,t}"}} "$qualifier"}\\vspace*{-0.5em}"
    -if {@#>1}
      -e[] "~\\\\\\textbf{\\Cb{Arguments: }} "
      -repeat {@#-1} -l[{1+$>}]
        -v - -s y,-60 -if {@#>1} -i[1--2] ({'\\-'}) -endif -y -a y
        -_document_gmic_replace_latex -v +
        -e[] ${s{$>!=0}}"{\\small \\Cb{\\texttt{"@{0,t}"}}}"${e{$<==0}}
      -endl -done
    -endif
    -v -
  -endif

_document_gmic_description_latex :
  s0="" s1="~\\\\" s=${s$_is_desc}
  -_document_gmic_replace_latex
  -if {@{-1,0-12}'=='{'"Default value"'}}  # Reached line as '#@gmic : Default value(s) : ... '.
    -s +,{':'} -l[^0] -a y -endl -autocrop {':'} -autocrop {'" "'}
    -if {@#>1}
      -replace_str[1] " and ","} and \\\\texttt{"
      -v + -e[] @{-eoff}$s"~\\\\\\Cc{\\textbf{"@{0,t}"}: {\\small \\texttt{"@{-1,t}"}}}" -v -
    -else -v + -e[] @{-eoff}$s"~\\\\"@{0,t} -v -
    -endif
  -elif {@{-1,0-7}'=='{'"(eq. to "'}}      # Reached line as '#@gmic : (eq. to '-shortcut').'.
    -rows[-1] 8,100% -autocrop[-1] {'.'} -autocrop[-1] {')'} -autocrop[-1] {'" "'}
    -v + -e[] @{-eoff}$s"(\\emph{eq. to} {\\small \\texttt{"@{-1,t}"}})." -v -
  -else                                    # Reached line as '#@gmic : description'.
    -if {(i<{'A'}" || "i>{'Z'})" && "i!=40" && "i!=39} -v + -e[] @{-eoff}@{-1,t} -v -
    -else -v + -e[] @{-eoff}$s@{-1,t} -v -
    -endif
  -endif
  _is_desc=1

_document_gmic_example_latex :
  -if {i=={'$'}} # Link to a tutorial page.
    -if {h==1&&i=={'$'}} tuturl=http://gmic.eu/tutorial/\\_$_command_name.shtml
    -else -autocrop {'$'} -autocrop {'" "'} tuturl=http://gmic.eu/tutorial/@{0,t}.shtml
    -endif
    -l[] ({'$tuturl'}) -replace_str "_","\\_"
    -s x,-60 -if {@#>1} -i[1--2] ({'\\\\-'}) -endif -a x
    -replace_str[-1] "_","\\_" tuturl=@{-1,t} -rm -endl
    -v +
    -e[] @{-eoff}
    -if {!$_is_ex} -e[] "~\\\\" -endif
    -e[] "~\\textbf{Tutorial page: }\\\\\\tt{"$tuturl"}"
    -v -
  -else # Regular example.
    _is_desc=0
    -if $_filename -else # Generate picture only if the file doesn't yet exist.
       -m "foo : "@{-1,t}
       -l[] -v -99 -reset -foo -v -1 -_document_gmic -o $_filename,85 -rm -endl
       -uncommand foo
    -endif
    -_document_gmic_replace_latex
    -v +
    -e[] @{-eon}"\\includegraphics[keepaspectratio=true,height=7cm,width=\\textwidth]{"$_filename"}\\\\"
    -e[] "{\\footnotesize \\textbf{Example "$_example"~:} \\texttt{"@{-1,t}"}}"
    -v -
  -endif

_document_gmic_footer_latex :
  -if $_shortcut # Document shortcuts.
    ({'"Commands shortcuts"'}) -_document_gmic_subsection_latex[-1] -rm[-1]
    -v + -repeat $_shortcut
      -e[] "$\\bullet$~'\\texttt{\\Ca{-"${_shortcut$>}"}}' "${_shortcutqualifier$>}"~is equivalent to~~'\\texttt{\\Ca{"${_shortcutlink$>}"}}'.\\\\"
    -done -v -
  -endif
  -if $1
    -v +
    -e[] "
\n\\printindex
\n~\\\\$\\square$~End of document.
\n\n\\end{document}"
    -v -
  -endif
  -uncommand eon,eoff

_document_gmic_replace_latex :
  -replace_str "\\","\\\\textbackslash "  # Replace '\'
  -replace_str "_","\\\\_"                # Replace '_'
  -replace_str "%","\\\\%"                # Replace '%'
  -replace_str "#","\\\\%"                # Replace '#'
  -replace_str "^","\\\\textasciicircum " # Replace '^'
  -replace_str "$","\\\\$"                # Replace '$'
  -replace_str "\{","\\\\\{"              # Replace '{'
  -replace_str "\}","\\\\\}"              # Replace '}'
  -replace_str "&","\\\\&"                # Replace '&'
  -replace_str "|","~$|$~"                # Replace '|'
  -replace_str "<","$\<$"                 # Replace '<'
  -replace_str ">","$\>$"                 # Replace '>'
  -replace_str "\\\\textbackslash -","\\\\-"  # Keep word cut.

# Define document_gmic commands for man page output.
_document_gmic_header_man : -skip $1
  _gmic_n="\\fR" _gmic_b="\\fB" _gmic_r="" _gmic_g="" _gmic_c="\\fB" _gmic_m=""
  -_document_gmic_header_ascii $"*"

_document_gmic_subsection_man :
  -v +
  -e[] "\n "$_gmic_b"** "@{0,t}":"$_gmic_n
  -v -

_document_gmic_declaration_man :
  -if {@{-1,t}'=='"(+)"} qualifier=" "@{-1,t} -rm[-1] -else qualifier="" -endif
  -if {@#>1" && "{@{-1,0-6}'=='{'"eq. to "'}}}  # Declaration of a shortcut command.
    -rows[-1] 7,100% -autocrop[-1] {'.'} -autocrop[-1] {'" "'} -autocrop[-1] 39
    _shortcut$_shortcut=@{0,t}
    _shortcutlink$_shortcut=@{-1,t}
    _shortcutqualifier$_shortcut=$qualifier
    _shortcut={$_shortcut+1}
  -else                                         # Declaration of a regular command.
    -v + -e[] "\n    "${_gmic_b}"-"@{0,t}${qualifier}":"$_gmic_n -v - -rm[0]
    -if @#
      s="                        "
      -y x
      -repeat {@#-1} ({'" |"'}) -a[$>,-1] x -done  # Insert ' |'.
      -repeat @# -l[$>] -_document_gmic_split_ascii 80,0
        -repeat {@#-1} ({'\n$s"  "'}) -a[$>,-1] x -done
        -a x -v + -e[] $s@{0,t} -v -
      -endl -done
    -endif
    -v + -e[] "" -v -
  -endif

_document_gmic_description_man :
  s="        " bs0="\n" bs1="\\\\\n         "
  -y x -if {!narg($_is_tutorial)} -_document_gmic_split_ascii 96 -endif
  -repeat {@#-1} ({'${bs$_is_example}$s"  "'}) -a[$>,-1] x -done -a x
  -replace_str "Default values:","Default values:"
  -replace_str "Default value:","Default value:"
  -replace_str "\\","\\\\"
  -v + -repeat @# -e[] $s@{$>,t} -v - -done

_document_gmic_example_man :

_document_gmic_footer_man : -skip $1
  -_document_gmic_footer_ascii $"*"

# Generate a single image from a list of images, for the reference documentation.
_document_gmic :
  -repeat @# -l[$>] W$>={w} H$>={h} D$>={d} S$>={s} IS_3D$>=@{-is_3d} -endl -done
  -repeat @# -l[$>] -if @{-is_3d} -r3d 1,1,0,-80 -r3d 0,1,0,80 -snapshot3d 400 -else -n 0,255 -endif -endl -done
  --append_tiles , -if {w>900} r={round(900*100/w,0.1)} -r[^-1] $r%,$r%,1,100%,2 -endif -rm[-1]
  -repeat @# -l[$>]
    -if {s==1} -r {w},{h},1,3 -else -r {w},{h},1,3,0 -endif
    -if {w<=h&&h<256} -r2dy 256,2 -elif {h<=w&&w<256} -r2dx 256,2 -endif
    -if {w<=h&&h>512} -r2dy 512,2 -elif {h<=w&&w>512} -r2dx 512,2 -endif
    -if {h<48} -r 100%,48 -endif
    -if {w<48} -r 48,100% -endif
    -frame 1,1,0 -frame 4,4,255
  -endl -done
  N=@# -repeat $N -l[$>]
    {w},16,1,3,255
    -if {w>75}
      -if {$N>1} -if {w>110} -t[-1] Image\ [$>]:,3,3,15 -else -t[-1] [$>]:,3,3,15 -endif -endif
      -if ${IS_3D$>} 0 -t[-1] (3d\ object),0,0,13,1,255
      -else 0 -t[-1] (${W$>}x${H$>}x${D$>}x${S$>}),0,0,13,1,255
      -endif
      -negative[-1] -n[-1] 0,255 -+[-1] 164 -c[-1] 0,255 -to_rgb[-1]
      -j[-2] [-1],{@{-2,w}-w-5},{@{-2,h}-h-1} -rm[-1]
    -else -t[-1] [$>]:,3,3,15 -endif
    -rv[-2,-1] -a[-2,-1] y
  -endl -done
  -- 255 -append_tiles , -+ 255
  -if {w<256} -- 255 -r 256,100%,1,3,0,0,0.5,0.5 -+ 255 -endif
  -if {h<256} -- 255 -r 100%,256,1,3,0,0,0.5,0.5 -+ 255 -endif

#@gmic e : eq. to '-echo'. : (+)

#@gmic echo : message : (+)
#@gmic : Output specified message, on the error output.
#@gmic : (eq. to '-e').
#@gmic : Command selection (if any) stands for displayed scope indices instead of image indices.

#@gmic echo_file : filename,message
#@gmic : Output specified message, appending it to specified output file.
#@gmic : (similar to '-echo' for specified output file stream).
echo_file : -skip "${2='\n'}"
  -v - ({"'${2--1}\n'"}) -o[-1] raw:$1,char -rm[-1] -v +

#@gmic echo_stdout : message
#@gmic : Output specified message, on the standard output (stdout).
#@gmic : (similar to '-echo' for output on standard output instead of standard error).
echo_stdout :
  -v - ({'"$*"\n'}) -o[-1] -.raw,char -rm[-1] -v +

#@gmic function1d : 0<=smoothness<=1,x0>=0,y0,x1>=0,y1,...,xn>=0,yn
#@gmic : Input continuous 1d function from specified list of keypoints (xk,yk)
#@gmic : in range [0,max(xk)] (xk are positive integers).
#@gmic : Default values: 'smoothness=1' and 'x0=y0=0'.
#@gmic : $ -function1d 1,0,0,10,30,40,20,70,30,80,0 --display_graph 400,300
function1d : -check "${1=1}>=0 && $1<=1" -skip ${2=0},${3=0}
  -e[^-1] "Input continuous 1d function, with smoothness $1 and keypoints (${2--1})."
  -v - -l[]

  # Sort and normalize input keypoints.
  smoothness={max(0,min(1,$1))}
  (${2--1}) -r 2,{int(w/2)},1,1,-1
  -sort +,y -s x size=@{0,if(iM>=0,1+int(iM),0)}
  -if {!$size} -rm 0 -break -endif
  -a x

  # Compute slopes for splines.
  --f '0.5*(j(0,1,0,0,0,1)-j(0,-1,0,0,0,1))' -s[-1] x -max[-2] 0.01 -/[-1] [-2] -rm[-2] -a x

  # Determine spline coefficients for each part of the curve.
  $size,1,1,1,-1
  -repeat @{0,h-1}
    x0=@{0,i(0,$>)} y0=@{0,i(1,$>)} x1=@{0,i(0,$>+1)} y1=@{0,i(1,$>+1)}
    slope={($y1-$y0)/max(0.01,$x1-$x0)}
    yp0=@{0,i(2,$>)*$smoothness+(1-$smoothness)*$slope}
    yp1=@{0,i(2,$>+1)*$smoothness+(1-$smoothness)*$slope}
    i={round($x0,1,1)} j={round($x1,1,0)}
    -line[1] $i,0,$j,0,1,$>
    -if {$j-$i<=1} # Linear interpolation for very close points.
      ({$y0-$x0*$slope}^{$slope}^0^0)
    -else # Cubic interpolation otherwise.
      (1,$x0,{($x0)^2},{($x0)^3};\
       1,$x1,{($x1)^2},{($x1)^3};\
       0,1,{2*$x0},{3*($x0)^2};\
       0,1,{2*$x1},{3*($x1)^2})
      ($y0;$y1;$yp0;$yp1)
      -solve[-1] [-2] -rm[-2] -y[-1] c
    -endif
  -done
  -a[2--1] x -map[-2] [-1] -rm[-1]

  # Render final curve.
  100%,1,1,1,1
  (0,{w-1}) -r[-1] @{-2,w},1,1,1,3 -round[-1]
  --sqr[-1] --*[-2,-1] -a[-4--1] c -*[-2,-1] -s[-1] c -+[-4--1] -rm[-2]
  -endl -v +

#@gmic gmicky
#@gmic : Load a new image of the G'MIC mascot 'Gmicky'.
#@gmic : $ -gmicky
gmicky :
  -e[^-1] "Load image of the G\47MIC mascot 'Gmicky'."
  -v - -i http://gmic.eu/img/gmicky_large.cimgz -nm[-1] [gmicky] -v +

#@gmic gmicky_wilber
#@gmic : Load a new image of the G'MIC mascot 'Gmicky' together with GIMP mascot 'Wilber'.
#@gmic : $ -gmicky_wilber
gmicky_wilber :
  -e[^-1] "Load image of the G\47MIC mascot 'Gmicky' together with GIMP mascot 'Wilber'."
  -v - -i http://gmic.eu/img/gmicky_wilber_large.cimgz -nm[-1] [gmicky_wilber] -v +

#@gmic heart : _width>0,_height>0
#@gmic : Input heart binary mask with specified size.
#@gmic : $ -heart ,
heart : -check "${1=512}>=1 && ${2=$1}>=1"
  -e[^-1] "Input $1x$2 heart binary mask."
  -v - -l[]
    2048,1,1,1,'t=2*pi*x/w;16*sin(t)^3'
    2048,1,1,1,'t=2*pi*x/w;13*cos(t)-5*cos(2*t)-2*cos(3*t)-cos(4*t)'
    -a c -display_parametric $1,$2,1,0,0,0
    -flood 50%,50%,0,0,0,1,0 -==[-1] 0
    -nm "[Heart binary mask]"
  -endl -v +

#@gmic i : eq. to '-input'. : (+)

#@gmic input : [type:]filename : [type:]http://URL : [selection]x_nb_copies>0 : { width>0[%] | [image_w] },{ _height>0[%] | [image_h] },{ _depth>0[%] | [image_d] },{ _spectrum>0[%] | [image_s] },_{ value1,_value2,.. | 'formula' } : (value1{,|;|/|^}value2{,|;|/|^}..) : 0 : (+)
#@gmic : Insert a new image taken from a filename or from a copy of an existing image ['indice'],"
#@gmic : or insert new image with specified dimensions and values. Single quotes may be omitted in
#@gmic : 'formula'. Specifying argument '0' inserts an 'empty' image.
#@gmic : (eq. to '-i' | (no arg)).
#@gmic : Default values: 'nb_copies=1', 'height=depth=spectrum=1' and 'value1=0'.
#@gmic : $ -input image.jpg
#@gmic : $ -i (1,2,3;4,5,6;7,8,9^9,8,7;6,5,4;3,2,1)
#@gmic : $ image.jpg (1,2,3;4,5,6;7,8,9) (255^128^64) 400,400,1,3,'if(x>w/2,x,y)*c'
#@gmic : $$

#@gmic input_gpl : filename
#@gmic : Input specified filename as a GIMP palette data file.
input_gpl :
  -e[^-1] "Input GIMP palette file '$*'."
  -v - -l[]
    -i raw:"$*",char -replace 9,32 -s -,10
    colors=0
    -repeat @# -l[$>]
      -s -,32
      -if {@#>=3" && "isint(@{0,t})" && "isint(@{1,t})" && "isint(@{2,t})} colors=$colors;@{0,t},@{1,t},@{2,t} -endif
      -rm 0
    -onfail -rm 0 -endl -done
    -rm ($colors) -rows 1,100% -nm "$1" -permute yzcx
  -endl -v +

#@gmic o : eq. to '-output'. : (+)

#@gmic output : [type:]filename,_format_options : (+)
#@gmic : Output selected images as one or several numbered file(s).
#@gmic : (eq. to '-o').
#@gmic : Default value: 'format_options'=(undefined).

#@gmic output_ggr : filename,_gradient_name
#@gmic : Output selected images as GIMP gradient files.
#@gmic : If no gradient name is specified, it is deduced from the filename.
output_ggr : -skip "${2=}"
 -e[^-1] "Output image$? as GIMP gradient file '$1'."
 -v - N=@#
  -repeat $N --l[$>] -r 1,{w*h*d},1,100%,-1 -to_rgba -/ 255
    -if {narg("$2")} name="$2"
    -else -l[] 1 -nm[-1] "$1" ({'@{-1,b}'}) -f "if(x==0&&i>="{'a'}"&&i<="{'z'}",i-"{'a'}"+"{'A'}",i)" name=@{-1,t} -rm -endl
    -endif
    ({'"GIMP Gradient\nName: "$name\n@{0,h}\n'})
    -repeat @{0,h}
      start={_$>/@{0,h}}
      end={_($>+1)/@{0,h}}
      mid={_0.5*($start+$end)}
      rgba=@{-at[0]\ 0,$>}
      r={arg(1,$rgba)} g={arg(2,$rgba)} b={arg(3,$rgba)} a={arg(4,$rgba)}
      ({'$start" "$mid" "$end" "$r" "$g" "$b" "$a" "$r" "$g" "$b" "$a" 0 0\n"'})
    -done
    -rm[0] -a x
    -if {$N>1} -o raw:@{"-filename \"$1\",$>"},char -else -o raw:"$1",char -endif
    -rm
  -endl -done -v +

#@gmic on : eq. to '-outputn'.
on :
  -v - _gmic_s="$?" -v +
  -_outputn $*

#@gmic outputn : filename
#@gmic : Output selected images as automatically numbered filenames in repeat..done loops.
#@gmic : (eq. to '-on').
outputn :
  -v - _gmic_s="$?" -v +
  -_$0 $*

_outputn :
  -v - filename=@{-filename\ "$1",@{>}} -v +
  -e[0--3] "Output image"$_gmic_s" as file '"$filename"'."
  -v - -o $filename -v +

#@gmic op : eq. to '-outputp'.
op :
  -v - _gmic_s="$?" -v +
  -_outputp $*

#@gmic outputp : prefix
#@gmic : Output selected images as prefixed versions of their original filenames.
#@gmic : (eq. to '-op').
#@gmic : Default value: 'prefix=_'.
outputp :
  -v - _gmic_s="$?" -v +
  -_$0 $*

_outputp : -skip ${1="_"}
  -if {@#>1} -e[0--4] "Output image"$_gmic_s" as their initial locations, prefixed by '$1'."
  -else -e[0--4] "Output image"$_gmic_s" as its initial location, prefixed by '$1'."
  -endif
  -v - -repeat @# -o[$>] @{$>,f}$1@{$>,b}.@{$>,x} -done -v +

#@gmic ow : eq. to '-outputw'.
ow :
  -v - _gmic_s="$?" -v +
  -_outputw

#@gmic outputw
#@gmic : Output selected images by overwritting their original location.
#@gmic : (eq. to '-ow').
outputw :
  -v - _gmic_s="$?" -v +
  -_$0 $*

_outputw :
  -if {@#>1} -e[0--4] "Output image"$_gmic_s" as their initial location."
  -else -e[0--4] "Output image"$_gmic_s" as its initial location."
  -endif
  -v - -repeat @# -o[$>] @{$>,n} -done -v +

#@gmic ox : eq. to '-outputx'.
ox :
  -v - _gmic_s="$?" -v +
  -_outputx $*

#@gmic outputx : extension1,_extension2,_...,_extensionN,_output_at_same_location={ 0 | 1 }
#@gmic : Output selected images with same base filenames but for N different extensions.
#@gmic : (eq. to '-ox').
#@gmic : Default value: 'output_at_same_location=0'.
outputx :
  -v - _gmic_s="$?" -v +
  -_$0 $*

_outputx :
  -v -
  $=arg
  is_last_arg=0 is_same_location=0
  -if {isval($-1)} is_last_arg={isint($-1)&&$-1>=0&&$-1<=1} is_same_location=$-1 -endif
  N={$#-$is_last_arg} s0= s1=s
  -if {!$N} -v + -e[0--3] "Output image"$_gmic_s" at same location, with same base filename but extension '' (skipped, no extension provided)." -return
  -endif
  -if $is_same_location
    -v +
    -if $is_last_arg -e[0--4] "Output image"$_gmic_s" at same location, with same base filename but extension"${s{$N>1}}"' ${^-1}'."
    -else -e[0--4] "Output image"$_gmic_s" at same location, with same base filename but extension"${s{$N>1}}" '$*'."
    -endif
    -v -  -repeat @# -l[$>]
      -repeat $N -o @{0,f}@{0,b}.${arg{1+$>}} -done
    -endl -done
  -else
    -v +
    -if $is_last_arg -e[0--4] "Output image"$_gmic_s" with same base filename but extension"${s{$N>1}}"' ${^-1}'."
    -else -e[0--4] "Output image"$_gmic_s" with same base filename but extension"${s{$N>1}}" '$*'."
    -endif
    -v -  -repeat @# -l[$>]
      -repeat $N -o @{0,b}.${arg{1+$>}} -done
    -endl -done
  -endif
  -v +

#@gmic pass : _shared_state={ 0=non-shared (copy) | 1=shared | 2=adaptive } : (+)
#@gmic : Insert images from parent context of a custom command or a local environment.
#@gmic : Command selection (if any) stands for a selection of images in the parent context.
#@gmic : By default (adaptive shared state), selected images are inserted in a shared state if they do not belong to the context (selection) of the current custom command or local environment as well.
#@gmic : Typical use of command '-pass' concerns the design of custom commands that take images as arguments.
#@gmic : Default value: 'shared_state=2'.
#@gmic : $ -command "average : -pass$""1 -add[^-1] [-1] -remove[-1] -div 2" -testimage2d 512 --mirror y --average[0] [1]

#@gmic plot : _plot_type,_vertex_type,_xmin,_xmax,_ymin,_ymax : 'formula',_resolution>=0,_plot_type,_vertex_type,_xmin,xmax,_ymin,_ymax : (+)
#@gmic : Display selected image or formula in an interactive viewer (use the instant window [0] if opened).
#@gmic : 'plot_type' can be { 0=none | 1=lines | 2=splines | 3=bar }.
#@gmic : 'vertex_type' can be { 0=none | 1=points | 2,3=crosses | 4,5=circles | 6,7=squares }.
#@gmic : 'xmin','xmax','ymin','ymax' set the coordinates of the displayed xy-axes.
#@gmic : Default values: 'plot_type=1', 'vertex_type=1' and 'xmin=xmax=ymin=ymax=0 (auto)'.

#@gmic p : eq. to '-print'. : (+)

#@gmic print : (+)
#@gmic : Output information on selected images, on the standard error (stderr).
#@gmic : (eq. to '-p').

#@gmic rainbow_lut
#@gmic : Input a 256-entries RGB colormap of rainbow colors.
#@gmic : $ image.jpg -rainbow_lut --luminance[-2] -map[-1] [-2]
rainbow_lut :
  -e[^-1] "Input RGB colormap of 256 rainbow colors."
  -v -
  (2,10,13,13,15,16,15,15,18,23,26,31,33,37,38,39,42,42,44,45,44,44,45,45,44,42,44,45,45,49,50,52,54,55,56,57,\
   56,56,57,57,58,57,58,58,59,58,60,59,58,59,59,59,59,59,60,60,59,59,59,59,60,59,59,59,59,59,59,59,58,58,58,56,\
   56,54,51,48,44,39,33,20,5,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\
   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,25,50,66,81,90,102,109,118,129,137,144,152,158,168,178,183,190,199,207,\
   213,220,227,230,236,242,246,250,255,255,253,253,253,252,251,250,250,249,248,248,247,248,246,246,246,245,246,\
   245,245,245,246,246,246,246,246,246,246,246,245,245,245,245,245,244,245,244,245,245,245,245,245,245,245,245,\
   245,244,244,245,245,243,239,235,230,226,220,216,211,204,201,194,190,184,176,171,164,160,152,144,138,130,122,\
   114,107,96,87,78,69,57,50,46,38,31,19,5^3,10,14,15,17,18,19,18,19,23,25,30,31,35,37,39,42,44,45,48,49,50,51,\
   52,53,56,59,63,66,66,68,69,71,73,74,75,76,76,77,78,79,79,80,81,81,82,82,83,84,84,84,84,84,85,85,86,86,86,86,\
   87,88,87,86,86,86,86,88,89,89,90,92,92,94,96,99,102,104,107,111,117,120,126,130,136,142,149,155,161,167,172,\
   176,178,179,179,178,178,178,178,177,177,177,176,176,176,176,175,173,173,174,173,172,171,171,171,171,171,171,\
   171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,173,173,173,175,176,178,178,178,181,182,184,\
   186,186,190,192,193,195,198,200,201,204,206,209,211,208,206,202,197,194,190,185,182,178,172,167,162,157,152,\
   144,139,132,127,121,115,108,102,98,92,87,79,75,69,64,62,58,55,52,50,49,47,47,47,47,47,47,47,47,46,46,46,46,\
   45,44,44,42,42,41,41,40,39,38,37,36,34,31,30,29,30,30,31,32,32,32,33,33,34,34,33,34,33,32,31,31,30,29,26,25,\
   23,21,19,15,13,13,16,18,18,18,17,15,13,12,9,2^6,19,25,32,41,49,55,65,71,79,84,90,96,102,106,111,117,121,128,\
   132,134,139,143,146,149,152,155,156,157,159,159,160,161,162,163,164,164,165,166,167,166,165,166,166,167,167,\
   168,168,168,169,169,169,169,170,170,170,170,170,170,170,171,170,170,170,170,170,171,171,172,173,173,173,175,\
   177,179,180,183,185,187,190,193,198,201,206,213,219,225,227,227,223,218,214,204,199,192,184,179,172,168,162,\
   156,151,145,139,133,126,120,113,106,98,90,85,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,84,84,82,82,82,\
   82,82,83,83,81,81,81,80,80,78,78,78,76,74,73,73,71,72,69,68,67,65,62,59,58,56,51,50,49,45,43,40,38,37,35,32,\
   31,32,32,33,33,34,34,35,36,36,37,38,39,42,44,45,46,46,47,48,49,48,48,48,48,48,48,48,48,48,48,47,47,47,47,46,\
   45,45,43,43,42,41,40,39,38,37,38,38,37,37,38,38,38,38,39,40,39,40,39,40,40,39,39,38,38,37,35,34,32,30,28,26,\
   23,20,16,14,12,16,16,18,18,17,16,14,13,9,2)
  -nm[-1] [rainbow\ lut]
  -v +

#@gmic roddy
#@gmic : Load a new image of the G'MIC Rodilius mascot 'Roddy'.
#@gmic : $ -roddy
roddy :
  -e[^-1] "Load image of the G\47MIC Rodilius mascot 'Roddy'."
  -v - -i http://gmic.eu/img/roddy_large.cimgz -nm[-1] [roddy] -v +

#@gmic select : feature_type,_X,_Y,_Z : (+)
#@gmic : Interactively select a feature from selected images (use the instant window [0] if opened).
#@gmic : 'feature_type' can be { 0=point | 1=segment | 2=rectangle | 3=ellipse }.
#@gmic : Arguments 'X','Y','Z' determine the initial selection view, for 3d volumetric images.
#@gmic : The retrieved feature is returned as a 3d or 6d vector containing the feature coordinates.

#@gmic sh : eq. to '-shared'. : (+)

#@gmic shared : x0[%],x1[%],y[%],z[%],v[%] : y0[%],y1[%],z[%],v[%] : z0[%],z1[%],v[%] : v0[%],v1[%] : (no arg) : (+)
#@gmic : Insert shared buffers from (opt. points/rows/planes/channels of) selected images.
#@gmic : Shared buffers cannot be returned by a command, nor a local environment.
#@gmic : (eq. to '-sh').
#@gmic : $ image.jpg -shared 1,1 -blur[-1] 3 -remove[-1]
#@gmic : $ image.jpg -repeat {s} -shared 25%,75%,0,$> -mirror[-1] x -remove[-1] -done
#@gmic : $$

#@gmic srand : value : (no arg) : (+)
#@gmic : Set random generator seed.
#@gmic : If no argument is specified, a random value is used as the random generator seed.

#@gmic testimage2d : _width>0,_height>0,_spectrum>0
#@gmic : Input a 2d synthetic image.
#@gmic : Default values: 'width=512', 'height=width' and 'spectrum=3'.
#@gmic : $ -testimage2d 512
testimage2d : -check "${1=512}>0 && ${2=$1}>0 && ${3=3}>0"
  -e[^-1] "Input 2d synthetic image of size $1x$2x$3."
  -v -
  Dmax2={0.15*min($1,$2)^2}
  $1,$2,1,$3,'X=x-w/2;Y=y-h/2;a=atan2(Y,X);if(X^2+Y^2<=$Dmax2,255*abs(cos(c+200*(x/w-0.5)*(y/h-0.5))),850*(a%(0.1*(c+1))))'
  -polygon[-1] 4,20%,20%,60%,20%,70%,70%,35%,45%,0.9,0,255,0
  -torus3d {$1/7},{$1/20} -r3d[-1] 0,1,1,80 -col3d[-1] 128,200,255
  -j3d[-2] [-1],30%,70%,0,1,5,0,0 -rm[-1] -round[-1] 1
  -nm[-1] "[2d test image]"
  -v +

#@gmic uncommand : command_name[,_command_name2,...] : * : (+)
#@gmic : Discard last definition of specified custom commands.
#@gmic : Set argument to '*' for discarding all existing custom commands.

#@gmic uniform_distribution : nb_levels>=1,spectrum>=1
#@gmic : Input set of uniformly distributed N-d points in [0,1]^N.
#@gmic : $ -uniform_distribution 64,3 -* 255 --distribution3d -circles3d[-1] 10
uniform_distribution : -check "isint($1) && $1>0 && isint($2) && $2>0"
  -e[^1] "Input set of $1 uniformly distributed $2-d points in [0,1]^$2."
  -v - n={round($1^(1/$2),1,1)}
  (0,1) -r[-1] $n,1,1,1,3
  -repeat {$2-1} --channels[-1] 100% -r[-1] {$n*w},1,1,1,1 -r[-2] [-1],1,1,100%,0,2 -a[-2,-1] c -done
  -r[-1] $1,1,1,$2,1 -nm[-1] "[uniform $2d distribution]" -v +

#@gmic up : eq. to '-update'.
up :
  -_update

#@gmic update
#@gmic : Update commands from the latest definition file on the G'MIC server.
#@gmic : This requires an active Internet connection and an access to the external
#@gmic : tools 'curl' or 'wget'.
#@gmic : Once the update has been downloaded, running 'gmic' makes it use automatically.
#@gmic : (eq. to '-up').
update :
  -_$0

_update :
  -e[0--3] "Update commands from the latest definition file on the G\47MIC server."
  -v -
  -if @{-is_windows} out=$APPDATA/update@..gmic -else out=$HOME/.update@..gmic -endif
  -l[] cimgz:http://gmic.eu/update@..gmic
    -if {h>7" && "{@{-1,0-5}'=='{'"#@gmic"'}}} -o raw:$out,char -endif
    -rm
  -onfail -error[0--3] "Command '-update' : Unreachable update file."
  -endl
  -m $out
  -v +

# Generate film emulation page for G'MIC web.
# Input images : samples you want to generate
update_film_emulation_html :
  -if {!@#} -error[^-1] "Command '-update_film_emulation': Missing input images !" -endif
  -v -

  # Init variables.
  jpeg_quality=70    # Set JPEG quality of output images.
  thumb_width=180    # Set thumbnail width.
  thumb_height=90   # Set mini thumbnail height.
  categories=bw,instant_consumer,instant_pro,negative_color,negative_new,negative_old,print,colorslide,various
  category_names="Black and White","Instant [consumer]","Instant [pro]","Negative [color]","Negative [new]","Negative [old]","Print films","Slide [color]","Various"
  film_path=@{-path_user}
  -if {!@{-is_windows}} film_path=$film_path/.gmic_film_presets -endif
  -m "_thumb : -frame 3%,3%,255 -to_rgba -drop_shadow 2,2,3 -repeat @# -l[$>] -i[0] 100%,100%,1,3,245 -blend alpha -endl -done"
  -m "_title : ({'\"$""*\"'}) -replace[-1] {'_'},32 -f[-1] if((x==0||j(-1)==32)&&i>={'a'}&&i<={'z'},i+{'A'}-{'a'},i) -u @{-1,t} -rm[-1]"

  nb_presets=0
  -repeat {narg($categories)}
    category=@{-arg\ {1+$>},$categories}
    presets=@{-_gimp_emulate_film_$category}
    nb_presets={$nb_presets+narg($presets)}
  -done

  -v + -e[] "\n > Update film emulation pages, for "@#" image samples and "$nb_presets" presets." -v -

  # Prepare folder structure.
  -v + -e[] "\n  * Prepare folder structure." -v -
  -x "ln -fs ../copyright.html ."
  -x "ln -fs ../favicon.ico ."
  -x "ln -fs ../favicon.png ."
  -x "ln -fs ../footer.html ."
  -x "ln -fs ../header.html ."
  -x "ln -fs ../header.css ."
  -x "ln -fs ../jquery-1.11.0.min.js ."
  -x "ln -fs ../images ."
  -x "mkdir -p img"
  -x "cd img && ln -fs ../../img/logo4.jpg ."
  -x "cd img && ln -fs ../../img/logos.jpg ."
  -x "cd img && ln -fs ../../img/rss.png ."
  -x "ln -fs ../highslide ."

  # Generate thumbnails.
  -v + -e[] "\n  * Generate thumbnails from samples." -v -
  -if original -else -x "mkdir original" -endif
  nb_samples=@#
  -to_rgb -repeat $nb_samples -l[$<]
    -nm[0] sample_{1+$<}
    basename=@{0,b} basename$<=$basename
    -v + -e[] "    - "$basename -v -
    --r2dx $thumb_width
    --text_outline[0] "Reference",4,@{0,h-28},20,2 -frame[-1] 1,1,0
    -o[-1] original/$basename.jpg,$jpeg_quality -rm[-1]
    --_thumb[1] -o[-1] original/thumb_$basename.jpg,$jpeg_quality -rm[-1]
    --r2dy[0] $thumb_height -_thumb[-1] -o[-1] original/minithumb_$basename.jpg,$jpeg_quality -rm[-1]
  -endl -done

  # Generate film emulation data and rendering on each input sample.
  ind_preset=0
  -repeat {narg($categories)}
    category=@{-arg\ {1+$>},$categories}
    presets=@{-_gimp_emulate_film_$category}

    -v + -e[] "\n  * Category \#"{1+$>}": "$category" ***\n" -v -
    -if $category -else -x "mkdir "$category -endif
    -if $category/clut -else -x "mkdir "$category/clut -endif

    -repeat {narg($presets)}
      preset=@{-arg\ {1+$>},$presets}
      filename=$film_path/gmic_$preset.cimgz
      -v + -e[] "    - "$preset -v -

      -i $filename -to_rgb[-1] s={sqrt(w*h*d)}
      -if {!isint($s)}
        -v + -warn[] "Preset '"$preset"' must be resampled." -v -
        -r[-1] 64,64,64,3,3
      -endif
      s={sqrt(w*h*d)} --r[-1] $s,$s,1,3,-1
      -if {iM<=255} -*[-1] 257 -endif  # Force PNG to be saved in 16bits.
      -o[-1] $category/clut/$preset.png
      -rm[-1]

      -repeat $nb_samples -l[{2*$>},{2*$>+1},-1]
        basename=@{0,b}
        -if $category/$basename/$preset.jpg -else
          -if $category/$basename -else -x "mkdir \""$category/$basename"\"" -endif
          --map_clut[^-1] [-1]
          -text_outline[-2] @{-_title\ $preset},4,@{-2,h-28},20,2 -frame[-2] 1,1,0
          -o[-2] $category/$basename/$preset.jpg,$jpeg_quality
          -_thumb[-1] -o[-1] $category/$basename/thumb_$preset.jpg,$jpeg_quality
          -rm[-2,-1]
        -endif
      -endl -done

      -rm[-1]

      ind_preset={$ind_preset+1}
    -done

  -done

  -rm[1--1:2]  # Remove thumbnails.

  # Generate HTML gallery code.
  -v + -e[] "\n  * Generate html code.\n" -v -

  -repeat {narg($categories)}
    category=@{-arg\ {1+$>},$categories}
    -arg {1+$>},$category_names
    category_name=@{}
    presets=@{-_gimp_emulate_film_$category}

    -repeat $nb_samples
      width=@{$>,64+w} height=@{$>,64+h}
      basename=@{$>,b}
      -v + -e[] "    - "$category_name" / "$basename -v -

      ({'"
<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n
                      \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n\n
<!--#include file=\"header.html\" -->\n
<script type="text/javascript">\n
  hs.align = 'center';\n
</script>\n
<link href=\"../style.css\" rel=\"stylesheet\" type=\"text/css\">\n\n
<div id=\"bloc_option\"><div id=\"top_bleu\"><div id=\"text_top\">Film Emulation</div></div>\n
<div id=\"center\"><div id=\"text_centre_intro\">\n
<p>Among all features available in <b><font color=\"#000066\">G\47MIC</font></b>, our <b>Film Emulation</b> filters are able to apply various pre-defined <b>color presets</b> on your images.\n
Most of those <b>300+</b> presets have been designed by <a href=\"http://blog.patdavid.net/2013/08/film-emulation-presets-in-gmic-gimp.html\">Patrick David</a>, in order to emulate the look of\n
analog films. They have a dedicated section in the open-source <a href=\"../gimp.shtml\"><b><font color=\"#000066\">G\47MIC</font></b> plug-in for GIMP</a>, so you can apply all these easily in GIMP.</p>\n\n
<p>Below, you can navigate through the different proposed color presets and see how they modify the colors of some sample images.\na
You can also download each color preset separately as its corresponding <a href=\"http://www.quelsolaar.com/technology/clut.html\">Hald-CLUT</a> file (in <b>.png</b> format), to use it in\n
other softwares that support this feature.</p>\n\n
<p><b>Image credits:</b> All sample images below have been borrowed from <a href=\"https://www.flickr.com/photos/patdavid/\">Patrick David\47s Flickr</a> and are distributed under\n
<a href=\"https://creativecommons.org/licenses/by-sa/2.0/\">CC-by-SA 2.0</a>.</p>\n\n
<p><font size=\"-1\"><b>Disclaimer:</b><br/>\n
<i>The trademarked names which may appear in the filenames of the Hald CLUT images are there for informational purposes only. They serve only to inform the user which film stock the given Hald CLUT image\n
is designed to approximate. As there is no way to convey this information other than by using the trademarked name, we believe this constitutes fair use. Neither the publisher nor the authors are affiliated\n
with or endorsed by the companies that own the trademarks.</i></font></p>\n\n
</div></div><div id="footer"><img src="images/footer.jpg" /></div></div>\n
<div id=\"bloc_option\"><div id=\"top_bleu\"><div id=\"text_top\"><a id=\"browse\">Browse</a></div></div>\n
<div id=\"center\"><div id=\"text_centre_intro\">\n
<table><tr>\n
<td valign=\"top\" width=\"300\">Select film category:\n
<ul>\n"'})
      -repeat {narg($categories)}
        _category=@{-arg\ {1+$>},$categories}
        -arg {1+$>},$category_names
        _category_name=@{}
        -if {$_category'=='$category}
          ({'"
<li><font color="#CC7700"><b>"$_category_name"</b></font></li>\n
"'})
        -else
          ({'"
<li><a href=\""${_category}_$basename.shtml"#browse\">"$_category_name"</a></li>\n
"'})
        -endif
      -done

      ({'"
</ul>\n
</td>\n
<td valign=\"top\">Select sample image:<br/><br/>\n
"'})
      -repeat {$nb_samples}
        _basename=${basename$>}
        -if {$_basename'=='$basename}
          ({'"
<a href=\""${category}_$_basename.shtml"#browse\"><img style=\"border-color:#CC7700;\" border=\"3\" src=\""original/minithumb_$_basename.jpg"\"/></a>\n
"'})
        -else
          ({'"
<a href=\""${category}_$_basename.shtml"#browse\"><img src=\""original/minithumb_$_basename.jpg"\"/></a>\n
"'})
        -endif
      -done
({'"
</td>\n
</tr></table>\n
</div></div><div id="footer"><img src="images/footer.jpg" /></div></div>\n
"'})

      ({'"\n
<div id=\"bloc_option\"><div id=\"top_bleu\"><div id=\"text_top\">Presets ("{narg($presets)}")</div></div>\n
<div id=\"center\"><div id=\"text_centre_intro\">\n
<center><table>\n
<tr><td>\n
<div><a href=\"original/"$basename".jpg\" class=\"highslide\" onclick=\"return hs.expand(this)\"><img src=\"original/thumb_"$basename".jpg\" /></a>\n
<div class=\"highslide-caption\"><b>Reference Image</b></div></div>\n
</td></tr>\n
<tr><td align=\"center\"><b>Refence Image</b></td></tr>\n\n
"'})
      -repeat {narg($presets)}
        preset=@{-arg\ {1+$>},$presets}

        ({'$preset'}) -replace_seq[-1] 39,"92,92,39" preset_esc=@{-1,t} -rm[-1]

        title=@{-_title\ $preset}
        -if {$>%4==0} -if $> ({'"</tr>\n"'}) -endif ({'"<tr>"'}) -endif

        ({'"
<td><table>\n
<tr><td>\n
<div><a href=\"#\" onclick=\"return hs.htmlExpand(this, { width: "$width", height: "$height" })\">\n
<img src=\""$category/$basename/thumb_$preset".jpg\" />\n
</a>\n
<div class=\"highslide-maincontent\"><center>\n
<img src=\""$category/$basename/$preset.jpg"\" onclick=\"hs.close()\" onmouseover=\"javascript:this.src='"$category/$basename/$preset_esc.jpg"';\" onmouseout=\"javascript:this.src='original/"$basename".jpg';\" >\n
</center></div>\n
<div class=\"highslide-caption\"><b>Preset:</b> <i>"$title"</i> [<a href=\""$category/clut/$preset.png"\">Download CLUT</a>]</div></div>\n
</td></tr>\n
<tr><td align=\"center\"><font size=\"-1\">"$title"</font></td></tr>\n
</table></td>\n\n"'})
      -done
      ({'"
</table></center>\n
</div></div><div id="footer"><img src=\"images/footer.jpg\" /></div></div>\n
"'})

      ({'"<!--#include file=\"copyright.html\" -->\n
<!--#include file=\"footer.html\" -->\n
"'})
      -a[$nb_samples--1] x -o[-1] raw:${category}_$basename.shtml,char -rm[-1]

    -done
  -done

  # All done, exiting.
  -rm
  category=@{-arg\ 1,$categories}
  -x "ln -fs "${category}_$basename0.shtml" index.shtml"
  -v + -e[] "\n > All done, for "$nb_presets" presets.\n"

# Generate gallery page for G'MIC web.
update_gallery_html :
  -e[^-1] "Generate gallery for the G'MIC web site."
  -v -
  thumb_size=128

  # Clean files from a possible previous gallery generation.
  -x "rm -f gallery.shtml img/gallery_*.jpg"

  # Define and load test images.
  img/chloe.jpg
  img/fawn.jpg
  img/house.jpg
  img/statue.jpg
  img/beach.jpg

  nb_imgs=@#
  -repeat @# --r2dy[$>] $thumb_size width$>={w} -rm[-1] -done  # Get width of standard thumbnails.

  # Define commands used to generate the gallery.
  _nb_coms=-1

  -_update_gallery_html " "
  -_update_gallery_html " "
  -_update_gallery_html " "
  -_update_gallery_html " "
  -_update_gallery_html " "

  -_update_gallery_html "-luminance"
  -_update_gallery_html "-solarize"
  -_update_gallery_html "-negative"
  -_update_gallery_html "-select_color 100,0,0,0 -n 0,255"
  -_update_gallery_html "-array_fade 4,4"

  -_update_gallery_html "--mirror[-1] x -fade_x 40,60"
  -_update_gallery_html "-shift_tiles 20,20"
  -_update_gallery_html "-fisheye 40"
  -_update_gallery_html "-fisheye 50"
  -_update_gallery_html "-shade_stripes ,"

  -_update_gallery_html "-shade_stripes 40,1"
  -_update_gallery_html "-tetris 10"
  -_update_gallery_html "-blur 1 -gradient_orientation 2 -+ -n 0,255 -smooth 60,0,1,1,3"
  -_update_gallery_html "-flower 30,5"
  -_update_gallery_html "-water 30,1.5"

  -_update_gallery_html "-wave 4,0.4"
  -_update_gallery_html "-wave 15,0.2"
  -_update_gallery_html "-deform 10"
  -_update_gallery_html "-light_patch 4,0.7,1.7"
  -_update_gallery_html "-mosaic 0.5,80,1"

  -_update_gallery_html "-sponge 13"
  -_update_gallery_html "-hearts 15"
  -_update_gallery_html "-color_ellipses 1400,10,0.07"
  -_update_gallery_html "-whirls 3"
  -_update_gallery_html "-edges 15 -n 0,255"

  -_update_gallery_html "-to_rgba -gimp_reflect 50,1,110,160,190,64,0,1.5,0,-3.30,7,1.5 -drgba"
  -_update_gallery_html "-transform_polar R-r"
  -_update_gallery_html "-drawing 200"
  -_update_gallery_html "-draw_whirl 100"
  -_update_gallery_html "-texturize_paper"

  -_update_gallery_html "-stencilbw 30"
  -_update_gallery_html "-glow 4"
  -_update_gallery_html "-ditheredbw"
  -_update_gallery_html "-blur_angular 10"
  -_update_gallery_html "-blur_radial 10"

  -_update_gallery_html "-repeat 3 --deform[0] 10 -done -+ -n 0,255"
  -_update_gallery_html "-flood 50%,50%,0,50,0,0.7,155,100,255"
  -_update_gallery_html "--mirror x --mirror y -* -equalize 255 -n 0,255"
  -_update_gallery_html "-kaleidoscope 0.5,0.5,50,20"
  -_update_gallery_html "-noise 40 -cut 0,255 --meancurvature_flow[-1] 20 -sharpen[-1] 100 -a x"

  -_update_gallery_html "-gradient_norm -sqrt -n 0,255"
  -_update_gallery_html "-to_rgba -rotate_tiles 15,5,5 -drgba"
  -_update_gallery_html "-taquin 5"
  -_update_gallery_html "img/chloe.jpg -drop_shadow[-1] 3 -rotate[-1] 55 -blend alpha"
  -_update_gallery_html "[-1] -deform 10 -morph 4,0.05 -a x"

  -_update_gallery_html "-polaroid 20 -drop_shadow 3,3 -rotate 10,1 -drgba"
  -_update_gallery_html "--plasma 10,10 -n[-1] 0.5,2.5 -n 0,255 -and -equalize 256"
  -_update_gallery_html "100%,100% -mandelbrot[-1] -1.17229,-0.3038,-1.15209,-0.2836,1000 -map[-1] 0 -*[-2] 1.5 -+ -n 0,255"
  -_update_gallery_html "--edges 15 -n 0,255 -fade_y 30,70"
  -_update_gallery_html "-split_tiles 5,5 -blur 8 -sharpen 1000 -equalize 255 -append_tiles 5,5"

  -_update_gallery_html "-imagecube3d -*3d 256 -r3d 1,1,0,60 512,512,1,3 -plasma[-1] 10,10 -n[-1] 0,128 -m3d 5 -db3d 0 -object3d[1] [0],50%,50% -k[1] -n 0,255"
  -_update_gallery_html "-warp_perspective 0.3,0.9,0.5"
  -_update_gallery_html "-rodilius ,"
  -_update_gallery_html "-blur 3 -gradient2rgb 1"
  -_update_gallery_html "-normalize_local 80,7"

  -_update_gallery_html "-normalize_local 80,3"
  -_update_gallery_html "-normalize_local 80,7"
  -_update_gallery_html "-normalize_local 80,6,2"
  -_update_gallery_html "-isophotes 4 -dilate 3 -i[0] (0;255^0;255^100;100) -r[0] [1],[1],1,3,3 -blend alpha"
  -_update_gallery_html "-crop 30%,30%,70%,70% -resize 200%,200%,1,100%,5 -frame_fuzzy 30,30"

  -_update_gallery_html "-cartoon ,"
  -_update_gallery_html "-cartoon ,"
  -_update_gallery_html "-cartoon ,"
  -_update_gallery_html "-cartoon ,"
  -_update_gallery_html "-cartoon ,"

  -_update_gallery_html "-resize2dx 300 -m3d 2 -elevation3d 0.3 -f3d 200 -snapshot3d 400,1.5"
  -_update_gallery_html "-resize2dx 300 -m3d 2 -elevation3d 0.3 -f3d 200 -snapshot3d 400,1.5"
  -_update_gallery_html "-resize2dx 300 -m3d 2 -elevation3d 0.3 -f3d 200 -snapshot3d 400,1.5"
  -_update_gallery_html "-resize2dx 300 -m3d 2 -elevation3d 0.3 -f3d 200 -snapshot3d 400,1.5"
  -_update_gallery_html "-resize2dx 300 -m3d 2 -elevation3d 0.3 -f3d 200 -snapshot3d 400,1.5"

  -_update_gallery_html "-topographic_map 16,2"
  -_update_gallery_html "-topographic_map 16,2"
  -_update_gallery_html "-topographic_map 16,2"
  -_update_gallery_html "-topographic_map 16,2"
  -_update_gallery_html "-topographic_map 16,2"

  -_update_gallery_html "--blur 10 -curvature[-1] -norm[-1] -+[-1] 0.01 -/ -equalize 255 -n 0,255"
  -_update_gallery_html "--blur 10 -curvature[-1] -norm[-1] -+[-1] 0.01 -/ -equalize 255 -n 0,255"
  -_update_gallery_html "--blur 10 -curvature[-1] -norm[-1] -+[-1] 0.01 -/ -equalize 255 -n 0,255"
  -_update_gallery_html "--blur 10 -curvature[-1] -norm[-1] -+[-1] 0.01 -/ -equalize 255 -n 0,255"
  -_update_gallery_html "--blur 10 -curvature[-1] -norm[-1] -+[-1] 0.01 -/ -equalize 255 -n 0,255"

  -_update_gallery_html "-blur 1 -pencilbw 0.3"
  -_update_gallery_html "-blur 1 -pencilbw 0.3"
  -_update_gallery_html "-blur 1 -pencilbw 0.3"
  -_update_gallery_html "-blur 1 -pencilbw 0.3"
  -_update_gallery_html "-blur 1 -pencilbw 0.3"

  -_update_gallery_html "-old_photo -drop_shadow 3,3 -rotate -5,1 -drgba"
  -_update_gallery_html "-old_photo -drop_shadow 3,3 -rotate -10,1 -drgba"
  -_update_gallery_html "-old_photo -drop_shadow 3,3 -rotate -15,1 -drgba"
  -_update_gallery_html "-old_photo -drop_shadow 3,3 -rotate -20,1 -drgba"
  -_update_gallery_html "-old_photo -drop_shadow 3,3 -rotate -25,1 -drgba"

  -_update_gallery_html "-erode 10 --erode 3 -- -equalize 255 -smooth 40,0,1,1,3 -n 0,255 -negative"
  -_update_gallery_html "-erode 10 --erode 3 -- -equalize 255 -smooth 60,0,1,1,3 -n 0,255 -negative"
  -_update_gallery_html "-erode 10 --erode 3 -- -equalize 255 -smooth 80,0,1,1,3 -n 0,255 -negative"
  -_update_gallery_html "-erode 10 --erode 3 -- -equalize 255 -smooth 100,0,1,1,3 -n 0,255 -negative"
  -_update_gallery_html "-erode 10 --erode 3 -- -equalize 255 -smooth 120,0,1,1,3 -n 0,255 -negative"

  -_update_gallery_html "-light_relief ,"
  -_update_gallery_html "-light_relief ,"
  -_update_gallery_html "-light_relief ,"
  -_update_gallery_html "-light_relief ,"
  -_update_gallery_html "-light_relief ,"

  -_update_gallery_html "--warhol 2 -fade_radial 50,70"
  -_update_gallery_html "--warhol 3 -fade_radial 50,70"
  -_update_gallery_html "--warhol 4 -fade_radial 50,70"
  -_update_gallery_html "--warhol 5 -fade_radial 50,70"
  -_update_gallery_html "--warhol 6 -fade_radial 50,70"

  -_update_gallery_html "--sketchbw , -rv -blend overlay"
  -_update_gallery_html "--sketchbw , -rv -blend overlay"
  -_update_gallery_html "--mirror x -a x -map_sphere ,"
  -_update_gallery_html "--mirror x -a x -map_sphere ,"
  -_update_gallery_html "-gimp_painting 2,1.5,2"

  -_update_gallery_html "-f3d 800 -rm 512,512,1,3 -chessboard 64,64,0,0,15,1,@{-RGB},@{-RGB} --imagecube3d -*3d[-1] 230 -r3d[-1] 1,1,0.5,50 -m3d 3 -object3d[-2] [-1],50%,50%,0 -rm[-1] -gimp_painting 1,1.5,2 -equalize[-1] 256"
  -_update_gallery_html "--histogram 256 -display_graph[-1] @{0,w},@{0,h},3 -to_rgba[-1] -*[-1] 0.5 -blend alpha"
  -_update_gallery_html "100%,100%,1,1,'X=(x-w/2)/30;Y=(y-h/2)/30;5*cos(X*Y)*sqrt(X^2+Y^2)' -elevation3d[0] [1] -k[0] -r3d 1,1,0,60 -snapshot3d 500,2"
  -_update_gallery_html "-kuwahara 10 -noise 30 -smooth 100,0,1,3,3 -sharpen 400 -n 0,255 -equalize 256"
  -_update_gallery_html "-frame 4,4,0 -array_mirror 1,3"

  _nb_coms={$_nb_coms+1}

  # Generate gallery HTML header.
  ({'"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n\
      \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n\
<!--#include file=\"header.html\" -->\n
<link href=\"style.css\" rel=\"stylesheet\" type=\"text/css\">\n
<div id=\"bloc_option\"><div id=\"top_bleu\"><div id=\"text_top\">Image Gallery</div></div>\n
<div id=\"center\"><div id=\"text_centre_intro\">\n
  All the images below have been processed by the command line version <b><a href=\"documentation.shtml\">gmic</a></b>\n
  of <b><font color=\"#000066\">G\47MIC</font></b>, from a set of initial 2D color images (displayed on the first row).<br/>\n
  Click on an image to zoom-in. The corresponding <b><font color=\"#000066\">G\47MIC</font></b> command used to generate the image appears as a caption.\n
  This gallery is intended to show the flexibility and the genericity of the <b><font color=\"#000066\">G\47MIC</font></b> language.\n
  Remember, you can easily define your own image filters and effects by writting\n
  your custom <b><font color=\"#000066\">G\47MIC</font></b> <a href=\"http://gmic.eu/gmic_def.gmic\">command file</a>,\n
  and eventually put them directly in <a href=\"http://www.gimp.org\">GIMP</a> afterwards.\n\n
  <ul>\n
  <li>See also the <a href=\"gimp.shtml\">GIMP plug-in page</a> to see various screenshots of what <b><font color=\"#000066\">G\47MIC</font></b> can do.</li>\n
  <li>See also the <a href=\"reference.shtml\">G\47MIC reference page</a> to have processing examples of almost all <b><font color=\"#000066\">G\47MIC</font></b> commands\n
    (scroll down there to view example images).</li>\n
  <li>See also the <a href=\"http://www.flickr.com/groups/gmic/pool/\">Flickr slideshow</a>, showing uses of the <a href=\"gimp.shtml\">G\47MIC plug-in</a>\n
  by various artists.</li>\n
  </ul>\n
  <b>Copyrights : </b> All pictures have been shot by <a href=\"http://tschumperle.users.greyc.fr/\">David Tschumperl&eacute;</a>.<br/><br/>\n"'})

  # Generate main gallery table.
  ({'"<center><table cellpadding=\"1\" border=\"0\" cellspacing=\"2\">"\n'})
  row=0
  -repeat $_nb_coms

    ind={$>%$nb_imgs}
    out_img=@{"-filename "img/gallery.jpg,$>}
    out_thumb=@{"-filename "img/gallery_thumb.png,$>}

    # Start new row.
    -if {!$ind} ({'"<tr>\n"'}) -endif

    com=${_com$>}

    -v + -e[] " - Image "{$>+1}/$_nb_coms" : $ "$com -v -

    displayed_com$ind=$com
    -if {!narg($com)} com="-skip ," -endif
    --__update_gallery_html[$ind] $com

    iind={$ind%5}

    width=@{$iind,w} height=@{$iind,h}
    -o[-1] $out_img,75
    -r2dy[-1] $thumb_size -if {w>${width$ind}} -r[-1] ${width$ind},100%,100%,100%,2 -endif
    -l[-1] -frame 3%,3%,255 -to_rgba -drop_shadow 2,2,3 -endl
    -o[-1] $out_thumb -rm[-1]

    ({'"<td width=\""${width$>}"\"><center><div>\
        <a href=\""$out_img"\" class=\"highslide\" onclick=\"return hs.expand(this)\">\
	<img src=\""$out_thumb"\"/></a>\
        <div class=\"highslide-caption\">gmic "@{$ind,b}.@{$ind,x}" "${displayed_com$ind}"</div>\
        </div></center></td>\n"'})

    -if {$ind==$nb_imgs-1" || "$>==$_nb_coms-1} # End row.
      ({'"</tr>\n<tr bgcolor=\""$bgcolor"\">"\n'})
      -repeat {$ind+1}
        ({'"<td width=\""${width$>}"\"><center><font size=\"1\">gmic "@{$>,b}.@{$>,x}" "${displayed_com$>}"</font></center></td>\n"'})
      -done
      ({'"</tr>\n"'})
      row={$row+1}
    -endif

  -done
  ({'"</table></center>\n"'})

  # Generate gallery footer.
  ({'"</div></div><div id=\"footer\"><img src=\"images/footer.jpg\" /></div></div>\n\
      <!--#include file=\"copyright.html\" -->\n\
      <!--#include file=\"footer.html\" -->\n"'})

  # Save html page and exit properly.
  -rm[0-{$nb_imgs-1}] -a x
  -o gallery.raw,uchar -x "mv gallery.raw gallery.shtml" -rm
  -v + -e[^-1] "All done !"

_update_gallery_html :
  _nb_coms={$_nb_coms+1} _com$_nb_coms="$1"

__update_gallery_html :
  ${1--1}

# Function that updates filters definitions on the G'MIC web server.
# It sorts and merges filters from all available sources, and save
# a single update file on the G'MIC server. It also print on the standart
# output (stdout), the list of available filters.
# $1 = update version number.
# $2 = enable/disable filters list output on stdout.
update_server : -skip ${1=@.},${2=1}
  -v -

  # Create substitution list to force filters having a particular location.
  -_update_server_move "/Artistic/Pastell~art","/Testing/Naggobot"
  -_update_server_move "/Artistic/Simple~noise~canvas","/Patterns"
  -_update_server_move "/Degradations/Tilt~shift","/Testing/J&#233;J&#233;"
  -_update_server_move "/Layers/Fast~median~stack","/Testing/Iain~fergusson"
  -_update_server_move "/Rendering/Chryzodes","/Testing/Samj/Rendering"
  -_update_server_move "/Testing/J&#233;J&#233;/Rays","/Patterns"
  -_update_server_move "/Testing/Iain~fergusson/Halftone~shapes","/Patterns"
  -_update_server_move "/Testing/Iain~fergusson/Simple~local~contrast","/Details"
  -_update_server_move "/Testing/Garagecoder/Aurora","/Artistic"
  -_update_server_move "/Testing/Garagecoder/Despeckle","/Repair"
  -_update_server_move "/Testing/Garagecoder/HSL~adjustment","/Colors"
  -_update_server_move "/Testing/Garagecoder/HSV~select","/Colors"
  -_update_server_move "/Testing/Garagecoder/Stereo~image","/Stereoscopic~3d"
  -_update_server_move "/Testing/Garagecoder/Undo~anaglyph","/Stereoscopic~3d"
  -_update_server_move "/Testing/Naggobot/Blockism","/Artistic"
  -_update_server_move "/Testing/Samj/Chalk~it~up","/Artistic"
  -_update_server_move "/Testing/Samj/Denim~texture","/Patterns"
  -_update_server_move "/Testing/Zonderr/Spiral","/Rendering"

  # Define useful sub-commands.
  -m "parent : -l[] ({'$""1'}) -s -,{'/'} -if @# -rm[-1] -endif -i[0--1] (47) -a y -u @{0,t} -rm -endl" # Command to return parent of a path.
  -m "_max : ({'\"$""1\"'}) ({'\"$""2\"'}) -f[-2,-1] 'if(i>=97&&i<=122,i-32,i)' -r[-2,-1] {max(w,@{-2,w})},1,1,1,0 --[-2,-1] -autocrop[-1] 0 "\
     "-u {i>0} -rm[-1]" # Command to compare two strings (eq. to strcasecmp).
  -m "load_gmic : "\
     "_nb_sources={$_nb_sources+1} filename=@{\"-basename $""1\"} "\
     "-v + -e[] \"  \"$_nb_sources\". \"$filename\"  \" -v - "\
     "-l[] "\
     "  -i raw:$""1,char -v + -e[] \"      [retrieved from source '$""1']\" -v - "\
     "  -l "\
     "    -o raw:/tmp/$filename,char "\
     "    -_update_server_upload /tmp/$filename,include/$filename "\
     "    -v + -e[] \"      [archived]\n\" -v - "\
     "  -onfail -v + -e[] \"      [could not be archived!]\n\" -v - -endl "\
     "-onfail -l[] "\
     "  source=http://gmic.eu/include/$filename "\
     "  -i raw:$source,char -v + -e[] \"      [retrieved from archive '\"$source\"']\n\" -v - "\
     "  -onfail -v + -e[] \"      [error, not reachable!]\n\" -v -"\
     "  -endl -endl"
  -m "calibrate_name : "\
     "-autocrop 32 "\
     "-f 'if(i>=65&&i<=90,i+32,i)' "\
     "-replace {'_'},32 -autocrop 32 "\
     "-replace_str Fft,FFT "\
     "-replace_str rgb,RGB "\
     "-replace_str lab,Lab "\
     "-replace_str hsv,HSV "\
     "-replace_str hsl,HSL "\
     "-replace_str ycbcr,YCbCr "\
     "-replace_str cmyk,CMYK "\
     "-replace_str b&amp;w,B&amp;W "\
     "-replace_str gimp,GIMP "\
     "-replace_str roddy,Roddy "\
     "-replace_str crt,CRT "\
     "-replace_str colorabstractionpaint,\"Color abstraction paint\" "\
     "-replace_str g\47mic,G\47MIC "\
     "-f 'if(y==0&&i>=97&&i<=122,i-32,i)' "

  # Copy latest command definitions on G'MIC server if necessary.
  -if {$1==@.}
    -v + -e[] "> Upload latest version ("@{-strver}") of commands on G'MIC server.\n" -v -
    -_update_server_upload $HOME/work/src/gmic/src/gmic_def.gmic,gmic_def.$1
    -_update_server_upload $HOME/work/src/gmic/src/gmic_def.gmic
  -endif

  # Get command source files and archive them.
  -v + -e[] "> Load and archive .gmic source files.\n" -v -
  _nb_sources=0
  -load_gmic http://gmic.eu/gmic_def.$1
  -load_gmic http://gmic.eu/compatibility.gmic
  -if {$1!=@.} -l -load_gmic http://gmic.eu/backports$1.gmic -onfail -endl -endif
  -load_gmic http://s406833247.websitehome.co.uk/gmic/garagecoder.gmic
  -load_gmic http://gentlemanbeggar.bplaced.net/gentlemanbeggar_gmic.gmic
  -load_gmic http://www.iain.bplaced.net/iain_fergusson.gmic
  -load_gmic http://jaypri.ch/GMIC/jayprich.gmic
  -load_gmic https://raw.github.com/jboulanger/jboulanger-gmic/master/jboulanger.gmic
  -load_gmic http://particularart.com/static/gmictutor.gmic
  -load_gmic http://karo03.bplaced.net/gmic/karos.gmic
  -load_gmic http://www.saunalahti.fi/naggobot/naggobot.gmic
  -load_gmic http://gmic.eu/photocomix.gmic
  -load_gmic http://gmic.eu/ronounours.gmic
  -load_gmic http://www.aljacom.com/~gmic/samj.gmic
  -load_gmic http://gmic.eu/tomkeil.gmic
  -load_gmic http://docgmic.tuxfamily.org/zonderr.gmic

  # Merge them together.
  -i[0] (10) -i[2--1] ({"'\n#@gimp ________________\n'"}) -y -a y -discard 13 -replace 9,32
  -s +,{'"#@gimp"'}
  -repeat {int((@#-1)/2)} -a[{$>+1},{$>+2}] y -done
  -nm[0] !header

  # Parse filter tree.
  -v + -e[] "> Start filter parsing.\n" -v -
  progress_factor={100/(@#-1)}
  merge_request=0
  merge_start=0
  nb_filters=0
  offset=0
  path=/

  -repeat @#
    ind={$>-$offset}
    -if {@{{$ind-1},-1}==10" && "{{`@{$ind,0-5}`}'=='"#@gimp"}" && "(@{$ind,6}==32" || "@{$ind,6}=={'_'})} -l[$ind] # Line starts by '#@gimp[_] '

      is_folder=0
      -s +,10
      -if {@{0,6}=={'_'}} --rows[0] 9,100% -rows[0] 0,8 # Treat a localized filter as a regular filter.
      -else --rows[0] 6,100% -rows[0] 0,5
      -endif
      -autocrop[-1] 32 -mv[-1] 1

      -if {@{1,0}!={':'}} # Found a new filter or folder definition.
        -l[1]

          # Format string by removing special character sequences.
          -s +,{':'}
          -replace_str[0] "<b>"
          -replace_str[0] "</b>"
          -replace_str[0] "<i>"
          -replace_str[0] "</i>"
          -replace[0] {'/'},{'-'}
          -replace[0] {','},{';'}
          -autocrop[0] 32

          -if {@#>1} # Found new filter.
            -calibrate_name[0] --replace[0] 32,{'~'}
            name=$path@{-1,t} -rm[-1]
            merge_request=1
            nb_filters={$nb_filters+1}
            -i[0,1] (32) -a y
            -v + -e[] "  "$nb_filters". "$name" ("{round($>*$progress_factor)}"%)." -v -

          -else # Found new folder (opt. parent(s)).
            -if {i=={'_'}} # Folder has parents before creating it.
              -do path=@{"-parent[] "$path} -shift 0,-1,0,0 -while {i=={'_'}}
              -autocrop 0 -autocrop 32
              -if {w} -calibrate_name -replace 32,{'~'} path=$path@{0,t}/ -endif # Folder name specified after the underscore(s).
            -else # Folder name don't start with '_'.
              -autocrop 32 -calibrate_name -replace 32,{'~'} path=$path@{0,t}/
            -endif
            is_folder=1

          -endif # -if {@#>1}
        -endl # -l[-1]

        -if $is_folder -rm[0,1] -i[0] (10) # Discard folder definition (will be recreated afterwards).
        -else -nm[0] $name -endif

      -else # Found possibly a filter argument.

        -if {@#>=3} -l[1]
          -s +,{'='}
          -if {@#>=3} -if {@{1,0}=={'='}}
            -rows[0] 1,100% -calibrate_name[0]
            -i[0] ({':'};32) -i[2] (32)
          -endif -endif
        -endl -endif
        -i[1] (32)

      -endif # -if {i!={':'}}
      -a y

    -endl -endif

    -if {$merge_request" && "$ind>0} # Merge previous lines.
      -a[$merge_start-{$ind-1}] y
      offset={$offset+$ind-$merge_start-1}
      merge_start={$merge_start+1}
      merge_request=0
    -endif

  -done

  -a[$merge_start--1] y # Final merge.

  # Force filters to move if necessary.
  -v + -e[] "\n> Force filters to move, if necessary." -v -
  -repeat @# ind=$> -repeat $_nbm -if {@{$ind,n}'=='${_to_move$>}}
   -v + -e[] "  "$ind". Move '"@{$ind,n}"' to '"${_move_to$>}"'." -v -
   -name[$ind] ${_move_to$>}/@{$ind,b}
  -endif -done -done

  # Sort filter code by lexicographical order.
  -v + -e[] "\n> Sort filters by lexicographic order." -v -
  -_update_server_sort 0,{@#-1}

  # Remove duplicate filters.
  -v + -e[] "\n> Remove duplicate filters." -v -
  pname=@{-1,n}
  -repeat {@#-1} cname=@{$<,n}
    -if {$cname'=='$pname}
      -v + -e[] "  "$<". Remove duplicate '"$cname"'." -v -
      -rm[$<]
    -else pname=$cname -endif
  -done

  # Rebuild folder structure.
  -v + -e[] "\n> Rebuild folder structure." -v -
  -m "nb_levels : -l[] ({'$""1'}) -s -,{'/'} -u @# -rm -endl"  # Command to count number of folders in a given path.

  path=/
  -repeat @# -l[$>]
    npath=@{"-parent "@{0,n}}

    -if {$path'!='$npath} # Need to change the path.
      nc=@{"-nb_levels[] "$path}
      nn=@{"-nb_levels[] "$npath}

      # Get the minimal basis path in common and the number of up/down operations.
      nb_up=0
      nb_down=0
      basis=$path nbasis=$npath
      -do
        nc=@{"-nb_levels[] "$basis}
        nn=@{"-nb_levels[] "$nbasis}
        -if {$nc>$nn} basis=@{"-parent[] "$basis} nb_up={$nb_up+1}
        -elif {$nn>$nc} nbasis=@{"-parent[] "$nbasis} nb_down={$nb_down+1}
        -elif {$nbasis'!='$basis} basis=@{"-parent[] "$basis} nb_up={$nb_up+1} nbasis=@{"-parent[] "$nbasis} nb_down={$nb_down+1}
        -endif
      -while {$nbasis'!='$basis}

      # Deduce the G'MIC command to apply.
      command=
      -if $nb_up 1,$nb_up,1,1,{'_'} command="#@gimp "@{-1,t}"\n" -rm[-1] -endif
      -if $nb_down -l[]
        ({'$npath'}) -s -,{'/'} -k[-$nb_down--1] -replace {'~'},32
        level={@{"-nb_levels "$path}-$nb_up}
        balise=@{"-if "{$level<=0" && "{$npath'!='/About/}}" -u b -else -u i -endif"}
        -repeat @#
          command=$command"#@gimp <"$balise">"@{$>,t}"</"$balise">\n"
          balise="i"
        -done -rm
      -endl -endif
      -if {narg($command)} name=@{0,n} -i[0] ({'$command'}) -y[0] -a y -nm $name
      -endif

      path=$npath
    -endif

  -endl -done

  # Search / replace strings and add footer.
  -v + -e[] "> Search and replace strings." -v -
  -replace_str "Saturation eq p","Saturation equalizer"
  -replace_str "CMYK tone p","CMYK tone"
  -replace_str "Texture enhance p","Texture enhance"
  -replace_str "\#@gmic\n",""

  # Remove useless comments and line breaks.
  -repeat @# -l[$>] -s -,10 -repeat @# -l[$<]
    -if {i[0]=={'\#'}" && "i[1]!={'@'}} -rm -endif
  -endl -done -i[^0] ({'\n'}) -a y -endl -done

  # Retrieve G'MIC command name for each filter.
  -repeat @# --l[$>] command_name$>=""
    --rows 0,6 head=@{-1,t} -rm[-1]
    -if {$head'=='"#@gimp "} -s -,{':'}
      -if {@#>=1} -l[1] -s -,{','}
        -if @# -autocrop[0] 32 command_name$>=@{0,t} -endif
      -endl -endif
    -endif
  -rm -endl -done

  # Save reordered .gmic file.
  -if {$nb_filters>500}
    -v + -e[] "> Save output .gmic file.\n" -v -
    --a y

    # Add footer and header.
    -i[-2] ({'"\#@gmic"\n\
             "\#"\n\
             "\#  File        : gmic_def.gmic"\n\
             "\#                ( G\47MIC commands file )"\n\
             "\#"\n\
             "\#  Description : Update file for G\47MIC commands and filters (version "@{-strver}")."\n\
             "\#                ( http://gmic.eu )"\n\
             "\#"\n\
             "\#  License     : CeCILL v2.0"\n\
             "\#                ( http://www.cecill.info/licences/Licence_CeCILL_V2-en.html )"\n\
             "\#"\n\n'})
    ({'"\n\# Local Variables:"\n\
       "\# mode: sh"\n\
       "\# End:"\n\
       "\#"\n\
       "\# (End of G\47MIC update file)"'})
    -y[-3,-1] -a[-3--1] y

    -o[-1] raw:$HOME/.update$1.gmic,char
    -o[-1] /tmp/.update$1.cimgz,char
    -_update_server_upload /tmp/.update$1.cimgz,update$1.gmic
    -_update_server_upload /tmp/.update$1.cimgz,update1604.gmic
    -rm[-1]
  -endif

  # Display list of filters (sorted alphabetically) on stdout.
  -if {$2" && "$1==@.}
    -v + -e[] "> Output list of filters in stdout.\n" -v -
    -x "date +%Y,%m,%d,%H >"@{-path_tmp}/date.dlm
    @{-path_tmp}/date.dlm
    -echo_stdout "*** List of filters in the G\47MIC plug-in for GIMP ("$nb_filters" filters, on "{i}/{i(1)}/{i(2)}" "{i[3]}:00") ***\n"
    -rm[-1]
    -echo_stdout "* List of filters, sorted by path:\n"
    -repeat @# -l[$>]
      ({'@{0,n}'}) -if {i!={'!'}}
        -r[-1] {w-1},1,1,1,0,0,1
        -replace_str[-1] "&amp;","&"
        -replace_str[-1] "&#233;","e"
        -replace_str[-1] "/","~/~"
        -replace[-1] {'~'},32
        -if {narg(${command_name$>})} -echo_stdout[] "  "@{-1,t}" (command '-"${command_name$>}"')"
        -else -echo_stdout[] "  "@{-1,t}
        -endif
      -endif -rm[-1]
    -endl -done

    -echo_stdout "\n* List of filters, sorted alphabetically:\n"

    -repeat @#
      name=@{$>,b}
      path=@{$>,f}
      -nm[$>] $name"~(in~'"$path"')"
    -done

    -_update_server_sort 0,{@#-1}
    -repeat @# -l[$>]
      ({'@{0,n}'}) -if {i!={'!'}}
        -replace_str[-1] "&amp;","&"
        -replace_str[-1] "&#233;","e"
        -replace[-1] {'~'},32
        -echo_stdout[] "  "@{-1,t}
      -endif -rm[-1]
    -endl -done
    -echo_stdout "\n*** End of list ***\n"
  -endif

  # All done, exiting.
  -rm -v + -e[] "> All done !\n"

# String sorting algorithm (quicksort).
_update_server_sort :
  mid={int(($1+$2)/2)}
  -if @{"-_max[] "@{$1,n},@{$mid,n}} -rv[$1,$mid] -endif
  -if @{"-_max[] "@{$mid,n},@{$2,n}} -rv[$2,$mid] -endif
  -if @{"-_max[] "@{$1,n},@{$mid,n}} -rv[$1,$mid] -endif
  -if {$2-$1>=3}
    pivot=@{$mid,n}
    i=$1 j=$2
    -do
      -if @{"-_max[] "$pivot,@{$i,n}} -do i={$i+1} -while @{"-_max[] "$pivot,@{$i,n}} -endif
      -if @{"-_max[] "@{$j,n},$pivot} -do j={$j-1} -while @{"-_max[] "@{$j,n},$pivot} -endif
      -if {$i<=$j} -rv[$i,$j] i={$i+1} j={$j-1} -endif
    -while {$i<=$j}
    -if {$1<$j} -_update_server_sort $1,$j -endif
    -if {$i<$2} -_update_server_sort $i,$2 -endif
  -endif

_update_server_move :
  -if {!narg($_nbm)} _nbm=0 -endif
  _to_move${_nbm}="$1" _move_to${_nbm}="$2" _nbm={$_nbm+1}

_update_server_upload : -skip "${2=$1}"
  GMIC_LOGIN=@{-gmic_ftp\ 0}
  GMIC_PASSWD=@{-gmic_ftp\ 1}
  -x "lftp ftp://"$GMIC_LOGIN":"$GMIC_PASSWD"@ftp.gmic.eu -e \"put -O /www/gmic/ \\\"$1\\\" -o \\\"$2\\\"; quit\" >/dev/null"

# Convert G'MIC tutorial from Garry Osgood's blog (http://www.particularart.com), into the G'MIC web look.
update_tutorial_html :
  -e[^-1] "Convert G\47MIC tutorial from Garry Osgood\47s blog (http://www.particularart.com), for the G\47MIC web page."
  -v - -rm -m "add_page : -__update_tutorial_html $""*"
  -use_vt100

  # Init list of pages to retrieve.
  # -add_page /,1700,index,_index
  # -add_page basics,4000

  # -add_page beginners-cookbook,1000
  # -add_page beginners-cookbook/cauldron,3500
  # -add_page beginners-cookbook/dyidiffusion,1000
  # -add_page beginners-cookbook/dyidiffusion/graduated-blurs,3800
  # -add_page beginners-cookbook/dyidiffusion/variations-on-a-theme,3800
  # -add_page beginners-cookbook/dyidiffusion/eigenvalues-and-eigenvectors,2300
  # -add_page beginners-cookbook/dyidiffusion/directional-blurring,3500
  # -add_page beginners-cookbook/dyidiffusion/tensors-for-the-tonsorially-challenged,8500
  # -add_page beginners-cookbook/dyidiffusion/eigen-thingys,4800
  # -add_page beginners-cookbook/dyidiffusion/fake-depth-of-field,7600
  # -add_page beginners-cookbook/fingerpainting,12000
  # -add_page beginners-cookbook/ramps,1200
  # -add_page beginners-cookbook/ramps/applying-a-curve,600
  # -add_page beginners-cookbook/ramps/blurring,600
  # -add_page beginners-cookbook/ramps/general-ramps,2500
  # -add_page beginners-cookbook/ramps/input-and-fill,1200
  # -add_page beginners-cookbook/ramps/one-dimensional-functions,800
  # -add_page beginners-cookbook/ramps/remapping-space,2200
  # -add_page beginners-cookbook/ramps/resizing,600
  # -add_page beginners-cookbook/ramps/warp,800
  # -add_page beginners-cookbook/road-systems,2500
  # -add_page beginners-cookbook/stained-glass,4000
  # -add_page beginners-cookbook/spectral-art,1500
  # -add_page beginners-cookbook/spectral-art/the-spatial-and-the-spectral,2000
  # -add_page beginners-cookbook/spectral-art/the-spectral-course,2000
  # -add_page beginners-cookbook/spectral-art/the-spectral-domain,2000
  # -add_page beginners-cookbook/spectral-art/the-complex-number-field,3300
  # -add_page beginners-cookbook/spectral-art/painting-with-waves-part-one,2200
  # -add_page beginners-cookbook/spectral-art/painting-with-waves-part-two,2200
  # -add_page beginners-cookbook/spectral-art/a-revised-map,1500
  # -add_page beginners-cookbook/spectral-art/intermezzo-spectral-editing,1500
  # -add_page beginners-cookbook/spectral-art/a-wave-painting-workflow,2000
  # -add_page beginners-cookbook/spectral-art/tiletex,5000
  # -add_page beginners-cookbook/spectral-art/coefficient-values,3000
  # -add_page beginners-cookbook/spectral-art/coefficient-values-part-two,4500
  # -add_page beginners-cookbook/spectral-art/coefficient-values-part-three,2500
  # -add_page beginners-cookbook/spectral-art/cheat-sheet,9000
  # -add_page beginners-cookbook/spectral-art/appendix,2500

  # -add_page command-decorations,3500
  # -add_page images,2000
  # -add_page images/conjuring-images,1000
  # -add_page images/images-as-datasets,3500
  # -add_page images/images-have-edges,1200
  # -add_page command-guide,5500

  # -add_page command-guide/color-manipulation/-compose_channels,1000,,,commands-colors-manipulation
  # -add_page command-guide/color-manipulation/-direction2rgb,1000,,,commands-colors-manipulation
  # -add_page command-guide/color-manipulation/-gradient2rgb,1000,,,commands-colors-manipulation
  # -add_page command-guide/color-manipulation/-mix_rgb,4000,,,commands-colors-manipulation
  # -add_page command-guide/color-manipulation/-select_color,3000,,,commands-colors-manipulation

  # -add_page command-guide/feature-extraction/-distance,9500,,,commands-features-extraction
  # -add_page command-guide/feature-extraction/-label,1300,,,commands-features-extraction

  # -add_page command-guide/filtering/-bandpass,5000,,,commands-filtering
  # -add_page command-guide/filtering/-blur,2000,,,commands-filtering
  # -add_page command-guide/filtering/-blur_angular,700,,,commands-filtering
  # -add_page command-guide/filtering/-blur_linear,700,,,commands-filtering
  # -add_page command-guide/filtering/-blur_radial,700,,,commands-filtering
  # -add_page command-guide/filtering/-blur_selective,3500,,,commands-filtering
  # -add_page command-guide/filtering/-blur_x,700,,,commands-filtering
  # -add_page command-guide/filtering/-blur_xy,700,,,commands-filtering
  # -add_page command-guide/filtering/-blur_xyz,700,,,commands-filtering
  # -add_page command-guide/filtering/-blur_y,700,,,commands-filtering
  # -add_page command-guide/filtering/-blur_z,2500,,,commands-filtering
  # -add_page command-guide/filtering/-convolve,3500,,,commands-filtering
  # -add_page command-guide/filtering/-deriche,1500,,,commands-filtering
  # -add_page command-guide/filtering/-diffusiontensors,7200,,,commands-filtering
  -add_page command-guide/filtering/-fft,6300,,,commands-filtering
  # -add_page command-guide/filtering/-gradient,3000,,,commands-filtering
  # -add_page command-guide/filtering/-gradient_norm,1300,,,commands-filtering
  # -add_page command-guide/filtering/-gradient_orientation,3300,,,commands-filtering
  # -add_page command-guide/filtering/-haar,2000,,,commands-filtering
  # -add_page command-guide/filtering/-smooth,4300,,,commands-filtering
  # -add_page command-guide/filtering/-structuretensors,3300,,,commands-filtering

  # -add_page command-guide/geometry-manipulation/-warp,5000,,,commands-geometry-manipulation

  # -add_page command-guide/image-drawing/-gaussian,2000,,,commands-image-drawing
  # -add_page command-guide/image-drawing/-plasma,4500,,,commands-image-drawing
  # -add_page command-guide/image-drawing/-turbulence,5500,,,commands-image-drawing

  # -add_page command-guide/inputs-outputs/-display,2000,,,commands-inputs-outputs
  # -add_page command-guide/inputs-outputs/-display_tensors,1500,,,commands-inputs-outputs
  # -add_page command-guide/inputs-outputs/-input,7500,,,commands-inputs-outputs
  # -add_page command-guide/inputs-outputs/-shared,2000,,,commands-inputs-outputs

  # -add_page command-guide/matrix-computation/-eigen,2000,,,commands-matrix-computation

  # -add_page command-guide/program-control/-local,3500,,,commands-program-control
  # -add_page command-guide/program-control/-do,6500,,,commands-program-control
  # -add_page command-guide/program-control/-if,3500,,,commands-program-control
  # -add_page command-guide/program-control/-repeat,2000,,,commands-program-control

  # -add_page command-guide/values-manipulation/-eigen2tensor,5500,,,commands-values-manipulation
  # -add_page command-guide/values-manipulation/-norm,700,,,commands-values-manipulation
  # -add_page command-guide/values-manipulation/-normalize,1700,,,commands-values-manipulation
  # -add_page command-guide/values-manipulation/-orientation,5000,,,commands-values-manipulation
  # -add_page command-guide/values-manipulation/-threshold,1500,,,commands-values-manipulation

  # -add_page technical-notes/trigometric-and-inverse-trigometric-commands,2500
  # -add_page technical-notes/wavelet-analysis-and-synthesis-in-gmic,5000
  # -add_page gimp-filters,1500
  # -add_page gimp-filters/blur-by-color-filter,22500
  # -add_page gimp-filters/the-fingerpainting-filter,2200
  # -add_page gimp-filters/the-hairlock-filter,8500

  # Prepare folder structure.
  -v + -e[] "\n  * Prepare folder structure." -v -
  -x "ln -fs ../tutorial.css ."
  -x "ln -fs ../copyright.html ."
  -x "ln -fs ../favicon.ico ."
  -x "ln -fs ../favicon.png ."
  -x "ln -fs ../footer.html ."
  -x "ln -fs ../header.html ."
  -x "ln -fs ../header.css ."
  -x "ln -fs ../jquery-1.11.0.min.js ."
  -x "ln -fs ../images ."
  -x "mkdir -p img"
  -x "cd img && ln -fs ../../img/logo4.jpg ."
  -x "cd img && ln -fs ../../img/logos.jpg ."
  -x "cd img && ln -fs ../../img/rss.png ."
  -x "cd img && ln -fs ../../convert_raw_img/* ."
  -x "ln -fs ../convert_raw.html ../convert_raw.shtml ."
  -x "ln -fs ../tutorial_toc.html ."
  -x "ln -fs ../highslide ."

  # Create images for toc tree.
  11,11,1,3,255 -frame 1,1,0 -line 3,50%,{w-4},50%,1,0 --line 50%,3,50%,{h-4},1,0
  -a x -o img/toc_buttons.png
  100%,100%,1,4 -fc[-1] 245,245,245,0 -o[-1] img/toc_void.png
  -rm

  # Start page conversion.
  -if {!narg($_N)} _N=0 -endif
  0 -repeat $_N
    -o[-1] ${_output_html$>} -o[-1] ${_output_shtml$>}
  -done -rm[-1]
  -repeat $_N
    -v + -_update_tutorial_html[] ${_input$>},${_height$>},${_output_shtml$>},${_output_html$>},${_img_prefix$>},${_tocid$>} -v -
  -done

  # Clean temp files.
  -x "rm -f __tmp.html"
  -v + -e[] "\n  * All done !.\n\n"

# Add page to the list of pages to explore.
__update_tutorial_html : -skip ${3=""},${4=""},${5=""}
  -if {!narg($_N)} _N=0 -endif
  _input$_N=$1 _height$_N=$2

  # Determine parent id for toc.
  -if {narg("$5")} _tocid$_N="$5"
  -else
    ({'"$1"'}) -s -,{'/'} -if @# _tocid$_N=@{0,t} -rm -else _tocid$_N=index -endif
  -endif

  # Determine output filenames.
  ({'"$1"'}) -s -,{'/'}
  output_base=""
  -if @# output_base=@{-1,t} -endif
  -if {@#>2" && "i[0]!={'-'}} output_base=@{-2,t}_@{-1,t} -endif
  -rm
  -if {narg($output_base)}
    ({'$output_base'}) -if {i=={'-'}} -=[-1] {'_'} output_base=@{-1,t} -endif -rm[-1] # Replace first '-' by underscore if necessary.
  -endif
  -if {narg("$3")} _output_shtml$_N="$3".shtml _output_html$_N="$3".html _img_prefix$_N="$3"
  -else _output_shtml$_N=$output_base.shtml _output_html$_N=$output_base.html _img_prefix$_N=$output_base
  -endif
  -if {narg("$4")} _output_html$_N="$4".html -endif
  _N={$_N+1}

# Retrieve one html page and convert it.
_update_tutorial_html :
  -v -
  url="http://particularart.com/tools-and-toys/gmic/$1"
  -v + -e[] "\n  * Convert tutorial page '"$url"'." -v -

  # Get web page.
  -v + -e[] "    > Retrieve page '"$url"'." -v -
  -x "wget -q "$url" -O __tmp.html"
  -i raw:__tmp.html,char

  # Discard or replace undesired text.
  -discard 13
  -replace_str "class=\"internal\" "
  -replace_str "class=\"external\" "
  -replace_str "dir=\"ltr\" "
  -replace_str "border: 1px","border: 0px"
  -replace_str "G\140MIC","G\47MIC"
  -replace_str "CNTL","CTRL"
  -replace_str "Rashid","Rachid"
  -replace_str "http://gmic.sourceforge.net","http://gmic.eu"

  # Discard original header.
  -s -,{'"<!-- GIMMICKRY! -->"'} -k[1]
  -s -,{'"<!-- GIMMICKRY! End -->"'} -k[0]

  # Discard original footer.
  -s +,{'"   </div>\n</div>\n<footer>"'} -k[0]

  # Add header and footer.
  -i[0] ({'"<!DOCTYPE html>"\n\
          "<html lang=\"en-us\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">"\n\
          "<link rel=\"stylesheet\" href=\"tutorial.css\">"\n\
          "<script type=\"text/javascript\" src=\"highslide/highslide.js\"></script>"\n\
          "<link rel=\"stylesheet\" type=\"text/css\" href=\"highslide/highslide.css\" />"\n\
          "<script type=\"text/javascript\">"\n\
          "hs.graphicsDir = 'highslide/graphics/';"\n\
          "hs.wrapperClassName = 'wide-border';"\n\
          "</script>"\n\
          "<script type=\"text/javascript\" src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>"\n\
          "<body>"\n\n'})
  ({'\n</body></html>'})
  -y -a y

  # Replace image links.
  -replace_str "\"/static/media/uploads/","\"http://particularart.com/static/media/uploads/"
  -replace_str "\"/tools-and-toys/gmic/","\"http://particularart.com/tools-and-toys/gmic/"
  -replace_str "\"http://particularart.com/","\"http://www.particularart.com/"

  # Search and replace links to 'internal' pages.
  -s +,{'"<a "'}
  -repeat @# -if {$>>0" && "{@{{$>-1},t}'=='"<a "}} -l[$>] -s +,{'href=\"'} -l[-1]
    -s +,{'\"'}
    -if {@#>0}
      link=@{0,t}
      ({'$link'}) -z[-1] 0,48 baselink=@{-1,t} -rm[-1]

      -if {$baselink'=='"http://www.particularart.com/tools-and-toys/gmic/"}  # Check for a 'local' link.

        # Retrieve anchor if any.
        -l[] anchor="" ({'$link'}) -s +,{"'\#'"} -if {@#>1} anchor=#@{-1,t} link=@{0,t} -endif -rm -endl
        ({'$link'}) -autocrop[-1] {'/'}
        -l[-1] -s -,{'/'} -if {@#>6" && "{@{-2,t}'!='command-guide}" && "{@{-3,t}'!='command-guide}} relink=@{-2,t}_@{-1,t}.shtml -else relink=@{-1,t}.shtml -endif -rm -endl
        ({'$relink'}) -if {i=={'-'}} -=[-1] {'_'} relink=@{-1,t} -endif -rm[-1] # Replace first '-' by underscore if necessary.

        -if $relink # If the relinked page exists.
          relink=$relink$anchor
          -v + -e[] "    > Local link '"$link$anchor"' relinked to '"$relink"'." -v -
          -rm[0] -i[0] ({'$relink'}) -y[0]
        -else # Else try to relink to reference page if link to a command.
          ({'$relink'}) -if {i=={'_'}}
            -l[-1] -z 1,100% -s -,{'.'} command=@{-basename\ @{0,t}} -k[0] -endl
            relink="http://gmic.eu/reference.shtml#"$command
            -v + -e[] "    > Local link '"$link$anchor"' relinked to '"$relink"' "${_gmic_g}"(reference command)."${_gmic_n} -v -
            -rm[0] -i[0] ({'$relink'}) -y[0]
          -else # If fail, link to original page with a hard link.
            relink=$link$anchor
            -v + -e[] "    > Local link '"$link$anchor"' relinked to '"$relink"' "${_gmic_r}"(no corresponding local page)."${_gmic_n} -v -
            -rm[0] -i[0] ({'$relink'}) -y[0]
          -endif
          -rm[-1]
        -endif
#      -elif {$baselink'=='"http://www.particularart.com/static/media/uploads"}
#         relink=$link
#         -v + -e[] "    > Local (media) link '"$link"' found." -v -
       -else -l # External link.
         0 -nm[-1] $link ext=@{-1,x} -rm[-1]
         -if {narg($ext)} ext=@{-struncase\ $ext} -endif
         -if {{$ext'=='png}||{$ext'=='jpg}||{$ext'=='jpeg}}  # Check for an image link.
           relink=img/$5_@{-basename\ $link} 0 -nm[-1] $relink relink=@{-1,f}@{-1,b}.jpg -rm[-1]
           -if $relink -v + -e[] "    > External image link '"$link"' relinked to '"$relink"'." -v -
           -else
             -l[] -i $link -k[0] is_opaque=0
             -split_opacity -if {@#==1" || "ia>250} is_opaque=1 -endif -a c
             -if {$is_opaque} -to_rgb -else -to_rgba -i[0] 100%,100%,1,3 -fc[0] 245,245,245 -blend alpha -endif
             -o $relink,60 -rm
             # -x "git add "$relink
             -v + -e[] "    > Image link '"$link"' converted and relinked to '"$relink"'." -v -
             -onfail relink=$link -v + -e[] "    > Failed to retrieve image link '"$link"'." -v - -rm
             -endl
           -endif
           -rm[0] -i[0] ({'$relink'})
           -i[2] ({'" class=\"highslide\" onclick=\"return hs.expand(this)\""'})
           -y[0,2]
         -else
           -v + -e[] "    > External link '"$link"' found." -v -
         -endif
       -onfail -endl -endif
       -a y
    -endif
  -endl -a y -endl -endif -done
  -a y

  # Manage embedded images.
  -s +,{'"<img"'}
  -repeat @# -if {$>>0" && "{@{{$>-1},t}'=='"<img"}}
    -l[$>]
      -s +,{'"src=\""'}
      -l[2]
        -s +,{'\"'} link=@{0,t}
        relink=img/$5_@{-basename\ $link} 0 -nm[-1] $relink relink=@{-1,f}@{-1,b}.jpg -rm[-1]
        -if $relink -v + -e[] "    > Image '"$link"' relinked to '"$relink"'." -v -
        -else
          -l[] -i $link -k[0] is_opaque=0
          -split_opacity -if {@#==1" || "ia>250} is_opaque=1 -endif -a c
          -if $is_opaque -to_rgb -frame 1,1,0 -frame 10,10,245
          -else -to_rgba -i[0] 100%,100%,1,3 -fc[0] 245,245,245 -blend alpha
          -endif
          -o $relink,60 -rm
          # -x "git add "$relink
          -v + -e[] "    > Image '"$link"' converted and relinked to '"$relink"'." -v -
          -onfail relink=$link -v + -e[] "      > Failed to retrieve image '"$link"'." -v - -rm
          -endl
        -endif
        -rm[0] -i[0] ({'$relink'}) -y[0]
      -endl
      -a y
    -endl
  -endif -done
  -a y

  # Force images in tables to have a minimal width (fix for Chrome).
  -replace_str "<td><img","<td width=\"256\"><img"
  -replace_str "<td>\n<p><img","<td width=\"256\"><p><img"
  -replace_str "<td>&nbsp;<img","<td width=\"256\"><img"

  # Set all links targets to "_parent"
  -replace_str "<a ","<a target=\"_parent\" "

  # Save .html page.
  -o raw:$4,char
  # -x "git add $4"
  -rm

  # Generate parent .shtml page.
  ({'"<!DOCTYPE html>"\n\
     "<html lang=\"en-us\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">"\n\
     "<!--#include file=\"header.html\" -->"\n\
     "<link href=\"../style.css\" rel=\"stylesheet\" type=\"text/css\">"\n\
     "<div id=\"bloc_option\"><div id=\"top_vert\"><div id=\"text_top\">Tutorial</div></div>"\n\
     "<div id=\"center\"><div id=\"text_centre_intro\">"\n\
     "<script language=\"javascript\">var gFilename = '$6';</script>"\n\
     "<!--#include file=\"tutorial_toc.html\" -->"\n\
     "<iframe width=\"100%\" height=\"$2\" frameborder=\"0\" src=\""$4"\" seamless></iframe>"\n\
     "</div></div><div id=\"footer\"><img src=\"images/footer.jpg\" /></div></div>"\n\
     "<!--#include file=\"copyright.html\" -->"\n\
     "<!--#include file=\"footer.html\" -->"\n'})
  -o raw:$3,char
  # -x "git add $3"
  -rm
  -wait {5000+?(2000)}
  -v +

#@gmic v : eq. to '-verbose'. : (+)

#@gmic verbose : level : { + | - } : (+)
#@gmic : Set or increment/decrement the verbosity level. Default level is 0.
#@gmic : (eq. to '-v').
#@gmic : When 'level'>=0, G'MIC log messages are displayed on the standard error (stderr).
#@gmic : Default value: 'level=0'.

#@gmic wait : delay : (no arg) : (+)
#@gmic : Wait for a given delay (in ms) since last call, or sleep during a specified delay,
#@gmic : or wait for a user event occuring on the selected instant window.
#@gmic : 'delay' can be { <0=delay+flush | 0=event | >0=delay }.
#@gmic : Command selection (if any) stands for instant window indices instead of image indices.
#@gmic : If no window indices are specified and if 'delay' is negative, the command results
#@gmic : in a hard sleep during specified delay.
#@gmic : Default value: 'delay=0'.

#@gmic warn : message : (+)
#@gmic : Print specified warning message, on the standard error (stderr).
#@gmic : Command selection (if any) stands for displayed scope indices instead of image indices.

#@gmic w : eq. to '-window'. : (+)

#@gmic window : _width[%]>=-1,_height[%]>=-1,_normalization,_fullscreen,_pos_x[%],_pos_y[%],_title : (+)
#@gmic : Display selected images into an instant window with specified size, normalization type,
#@gmic : fullscreen mode and title.
#@gmic : (eq. to '-w').
#@gmic : If 'width' or 'height' is set to -1, the corresponding dimension is adjusted to the window
#@gmic : or image size.
#@gmic : When arguments 'pos_x' and 'pos_y' are both different than -1, the window is moved to
#@gmic : the specified coordinates.
#@gmic : 'width'=0 or 'height'=0 closes the instant window.
#@gmic : 'normalization' can be { -1=keep same | 0=none | 1=always | 2=1st-time | 3=auto }.
#@gmic : 'fullscreen' can be { -1=keep same | 0=no | 1=yes }.
#@gmic : You can manage up to 10 different instant windows by using the numbered variants
#@gmic : '-w0' (default, eq. to '-w'),'-w1',..,'-w9' of the command '-w'.
#@gmic : Default values: 'width=height=normalization=fullscreen=-1' and 'title=(undefined)'.

#---------------------------------
#
#@gmic :: List manipulation
#
#---------------------------------

#@gmic k : eq. to '-keep'. : (+)

#@gmic keep : (+)
#@gmic : Keep only selected images.
#@gmic : (eq. to '-k').
#@gmic : $ image.jpg -split x -keep[0-50%:2] -append x
#@gmic : $ image.jpg -split x -keep[^30%-70%] -append x

#@gmic mv : eq. to '-move'. : (+)

#@gmic move : position[%] : (+)
#@gmic : Move selected images at specified position.
#@gmic : (eq. to '-mv').
#@gmic : $ image.jpg -split x,3 -move[1] 0
#@gmic : $ image.jpg -split x -move[50%--1:2] 0 -append x

#@gmic nm : eq. to '-name'. : (+)

#@gmic name : name,_is_modified={ 0 | 1 } : (+)
#@gmic : Set name of selected images.
#@gmic : (eq. to '-nm').
#@gmic : Argument 'is_modified' tells about the modified state of selected images.
#@gmic : Default value: 'is_modified=0'.
#@gmic : $ image.jpg -name image -blur[image] 2

#@gmic nms : eq. to '-names'.
nms :
  -v - _gmic_s="$?" -v +
  -_names $*

#@gmic names : name1,name2,...,nameN
#@gmic : Set each name of (multiple) selected images from the sequence of the provided arguments.
#@gmic : (eq. to '-nms').
names :
  -v - _gmic_s="$?" -v +
  -_$0 $*

_names :
  -e[0--3] "Set names of image$? to '$*'."
  -if {$#!=@#} -warn[0--3] "Number of selected images ("@#") is different than number of provided arguments ($#)." -endif
  -v - $=arg -repeat {min(@#,$#)} -nm[$>] ${arg{1+$>}} -done -v +

#@gmic rm : eq. to '-remove'. : (+)

#@gmic remove : (+)
#@gmic : Remove selected images.
#@gmic : (eq. to '-rm').
#@gmic : $ image.jpg -split x -remove[30%-70%] -append x
#@gmic : $ image.jpg -split x -remove[0-50%:2] -append x

#@gmic remove_duplicates
#@gmic : Remove duplicates images in the selected images list.
#@gmic : $ (1,2,3,4,2,4,3,1,3,4,2,1) -split x -remove_duplicates -append x
remove_duplicates :
  -e[^-1] "Remove duplicates images in selected list of image$?."
  -v - -repeat @#
    base=$> off=0
    -repeat {@#-$>-1}
      comp={$base+1+$>-$off}
      -if {$comp>=@#} -break -endif
      ---[$base,$comp] -abs[-1] is_duplicate={!@{-1,+}} -rm[-1]
      -if $is_duplicate -rm[$comp] off={$off+1} -endif
    -done
  -done -v +

#@gmic remove_empty
#@gmic : Remove empty images in the selected image list.
remove_empty :
  -e[^-1] "Remove empty images in selected list of image$?."
  -v - -repeat @# -if {!@{$<,whds}} -rm[$<] -endif -done -v +

#@gmic rv : eq. to '-reverse'. : (+)

#@gmic reverse : (+)
#@gmic : Reverse positions of selected images.
#@gmic : (eq. to '-rv').
#@gmic : $ image.jpg -split x,3 -reverse[-2,-1]
#@gmic : $ image.jpg -split x,-16 -reverse[50%-100%] -append x

#@gmic sort_list : _ordering={ + | - },_criterion
#@gmic : Sort list of selected images according to the specified image criterion.
#@gmic : Default values: 'ordering=+', 'criterion=i'.
#@gmic : $ (1;4;7;3;9;2;4;7;6;3;9;1;0;3;3;2) -split y -sort_list + -append y
sort_list : -skip ${1=+},${2=i}
  -e[^-1] "Sort list of image$? in "@{-arg\ 1+{$1'=='+},descending,ascending}" order, "\
          "according to the image criterion '$2'."
  -v - -if @#
    i=@# -repeat @# (@{$>,$2}) -done -a[$i--1] y --f[-1] 'y' -a[-2,-1] x -sort[-1] $1,y -z[-1] 1,1
    -repeat {h} nm$>=@{$>,n} -nm[$>] sortlist$> -done
    -repeat {h} -mv[sortlist{i(0,$>)}] -1 -done
    -repeat {h} -nm[$>] ${nm{i(0,$>)}} -done
  -rm[-1] -endif -v +

#@gmic sort_str
#@gmic : Sort selected images (viewed as a list of strings) in lexicographic order.
sort_str :
  -e[^-1] "Sort image$? in lexicographic order."
  -v - -y -a x
  -repeat {round(h/4,1,1)} y={4*$>}
    -repeat @# -l[$<]
      --rows $y,{$y+3} -f[1] 'if(i>=97&&i<=122,i-32,i)' --[-1] 32 -c[-1] 0,63 -s[-1] y -*[-2] 64 -*[-3] 4096 -*[-4] 262144 -+[-4--1]
      -rv -a y -sort +,x --rows 0 -rows[0] 1,100% -label[1] -%[1] 2
      -s[1] +,0 N={@#-1}
      x0=0 -repeat {@#-1} x1={$x0+@{{1+$>},h}} --z[0] $x0,{$x1-1} x0=$x1 -done
      -rm[0-$N]
    -endl -done
  -done -s x -v +

#---------------------------------
#
#@gmic :: Mathematical operators
#
#---------------------------------

#@gmic abs : (+)
#@gmic : Compute the pointwise absolute values of selected images.
#@gmic : $ image.jpg --sub {ia} -abs[-1]
#@gmic : $ 300,1,1,1,'cos(20*x/w)' --abs -display_graph 400,300

#@gmic acos : (+)
#@gmic : Compute the pointwise arc-cosine of selected images.
#@gmic : $ image.jpg --normalize -1,1 -acos[-1]
#@gmic : $ 300,1,1,1,'x/w+0.1*u' --acos -display_graph 400,300
#@gmic : $$ trigometric-and-inverse-trigometric-commands

#@gmic + : eq. to '-add'. : (+)

#@gmic add : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Add specified value, image or mathematical expression to selected images,
#@gmic : or compute the pointwise sum of selected images.
#@gmic : (eq. to '-+').
#@gmic : $ image.jpg --add 30% -cut 0,255
#@gmic : $ image.jpg --blur 5 -normalize 0,255 -add[1] [0]
#@gmic : $ image.jpg -add '80*cos(80*(x/w-0.5)*(y/w-0.5)+c)' -cut 0,255
#@gmic : $ image.jpg -repeat 9 --rotate[0] {$>*36},1,0,50%,50% -done -add -div 10

#@gmic & : eq. to '-and'. : (+)

#@gmic and : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the bitwise AND of selected images with specified value, image or mathematical
#@gmic : expression, or compute the pointwise sequential bitwise AND of selected images.
#@gmic : (eq. to '-&').
#@gmic : $ image.jpg -and {128+64}
#@gmic : $ image.jpg --mirror x -and

#@gmic asin : (+)
#@gmic : Compute the pointwise arc-sine of selected images.
#@gmic : $ image.jpg --normalize -1,1 -asin[-1]
#@gmic : $ 300,1,1,1,'x/w+0.1*u' --asin -display_graph 400,300
#@gmic : $$ trigometric-and-inverse-trigometric-commands

#@gmic atan : (+)
#@gmic : Compute the pointwise arc-tangent of selected images.
#@gmic : $ image.jpg --normalize 0,8 -atan[-1]
#@gmic : $ 300,1,1,1,'4*x/w+u' --atan -display_graph 400,300
#@gmic : $$ trigometric-and-inverse-trigometric-commands

#@gmic atan2 : [x_argument] : (+)
#@gmic : Compute the pointwise oriented arc-tangent of selected images.
#@gmic : Each selected image is regarded as the y-argument of the arc-tangent function, while the
#@gmic : specified image gives the corresponding x-argument.
#@gmic : $ (-1,1) (-1;1) -resize 400,400,1,1,3 -atan2[1] [0] -keep[1] -mod {pi/8}
#@gmic : $$ trigometric-and-inverse-trigometric-commands

#@gmic << : eq. to '-bsl'. : (+)

#@gmic bsl : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the bitwise left shift of selected images with specified value, image or
#@gmic : mathematical expression, or compute the pointwise sequential bitwise left shift of
#@gmic : selected images.
#@gmic : (eq. to '-<<').
#@gmic : $ image.jpg -bsl 'round(3*x/w,0)' -cut 0,255

#@gmic >> : eq. to '-bsr'. : (+)

#@gmic bsr : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the bitwise right shift of selected images with specified value, image or"
#@gmic : mathematical expression, or compute the pointwise sequential bitwise right shift of
#@gmic : selected images.
#@gmic : (eq. to '->>').
#@gmic : $ image.jpg -bsr 'round(3*x/w,0)' -cut 0,255

#@gmic cos : (+)
#@gmic : Compute the pointwise cosine of selected images.
#@gmic : $ image.jpg --normalize 0,{2*pi} -cos[-1]
#@gmic : $ 300,1,1,1,'20*x/w+u' --cos -display_graph 400,300
#@gmic : $$ trigometric-and-inverse-trigometric-commands

#@gmic cosh : (+)
#@gmic : Compute the pointwise hyperbolic cosine of selected images.
#@gmic : $ image.jpg --normalize -3,3 -cosh[-1]
#@gmic : $ 300,1,1,1,'4*x/w+u' --cosh -display_graph 400,300

#@gmic / : eq. to '-div'. : (+)

#@gmic div : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Divide selected image by specified value, image or mathematical expression,
#@gmic : or compute the pointwise quotient of selected images.
#@gmic : (eq. to '-/').
#@gmic : $ image.jpg -div '1+abs(cos(x/10)*sin(y/10))'
#@gmic : $ image.jpg --norm -add[-1] 1 --div

#@gmic == : eq. to '-eq'. : (+)

#@gmic eq : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the boolean equality of selected images with specified value, image or
#@gmic : mathematical expression, or compute the boolean equality of selected images.
#@gmic : (eq. to '-==').
#@gmic : $ image.jpg -round 40 -eq {round(ia,40)}
#@gmic : $ image.jpg --mirror x -eq

#@gmic exp : (+)
#@gmic : Compute the pointwise exponential of selected images.
#@gmic : $ image.jpg --normalize 0,2 -exp[-1]
#@gmic : $ 300,1,1,1,'7*x/w+u' --exp -display_graph 400,300

#@gmic >= : eq. to '-ge'. : (+)

#@gmic ge : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the boolean 'greater or equal than' of selected images with specified value, image
#@gmic : or mathematical expression, or compute the boolean 'greater or equal than' of selected images.
#@gmic : (eq. to '->=').
#@gmic : $ image.jpg -ge {ia}
#@gmic : $ image.jpg --mirror x -ge

#@gmic > : eq. to '-gt'. : (+)

#@gmic gt : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the boolean 'greater than' of selected images with specified value, image or
#@gmic : mathematical expression, or compute the boolean 'greater than' of selected images.
#@gmic : (eq. to '->').
#@gmic : $ image.jpg -gt {ia}
#@gmic : $ image.jpg --mirror x -gt

#@gmic <= : eq. to '-le'. : (+)

#@gmic le : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the boolean 'less or equal than' of selected images with specified value, image or
#@gmic : mathematical expression, or compute the boolean 'less or equal than' of selected images.
#@gmic : (eq. to '-<=').
#@gmic : $ image.jpg -le {ia}
#@gmic : $ image.jpg --mirror x -le

#@gmic < : eq. to '-lt'. : (+)

#@gmic lt : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the boolean 'less than' of selected images with specified value, image or
#@gmic : mathematical expression, or compute the boolean 'less than' of selected images.
#@gmic : (eq. to '-<').
#@gmic : $ image.jpg -lt {ia}
#@gmic : $ image.jpg --mirror x -lt

#@gmic log : (+)
#@gmic : Compute the pointwise base-e logarithm of selected images.
#@gmic : $ image.jpg --add 1 -log[-1]
#@gmic : $ 300,1,1,1,'7*x/w+u' --log -display_graph 400,300

#@gmic log10 : (+)
#@gmic : Compute the pointwise base-10 logarithm of selected images.
#@gmic : $ image.jpg --add 1 -log10[-1]
#@gmic : $ 300,1,1,1,'7*x/w+u' --log10 -display_graph 400,300

#@gmic log2 : (+)
#@gmic : Compute the pointwise base-2 logarithm of selected images
#@gmic : $ image.jpg --add 1 -log2[-1]
#@gmic : $ 300,1,1,1,'7*x/w+u' --log2 -display_graph 400,300

#@gmic max : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the maximum between selected images and specified value, image or
#@gmic : mathematical expression, or compute the pointwise maxima between selected images.
#@gmic : $ image.jpg --mirror x -max
#@gmic : $ image.jpg -max 'R=((x/w-0.5)^2+(y/h-0.5)^2)^0.5;255*R'

#@gmic // : eq. to '-mdiv'. : (+)

#@gmic mdiv : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the matrix division of selected matrices/vectors by specified value, image or
#@gmic : mathematical expression, or compute the matrix division of selected images.
#@gmic : (eq. to '-//').

#@gmic min : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the minimum between selected images and specified value, image or
#@gmic : mathematical expression, or compute the pointwise minima between selected images.
#@gmic : $ image.jpg --mirror x -min
#@gmic : $ image.jpg -min 'R=((x/w-0.5)^2+(y/h-0.5)^2)^0.5;255*R'

#@gmic % : eq. to '-mod'. : (+)

#@gmic mod : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the modulo of selected images with specified value, image or mathematical
#@gmic : expression, or compute the pointwise sequential modulo of selected images.
#@gmic : (eq. to '-%').
#@gmic : $ image.jpg --mirror x -mod
#@gmic : $ image.jpg -mod 'R=((x/w-0.5)^2+(y/h-0.5)^2)^0.5;255*R'

#@gmic ** : eq. to '-mmul'. : (+)

#@gmic mmul : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the matrix right multiplication of selected matrices/vectors by specified value, image or
#@gmic : mathematical expression, or compute the matrix right multiplication of selected images.
#@gmic : (eq. to '-**').
#@gmic : $ (0,1,0;0,0,1;1,0,0) (1;2;3) --mmul

#@gmic * : eq. to '-mul'. : (+)

#@gmic mul : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Multiply selected images by specified value, image or mathematical expression,
#@gmic : or compute the pointwise product of selected images.
#@gmic : (eq. to '-*').
#@gmic : $ image.jpg --mul 2 -cut 0,255
#@gmic : $ image.jpg (1,2,3,4,5,6,7,8) -resize[-1] [0] -mul[0] [-1]
#@gmic : $ image.jpg -mul '1-3*abs(x/w-0.5)' -cut 0,255
#@gmic : $ image.jpg --luminance -negative[-1] --mul

#@gmic mul_channels : value1,_value2,...,_valueN
#@gmic : Multiply channels of selected images by specified sequence of values.
#@gmic : $ image.jpg --mul_channels 1,0.5,0.8
mul_channels :
  -e[^-1] "Multiply channels of image$? by value sequence ($*)."
  -v - $=arg -repeat $#
    i=$> fact=${arg{1+($>%$#)}}
    -repeat @# -if @{$>,$i<s} -sh[$>] $i,$i -*[-1] $fact -rm[-1] -endif -done
  -done -v +

#@gmic != : eq. to '-neq'. : (+)

#@gmic neq : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the boolean inequality of selected images with specified value, image or
#@gmic : mathematical expression, or compute the boolean inequality of selected images.
#@gmic : (eq. to '-!=').
#@gmic : $ image.jpg -round 40 -neq {round(ia,40)}

#@gmic | : eq. to '-or'. : (+)

#@gmic or : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the bitwise OR of selected images with specified value, image or mathematical
#@gmic : expression, or compute the pointwise sequential bitwise OR of selected images.
#@gmic : (eq. to '-|').
#@gmic : $ image.jpg -or 128
#@gmic : $ image.jpg --mirror x -or

#@gmic ^ : eq. to '-pow'. : (+)

#@gmic pow : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Raise selected image to the power of specified value, image or mathematical
#@gmic : expression, or compute the pointwise sequential powers of selected images.
#@gmic : (eq. to '-^').
#@gmic : $ image.jpg -div 255 --pow 0.5 -mul 255
#@gmic : $ image.jpg -gradient -pow 2 -add -pow 0.2

#@gmic rol : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the bitwise left rotation of selected images with specified value, image or
#@gmic : mathematical expression, or compute the pointwise sequential bitwise left rotation of
#@gmic : selected images.
#@gmic : $ image.jpg -rol 'round(3*x/w,0)' -cut 0,255

#@gmic ror : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the bitwise right rotation of selected images with specified value, image or
#@gmic : mathematical expression, or compute the pointwise sequential bitwise right rotation of
#@gmic : selected images.
#@gmic : $ image.jpg -ror 'round(3*x/w,0)' -cut 0,255

#@gmic sign : (+)
#@gmic : Compute the pointwise sign of selected images.
#@gmic : $ image.jpg --sub {ia} -sign[-1]
#@gmic : $ 300,1,1,1,'cos(20*x/w+u)' --sign -display_graph 400,300

#@gmic sin : (+)
#@gmic : Compute the pointwise sine of selected images.
#@gmic : $ image.jpg --normalize 0,{2*pi} -sin[-1]
#@gmic : $ 300,1,1,1,'20*x/w+u' --sin -display_graph 400,300
#@gmic : $$ trigometric-and-inverse-trigometric-commands

#@gmic sinc : (+)
#@gmic : Compute the pointwise sinc function of selected images.
#@gmic : $ image.jpg --normalize {-2*pi},{2*pi} -sinc[-1]
#@gmic : $ 300,1,1,1,'20*x/w+u' --sinc -display_graph 400,300

#@gmic sinh : (+)
#@gmic : Compute the pointwise hyperbolic sine of selected images.
#@gmic : $ image.jpg --normalize -3,3 -sinh[-1]
#@gmic : $ 300,1,1,1,'4*x/w+u' --sinh -display_graph 400,300

#@gmic sqr : (+)
#@gmic : Compute the pointwise square function of selected images.
#@gmic : $ image.jpg --sqr
#@gmic : $ 300,1,1,1,'40*x/w+u' --sqr -display_graph 400,300

#@gmic sqrt : (+)
#@gmic : Compute the pointwise square root of selected images.
#@gmic : $ image.jpg --sqrt
#@gmic : $ 300,1,1,1,'40*x/w+u' --sqrt -display_graph 400,300

#@gmic - : eq. to '-sub'. : (+)

#@gmic sub : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Subtract specified value, image or mathematical expression to selected images,
#@gmic : or compute the pointwise difference of selected images.
#@gmic : (eq. to '--').
#@gmic : $ image.jpg --sub 30% -cut 0,255
#@gmic : $ image.jpg --mirror x -sub[-1] [0]
#@gmic : $ image.jpg -sub 'i(w/2+0.9*(x-w/2),y)'
#@gmic : $ image.jpg --mirror x -sub

#@gmic tan : (+)
#@gmic : Compute the pointwise tangent of selected images.
#@gmic : $ image.jpg --normalize {-0.47*pi},{0.47*pi} -tan[-1]
#@gmic : $ 300,1,1,1,'20*x/w+u' --tan -display_graph 400,300
#@gmic : $$ trigometric-and-inverse-trigometric-commands

#@gmic tanh : (+)
#@gmic : Compute the pointwise hyperbolic tangent of selected images.
#@gmic : $ image.jpg --normalize -3,3 -tanh[-1]
#@gmic : $ 300,1,1,1,'4*x/w+u' --tanh -display_graph 400,300

#@gmic xor : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the bitwise XOR of selected images with specified value, image or mathematical
#@gmic : expression, or compute the pointwise sequential bitwise XOR of selected images.
#@gmic : $ image.jpg -xor 128
#@gmic : $ image.jpg --mirror x -xor

#---------------------------------
#
#@gmic :: Values manipulation
#
#---------------------------------

#@gmic apply_curve : 0<=smoothness<=1,x0,y0,x1,y1,x2,y2,...,xN,yN
#@gmic : Apply curve transformation to image values.
#@gmic : Default values: 'smoothness=1', 'x0=0', 'y0=100'.
#@gmic : $ image.jpg --apply_curve 1,0,0,128,255,255,0
apply_curve : -check "${1=1}>=0 && $1<=1" -skip ${2=0},${3=100}
  -e[^-1] "Apply intensity curve with smoothness $1 and keypoints (${2--1}) on image$?."
  -v - -function1d ${^0} -map[^-1] [-1],1 -rm[-1]
  -v +

#@gmic apply_gamma : gamma>=0
#@gmic : Apply gamma correction to selected images.
#@gmic : $ image.jpg --apply_gamma 2
apply_gamma : -check $1>=0
  -e[^-1] "Apply Gamma-correction to image$?, with gamma $1."
  -if {$1==1} -return -endif
  -v - -repeat @# -l[$>] mM={im},{iM} -n 0,1 -^ {1/$1} -n $mM -endl -done -v +

#@gmic balance_gamma : _ref_color1,...
#@gmic : Apply color balance transformation on selected image, with respect to specified reference color.
#@gmic : Default value: 'ref_color1=128'.
#@gmic : $ image.jpg --balance_gamma 128,64,64
balance_gamma : -skip ${1=128}
  -e[^-1] "Apply color balance transformation on image$?, with gamma curve and reference color ("${^0}")."
  -v - -repeat @# -l[$>]
    (${^0}) -r[-1] @{-2,s},1,1,1,0,1 -s[-2] c -/[-1] 255
    -repeat {@#-1} -/[$>] 255 -^[$>] {log(@{-1,$>})/log(@{$>,a})} -*[$>] 255 -done
    -rm[-1] -a c -c 0,255
  -endl -done -v +

#@gmic complex2polar
#@gmic : Compute complex to polar transforms of selected images.
#@gmic : $ image.jpg --fft -complex2polar[-2,-1] -log[-2] -shift[-2] 50%,50%,0,0,2 -remove[-1]
complex2polar :
  -e[^-1] "Compute complex to polar transforms of image$?."
  -v - -repeat {int(@#/2)} -l[{2*$>},{2*$>+1}]
    -r[1] [0],3 --atan2[1] [0] -nm[-1] @{1,n},1 -sqr[-3,-2] -+[-3,-2] -sqrt[-2]
  -endl -done -v +

#@gmic compress_rle : _is_binary_data={ 0 | 1 },_maximum_sequence_length>=0
#@gmic : Compress selected images as 2xN data matrices, using RLE algorithm.
#@gmic : Set 'maximum_sequence_length=0' to disable maximum length constraint.
#@gmic : Default values: 'is_binary_data=0' and 'maximum_sequence_length=0'.
#@gmic : $ image.jpg -resize2dy 100 -quantize 4 -round --compress_rle , --uncompress_rle[-1]
compress_rle : -skip ${1=0} -check "isint(${2=0}) && $2>=0"
  -v - s0=" for binary data" s1=""
  -if $2 s=", with maximal sequence length "$2 -else s="" -endif
  -v + -e[^-1] "Compress image$? using RLE algorithm"${s{!$1}}$s"." -v -
  -repeat @# -l[$>] nm=@{0,n} im={im} header={w};{h};{d};{s};$im;{$1!=0}
    -- $im -y x ({@{0,-1}+1}) -a x -r 100%,3
    -f '>if(y==0,i,if(y==1,if(i(x,0)==i(x+1,0),-1,x),if(i(x-1,1)==-1,i(x-1,2)+1,1)))'
    -if $2 # Constrain maximum sequence length.
      -transpose -mirror x
      -f[-1] '>if(x==2,i,if(x==0,if(j(0,-1)==$2,1,if(i!=1,j(0,-1)+1,1)),if(i==-1&&j(-1)==$2,y,i)))'
      -mirror x -transpose
    -endif
    -z 0,{w-2} -s y,3 -discard[1] -1 -warp[0,2] [1],0,0 -rm[1]
    -if $1 # Encode for binary data.
      -!=[0] 0 -*[0] 2 --[0] 1 -*
    -else # Encode for arbitrary data.
      -*[-1] -1 -rv -a x -y -discard -1 -f '>if(i(0,y-1)<0&&i==0&&i(0,y+1)<0,-1,i)' -discard -1
    -endif
    -i[0] ($header) -a y -nm $nm,1
  -endl -done -v +

#@gmic cumulate : { x | y | z | c }..{ x | y | z | c } : (no arg) : (+)
#@gmic : Compute the cumulative function of specified image data, optionally along the specified axes.
#@gmic : $ image.jpg --histogram --cumulate[-1] -display_graph[-2,-1] 400,300,3

#@gmic c : eq. to '-cut'. : (+)

#@gmic cut : { value0[%] | [image0] },{ value1[%] | [image1] } : [image] : (no arg) : (+)
#@gmic : Cut values of selected images in specified range.
#@gmic : (eq. to '-c').
#@gmic : (no arg) runs interactive mode (uses the instant window [0] if opened).
#@gmic : $ image.jpg --add 30% -cut[-1] 0,255
#@gmic : $ image.jpg --cut 25%,75%

#@gmic discard : _value1,_value2,... : { x | y | z | c}..{ x | y | z | c},_value1,_value2,... : (no args) : (+)
#@gmic : Discard specified values in selected images or discard neighboring duplicate values,
#@gmic : optionally only for the values along the first of a specified axis.
#@gmic : If no values are specified, neighboring duplicate values are discarded.
#@gmic : If all pixels of a selected image are discarded, an empty image is returned.
#@gmic : $ (1;2;3;4;3;2;1) --discard 2
#@gmic : $ (1,2,2,3,3,3,4,4,4,4) --discard x

#@gmic eigen2tensor
#@gmic : Recompose selected pairs of eigenvalues/eigenvectors as 2x2 or 3x3 tensor fields.
#@gmic : $$
eigen2tensor :
  -e[^-1] "Recompose pairs in eigen field$? as 2x2 or 3x3 tensor fields."
  -v - -repeat {@#/2} -l[$>,{$>+1}] nm=@{0,n}
    -if {s==2} # 2d tensors.
      -s[-1] c
      --sqr[-1] -*[-2] [-3] -sqr[-3] # u^2 uv v^2
      -sh[-1] --*[-3] -1
      -sh[-5]     # v^2 -uv u^2
      -a[-3--1] c -a[-4--2] c
      -sh[-3] 0,0 -*[-3,-1]          # l1*(u^2;uv;v^2)
      -sh[-3] 1,1 -*[-2,-1]          # l2*(v^2;-uv;u^2)
      -rm[-3] -+[-2,-1]
    -elif {s==6} # 3d tensors.
      -s[-1] c
      -l[-6--4] --sqr[-2] --*[-2,-3] --sqr[-3] -*[-5] [-6] -*[-4] [-6] -sqr[-6] -a c -endl
      -l[-3--1] --sqr[-2] --*[-2,-3] --sqr[-3] -*[-5] [-6] -*[-4] [-6] -sqr[-6] -a c -endl
      -s[-3] c
      --[-5] [-3] --[-4] [-3] -*[-2] [-5] -*[-1] [-4]
      (1^0^0^1^0^1) -r[-1] [-3] -*[-1] [-4] -rm[-6--4] -+[-3--1]
    -else -error[0--3] "Command '-eigen2tensor': Invalid image ["{@#-$>-1}"] : Dimensions "{w}","{h}","{d}","{s}" does not represent a field of 2d or 3d eigenvectors."
    -endif
  -nm $nm,1 -endl -done -v +

#@gmic endian : _datatype : (+)
#@gmic : Reverse data endianness of selected images, eventually considering the pixel being of the specified datatype.
#@gmic : 'datatype' can be { uchar | char | ushort | short | uint | int | ulong | long | float | double }.

#@gmic equalize : _nb_levels>0[%],_value_min[%],_value_max[%] : (+)
#@gmic : Equalize histograms of selected images.
#@gmic : If value range is specified, the equalization is done only for pixels in the specified
#@gmic : value range.
#@gmic : Default values: 'nb_levels=256', 'value_min=0%' and 'value_max=100%'.
#@gmic : $ image.jpg --equalize
#@gmic : $ image.jpg --equalize 4,0,128

#@gmic f : eq. to '-fill'. : (+)

#@gmic fill : value1,_value2,.. : [image] : 'formula' : (+)
#@gmic : Fill selected images with values read from the specified value list, existing image
#@gmic : or mathematical expression. Single quotes may be omitted in 'formula'.
#@gmic : (eq. to '-f').
#@gmic : $ 4,4 -fill 1,2,3,4,5,6,7
#@gmic : $ 4,4 (1,2,3,4,5,6,7) -fill[-2] [-1]
#@gmic : $ 400,400,1,3 -fill "X=x-w/2; Y=y-h/2; R=sqrt(X^2+Y^2); a=atan2(Y,X); if (R<=180,255*abs(cos(c+200*(x/w-0.5)*(y/h-0.5))),850*(a%(0.1*(c+1))))"

#@gmic float2int8
#@gmic : Convert selected float-valued images to 8bits integer representations.
float2int8 :
  -e[^-1] "Convert float-valued image$? to 8bits integer representations."
  -v - -repeat @# -l[$>]
    -s c -repeat @# -l[$>]
      m={im} M={iM} -quantize 16777216,0,1
      -->> 8 -and[-1] 255 --and[-2] 255 ->>[-3] 16
      ({'$m,$M'}) -a y
    -endl -done -a c
  -endl -done -v +

#@gmic int82float
#@gmic : Convert selected 8bits integer representations to float-valued images.
int82float :
  -e[^-1] "Convert 8bits integer representation$? to float-valued image$?."
  -v - -repeat @# -l[$>]
    -s c -repeat @# -l[$>]
      -sh[-1] {h-1},{h-1},0,0 m=@{-1,t} -rm[-1]
      -rows 0,{h-2} -s y,3 -*[-3] 65536 -*[-2] 256 -or
      -skip @{-n\ $m}
    -endl -done -a c
  -endl -done -v +

#@gmic index : { [palette] | predefined_palette },0<=_dithering<=1,_map_palette={ 0 | 1 } : (+)
#@gmic : Index selected vector-valued images by specified vector-valued palette.
#@gmic : 'predefined_palette' can be { 0=default | 1=HSV | 2=lines | 3=hot | 4=cool | 5=jet | 6=flag | 7=cube }.
#@gmic : Default values: 'dithering=0' and 'map_palette=0'.
#@gmic : $ image.jpg --index 1,1,1
#@gmic : $ image.jpg (0;255;255^0;128;255^0;0;255) --index[-2] [-1],1,1

#@gmic ir : eq. to '-inrange'.
ir :
  -v - _gmic_s="$?" -v +
  -_inrange $*

#@gmic inrange : min[%],max[%]
#@gmic : Detect pixels whose values are in specified range [min,max], in selected images.
#@gmic : (eq. to '-ir').
#@gmic : $ image.jpg --inrange 25%,75%
inrange :
  -v - _gmic_s="$?" -v +
  -_$0 $*

_inrange :
  -e[0--3] "Detect pixel values in range [$1,$2] in image"$_gmic_s"."
  -v - -repeat @# -l[$>]
    m=$1 M=$2
    -if @{-is_percent\ $1} m={im+(iM-im)*$m} -endif
    -if @{-is_percent\ $2} M={im+(iM-im)*$M} -endif
    -- {0.5*($m+$M)} -abs -<= {0.5*abs($M-$m)}
  -endl -done -v +

#@gmic map : [palette],_boundary : predefined_palette,_boundary : (+)
#@gmic : Map specified vector-valued palette to selected indexed scalar images.
#@gmic : 'predefined_palette' can be { 0=default | 1=HSV | 2=lines | 3=hot | 4=cool | 5=jet | 6=flag | 7=cube }.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann | 2=periodic }.
#@gmic : Default value: 'boundary=0'.
#@gmic : $ image.jpg --luminance -map[-1] 3
#@gmic : $ image.jpg --rgb2ycbcr -split[-1] c (0,255,0) -resize[-1] 256,1,1,1,3 -map[-4] [-1] -remove[-1] -append[-3--1] c -ycbcr2rgb[-1]

#@gmic map_clut : [clut]
#@gmic : Map specified RGB color LUT to selected images.
#@gmic : $ image.jpg -uniform_distribution {2^6},3 -mirror[-1] x --map_clut[0] [1]
map_clut : -check @{-is_image_arg\ $1}
  -e[^-1] "Map color LUT $1 on image$?."
  -v -
  -if {!@#} -v + -return -endif
  -to_color
  -pass$1 0 -to_rgb[-1]
  l={round((w*h*d)^(1/3))}
  -if {w*h*d!=$l^3} -error "Command '-map_clut': Specified CLUT $1 has invalid dimensions "({w},{h},{d},{s}). -endif
  -r[-1] $l,$l,$l,3,-1
  -repeat {@#-1} -l[$>,-1] -split_opacity[0] -/[0] {256/$l}
    --warp[-1] [0],0,1,1
    -rm[0] -mv[-1] 0 -a[^-1] c
  -endl -done -rm[-1] -v +

#@gmic mix_channels : (a00,...,aMN)
#@gmic : Apply specified matrix to channels of selected images.
#@gmic : $ image.jpg --mix_channels (0,1,0;1,0,0;0,0,1)
mix_channels :
  -e[^-1] "Apply matrix $1 to channels of image$?."
  -v - -repeat @# -l[$>] nm=@{0,n}
    whd={w},{h},{d} -r {w*h*d},{s},1,1,-1 -i[0] ${^0} -** -r $whd,{h},-1
  -nm $nm,1 -endl -done -v +

#@gmic negative
#@gmic : Compute negative of selected images.
#@gmic : $ image.jpg --negative
negative :
  -e[^-1] "Compute negative of image$?."
  -v - -repeat @# -l[$>] -- {iM} -endl -done -* -1 -v +

#@gmic noise : std_variation>=0[%],_noise_type : (+)
#@gmic : Add random noise to selected images.
#@gmic : 'noise_type' can be { 0=gaussian | 1=uniform | 2=salt&pepper | 3=poisson | 4=rice }.
#@gmic : Default value: 'noise_type=0'.
#@gmic : $ image.jpg --noise[0] 50,0 --noise[0] 50,1 --noise[0] 10,2 -cut 0,255
#@gmic : $ 300,300,1,3 [0] -noise[0] 20,0 -noise[1] 20,1 --histogram 100 -display_graph[-2,-1] 400,300,3

#@gmic norm
#@gmic : Compute the pointwise euclidean norm of vector-valued pixels in selected images.
#@gmic : $ image.jpg --norm
#@gmic : $$
norm :
  -e[^-1] "Compute pointwise euclidean norm of vectors, in image$?."
  -v - -sqr -compose_channels + -sqrt -v +

#@gmic n : eq. to '-normalize'. : (+)

#@gmic normalize : { value0[%] | [image0] },{ value1[%] | [image1] } : [image] : (+)
#@gmic : Linearly normalize values of selected images in specified range.
#@gmic : (eq. to '-n').
#@gmic : $ image.jpg -split x,2 -normalize[-1] 64,196 -append x
#@gmic : $$

#@gmic normalize_sum
#@gmic : Normalize selected images with a unitary sum.
#@gmic : $ image.jpg --histogram[-1] -normalize_sum[-1] -display_graph[-1] 400,300
normalize_sum :
  -e[^-1] "Normalize image$? with a unitary sum."
  -v - -repeat @# -/[$>] {sum=@{$>,+};if(sum!=0,sum,1)} -done -v +

#@gmic not
#@gmic : Apply boolean not operation on selected images.
#@gmic : $ image.jpg --ge 50% --not[-1]
not :
  -e[^-1] "Apply boolean not operation on image$?."
  -v - -== 0 -v +

#@gmic orientation
#@gmic : Compute the pointwise orientation of vector-valued pixels in selected images.
#@gmic : $ image.jpg --orientation --norm[-2] -negative[-1] -mul[-2] [-1] -reverse[-2,-1]
#@gmic : $$
orientation :
  -e[^-1] "Compute pointwise orientation vectors, in image$?."
  -v - -repeat @# --norm[$>] -replace[-1] 0,1 -/[$>,-1] -done -v +

#@gmic oneminus
#@gmic : For each selected image, compute one minus image.
#@gmic : $ image.jpg -n 0,1 --oneminus
oneminus :
  -e[^-1] "Compute one minus selected images$?."
  -v + -* -1 -+ 1 -v -

#@gmic otsu : _nb_levels>0
#@gmic : Hard-threshold selected images using Otsu's method.
#@gmic : The computed thresholds are returned as a list of values in the status.
#@gmic : Default value: 'nb_levels=256'.
#@gmic : $ image.jpg -luminance --otsu ,
otsu : -check "isint(${1=256}) && $1>0"
  -e[^-1] "Hard-threshold image$? using Otsu\47s method, with $1 histogram levels."
  -v - -repeat @# -l[$>]
    im={im} iM={iM} -n 0,{$1-1}
    --histogram $1 total=@{-1,+}
    --*[-1] 'x' sum=@{-1,+} -rm[-1]
    sumB=0 wB=0 wF=0 varMax=0 threshold=0
    -repeat $1
      wB={$wB+@{-1,$>}}
      -if {$wB==0} -continue -endif
      wF={$total-$wB}
      -if {$wF==0} -break -endif
      sumB={$sumB+$>*@{-1,$>}}
      mB={$sumB/$wB}
      mF={($sum-$sumB)/$wF}
      varBetween={$wB*$wF*($mB-$mF)^2}
      -if {$varBetween>$varMax} varMax=$varBetween threshold=$> -endif
    -done
    -rm[-1] ->=[-1] $threshold
    threshold={$im+$threshold*($iM-$im)/($1-1)}
    -if $> -u @{},$threshold -else -u $threshold -endif
  -endl -done -v +

#@gmic polar2complex
#@gmic : Compute polar to complex transforms of selected images.
polar2complex :
  -e[^-1] "Compute polar to complex transforms of image$?."
  -v - -repeat {int(@#/2)} -l[{2*$>},{2*$>+1}]
    -r[1] [0],3 --sin[-1] -cos[-2] -*[-1] [-3] -*[-3,-2]
  -endl -done -v +

#@gmic quantize : nb_levels>=1,_keep_values={ 0 | 1 },_is_uniform={ 0 | 1 }
#@gmic : Quantize selected images.
#@gmic : Default value: 'keep_values=1' and 'is_uniform=0'.
#@gmic : $ image.jpg -luminance --quantize 3
#@gmic : $ 200,200,1,1,'cos(x/10)*sin(y/10)' --quantize[0] 6 --quantize[0] 4 --quantize[0] 3 --quantize[0] 2
quantize : -check "isint($1) && $1>=1" -skip ${2=1},${3=0}
  -e[^-1] "Quantize image$? using $1 levels, "@{-arg\ 1+!$2,with,without}" keeping value range."
  -v - -repeat @# -l[$>]
    -if $3 # Uniform quantization.
      -if {s==1} # Greyscale image.
        -if $2 mM={im},{iM} -n 0,$1 -round 1,-1 -min {$1-1} -n $mM
        -else -n 0,$1 -round 1,-1 -min {$1-1} -endif
      -else mM={im},{iM} -uniform_distribution $1,{s} -n[-1] $mM -index[-2] [-1],0,$2 -rm[-1]
      -endif
    -else --colormap $1,0 -index[-2] [-1],0,$2 -rm[-1] # Non-uniform quantization.
    -endif
  -endl -done -v +

#@gmic rand : { value0[%] | [image0] },{ value1[%] | [image1] } : [image] : (+)
#@gmic : Fill selected images with random values uniformly distributed in the specified range.
#@gmic : $ 400,400,1,3 -rand -10,10 --blur 10 -sign[-1]

#@gmic replace : value_src,value_dest
#@gmic : Replace pixel values in selected images.
#@gmic : $ (1;2;3;4) --replace 2,3
replace :
  -e[^-1] "Replace pixel values $1 with $2 in image$?."
  -v - -repeat @# -l[$>] --== $1 -*[-1] {$2-$1} -+ -endl -done -v +

#@gmic replace_inf : _expression
#@gmic : Replace all infinite values in selected images by specified expression.
#@gmic : $ (0;1;2) -log --replace_inf 2
replace_inf :
  -e[^-1] "Replace all infinite values in image$? by expression '$1'."
  -v - -f "if(i==i+1,$1,i)" -v +

#@gmic replace_nan : _expression
#@gmic : Replace all NaN values in selected images by specified expression.
#@gmic : $ (-1;0;2) -sqrt --replace_nan 2
replace_nan :
  -e[^-1] "Replace all NaN values in images$? by expression '$1'."
  -v - -f "if(i>=0 || i<=0,i,$1)" -v +

#@gmic replace_seq : "search_seq","replace_seq"
#@gmic : Search and replace a sequence of values in selected images.
#@gmic : $ (1;2;3;4;5) --replace_seq "2,3,4","7,8"
replace_seq : -skip "${2=}"
  -e[^-1] "Replace value sequence '$1' by value sequence '${2--1}' in image$?."
  -v - ns={narg($1)} nd={narg(${2--1})} ratio={$nd*100/$ns}
  -repeat @# -l[$>] -if {w}
    -s +,$1 --rows[0] 0,{$ns-1} ($1) --[-2,-1] -abs[-1] ind={iM!=0} -rm[-1]
    -if {$ind<@#} -if $nd -r[$ind--1:2] 1,$ratio%,1,1,0 -f[$ind--1:2] ${2--1} -else -rm[$ind--1:2] -endif -a y -endif
  -endif -endl -done -v +

#@gmic replace_str : "search_str","replace_str"
#@gmic : Search and replace a string in selected images (viewed as strings, i.e. sequences of ascii codes).
#@gmic : $ ({'"Hello there, how are you ?"'}) --replace_str "Hello there","Hi David"
replace_str : -skip "${2=}"
  -e[^-1] "Replace string '$1' by string '${2--1}' in image$? (viewed as string$?)."
  -v - -replace_seq @{-quote\ {'"$1"'}},{'"${2--1}"'} -v +

#@gmic round : rounding_value>=0,_rounding_type : (no arg) : (+)
#@gmic : Round values of selected images.
#@gmic : 'rounding_type' can be { -1=backward | 0=nearest | 1=forward }.
#@gmic : Default value: 'rounding_type=0'.
#@gmic : $ image.jpg --round 100
#@gmic : $ image.jpg -mul {pi/180} -sin --round

#@gmic roundify : gamma>=0
#@gmic : Apply roundify transformation on float-valued data, with specified gamma.
#@gmic : Default value: 'gamma=0'.
#@gmic : $ 1000 -fill '4*x/w' -repeat 5 --roundify[0] {$>*0.2} -done -append c -display_graph 400,300
roundify : -check $1>=0
  -e[^-1] "Roundify image$?, with gamma $1."
  -if {$1==1} -return -endif
  -v - -repeat @# -l[$>]
    --round 1 --[-2] [-1] --*[-2] 2 -abs[-1] -^[-1] $1 -sign[-3] -*[-3,-1] -*[-2] 0.5 -+
  -endl -done -v +

#@gmic = : eq. to '-set'. : (+)

#@gmic set : value,_x[%],_y[%],_z[%],_c[%] : (+)
#@gmic : Set pixel value in selected images, at specified coordinates.
#@gmic : (eq. to '-=').
#@gmic : If specified coordinates are outside the image bounds, no action is performed.
#@gmic : Default values: 'x=y=z=c=0'.
#@gmic : $ 2,2 -set 1,0,0 -set 2,1,0 -set 3,0,1 -set 4,1,1
#@gmic : $ image.jpg -repeat 10000 -set 255,{?(100)}%,{?(100)}%,0,{?(100)}% -done

#@gmic threshold : value[%],_is_soft : (no arg) : (+)
#@gmic : Threshold values of selected images.
#@gmic : 'soft' can be { 0=hard-thresholding | 1=soft-thresholding }.
#@gmic : (no arg) runs interactive mode (uses the instant window [0] if opened).
#@gmic : Default value: 'is_soft=0'.
#@gmic : $ image.jpg --threshold[0] 50% --threshold[0] 50%,1
#@gmic : $$

#@gmic uncompress_rle
#@gmic : Uncompress selected 2xN data matrices, using RLE algorithm.
uncompress_rle :
  -e[^-1] "Uncompress data vector$?, using RLE algorithm."
  -v - -repeat @# -l[$>]

    # Retrieve original data dimension and min value.
    -y whds=@{0,0-3} im=@{0,4} is_binary_data=@{0,5} -rows 6,100%

    # Transform RLE data to list of pairs {nb_occurences,value}.
    -if $is_binary_data  # Decode for binary data.
      -->= 0 -abs[0] -a x
    -else # Decode for arbitrary data
      --<[-1] 0 (0;1;1) -erode[-2] [-1],0 -rm[-1] --[-1] 1 -a x -discard -1  # Get back compressed '0' (minimum) values.
      --< 0 (1;1;0) -dilate[-2] [-1] -rm[-1] -*[-1] -2 -+[-1] 1              # Get back singletons.
      -rv -abs[-1] -a x -discard -1
      -r 2,{h/2},1,1,-1
    -endif

    # Uncompress, using 3d objects.
    -s y,-256
    -repeat @# -l[$>]
      -i[0] ({'CImg3d'}) -+[0] 0.5
      -i[1] ({2*h};{h})
      -s[-1] x,2 -cumulate[-2] siz=@{-2,-1}
      --shift[-2] 0,1 --[-3] 1 -rv[-3,-1] -z[-3,-1] 0,2 -a[-3,-1] x
      -i[3] (2,0,1;2,{2*h-2},{2*h-1}) -r[3] 3,{h},1,1,3 -round[3]
      -r[4] 3 1,100%,1,1,1 -y -a y
      $siz -j3d[-1] [-2],0,0,0,1,2,0,0 -rm[-2]
    -endl -done
    -a x -r $whds,-1 -+ $im
  -endl -done -v +

#@gmic unrepeat
#@gmic : Remove repetition of adjacent values in selected images.
#@gmic : $ (1;1;1;1;1;2;2;2;3;4;4;4;5;5;5) --unrepeat
unrepeat :
  -e[^-1] "Remove repetition of adjacent values in image$?."
  -v - -repeat @# -l[$>] nm=@{0,n}
    -y x ({@{0,-1}+1}) -a x -r 100%,2
    -f[-1] '>if(y==0,i,if(i(x,0)==i(x+1,0),-1,x))'
    -z 0,{w-2} -s y,2 -discard[1] -1 -map[1] [0]
    -rm[0] -nm $nm,1
  -endl -done -v +

#@gmic vector2tensor
#@gmic : Convert selected vector fields to corresponding tensor fields.
vector2tensor :
  -e[^-1] "Convert vector field$? to tensor field$?."
  -v - -repeat @# -l[$>]
    -s c
    -if {@#==2} --sqr[-1] -*[-2] [-3] -sqr[-3]
    -elif {@#==3} --sqr[-2] --*[-3] [-2] --sqr[-3] -*[-5,-4] [-6] -sqr[-6]
    -else -error[0--4] "Command '-vector2tensor': Invalid image ["{@#-$>-1}"] : Dimensions "{w}","{h}","{d}","{s}" does not represent a field of 2d or 3d vectors."
    -endif
    -a c
  -endl -done -v +

#---------------------------------
#
#@gmic :: Colors manipulation
#
#---------------------------------

#@gmic apply_channels : "command",_channels={ all=0 | rgba=1 | rgb=2 | y=3 | cbcr=4 | cb=5 | cr=6 | l=7 | ab=8 | a=9 | b=10 | h=11 | s=12 | v=13 | k=14 | cg=15 | ch=16 | c=17 | H=18 | r=19 | g=20 | b=21 | alpha==22 },_normalize={ 0=cut | 1=normalize }
#@gmic : Apply specified command on chosen normalized channels of each selected images.
#@gmic : Default value: 'normalize=0'.
#@gmic : $ image.jpg --apply_channels "-equalize -blur 2",cbcr
apply_channels : -skip ${3=0}

  # All components.
  -if {{$2'=='all}" || "{$2'=='0}}
    -e[^-1] "Apply command '$1' on image$?." -v -
    -repeat @# -l[$>]
      -_apply_channels "$1"
      -if $3 -n 0,255 -else -c 0,255 -endif
    -endl -done

  # RGBA.
  -elif {{$2'=='rgba}" || "{$2'=='1}}
    -e[^-1] "Apply command '$1' on RGBA channels of image$?." -v -
    -to_rgba -repeat @# -l[$>]
      -_apply_channels "$1"
      -if $3 -n 0,255 -else -c 0,255 -endif
    -endl -done

  # RGB.
  -elif {{$2'=='rgb}" || "{$2'=='2}}
    -e[^-1] "Apply command '$1' on RGB channels of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0]
      -_apply_channels[0] "$1"
      -if $3 -n[0] 0,255 -else -c[0] 0,255 -endif
      -to_rgb[0]
      -a c
    -endl -done

  # Y.
  -elif {{$2'=='y}" || "{$2'=='3}}
    -e[^-1] "Apply command '$1' on luminance Y of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2ycbcr[0] -s[0] c
      -_apply_channels[0] "$1" -channels[0] 0
      -if $3 -n[0] 0,255 -else -c[0] 0,255 -endif
      -a[0-2] c -ycbcr2rgb[0] -a c
    -endl -done

  # CbCr.
  -elif {{$2'=='cbcr}" || "{$2'=='4}}
    -e[^-1] "Apply command '$1' on blue and red chrominances CbCr of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2ycbcr[0] -s[0] c -a[1,2] c
      -_apply_channels[1] "$1" -channels[1] 0,1
      -if $3 -n[1] 0,255 -else -c[1] 0,255 -endif
      -a[0-1] c -ycbcr2rgb[0] -a c
    -endl -done

  # Cb.
  -elif {{$2'=='cb}" || "{$2'=='5}}
    -e[^-1] "Apply command '$1' on blue chrominance Cb of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2ycbcr[0] -s[0] c
      -_apply_channels[1] "$1" -channels[1] 0
      -if $3 -n[1] 0,255 -else -c[1] 0,255 -endif
      -a[0-2] c -ycbcr2rgb[0] -a c
    -endl -done

  # Cr.
  -elif {{$2'=='cr}" || "{$2'=='6}}
    -e[^-1] "Apply command '$1' on red chrominance Cr of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2ycbcr[0] -s[0] c
      -_apply_channels[2] "$1" -channels[2] 0
      -if $3 -n[2] 0,255 -else -c[2] 0,255 -endif
      -a[0-2] c -ycbcr2rgb[0] -a c
    -endl -done

  # L.
  -elif {{$2'=='l}" || "{$2'=='7}}
    -e[^-1] "Apply command '$1' on lightness L of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2lab[0] -s[0] c
      -*[0] 2.55 -_apply_channels[0] "$1" -channels[0] 0 -/[0] 2.55
      -if $3 -n[0] 0,100 -else -c[0] 0,100 -endif
      -a[0-2] c -lab2rgb[0] -a c
    -endl -done

  # a-b.
  -elif {{$2'=='ab}" || "{$2'=='8}}
    -e[^-1] "Apply command '$1' on a-b channels of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2lab[0] -s[0] c
      -+[1] 86 -*[1] 1.38587 -+[2] 108 -*[2] 1.25616
      -a[1,2] c -_apply_channels[1] "$1" -channels[1] 0,1 -s[1] c
      -/[1] 1.38587 --[1] 86 -/[2] 1.25616 --[2] 108
      -if $3 -n[1] -86,98 -n[2] -108,95 -endif
      -a[0-2] c -lab2rgb[0] -a c
    -endl -done

  # a.
  -elif {{$2'=='a}" || "{$2'=='9}}
    -e[^-1] "Apply command '$1' on a-channel of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2lab[0] -s[0] c
      -+[1] 86 -*[1] 1.38587 -_apply_channels[1] "$1" -channels[1] 0 -/[1] 1.38587 --[1] 86
      -if $3 -n[1] -86,98 -endif
      -a[0-2] c -lab2rgb[0] -a c
    -endl -done

  # b.
  -elif {{$2'=='b}" || "{$2'=='10}}
    -e[^-1] "Apply command '$1' on b-channel of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2lab[0] -s[0] c
      -+[2] 108 -*[2] 1.25616 -_apply_channels[2] "$1" -channels[2] 0 -/[2] 1.25616 --[2] 108
      -if $3 -n[1] -108,95 -endif
      -a[0-2] c -lab2rgb[0] -a c
    -endl -done

  # H.
  -elif {{$2'=='h}" || "{$2'=='11}}
    -e[^-1] "Apply command '$1' on hue H of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2hsv[0] -s[0] c
      -*[0] 0.708333 -_apply_channels[0] "$1" -channels[0] 0 -/[0] 0.708333
      -if $3 -n[0] 0,360 -else -%[0] 360 -endif
      -a[0-2] c -hsv2rgb[0] -a c
    -endl -done

  # S.
  -elif {{$2'=='s}" || "{$2'=='12}}
    -e[^-1] "Apply command '$1' on saturation S of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2hsv[0] -s[0] c
      -*[1] 255 -_apply_channels[1] "$1" -channels[1] 0 -/[1] 255
      -if $3 -n[1] 0,1 -else -c[1] 0,1 -endif
      -a[0-2] c -hsv2rgb[0] -a c
    -endl -done

  # V.
  -elif {{$2'=='v}" || "{$2'=='13}}
    -e[^-1] "Apply command '$1' on value V of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2hsv[0] -s[0] c
      -*[2] 255 -_apply_channels[2] "$1" -channels[2] 0 -/[2] 255
      -if $3 -n[2] 0,1 -else -c[2] 0,1 -endif
      -a[0-2] c -hsv2rgb[0] -a c
    -endl -done

  # K.
  -elif {{$2'=='k" || "{$2'=='14}}
    -e[^-1] "Apply command '$1' on key channel K of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2cmyk[0] -s[0] c
      -_apply_channels[3] "$1" -channels[3] 0
      -if $3 -n[3] 0,255 -else -c[3] 0,255 -endif
      -a[0-3] c -cmyk2rgb[0] -a c
    -endl -done

  # Cg.
  -elif {{$2'=='cg}" || "{$2'=='15}}
    -e[^-1] "Apply command(s) '$1' on green chrominance Cg of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -s[0] c -rv[1,2] -a[0-2] c -rgb2ycbcr[0] -s[0] c
      -_apply_channels[1] "$1" -channels[1] 0
      -if $3 -n[1] 0,255 -else -c[1] 0,255 -endif
      -a[0-2] c -ycbcr2rgb[0] -s[0] c -rv[1,2] -a c
    -endl -done

  # c-h.
  -elif {{$2'=='ch}" || "{$2'=='16}}
    -e[^-1] "Apply command '$1' on c-h channels of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2lch[0] -s[0] c
      -*[1] 2.55 -+[2] {pi} -*[2] {255/(2*pi)}
      -a[1,2] c -_apply_channels[1] "$1" -channels[1] 0,1 -s[1] c
      -/[1] 2.55 -/[2] {255/(2*pi)} --[2] {pi}
      -if $3 -n[1] 0,100 -n[2] -{pi},{pi} -endif
      -a[0-2] c -lch2rgb[0] -a c
    -endl -done

  # c.
  -elif {{$2'=='c}" || "{$2'=='17}}
    -e[^-1] "Apply command '$1' on c-channel of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2lch[0] -s[0] c
      -*[1] 2.55 -_apply_channels[1] "$1" -channels[1] 0 -/[1] 2.55
      -if $3 -n[1] 0,100 -else -c[1] 0,100 -endif
      -a[0-2] c -lch2rgb[0] -a c
    -endl -done

  # H.
  -elif {{$2'=='h}" || "{$2'=='18}}
    -e[^-1] "Apply command '$1' on h-channel of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2lch[0] -s[0] c
      -+[2] {pi} -*[2] {255/(2*pi)} -_apply_channels[2] "$1" -channels[2] 0 -/[2] {255/(2*pi)} --[2] {pi}
      -if $3 -n[2] -{pi},{pi} -endif
      -a[0-2] c -lch2rgb[0] -a c
    -endl -done

  # Red.
  -elif {{$2'=='r}" || "{$2'=='19}}
    -e[^-1] "Apply command '$1' on red channel R of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -s[0] c
      -_apply_channels[0] "$1"
      -if $3 -n[0] 0,255 -else -c[0] 0,255 -endif
      -to_gray[0]
      -a c
    -endl -done

  # Green.
  -elif {{$2'=='g}" || "{$2'=='20}}
    -e[^-1] "Apply command '$1' on green channel G of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -s[0] c
      -_apply_channels[1] "$1"
      -if $3 -n[1] 0,255 -else -c[1] 0,255 -endif
      -to_gray[1]
      -a c
    -endl -done

  # Blue.
  -elif {{$2'=='b}" || "{$2'=='21}}
    -e[^-1] "Apply command '$1' on blue channel B of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -s[0] c
      -_apply_channels[2] "$1"
      -if $3 -n[2] 0,255 -else -c[2] 0,255 -endif
      -to_gray[2]
      -a c
    -endl -done

  # Alpha.
  -elif {{$2'=='alpha}" || "{$2'=='22}}
    -e[^-1] "Apply command '$1' on alpha channel A of image$?." -v -
    -repeat @# -l[$>]
      -to_rgba -s c
      -_apply_channels[3] "$1"
      -if $3 -n[3] 0,255 -else -c[3] 0,255 -endif
      -to_gray[3]
      -a c
    -endl -done

  -endif
  -v +

_apply_channels :
  ${1--1} -k[0]

#@gmic autoindex : nb_colors>0,0<=_dithering<=1,_method={ 0=median-cut | 1=k-means }
#@gmic : Index selected vector-valued images by adapted colormaps.
#@gmic : Default values: 'dithering=0' and 'method=0'.
#@gmic : $ image.jpg --autoindex[0] 4 --autoindex[0] 8 --autoindex[0] 16
autoindex : -check "isint($1) && $1>0 && ${2=0}>=0" -skip ${3=0}
  -e[^-1] "Index colors in images$? by adapted colormap with $1 entries, dithering level $2 and "\
          @{-arg\ 1+!$3,k-means,median-cut}" method."
  -v - -repeat @# -l[$>]
    -if {w>h} -if {w>256} --r2dx 256 -else [0] -endif
    -else -if {h>256} --r2dy 256 -else [0] -endif
    -endif
    -colormap[1] $1,$3,0
    -index[0] [1],$2,1 -rm[1]
  -endl -done -v +

#@gmic bayer2rgb : _GM_smoothness,_RB_smoothness1,_RB_smoothness2
#@gmic : Transform selected RGB-Bayer sampled images to color images.
#@gmic : Default values: 'GM_smoothness=RB_smoothness=1' and 'RB_smoothness2=0.5'.
#@gmic : $ image.jpg -rgb2bayer 0 --bayer2rgb 1,1,0.5
bayer2rgb : -skip ${1=1},${2=1},${3=0.5}
  -e[^-1] "Transform RGB-Bayer image$? to color images, with smoothness ($1,$2,$3)."
  -v - -channels 0 -repeat @# -l[$>]

    # Expand image size to avoid problems with borders.
    -expand_x {"2 + 4*$1"},0 -expand_y {"2 + 4*$1"},0

    # Compute green-magenta chromaticity.
    (-1,1;1,-1) -r[-1] [-2],[-2],1,1,0,2
    --*[-2] [-1]

    (0.25,0.5,0.25) -convolve[-2] [-1] -transpose[-1] -convolve[-2] [-1] -rm[-1]
    -b[-1] $1

    -*[-2] [-1]
    --[-3,-2]

    # Compute red-blue chromaticity.
    (1,-1) -r[-1] [-2],[-2],1,1,0,2  # Horizontal estimate
    -*[-1] [-3]
    (0.25,0.5,0.25) -convolve[-2] [-1] -transpose[-1] -convolve[-2] [-1] -rm[-1]
    -blur_y[-1] $2 -blur_x[-1] $3

    (1;-1) -r[-1] [-2],[-2],1,1,0,2  # Vertical estimate
    -*[-1] [-4]
    (0.25,0.5,0.25) -convolve[-2] [-1] -transpose[-1] -convolve[-2] [-1] -rm[-1]
    -blur_x[-1] $2 -blur_y[-1] $3

    -+[-2,-1] -/[-1] 2

    # Luminance reconstruction.
    (2,0;0,-2) -r[-1] [-2],[-2],1,1,0,2
    -*[-1] [-2]
    --[-4,-1]

    # RGB reconstruction.
    -a[-3--1] c
    -mix_rgb[-1] 1,-1,2,1,1,0,1,-1,-2

    # Shrink to original image size.
    -shrink_x {"2 + 4*$1"},0 -shrink_y {"2 + 4*$1"},0
    -c 0,255

  -endl -done -v +

#@gmic cmy2rgb
#@gmic : Convert selected images from CMY to RGB colorbases.
cmy2rgb :
  -e[^-1] "Convert image$? from CMY to RGB color bases."
  -v - -rgb2cmy -v +

#@gmic cmyk2rgb
#@gmic : Convert selected images from CMYK to RGB colorbases.
cmyk2rgb :
  -e[^-1] "Convert image$? from CMYK to RGB color bases."
  -v - -repeat @# -l[$>]
    -s c --/[-1] -255 -+[-1] 1 -*[0-2] [-1] -rm[-1] -+[0-2] [-1] -rm[-1]
    -a c -cmy2rgb
  -endl -done -v +

#@gmic colormap : nb_levels>=0,_method={ 0=median-cut | 1=k-means },_sort_vectors={ 0 | 1 }
#@gmic : Estimate best-fitting colormap with 'nb_colors' entries, to index selected images.
#@gmic : Set 'nb_levels==0' to extract all existing colors of an image.
#@gmic : Default value: 'method=0' and 'sort_vectors=1'.
#@gmic : $ image.jpg --colormap[0] 4 --colormap[0] 8 --colormap[0] 16
colormap : -check "isint($1) && $1>=0" -skip ${2=0},${3=1}
  -if $1
    -e[0--3] "Estimate colormap with $1 entries for image$?, by "@{-arg\ 1+!$2,k-means,median-cut}" method."
  -else
    -e[0--3] "Estimate full colormap for image$?."
  -endif
  -v - -repeat @# -l[$>]
    -if $1

      # Estimate quantized colormap.
      -r {w*h},1,1,100%,-1
      -if {!$2} -_colormap $1                                 # Just run the median-cut algorithm.
      -else
        m={im} M={iM} -n[-1] 0,255                            # Keep track of the initial statistics.
        --_colormap $1 --index[-2] [-1] -*[-1] 256 -+[-3,-1]  # Initialize k-means labels and add them on the image.

        # Start k-means iterations.
        -do
          -repeat {s}                                             # Estimate new colormap.
            -sh[0] $>,$> --histogram[-1] {$1*256},0,{$1*256-1} -rm[-2]
            -i[-2] 256,1,1,1,'x' -r[-2] {w},1,1,1,0,2 -*[-2] [-1] -r[-2,-1] $1,1,1,1,2 -max[-1] 0.01 -/[-2,-1]
          -done -a[2--1] c
          --[-2] [-1] -abs[-2] diff={@{-2,+}/w} -rm[-2]           # Compute colormap difference.
          -and[-2] 255 --index[-2] [-1],0,0 -*[-1] 256 -+[-3,-1]  # Compute new k-means labels.
        -while {$diff>0.5}
        -rm[-2] -*[-1] {($M-$m)/255} -+[-1] $m                    # Convert colormap values back to initial value range.
      -endif
    -else

      # Extract full colormap.
      -r {w*h*d},1,1,100%,-1
      -repeat {s} -ap "-sort +,x" -s x,0 -ap "-shift 0,0,0,1,2" -done
      -ap "-discard x" -a x

    -endif
    -if $3 --norm -rv -a y -sort +,x -rows 1 -endif             # Sort colors by increasing norm.
    -nm "[colormap of "@{-1,b}"]"
  -endl -done -v +

_colormap : # Implementation of the median-cut algorithm.
  -repeat {$1-1}
    @#,{s} -repeat {@#-1} # Compute box variances along all axes and find highest one (without a single element).
      n=$> -repeat @{$n,s} -sh[$n] $>,$> -=[-2] {if(w>1,iv,-1)},$n,$> -rm[-1] -done
    -done
    c=@{-1,C}
    b=@{-arg\ 1,$c}  # Indice of box with highest variance.
    a=@{-arg\ 2,$c}  # Indice of axe with highest variance inside box 'b'.
    -rm[-1] -shift[$b] 0,0,0,{-$a},2 -sort[$b] +,x -shift[$b] 0,0,0,$a,2 -s[$b] x,2 # Split selected box along its median axis.
  -done
  -r 1,1,1,100%,2 -a x # Average value in each box and append as final colormap.

#@gmic compose_channels
#@gmic : Compose all channels of each selected image, using specified arithmetic operator (+,-,or,min,...).
#@gmic : Default value: '1=+'.
#@gmic : $ image.jpg --compose_channels and
#@gmic : $$
compose_channels : -skip ${1="+"}
  -e[^-1] "Compose all channels of image$?, with operator '$1'."
  -v - -repeat @# -l[$>]
    -sh 0,0
    -repeat {@{-2,s}-1} -sh[-2] {$>+1},{$>+1} -l[-2,-1] -$1 -endl -done
    -rm[-1] -r 100%,100%,100%,1,-1
  -endl -done -v +

#@gmic direction2rgb
#@gmic : Compute RGB representation of selected 2d direction fields.
#@gmic : $ image.jpg -luminance -gradient -append c -blur 2 -orientation --direction2rgb
direction2rgb :
  -e[^-1] "Compute RGB representation of 2d direction field$?."
  -v - -channels 0,1 -repeat @# -l[$>] nm=@{0,n}
    -s c -complex2polar -round[-2] 0.001
    -*[-1] {180/pi} -%[-1] 360 100%,100%,1,1,1 -mv[-3] @#
    -if {im!=iM} -n[-1] 0,1 -else -f[-1] 1 -endif
    -a c -hsv2rgb
  -nm $nm,1 -endl -done -v +

#@gmic ditheredbw
#@gmic : Create dithered B&W version of selected images.
#@gmic : $ image.jpg --equalize -ditheredbw[-1]
ditheredbw :
  -e[^-1] "Create dithered B&W version of image$?."
  -v - -repeat @# -l[$>] -split_opacity
    -luminance[0] -n[0] 0,255 (0,255) -index[0] [-1],1,1 -rm[-1]
  -a c -endl -done -v +

#@gmic fc : eq. to '-fill_color'.
fc :
  -v - _gmic_s="$?" -v +
  -_fill_color $*

#@gmic fill_color : col1,...,colN
#@gmic : Fill selected images with specified color.
#@gmic : (eq. to '-fc').
#@gmic : $ image.jpg --fill_color 255,0,255
fill_color :
  -v - _gmic_s="$?" -v +
  -_$0 $*

_fill_color :
  -e[0--3] "Fill image"$_gmic_s" with color (${^0})."
  -v - -repeat @# -l[$>]
    -repeat {s} -sh[0] $>,$> -f[-1] {arg(1+$>,${^0})} -done -k[0]
  -nm @{-1,n},1 -endl -done -v +

#@gmic gradient2rgb : _is_orientation={ 0 | 1 }
#@gmic : Compute RGB representation of 2d gradient of selected images.
#@gmic : Default value: 'is_orientation=0'.
#@gmic : $ image.jpg --gradient2rgb 0 -equalize[-1]
gradient2rgb : -check "isbool(${1=0})"
  -arg 1+!$1,"orientation ",""
  -e[^-1] "Compute RGB representation of 2d gradient "@{}"of image$?."
  -v - -norm -repeat @# -l[$>]
    -if $1 -gradient_orientation 2 -else -g xy -endif
    -a c -direction2rgb
  -endl -done -v +

#@gmic hsi2rgb : (+)
#@gmic : Convert selected images from HSI to RGB colorbases.

#@gmic hsi82rgb
#@gmic : Convert selected images from HSI8 to RGB color bases.
hsi82rgb :
  -e[^-1] "Convert image$? from HSI8 to RGB color bases."
  -v - -_hsx82rgb -hsi2rgb -v +

#@gmic hsl2rgb : (+)
#@gmic : Convert selected images from HSL to RGB colorbases.

#@gmic hsl82rgb
#@gmic : Convert selected images from HSL8 to RGB color bases.
hsl82rgb :
  -e[^-1] "Convert image$? from HSL8 to RGB color bases."
  -v - -_hsx82rgb -hsl2rgb -v +

#@gmic hsv2rgb : (+)
#@gmic : Convert selected images from HSV to RGB colorbases.
#@gmic : $ (0,360;0,360^0,0;1,1^1,1;1,1) -resize 400,400,1,3,3 -hsv2rgb

#@gmic hsv82rgb
#@gmic : Convert selected images from HSV8 to RGB color bases.
hsv82rgb :
  -e[^-1] "Convert image$? from HSV8 to RGB color bases."
  -v - -_hsx82rgb -hsv2rgb -v +

_hsx82rgb :
 -repeat @#
   -sh[$>] 0,0 -/[-1] 0.708333 -rm[-1]
   -sh[$>] 1,2 -/[-1] 255 -rm[-1]
 -done

#@gmic int2rgb
#@gmic : Convert selected images from INT24 scalars to RGB.
int2rgb :
  -e[^-1] "Convert image$? from INT24 scalars to RGB."
  -v - -round -repeat @# -l[$>]
    -->> 8 -&[1] 255 --&[0] 255 ->>[0] 16 -a c
  -endl -done -v +

#@gmic lab2lch
#@gmic : Convert selected images from Lab to Lch color bases.
lab2lch :
  -e[^-1] "Convert image$? from Lab to Lch color bases."
  -v - -r 100%,100%,100%,3 -repeat @# -l[$>]
    -s c -complex2polar[-2,-1] -a c
  -endl -done -v +

#@gmic lab2rgb : (+)
#@gmic : Convert selected images from Lab to RGB colorbases.
#@gmic : $ (50,50;50,50^-3,3;-3,3^-3,-3;3,3) -resize 400,400,1,3,3 -lab2rgb

#@gmic lab82rgb
#@gmic : Convert selected images from Lab8 to RGB color bases.
lab82rgb :
  -e[^-1] "Convert image$? from Lab8 to RGB color bases."
  -v - -repeat @#
    -sh[$>] 0,0 -/[-1] 2.55 -rm[-1]
    -sh[$>] 1,1 -/[-1] 1.275 --[-1] 100 -rm[-1]
    -sh[$>] 2,2 -/[-1] 1.15909 --[-1] 110 -rm[-1]
  -done -lab2rgb -v +

#@gmic lch2lab
#@gmic : Convert selected images from Lch to Lab color bases.
lch2lab :
  -e[^-1] "Convert image$? from Lch to Lab color bases."
  -v - -r 100%,100%,100%,3 -repeat @# -l[$>]
    -s c -polar2complex[-2,-1] -a c
  -endl -done -v +

#@gmic lch2rgb
#@gmic : Convert selected images from Lch to RGB color bases.
lch2rgb :
  -e[^-1] "Convert image$? from Lch to RGB color bases."
  -v - -lch2lab -lab2rgb -v +

#@gmic lch82rgb
#@gmic : Convert selected images from Lch8 to RGB color bases.
lch82rgb :
  -e[^-1] "Convert image$? from Lch8 to RGB color bases."
  -v - -repeat @#
    -sh[$>] 0,0 -/[-1] 2.55 -rm[-1]
    -sh[$>] 1,1 -/[-1] 1.88889 -rm[-1]
    -sh[$>] 2,2 -/[-1] 40.5845 --[-1] 3.14159 -rm[-1]
  -done -lch2rgb -v +

#@gmic luminance
#@gmic : Compute luminance of selected sRGB images.
#@gmic : $ image.jpg --luminance
luminance :
  -e[^-1] "Compute luminance of image$?."
  -v - -remove_opacity -srgb2rgb
  -repeat @# -l[$>]
  -if {s==3} -sh 0,0 -sh[0] 1,1 -sh[0] 2,2 -*[1] 0.299 -*[2] 0.587 -*[3] 0.114 -+[1-3] -rm[1]
  -elif {s!=1} -norm -n 0,255
  -endif -endl -done
  -channels 0 -rgb2srgb -v +

#@gmic mix_rgb : a11,a12,a13,a21,a22,a23,a31,a32,a33
#@gmic : Apply 3x3 specified matrix to RGB colors of selected images.
#@gmic : Default values: 'a11=1', 'a12=a13=a21=0', 'a22=1', 'a23=a31=a32=0' and 'a33=1'.
#@gmic : $ image.jpg --mix_rgb 0,1,0,1,0,0,0,0,1
#@gmic : $$
mix_rgb : -skip ${1=1},${2=0},${3=0},${4=0},${5=1},${6=0},${7=0},${8=0},${9=1}
  -e[^-1] "Apply matrix [ $1 $2 $3 ; $4 $5 $6 ; $7 $8 $9 ] to RGB colors of image$?."
  -v - -r 100%,100%,1,3,0,2 -mix_channels ($1,$2,$3;$4,$5,$6;$7,$8,$9) -v +

#@gmic pseudogray : _max_increment>=0,_JND_threshold>=0,_bits_depth>0
#@gmic : Generate pseudogray colormap with specified increment and perceptual threshold.
#@gmic : If 'JND_threshold' is 0, no perceptual constraints are applied.
#@gmic : Default values: 'max_increment=5', 'JND_threshold=2.3' and 'bits_depth=8'.
#@gmic : $ -pseudogray 5
pseudogray : -check "isint(${1=5}) && $1>=0 && ${2=2.3}>=0 && isint(${3=8}) && $3>0"
  -e[^-1] "Generate pseudogray colormap with increment $1, JND threshold $2 and $3 bits depth."
  -v -

  # Generate all possible sRGB colors with given increments.
  {round(2^$3)},1,1,3,'x'
  -if {!$1} -n[-1] 0,255 -v + -return -endif
  {$1+1},{$1+1},{$1+1},1,'x' --f[-1] 'y' --f[-1] 'z' -a[-3--1] c -r[-1] {w*h*d},1,1,3,-1
  -f[-1] 'R=i(x,0,0,0);G=i(x,0,0,1);B=i(x,0,0,2);if(min(R,G,B),-1,i)'
  -permute[-1] cxyz -discard[-1] -1 -r[-1] 3,{h/3},1,1,-1 -permute[-1] yzcx
  -r[-2] {w*100}% -r[-1] [-2],0,2 -+[-2,-1]
  -f[-1] 'R=i(x,0,0,0);G=i(x,0,0,1);B=i(x,0,0,2);if(max(R,G,B)>2^$3-1,-1,i)'
  -permute[-1] cxyz -discard[-1] -1 -r[-1] 3,{h/3},1,1,-1 -permute[-1] yzcx
  -n[-1] 0,255
  --srgb2rgb[-1] -rgb2lab[-1] -rv[-2,-1] -a[-2,-1] y -sort[-1] +,x  # Sort by increasing lightness.
  -if {!$2} -rows[-1] 1
  -else # Add perceptual constraint if requested.

    # Constraint 1 : keep colors close enough to equivalent 'pure' grays.
    -s[-1] y -rv[-2,-1] [-1] -sh[-1] 1,2 -f[-1] 0 -rm[-1] --[-2,-1] -norm[-1]
    -<=[-1] $2 -*[-1] 'x+1' -discard[-1] 0 --[-1] 1 -map[-1] [-2] -rm[-2]

    # Constraint 2 : remove neighboring colors that are above the JND.
    -repeat 10000
      --srgb2rgb[-1] -rgb2lab[-1] --shift[-1] 0,{1-2*($>%2)},0,0,1 --[-2,-1] -norm[-1]
      -<=[-1] $2
      -if {im} -rm[-1] -break -endif
      -*[-1] 'y+1' -discard[-1] 0 --[-1] 1 -map[-1] [-2] -rm[-2]
    -done
    -transpose[-1]

  -endif
  -v +

#@gmic replace_color : tolerance[%]>=0,smoothness[%]>=0,src1,src2,...,dest1,dest2,...
#@gmic : Replace pixels from/to specified colors in selected images.
#@gmic : $ image.jpg --replace_color 40,3,204,153,110,255,0,0
replace_color : -check "$1>=0 && $2>=0"
  -v - -l[] (${3--1}) -y c -s c,2 col1=@0 col2=@1 -rm -endl -v +
  -e[^-1] "Replace color ("$col1") by color ("$col2") in image$?, with tolerance $1 and smoothness $2."
  -v - -repeat @# -l[$>]
    1,1,1,100%,$col1 -r[1] [0]
    -if $1 --[1] [0] -norm[1] -<=[1] $1 -else -==[1] [0] -l[1] -s c -and -endl -endif
    -b[1] $2
    1,1,1,@{0,s},$col2 -r[2] [0] -j[0] [2],0,0,0,0,1,[1] -k[0]
  -endl -done -v +

#@gmic rgb2bayer : _start_pattern=0,_color_grid=0
#@gmic : Transform selected color images to RGB-Bayer sampled images.
#@gmic : Default values: 'start_pattern=0' and 'color_grid=0'.
#@gmic : $ image.jpg --rgb2bayer 0
rgb2bayer : -skip ${1=0},${2=0}
  -e[^-1] "Transform image$? to a RGB-Bayer "@{-arg\ 1+!$2,color,monochrome}" grid, starting from pattern '$1'."
  -v - -to_rgb -repeat @# -l[$>]
    -_rgb2bayer$1 -r[1] [0],0,2 -* -if {!$2} -s c -+ -endif
  -endl -done -v +

_rgb2bayer0 : (1,0;0,0^0,1;1,0^0,0;0,1)
_rgb2bayer1 : (0,0;0,1^0,1;1,0^1,0;0,0)
_rgb2bayer2 : (0,1;0,0^1,0;0,1^0,0;1,0)
_rgb2bayer3 : (0,0;1,0^1,0;0,1^0,1;0,0)

#@gmic rgb2cmy
#@gmic : Convert selected images from RGB to CMY colorbases.
#@gmic : $ image.jpg -rgb2cmy -split c
rgb2cmy :
  -e[^-1] "Convert image$? from RGB to CMY color bases."
  -v - -to_rgb -c 0,255 -* -1 -+ 255 -v +

#@gmic rgb2cmyk
#@gmic : Convert selected images from RGB to CMYK colorbases.
#@gmic : $ image.jpg -rgb2cmyk -split c
#@gmic : $ image.jpg -rgb2cmyk -split c -fill[3] 0 -append c -cmyk2rgb
rgb2cmyk :
  -e[^-1] "Convert image$? from RGB to CMYK color bases."
  -v - -rgb2cmy -repeat @# -l[$>]
    -s c --min --[0-2] [-1] --/[-1] 255 --[-1] 1 -*[-1] -1 --==[-1] 0 -+[-2,-1]
    -/[0-2] [-1] -rm[-1] -a c
  -endl -done -v +

#@gmic rgb2hsi : (+)
#@gmic : Convert selected images from RGB to HSI colorbases.
#@gmic : $ image.jpg -rgb2hsi -split c

#@gmic rgb2hsi8
#@gmic : Convert selected images from RGB to HSI8 color bases.
#@gmic : $ image.jpg -rgb2hsi8 -split c
rgb2hsi8 :
  -e[^-1] "Convert image$? from RGB to HSI8 color bases."
  -v - -rgb2hsi -_rgb2hsx8 -v +

#@gmic rgb2hsl : (+)
#@gmic : Convert selected images from RGB to HSL colorbases.
#@gmic : $ image.jpg -rgb2hsl -split c
#@gmic : $ image.jpg -rgb2hsl --split c -add[-3] 100 -mod[-3] 360 -append[-3--1] c -hsl2rgb

#@gmic rgb2hsl8
#@gmic : Convert selected images from RGB to HSL8 color bases.
#@gmic : $ image.jpg -rgb2hsl8 -split c
rgb2hsl8 :
  -e[^-1] "Convert image$? from RGB to HSL8 color bases."
  -v - -rgb2hsl -_rgb2hsx8 -v +

#@gmic rgb2hsv : (+)
#@gmic : Convert selected images from RGB to HSV colorbases.
#@gmic : $ image.jpg -rgb2hsv -split c
#@gmic : $ image.jpg -rgb2hsv --split c -add[-2] 0.3 -cut[-2] 0,1 -append[-3--1] c -hsv2rgb

#@gmic rgb2hsv8
#@gmic : Convert selected images from RGB to HSV8 color bases.
#@gmic : $ image.jpg -rgb2hsv8 -split c
rgb2hsv8 :
  -e[^-1] "Convert image$? from RGB to HSV8 color bases."
  -v - -rgb2hsv -_rgb2hsx8 -v +

_rgb2hsx8 :
  -repeat @#
    -sh[$>] 0,0 -*[-1] 0.708333 -rm[-1]
    -sh[$>] 1,2 -*[-1] 255 -rm[-1]
  -done

#@gmic rgb2lab : (+)
#@gmic : Convert selected images from RGB to Lab colorbases.
#@gmic : $ image.jpg -rgb2lab -split c
#@gmic : $ image.jpg -rgb2lab --split c -mul[-2,-1] 2.5 -append[-3--1] c -lab2rgb

#@gmic rgb2lab8
#@gmic : Convert selected images from RGB to Lab8 color bases.
#@gmic : $ image.jpg -rgb2lab8 -split c
rgb2lab8 :
  -e[^-1] "Convert image$? from RGB to Lab8 color bases."
  -v - -rgb2lab -repeat @#
    -sh[$>] 0,0 -*[-1] 2.55 -rm[-1]
    -sh[$>] 1,1 -+[-1] 100 -*[-1] 1.275 -rm[-1]
    -sh[$>] 2,2 -+[-1] 110 -*[-1] 1.15909 -rm[-1]
  -done -v +

#@gmic rgb2lch
#@gmic : Convert selected images from RGB to Lch color bases.
#@gmic : $ image.jpg -rgb2lch -split c
rgb2lch :
  -e[^-1] "Convert image$? from RGB to Lch color bases."
  -v - -rgb2lab -lab2lch -v +

#@gmic rgb2lch8
#@gmic : Convert selected images from RGB to Lch8 color bases.
#@gmic : $ image.jpg -rgb2lch8 -split c
rgb2lch8 :
  -e[^-1] "Convert image$? from RGB to Lch8 color bases."
  -v - -rgb2lch -repeat @#
    -sh[$>] 0,0 -*[-1] 2.55 -rm[-1]
    -sh[$>] 1,1 -*[-1] 1.88889 -rm[-1]
    -sh[$>] 2,2 -+[-1] 3.14159 -*[-1] 40.5845 -rm[-1]
  -done -v +

#@gmic rgb2luv
#@gmic : Convert selected images from RGB to LUV color bases.
#@gmic : $ image.jpg -rgb2luv -split c
rgb2luv :
  -e[^-1] "Convert image$? from RGB to LUV color bases."
  -v - -repeat @# -l[$>]
    --rgb2xyz -rgb2lab[-2] -channels[-2] 0 -s[-1] c
    -*[-1] 3 --*[-2] 15 -+[-2,-1] -+[-1] [-3] -+[-1] 1e-8  # Z <- X+15Y+3Z
    -*[-3] 4 -*[-2] 9 -/[-3,-2] [-1] -rm[-1]
    --[-2] 0.2009 --[-1] 0.4610
    --*[-3] 13 -*[-3] [-1] -*[-2,-1] -a c
  -endl -done -v +

#@gmic rgb2int
#@gmic : Convert selected images from RGB to INT24 scalars.
#@gmic : $ image.jpg -rgb2int
rgb2int :
  -e[^-1] "Convert image$? from RGB to INT24 scalars."
  -v - -to_rgb -round -repeat @# -l[$>]
    -s c -<<[0] 16 -<<[1] 8 -+
  -endl -done -v +

#@gmic rgb2srgb : (+)
#@gmic : Convert selected images from RGB to sRGB colorbases.

#@gmic rgb2xyz
#@gmic : Convert selected images from RGB to XYZ colorbases.
#@gmic : the D65 illuminant is used as the white point).
#@gmic : $ image.jpg -rgb2xyz -split c
rgb2xyz :
  -e[^-1] "Convert image$? from RGB to XYZ color bases."
  -v - -/ 255 -mix_rgb 0.412453,0.357580,0.180423,0.212671,0.715160,0.072169,0.019334,0.119193,0.950227 -v +

#@gmic rgb2xyz8
#@gmic : Convert selected images from RGB to XYZ8 color bases.
#@gmic : $ image.jpg -rgb2xyz8 -split c
rgb2xyz8 :
  -e[^-1] "Convert image$? from RGB to XYZ8 color bases."
  -v - -rgb2xyz -repeat @#
    -sh[$>] 0,0 -*[-1] 255 -rm[-1]
    -sh[$>] 1,1 -*[-1] 255 -rm[-1]
    -sh[$>] 2,2 -*[-1] 231.8182 -rm[-1]
  -done -v +

#@gmic rgb2ycbcr
#@gmic : Convert selected images from RGB to YCbCr colorbases.
#@gmic : $ image.jpg -rgb2ycbcr -split c
rgb2ycbcr :
  -e[^-1] "Convert image$? from RGB to YCbCr color bases."
  -v - -mix_rgb 66,129,25,-38,-74,112,112,-94,-18 -+ 128 -/ 256
  -repeat @# -l[$>] -sh 0,0 -+[-1] 16 -rm[-1] -sh 1,2 -+[-1] 128 -rm[-1] -endl -done
  -v +

#@gmic rgb2yuv
#@gmic : Convert selected images from RGB to YUV colorbases.
#@gmic : $ image.jpg -rgb2yuv -split c
rgb2yuv :
  -e[^-1] "Convert image$? from RGB to YUV color bases."
  -v - -/ 255 -mix_rgb 0.299,0.587,0.114,-0.14713,-0.28886,0.436,0.615,-0.51498,-0.10001 -v +

#@gmic rgb2yuv8
#@gmic : Convert selected images from RGB to YUV8 color bases.
#@gmic : $ image.jpg -rgb2yuv8 -split c
rgb2yuv8 :
  -e[^-1] "Convert image$? from RGB to YUV8 color bases."
  -v - -rgb2yuv -repeat @#
    -sh[$>] 0,0 -*[-1] 255 -rm[-1]
    -sh[$>] 1,1 -+[-1] 0.44 -*[-1] 289.773 -rm[-1]
    -sh[$>] 2,2 -+[-1] 0.62 -*[-1] 205.645 -rm[-1]
  -done -v +

#@gmic remove_opacity
#@gmic : Remove opacity channel of selected images.
remove_opacity :
  -e[^-1] "Remove opacity channel of image$?."
  -v - -repeat @# -l[$>]
    -if {s==2} -channels 0
    -elif {s==4} -channels 0,2
    -endif
  -nm @{-1,n},1 -endl -done -v +

#@gmic select_color : tolerance[%]>=0,col1,..,colN
#@gmic : Select pixels with specified color in selected images.
#@gmic : $ image.jpg --select_color 40,204,153,110
#@gmic : $$
select_color : -skip ${1=0}
  -e[^-1] "Select color (${2--1}) in image$?, with tolerance $1."
  -v - -repeat @# -l[$>]
    --fc ${2--1} -- -norm -<= $1
  -endl -done -v +

#@gmic sepia
#@gmic : Apply sepia tones effect on selected images.
#@gmic : $ image.jpg --sepia
sepia :
  -e[^-1] "Apply sepia tones effect on image$?."
  -v - (0,44,115,143,196,244^0,20,84,119,184,235^0,5,44,73,144,200) -r[-1] 256,1,1,3,3
  -repeat {@#-1} -l[$>,-1] -split_opacity -luminance[0] -map[0] [-1] -a[^-1] c -endl -done
  -rm[-1] -v +

#@gmic solarize
#@gmic : Solarize selected images.
#@gmic : $ image.jpg --solarize
solarize :
  -e[^-1] "Solarize image$?."
  -v - -luminance -n 0,128 -map 1 -v +

#@gmic split_opacity
#@gmic : Split color and opacity parts of selected images.
split_opacity :
  -e[^-1] "Split color and opacity parts of image$?."
  -v - -repeat @# -l[$<] -s c,{if(s==4,-3,if(s==2,-1,-s))} -endl -done -v +

#@gmic srgb2rgb : (+)
#@gmic : Convert selected images from sRGB to RGB colorbases.

#@gmic to_a
#@gmic : Force selected images to have an alpha channel.
to_a :
  -e[^-1] "Force image$? to have an alpha channel."
  -v - -repeat @# -l[$>]
    -if {s==1||s==3} -channels 0,{s} -sh[-1] {s-1},{s-1} -f[-1] 255 -rm[-1] -endif
  -endl -done -v +

#@gmic to_color
#@gmic : Force selected images to be in color mode (RGB or RGBA).
to_color :
  -e[^-1] "Force image$? to be in color mode."
  -v - -repeat @# -l[$>]
    -if {s>4} -error[] "Command '-to_color': Image ["@{<,-1}"] is not a G,GA,RGB or RGBA image."
    -elif {s==2} -r 100%,100%,1,4,0,1,0,0,0,1
    -elif {s==1} -r 100%,100%,1,3,1
    -endif
  -endl -done -v +

#@gmic to_colormode : mode={ 0=adaptive | 1=G | 2=GA | 3=RGB | 4=RGBA }
#@gmic : Force selected images to be in a given color mode.
#@gmic : Default value: 'mode=0'.
to_colormode : -skip ${1=0}
  -if {$1==1} -to_gray
  -elif {$1==2} -to_graya
  -elif {$1==3} -to_rgb
  -elif {$1==4} -to_rgba
  -else
    s=1 -repeat @#
      -if {@{$>,s}>4} -error "Command '-to_colormode': Image ["$>"] is not a G,GA,RGB or RGBA image."
      -else s={max($s,@{$>,s})}
      -endif
    -done -to_colormode $s
  -endif

#@gmic to_gray
#@gmic : Force selected images to be in GRAY mode.
#@gmic : $ image.jpg --to_gray
to_gray :
  -e[^-1] "Force image$? to be in GRAY mode."
  -v - -repeat @# -l[$>]
    -if {s>4} -error[] "Command '-to_gray': Image ["@{<,-1}"] is not a G,GA,RGB or RGBA image."
    -elif {s>=3} -channels 0,2 -luminance
    -elif {s==2} -r 100%,100%,100%,1,0
    -endif
  -endl -done -v +

#@gmic to_graya
#@gmic : Force selected images to be in GRAYA mode.
to_graya :
  -e[^-1] "Force image$? to be in GRAYA mode."
  -v - -repeat @# -l[$>]
    -if {s>4} -error[] "Command '-to_graya': Image ["@{<,-1}"] is not a G,GA,RGB or RGBA image."
    -elif {s==4} --channels 3 -channels[-2] 0,2 -luminance[-2] -a c
    -elif {s==3} -luminance -channels 0,1 -sh[-1] 1,1 -f[-1] 255 -rm[-1]
    -elif {s==1} -channels 0,1 -sh[-1] 1,1 -f[-1] 255 -rm[-1]
    -endif
  -endl -done -v +

#@gmic to_pseudogray : _max_step>=0,_is_perceptual_constraint={ 0 | 1 },_bits_depth>0
#@gmic : Convert selected scalar images ([0-255]-valued) to pseudo-gray color images.
#@gmic : Default parameters : 'max_step=5', 'is_perceptual_constraint=1' and 'bits_depth=8'.
#@gmic : The original pseudo-gray technique has been introduced by Rich Franzen [http://r0k.us/graphics/pseudoGrey.html].
#@gmic : Extension of this technique to arbitrary increments for more tones, has been done by David Tschumperle.
to_pseudogray : -check "isint(${1=5}) && $1>=0 && isint(${3=8}) && $3>0" -skip ${2=1}
  -e[^-1] "Convert scalar image$? to pseudo-gray color images, with steps $1."
  -v - -channels 0 -srgb2rgb -pseudogray $1,{2.3*$2},$3

  # Compute colormap with 65336 entries, to have match corresponding lightness.
  --srgb2rgb[-1] -rgb2lab[-1] -channels[-1] 0 -*[-1] {65535/100} -round[-1] -rows[-1] 0,2
  -rv[-2,-1] -permute[-1] xcyz -+[-1] 1 -a[-2,-1] y -pointcloud[-1] 0
  --norm[-1] -!=[-1] 0 -distance[-1] 1 -*[-1] -1 -watershed[-2] [-1] -rm[-1] --[-1] 1

  # Map colormap to images, with lightness preservation.
  -repeat {@#-1}
    -to_rgb[$>] -rgb2lab[$>] -channels[$>] 0 -*[$>] {65535/100} -round[$>] -c[$>] 0,65535
    -map[$>] [-1]
  -done -rm[-1] -v +

#@gmic to_rgb
#@gmic : Force selected images to be in RGB mode.
to_rgb :
   -e[^-1] "Force image$? to be in RGB mode."
   -v - -repeat @# -l[$>]
     -if {s>4} -error[] "Command '-to_rgb': Image ["@{<,-1}"] is not a G,GA,RGB or RGBA image."
     -elif {s==4} -channels 0,2
     -elif {s==2} -channels 0,0 -r 100%,100%,100%,3
     -elif {s==1} -r 100%,100%,100%,3
     -endif
   -endl -done -v +

#@gmic to_rgba
#@gmic : Force selected images to be in RGBA mode.
to_rgba :
   -e[^-1] "Force image$? to be in RGBA mode."
   -v - -repeat @# -l[$>]
     -if {s>4} -error[] "Command '-to_rgba': Image ["@{<,-1}"] is not a G,GA,RGB or RGBA image."
     -elif {s==3} -channels 0,3 -sh[-1] 3,3 -f[-1] 255 -rm[-1]
     -elif {s==2} -r 100%,100%,100%,4 -sh[-1] 2,2 -f[-1] [-2] -rm[-1]
     -elif {s==1} -r 100%,100%,100%,4 -sh[-1] 3,3 -f[-1] 255 -rm[-1]
     -endif
   -endl -done -v +

#@gmic transfer_colors : [reference_image],_transfer_brightness={ 0 | 1 }
#@gmic : Transfer colors of the specified reference image to selected images.
#@gmic : Default value: 'transfer_brightness=0'.
#@gmic : $ image.jpg --rand 0,255 --transfer_colors[0] [1],1
transfer_colors : -skip ${1=0}
  -e[^-1] "Transfer colors of image $1 to image$?."
  -v - -pass$1 0 -mv[-1] 0 -to_rgb[0] -to_colormode[^0] {max(3,@{-max_s})} -c 0,255      # Convert all images to RGB[A]
  -repeat @# -l[$>] -split_opacity -rgb2ycbcr[0] -a c -endl -done    # Perform RGB[A] to YCbCr[A] conversion.
  -l[0] -s c -histogram_cumul 256,1,0,255 -a c -* 255 -endl          # Compute channel-by-channel cumulative histogram of target image.
  -repeat {@#-1} -l[0,{$<+1}]
    -if $1 -repeat 3 -sh[0,1] $>,$> -equalize[-1] 256,0,255 -index[-1] [-2],0,0 -rm[-2,-1] -done         # Transfer brightness + colors.
    -else -repeat 2 -sh[0,1] {$>+1},{$>+1} -equalize[-1] 256,0,255 -index[-1] [-2],0,0 -rm[-2,-1] -done  # Transfer colors only.
    -endif
  -endl -done -rm[0]
  -repeat @# -l[$>] -split_opacity -ycbcr2rgb[0] -a c -endl -done    # Perform YCbCr[A] to RGB[A] conversion.
  -v +

_transfer_colors :  # Check transfer_colors performance.
  -repeat @# -l[$>] -rgb2ycbcr -s c -histogram 256,0,255 -a c -dg 300,200 -endl -done

#@gmic xyz2rgb
#@gmic : Convert selected images from XYZ to RGB colorbases.
xyz2rgb :
  -e[^-1] "Convert image$? from XYZ to RGB color bases."
  -v - -* 255 -mix_rgb 3.240479,-1.537150,-0.498535,-0.969256,1.875992,0.041556,0.055648,-0.204043,1.057311 -c 0,255 -v +

#@gmic xyz82rgb
#@gmic : Convert selected images from XYZ8 to RGB color bases.
xyz82rgb :
  -e[^-1] "Convert image$? from XYZ8 to RGB color bases."
  -v - -repeat @#
    -sh[$>] 0,0 -/[-1] 255 -rm[-1]
    -sh[$>] 1,1 -/[-1] 255 -rm[-1]
    -sh[$>] 2,2 -/[-1] 231.8182 -rm[-1]
  -done -xyz2rgb -v +

#@gmic ycbcr2rgb
#@gmic : Convert selected images from YCbCr to RGB colorbases.
ycbcr2rgb :
  -e[^-1] "Convert image$? from YCbCr to RGB color bases."
  -v - -repeat @# -l[$>] -sh 0,0 --[-1] 16 -rm[-1] -sh 1,2 --[-1] 128 -rm[-1] -endl -done
  -mix_rgb 298,0,409,298,-100,-208,298,516,0 -+ 128 -/ 256 -c 0,255
  -v +

#@gmic yuv2rgb
#@gmic : Convert selected images from YUV to RGB colorbases.
yuv2rgb :
  -e[^-1] "Convert image$? from YUV to RGB color bases."
  -v - -mix_rgb 1,0,1.13983,1,-0.39465,-0.5806,1,2.03211,0 -* 255 -v +

#@gmic yuv82rgb
#@gmic : Convert selected images from YUV8 to RGB color bases.
yuv82rgb :
  -e[^-1] "Convert image$? from YUV8 to RGB color bases."
  -v - -repeat @#
    -sh[$>] 0,0 -/[-1] 255 -rm[-1]
    -sh[$>] 1,1 -/[-1] 289.773 --[-1] 0.44 -rm[-1]
    -sh[$>] 2,2 -/[-1] 205.645 --[-1] 0.62 -rm[-1]
  -done -yuv2rgb -v +

#---------------------------------
#
#@gmic :: Geometry manipulation
#
#---------------------------------

#@gmic a : eq. to '-append' : (+)

#@gmic append : [image],axis,_centering : axis,_centering : (+)
#@gmic : Append specified image to selected images, or all selected images together, along specified axis.
#@gmic : (eq. to '-a').
#@gmic : 'axis' can be { x | y | z | c }.
#@gmic : Usual 'centering' values are { 0=left-justified | 0.5=centered | 1=right-justified }.
#@gmic : Default value: 'centering=0'.
#@gmic : $ image.jpg -split y,10 -reverse -append y
#@gmic : $ image.jpg -repeat 5 --rows[0] 0,{10+18*$>}% -done -remove[0] -append x,0.5
#@gmic : $ image.jpg -append[0] [0],y

#@gmic append_tiles : _M>=0,_N>=0,0<=_centering_x<=1,0<=_centering_y<=1
#@gmic : Append MxN selected tiles as new images.
#@gmic : If 'N' is set to 0, number of rows is estimated automatically.
#@gmic : If 'M' is set to 0, number of columns is estimated automatically.
#@gmic : If 'M' and 'N' are both set to '0', auto-mode is used.
#@gmic : If 'M' or 'N' is set to 0, only a single image is produced.
#@gmic : 'centering_x' and 'centering_y' tells about the centering of tiles when they have different sizes.
#@gmic : Default values: 'M=0', 'N=0', 'centering_x=centering_y=0.5'.
#@gmic : $ image.jpg -split xy,4 -append_tiles ,
append_tiles : -check "isint(${1=0}) && isint(${2=0}) && ${3=0.5}>=0 && $3<=1 && ${4=$3}>=0 && $4<=1"
  -if {!@#} -e[0--3] "Append image$? as a 0x0-tiled image." -return -endif
  -if {!$1&&!$2} # auto-mode
    -v - N={int(sqrt(@#))} M={round(@#/$N,1,1)}
    -v + -e[0--3] "Append image$? as a "${M}x${N}"-tiled image (auto-mode)." -v -
    MN={$M*$N} -if {@#%$MN} {$MN-(@#%$MN)} -s[-1] x -endif
  -elif {!$2} # auto-rows
    -v - M=$1 N={round(@#/$1,1,1)}
    -v + -e[0--3] "Append image$? as a "${M}x${N}"-tiled image." -v -
    -if {$M>@#} -v + -warn[0--3] "Missing images for having one row in a "${M}x${N}"-tiled image." -return -endif
    -if {@#%$M} {$M-(@#%$M)} -s[-1] x -endif
  -elif {!$1} # auto-columns
    -v - M={round(@#/$2,1,1)} N=$2
    -v + -e[0--3] "Append image$? as a "${M}x${N}"-tiled image." -v -
    -if {$N>@#} -v + -warn[0--3] "Missing images for having one column in a "${M}x${N}"-tiled image." -return -endif
    -if {@#%$M} {$M-(@#%$M)} -s[-1] x -endif
  -else
    -e[0--3] "Append image$?, as $1x$2-tiled images." -v -
    M=$1 N=$2
  -endif

  MN={$M*$N}
  -repeat {int(@#/$MN)} -l[$>-{$>+$MN-1}]

    # Resize to best match for each column and row.
    $MN,1,1,2 -repeat $MN -point[-1] $>,0,0,1,@{$>,w},@{$>,h} -done -r[-1] $M,$N,1,2,-1
    -s[-1] c -l[-2] -s y -max -endl -l[-1] -s x -max -endl
    i=0 -repeat $N y=$> -repeat $M -r[$i] @{-2,$>},@{-1,$y},100%,100%,0,0,$3,$4 i={$i+1} -done -done
    -rm[-2,-1]

    # Append images together.
    -repeat {int(@#/$M)} -a[$>-{$>+$M-1}] x -done
    -repeat {int(@#/$N)} -a[$>-{$>+$N-1}] y -done
  -endl -done
  -v +

#@gmic autocrop : value1,value2,... : (no arg) : (+)
#@gmic : Autocrop selected images by specified vector-valued intensity.
#@gmic : If no arguments are provided, cropping value is guessed.
#@gmic : $ 400,400,1,3 -fill_color 64,128,255 -ellipse 50%,50%,120,120,0,1,255 --autocrop

#@gmic autocrop_components : _threshold[%],_min_area[%]>=0,_is_high_connectivity={ 0 | 1 },_output_type={ 0=crop | 1=segmentation | 2=coordinates }
#@gmic : Autocrop and extract connected components in selected images, according to a mask given as the last channel of
#@gmic : each of the selected image (e.g. alpha-channel).
#@gmic : Default values: 'threshold=0%', 'min_area=0.1%', 'is_high_connectivity=0' and 'output_type=1'.
#@gmic : $ 256,256 -noise 0.1,2 -dilate_circ 20 -label_fg 0,1 -normalize 0,255 --neq 0 -*[-1] 255 -append c --autocrop_components ,
autocrop_components : -skip ${1=0%} -check "${2=0.1%}>=0 && isbool(${3=0}) && isint(${4=1}) && $4>=0 && $4<=2"
  -e[^-1] "Autocrop connected components from image$?, with threshold $1, minimal area $2, "@{-arg\ 1+$3,low,high}" connectivity "\
          "and output type set to '"@{-arg\ 1+$4,crop,segmentation,coordinates}"'.\n"
  -v - -repeat @# -l[$>]
    min_area={max(1,round(if(@{-is_percent\ $2},$2*w*h,$2)))}
    --channels 100% ->[-1] $1 -area_fg[-1] 0,$3 ->=[-1] $min_area  # Discard background and small objects.
    --area[-1] 0,1 -<[-1] $min_area -or[-2,-1] -label_fg[-1] 0,1   # Fill small holes in objects.

    # Extract detected objects.
    N={iM} -repeat {iM}
      n={1+$>}
      -v + -e[] "\r  > "$n/$N -v -
      -rprogress {100*$n/$N}
      --==[1] $n --*[0,-1] -rm[-2]
      -if {$4==0} coords=@{-autocrop_coords[-1]\ auto} -rm[-1] --z[0] $coords
      -elif {$4==1} -autocrop[-1]
      -else coords=@{-autocrop_coords[-1]\ auto} -rm[-1] ($coords) -y[-1]
      -endif
    -done
    -rm[0,1]
    -if {!@#} 0 -endif
    -if {$4==2} -a x -endif
  -endl -done -v +

#@gmic autocrop_seq : value1,value2,... | auto
#@gmic : Autocrop selected images using the crop geometry of the last one by specified vector-valued intensity,
#@gmic : or by automatic guessing the cropping value.
#@gmic : Default value: auto mode.
#@gmic : $ image.jpg --fill[-1] 0 -ellipse[-1] 50%,50%,30%,20%,0,1,1 -autocrop_seq 0
autocrop_seq : -skip ${1=auto}
  -e[^-1] "Auto-crop image$? using crop geometry of last image by vector '$*'."
  -if {!@#} -return -endif
  -v -
  -if {@#==1} -_autocrop$is_auto ${1--1} -v + -return -endif
  coords=@{-autocrop_coords[-1]\ ${1--1}}
  x0={arg(1,$coords)} y0={arg(2,$coords)} z0={arg(3,$coords)}
  x1={arg(4,$coords)} y1={arg(5,$coords)} z1={arg(6,$coords)}
  -if {$x0>$x1" || "$y0>$y1" || "$z0>$z1} -i[0--2] 0 -rm[1--1:2]
  -else -z $x0,$y0,$z0,$x1,$y1,$z1
  -endif
  -v +

#@gmic channels : { [image0] | c0[%] },_{ [image1] | c1[%] } : (+)
#@gmic : Keep only specified channels of selected images.
#@gmic : Dirichlet boundary is used when specified channels are out of range.
#@gmic : $ image.jpg -channels 0,1
#@gmic : $ image.jpg -luminance -channels 0,2

#@gmic columns : { [image0] | x0[%] },_{ [image1] | x1[%] } : (+)
#@gmic : Keep only specified columns of selected images.
#@gmic : Dirichlet boundary is used when specified columns are out of range.
#@gmic : $ image.jpg -columns -25%,50%

#@gmic z : eq. to '-crop'. : (+)

#@gmic crop : x0[%],x1[%],_boundary : x0[%],y0[%],x1[%],y1[%],_boundary : x0[%],y0[%],z0[%],x1[%],y1[%],z1[%],_boundary : x0[%],y0[%],z0[%],c0[%],x1[%],y1[%],z1[%],c1[%],_boundary : (no arg) : (+)
#@gmic : Crop selected images with specified region coordinates.
#@gmic : (eq. to '-z').
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : (no arg) runs interactive mode (uses the instant window [0] if opened).
#@gmic : Default value: 'boundary=0'.
#@gmic : $ image.jpg --crop -230,-230,280,280,1 -crop[0] -230,-230,280,280,0
#@gmic : $ image.jpg -crop 25%,25%,75%,75%

#@gmic diagonal
#@gmic : Transform selected vectors as diagonal matrices.
#@gmic : $ 1,10,1,1,'y' --diagonal
diagonal :
  -e[^-1] "Transform vector$? as diagonal matrix."
  -v - -y -repeat @# -r[$>] @{$>,h+1},100%,1,1,0 -r[$>] @{$>,h},100%,1,1,-1 -done -v +

#@gmic elevate : _depth,_is_plain,_is_colored
#@gmic : Elevate selected 2d images into 3d volumes.
#@gmic : Default values: 'depth=64', 'is_plain=1' and 'is_colored=1'.
elevate : -check "${1=64}>0" -skip ${2=1},${3=1}
  -e[^-1] "Elevate 2d image$? into $1-slices volume(s)."
  -v - -r 100%,100%,1,100%
  -repeat @# -l[$>] nm=@{0,n}
    --norm 100%,100%,$1,{if($3,@{0,s},1)}
    m=@{-2,m} d={@{-2,M}-$m}
    -repeat $1
      -if $2 -->=[1] {$m+$d*($>+1)/$1}
      -else --ir[1] {$m+$d*$>/$1},{$m+$d*($>+1)/$1}
      -endif
      -r[-1] 100%,100%,1,[-2] -if $3 -*[-1] [0] -endif
      -j[-2] [-1],0,0,$> -rm[-1]
    -done
  -rm[0,1] -nm $nm,1 -endl -done -v +

#@gmic expand_x : size_x>=0,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Expand selected images along the x-axis.
#@gmic : Default value: 'border=1'.
#@gmic : $ image.jpg -expand_x 30,0
expand_x : -check "$1>=0 && ${2=1}>=0 && $2<=2"
  -e[^-1] "Expand image$? along the x-axis with size $1 and border conditions $2."
  -v - -repeat @# -r[$>] @{$>,w+2*$1},100%,100%,100%,0,$2,0.5,0.5,0.5 -done -v +

#@gmic expand_xy : size>=0,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Expand selected images along the xy-axes.
#@gmic : Default value: 'border=1'.
#@gmic : $ image.jpg -expand_xy 30,0
expand_xy : -check "$1>=0 && ${2=1}>=0 && $2<=2"
  -e[^-1] "Expand image$? along the xy-axes with size $1 and border conditions $2."
  -v - -repeat @# -r[$>] @{$>,w+2*$1},@{$>,h+2*$1},100%,100%,0,$2,0.5,0.5,0.5 -done -v +

#@gmic expand_xyz : size>=0,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Expand selected images along the xyz-axes.
#@gmic : Default value: 'border=1'.
expand_xyz : -check "$1>=0 && ${2=1}>=0 && $2<=2"
  -e[^-1] "Expand image$? along the xyz-axes with size $1 and border conditions $2."
  -v - -repeat @# -r[$>] @{$>,w+2*$1},@{$>,h+2*$1},@{$>,d+2*$1},100%,0,$2,0.5,0.5,0.5 -done -v +

#@gmic expand_y : size_y>=0,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Expand selected images along the y-axis.
#@gmic : Default value: 'border=1'.
#@gmic : $ image.jpg -expand_y 30,0
expand_y : -check "$1>=0 && ${2=1}>=0 && $2<=2"
  -e[^-1] "Expand image$? along the y-axis with size $1 and border conditions $2."
  -v - -repeat @# -r[$>] 100%,@{$>,h+2*$1},100%,100%,0,$2,0.5,0.5,0.5 -done -v +

#@gmic expand_z : size_z>=0,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Expand selected images along the z-axis.
#@gmic : Default value: 'border=1'.
expand_z : -check "$1>=0 && ${2=1}>=0 && $2<=2"
  -e[^-1] "Expand image$? along the z-axis with size $1 and border conditions $2."
  -v - -repeat @# -r[$>] 100%,100%,@{$>,d+2*$1},100%,0,$2,0.5,0.5,0.5 -done -v +

#@gmic montage : "_layout_code",_montage_mode={ 0<=centering<=1 | 2<=scale+2<=3 },_output_mode={ 0=single layer | 1=multiple layers },"_processing_command"
#@gmic : Create a single image montage from selected images, according to specified layout code :
#@gmic : - 'X' to assemble all images using an automatically estimated layout.
#@gmic : - 'H' to assemble all images horizontally.
#@gmic : - 'V' to assemble all images vertically.
#@gmic : - 'A' to assemble all images as an horizontal array.
#@gmic : - 'B' to assemble all images as a vertical array.
#@gmic : - 'Ha:b' to assemble two blocks 'a' and 'b' horizontally.
#@gmic : - 'Va:b' to assemble two blocks 'a' and 'b' vertically.
#@gmic : - 'Ra' to rotate a block 'a' by 90 deg. ('RRa' for 180 deg. and 'RRRa' for 270 deg.).
#@gmic : - 'Ma' to mirror a block 'a' along the X-axis ('MRRa' for the Y-axis).
#@gmic : A block 'a' can be an image indice (treated periodically) or a nested layout expression 'Hb:c','Vb:c','Rb' or 'Mb' itself.
#@gmic : For example, layout code 'H0:V1:2' creates an image where image [0] is on the left, and images [1] and [2] vertically packed on the right.
#@gmic : Default values: 'layout_code=X', 'montage_mode=2', output_mode='0' and 'processing_command=""'.
#@gmic : $ image.jpg -testimage2d 512 --plasma[0] -cupid 256 -normalize 0,255 -frame 3,3,0 -frame 10,10,255 -to_rgb --montage A --montage[^-1] H1:V0:VH2:1H0:3
montage : -check "isval(${2=2}) && $2>=0 && $2<=3" -skip "${1=X}",${3=0},"${4=}"
  -v -
  -if {$2<=1} -v + -e[0--3] "Create aligned montage from image$?, with layout code '$1' and centering $2."
  -else -v + -e[0--3] "Create scaled montage from image$?, with layout code '$1' and scale "{$2-2}"."
  -endif
  -v -

  # Manage automatic layout.
  -if {{"$1"'=='X}||{"$1"'=='x}} --l
    -repeat @# -nm[$>] $> -done
    -repeat {@#-1}
      -if {@{-2,w>h}" && "w>h} mode=V      # Both landscape.
      -elif {@{-2,h>w}" && "h>w} mode=H    # Both portrait.
      -elif {@{-2,w>h}" && "h>w} # Landscape - portrait.
        -if {@{-2,h/w}<(w/h)} mode=V -else mode=H -endif
      -else # Portrait - landscape.
        -if {@{-2,w/h}<(h/w)} mode=H -else mode=V -endif
      -endif
      name=$mode@{-2,n}:@{-1,n}
      -montage[-2,-1] $mode,$2
      -mv[-1] 0 -nm[0] $name
    -done
    layout=@{0,n}
    -rm -endl -montage $layout,$2,$3,"$4"

  -else # Non-automatic layout.

    # Format and check validity of layout code.
    N=@#
    -l[] _scode="$1" _mode=$2
      -if {{"$1"'=='H}||{"$1"'=='h}} -if {$N>1} {$N-1},1,1,1,-1 $N,1,1,1,x -a x -y -else -v + -return -endif # Simple horizontal montage.
      -elif {{"$1"'=='V}||{"$1"'=='v}} -if {$N>1} {$N-1},1,1,1,-2 $N,1,1,1,x -a x -y -else -v + -return -endif # Simple vertical montage.
      -elif {{"$1"'=='A}||{"$1"'=='a}||{"$1"'=='B}||{"$1"'=='b}} # Montage as an array.
        -if {$N<2} -v + -return -endif
        nr={round(sqrt($N))} nc={round($N/$nr,1,1)}              # Horizontal array.
        -if {{"$1"'=='B}||{"$1"'=='b}} n=$nr nr=$nc nc=$n -endif # Vertical array.
        $N,1,1,1,x -s x,-{round(w/$nr,1,1)} -repeat @# -l[$>] -if {w>1} -i[0] {w-1},1,1,1,-1 -a x -endif -endl -done -a x
        -if {$nr>1} -i[0] {$nr-1},1,1,1,-2 -a x -endif -y
      -else # Other complex montage.
        ({'"$1"'}) -f 'if(i==72||i==104,-1,if(i==86||i==118,-2,if(i==82||i==114,-3,if(i==77||i==109,-4,if(i>=48&&i<=57,i-48,-5)))))'
        -s +,-1 -s +,-2 -s +,-3 -s +,-4 -s +,-5
        -repeat @# -l[$>] -if {im>=0} --+[-1] 48 -=[-2] @{-1,t} -rm[-1] -rows 0 -endif -endl -done -a y -discard -5
      -endif
      -f 'if(i<0,i,i%$N)'
    -endl
    -if {@#==$N} -rm -v + -return -endif  # Empty layout code.
    -nm[^-1] 0 -repeat {h} c={i[$>]} -if {$c>=0} -if @{$c,n} -i[-2] [$c] i={@#-2} -=[-1] $i,0,$> ref$i=$c -else -nm[$c] 1 ref$c=$c -endif -endif -done # Duplicate multiple references.
    _code=@-1 _lcode={narg($_code)} -rm[-1]

    # Determine image positions and sizes.
    N=@# -repeat $N ($>,0,0,@{$>,w},@{$>,h},0,0,0) -done
    -l[$N--1] _p=1 -k[@{-_montage}] w={i[3]} h={i[4]} -f 'if(i(0,y)<0,-1,i)' -discard -1 -r 8,{h/8},1,1,-1 -endl

    # Render montage.
    -if {narg("$4")} -m "__montage : $4 -k[0]"
    -else
    -m "__montage : -if {$""7%2} -mirror x -endif -if {$""8%2} -mirror y -endif -rotate {90*$""6} -r {max(1,round($""4,1,1))},{max(1,round($""5,1,1))},1,100%,3"
    -endif
    s=@{-max_s[^-1]}
    -repeat {h}
      i={i(0,$>)} xi={i(1,$>)} yi={i(2,$>)} wi={i(3,$>)} hi={i(4,$>)} ai={i(5,$>)} mxi={i(6,$>)} myi={i(7,$>)}
      -if {$3||!$>} -i[-2] $w,$h,1,$s -endif
      -__montage[$i] ${ref$i},$xi,$yi,{max(1,$wi)},{max(1,$hi)},$ai,$mxi,$myi
      -j[-2] [$i],$xi,$yi
    -done
    -uncommand __montage
    -rm[0-{$N-1},-1]

  -endif
  -nm "[Montage '$1']"
  -v +

_montage :
  -if {$_p>$_lcode} -error "Command '-montage': Incomplete layout code '"$_scode"'." -endif
  c={arg($_p,$_code)}
  -if {$c>=0} _p={$_p+1} -u $c # Single indice.
  -elif {$c==-4} # Mirror.
    _p={$_p+1} l=@{-_montage} -f[$l] 'a=i(5,y)%2;if((x==7&&a)||(x==6&&!a),!i,if(x==1,i(3,0)-i(3,y)-i,i))' -u $l
  -elif {$c==-3} # Rotation.
    _p={$_p+1} l=@{-_montage} -l[$l] -s x -+[2] [4] -rv[1,2] -*[1] -1 -+[1] @{4,0} -rv[3,4] -+[5] 1 -a x -endl -u $l
  -else # Merge.
    _p={$_p+1}
    l=@{-_montage} lw=@{$l,3} lh=@{$l,4}
    r=@{-_montage} rw=@{$r,3} rh=@{$r,4}

    -if {$c==-1} # Horizontal merge.
      -if {$_mode<2}
        h={max($lh,$rh)} -+[$l] '0,0,{($h-$lh)*min(1,$_mode)},0,0,0,0,0' -+[$r] '0,$lw,{($h-$rh)*min(1,$_mode)},0,0,0,0,0'
      -else
        h={($_mode-2)*max($lh,$rh)+(3-$_mode)*min($lh,$rh)}
        lf={$h/$lh} rf={$h/$rh} lw={$lw*$lf} rw={$rw*$rf}
        -*[$l] '1,$lf,$lf,$lf,$lf,1,1,1' -*[$r] '1,$rf,$rf,$rf,$rf,1,1,1' -+[$r] '0,$lw,0,0,0,0,0,0'
      -endif
      -i[$l] (-1,0,0,{$lw+$rw},$h,0,0,0) -a[$l,{$l+1}] y -a[$l] [$r],y -r[$r] 1,1,1,1,0

    -else # Vertical merge.
      -if {$_mode<2}
        w={max($lw,$rw)} -+[$l] '0,{($w-$lw)*min(1,$_mode)},0,0,0,0,0,0' -+[$r] '0,{($w-$rw)*min(1,$_mode)},$lh,0,0,0,0,0'
      -else
        w={($_mode-2)*max($lw,$rw)+(3-$_mode)*min($lw,$rw)}
        lf={$w/$lw} rf={$w/$rw} lh={$lh*$lf} rh={$rh*$rf}
        -*[$l] '1,$lf,$lf,$lf,$lf,1,1,1' -*[$r] '1,$rf,$rf,$rf,$rf,1,1,1' -+[$r] '0,0,$lh,0,0,0,0,0'
      -endif
      -i[$l] (-1,0,0,$w,{$lh+$rh},0,0,0) -a[$l,{$l+1}] y -a[$l] [$r],y -r[$r] 1,1,1,1,0
    -endif
    -u $l
  -endif

#@gmic mirror : { x | y | z }..{ x | y | z } : (+)
#@gmic : Mirror selected images along specified axes.
#@gmic : $ image.jpg --mirror y --mirror[0] c
#@gmic : $ image.jpg --mirror x --mirror y -append_tiles 2,2

#@gmic permute : permutation_string : (+)
#@gmic : Permute selected image axes by specified permutation.
#@gmic : 'permutation' is a combination of the character set {x|y|z|c},
#@gmic : e.g. 'xycz', 'cxyz', ..
#@gmic : $ image.jpg -permute yxzc

#@gmic r : eq. to '-resize'. : (+)

#@gmic resize : [image],_interpolation,_boundary,_ax,_ay,_az,_ac : {[image_w] | width>0[%]},_{[image_h] | height>0[%]},_{[image_d] | depth>0[%]},_{[image_s] | spectrum>0[%]},_interpolation,_boundary,_ax,_ay,_az,_ac : (no arg) : (+)
#@gmic : Resize selected images with specified geometry.
#@gmic : (eq. to '-r').
#@gmic : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@gmic : 'boundary' has different meanings, according to the chosen 'interpolation' mode :
#@gmic : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary' is meaningless.
#@gmic : . When 'interpolation==0', 'boundary' can be { 0=dirichlet | 1=neumann | 2=periodic }.
#@gmic : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary' can be { 0=none | 1=neumann }.
#@gmic : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0 or 4'
#@gmic : (set to '0' by default, must be defined in range [0,1]).
#@gmic : (no arg) runs interactive mode (uses the instant window [0] if opened).
#@gmic : Default values: 'interpolation=1', 'boundary=0' and 'ax=ay=az=ac=0'.
#@gmic : $ image.jpg (0,1;0,1^0,0;1,1^1,1;1,1) -resize[-1] [-2],3 -mul[-2] [-1]
#@gmic : $ image.jpg --resize[-1] 256,128,1,3,2 --resize[-1] 120%,120%,1,3,0,1,0.5,0.5 --resize[-1] 120%,120%,1,3,0,0,0.2,0.2 --resize[-1] [0],[0],1,3,4

#@gmic resize_pow2 : _interpolation,_boundary,_ax,_ay,_az,_ac
#@gmic : Resize selected images so that each dimension is a power of 2.
#@gmic : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@gmic : 'boundary' has different meanings, according to the chosen 'interpolation' mode :
#@gmic : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary' is meaningless.
#@gmic : . When 'interpolation==0', 'boundary' can be { 0=dirichlet | 1=neumann | 2=periodic }.
#@gmic : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary' can be { 0=none | 1=neumann }.
#@gmic : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@gmic : (set to '0' by default, must be defined in range [0,1]).
#@gmic : Default values: 'interpolation=0', 'boundary=0' and 'ax=ay=az=ac=0'.
#@gmic : $ image.jpg --resize_pow2[-1] 0
resize_pow2 : -check "isint(${1=0}) && $1>=-1 && $1<=6" -skip ${2=0},${3=0},${4=0},${5=0},${6=0}
  -e[^-1] "Resize image$? so that each dimension is a power of 2."
  -v - -repeat @#
    -r[$>] @{$>,2^(round(log2(w),1,1))},@{$>,2^(round(log2(h),1,1))},@{$>,2^(round(log2(d),1,1))},100%,${1-6}
  -done -v +

#@gmic rr2d : eq. to '-resize_ratio2d'.
rr2d :
  -v - _gmic_s="$?" -v +
  -_resize_ratio2d $*

#@gmic resize_ratio2d : width>0,height>0,_mode={ 0=inside | 1=outside | 2=padded },0=<_interpolation<=6
#@gmic : Resize selected images while preserving their aspect ratio.
#@gmic : (eq. to '-rr2d').
#@gmic : Default values: 'mode=0' and 'interpolation=6'.
resize_ratio2d :
  -v - _gmic_s="$?" -v +
  -_$0 $*

_resize_ratio2d : -check "$1>0 && $2>0 && ${3=0}>=0 && $3<=2 && ${4=6}>=0 && $4<=6"
  -e[0--3] "Resize 2d image"$_gmic_s" to $1x$2 with ratio-"@{-arg\ 1+$3,inside,outside,padded}\
           " mode and interpolation type $4."
  -v - -repeat @#
    ratio=@{$>,if($3==1,max($1/w,$2/h),min($1/w,$2/h))}
    -r[$>] @{$>,w*$ratio},@{$>,h*$ratio},100%,100%,$4
  -done
  -if {$3==2} -r $1,$2,100%,100%,0,0,0.5,0.5 -endif
  -v +

#@gmic r2dx : eq. to '-resize2dx'.
r2dx :
  -v - _gmic_s="$?" -v +
  -_resize2dx $*

#@gmic resize2dx : width[%]>0,_interpolation,_boundary,_ax,_ay,_az,_ac
#@gmic : Resize selected images along the x-axis, preserving 2d ratio.
#@gmic : (eq. to '-r2dx').
#@gmic : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@gmic : 'boundary' has different meanings, according to the chosen 'interpolation' mode :
#@gmic : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary' is meaningless.
#@gmic : . When 'interpolation==0', 'boundary' can be { 0=dirichlet | 1=neumann | 2=periodic }.
#@gmic : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary' can be { 0=none | 1=neumann }.
#@gmic : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@gmic : (set to '0' by default, must be defined in range [0,1]).
#@gmic : Default values: 'interpolation=3', 'boundary=0' and 'ax=ay=az=ac=0'.
#@gmic : $ image.jpg --resize2dx 100,2 -append x
resize2dx :
  -v - _gmic_s="$?" -v +
  -_$0 $*

_resize2dx : -check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=2 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
  -e[0--3] "Resize 2d image"$_gmic_s" to $1 pixels along the x-axis, preserving 2d ratio."
  -v - -repeat @# -l[$>]
    size={if(@{-is_percent\ $1},$1*w,$1)}
    -r {max(1,$size)},{max(1,h*$size/w)},100%,100%,${2-7}
  -endl -done -v +

#@gmic r2dy : eq. to '-resize2dy'.
r2dy :
  -v - _gmic_s="$?" -v +
  -_resize2dy $*

#@gmic resize2dy : height[%]>=0,_interpolation,_boundary,_ax,_ay,_az,_ac
#@gmic : Resize selected images along the y-axis, preserving 2d ratio.
#@gmic : (eq. to '-r2dy').
#@gmic : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@gmic : 'boundary' has different meanings, according to the chosen 'interpolation' mode :
#@gmic : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary' is meaningless.
#@gmic : . When 'interpolation==0', 'boundary' can be { 0=dirichlet | 1=neumann | 2=periodic }.
#@gmic : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary' can be { 0=none | 1=neumann }.
#@gmic : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@gmic : (set to '0' by default, must be defined in range [0,1]).
#@gmic : Default values: 'interpolation=3', 'boundary=0' and 'ax=ay=az=ac=0'.
#@gmic : $ image.jpg --resize2dy 100,2 -append x
resize2dy :
  -v - _gmic_s="$?" -v +
  -_$0 $*

_resize2dy : -check "$1>=0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=2 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
  -e[0--3] "Resize 2d image"$_gmic_s" to $1 pixels along the y-axis, preserving 2d ratio."
  -v - -repeat @# -l[$>]
    size={if(@{-is_percent\ $1},$1*h,$1)}
    -r {max(1,w*$size/h)},{max(1,$size)},100%,100%,${2-7}
  -endl -done -v +

#@gmic r3dx : eq. to '-resize3dx'.
r3dx :
  -v - _gmic_s="$?" -v +
  -_resize3dx $*

#@gmic resize3dx : width[%]>0,_interpolation,_boundary,_ax,_ay,_az,_ac
#@gmic : Resize selected images along the x-axis, preserving 3d ratio.
#@gmic : (eq. to '-r3dx').
#@gmic : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@gmic : 'boundary' has different meanings, according to the chosen 'interpolation' mode :
#@gmic : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary' is meaningless.
#@gmic : . When 'interpolation==0', 'boundary' can be { 0=dirichlet | 1=neumann | 2=periodic }.
#@gmic : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary' can be { 0=none | 1=neumann }.
#@gmic : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@gmic : (set to '0' by default, must be defined in range [0,1]).
#@gmic : Default values: 'interpolation=3', 'boundary=0' and 'ax=ay=az=ac=0'.
resize3dx :
  -v - _gmic_s="$?" -v +
  -_$0 $*

_resize3dx : -check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=2 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
  -e[0--3] "Resize 3d image"$_gmic_s" to $1 pixels along the x-axis, preserving 3d ratio."
  -v - -repeat @# -l[$>]
    size={if(@{-is_percent\ $1},$1*w,$1)}
    -r {max(1,$size)},{max(1,h*$size/w)},{max(1,d*$size/w)},100%,${2-7}
  -endl -done -v +

#@gmic r3dy : eq. to '-resize3dy'.
r3dy :
  -v - _gmic_s="$?" -v +
  -_resize3dy $*

#@gmic resize3dy : height[%]>0,_interpolation,_boundary,_ax,_ay,_az,_ac
#@gmic : Resize selected images along the y-axis, preserving 3d ratio.
#@gmic : (eq. to '-r3dy').
#@gmic : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@gmic : 'boundary' has different meanings, according to the chosen 'interpolation' mode :
#@gmic : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary' is meaningless.
#@gmic : . When 'interpolation==0', 'boundary' can be { 0=dirichlet | 1=neumann | 2=periodic }.
#@gmic : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary' can be { 0=none | 1=neumann }.
#@gmic : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@gmic : (set to '0' by default, must be defined in range [0,1]).
#@gmic : Default values: 'interpolation=3', 'boundary=0' and 'ax=ay=az=ac=0'.
resize3dy :
  -v - _gmic_s="$?" -v +
  -_$0 $*

_resize3dy : -check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=2 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
  -e[0--3] "Resize 3d image"$_gmic_s" to $1 pixels along the y-axis, preserving 3d ratio."
  -v - -repeat @# -l[$>]
    size={if(@{-is_percent\ $1},$1*h,$1)}
    -r {max(1,w*$size/h)},{max(1,$size)},{max(1,d*$size/h)},100%,${2-7}
  -endl -done -v +

#@gmic r3dz : eq. to '-resize3dz'.
r3dz :
  -v - _gmic_s="$?" -v +
  -_resize3dz $*

#@gmic resize3dz : depth[%]>0,_interpolation,_boundary,_ax,_ay,_az,_ac
#@gmic : Resize selected images along the z-axis, preserving 3d ratio.
#@gmic : (eq. to '-r3dz').
#@gmic : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@gmic : 'boundary' has different meanings, according to the chosen 'interpolation' mode :
#@gmic : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary' is meaningless.
#@gmic : . When 'interpolation==0', 'boundary' can be { 0=dirichlet | 1=neumann | 2=periodic }.
#@gmic : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary' can be { 0=none | 1=neumann }.
#@gmic : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@gmic : (set to '0' by default, must be defined in range [0,1]).
#@gmic : Default values: 'interpolation=3', 'boundary=0' and 'ax=ay=az=ac=0'.
resize3dz :
  -v - _gmic_s="$?" -v +
  -_$0 $*

_resize3dz : -check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=2 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
  -e[0--3] "Resize 3d image"$_gmic_s" to $1 pixels along the z-axis, preserving 3d ratio."
  -v - -repeat @# -l[$>]
    size={if(@{-is_percent\ $1},$1*d,$1)}
    -r[$>] {max(1,w*$size/d)},{max(1,h*$size/d)},{max(1,$size)},100%,${2-7}
  -endl -done -v +

#@gmic rotate : angle,_interpolation,_boundary,_center_x[%],_center_y[%],_zoom : (+)
#@gmic : Rotate selected images with specified angle (in deg.).
#@gmic : 'interpolation' can be { 0=none | 1=linear | 2=bicubic }.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann | 2=periodic }.
#@gmic : When rotation center is specified, the size of the image is preserved.
#@gmic : Default values: 'boundary=0', 'interpolation=1', 'cx=cy=(undefined)' and 'zoom=1'.
#@gmic : $ image.jpg --rotate -25,1,2,50%,50%,0.6 -rotate[0] 25

#@gmic rotate_tileable : angle,_max_size_factor>=0
#@gmic : Rotate selected images by specified angle and make them tileable.
#@gmic : If resulting size of an image is too big, the image is replaced by a 1x1 image.
#@gmic : Default values: 'max_size_factor=8'.
rotate_tileable : -check ${2=8}>=0
  -e[^-1] "Rotate image$? with angle $1 deg. and make them tileable."
  -v -

  # Reduce angle to known fraction.
  angle={$1%360}
  -if {$angle>=270} -rotate 270 angle={$angle-270}
  -elif {$angle>=180} -rotate 180 angle={$angle-180}
  -elif {$angle>=90} -rotate 90 angle={$angle-90}
  -endif
  (0,1;1,8;1,7;1,6;1,5;1,4;1,5;1,3;2,5;1,2;2,5;3,5;2,3;3,4;4,5;1,1;5,4;7,5;3,2;8,5;9,5;2,1;3,1;4,1;5,1;6,1;7,1;8,1) # List of known fractions.
  -s[-1] x,2 --/[-2,-1] -atan[-1] -*[-1] {180/pi}         # Compute corresponding angles.
  ($angle) -index[-1] [-2] -rm[-2]
  p=@{-3,@-1} q=@{-2,@-1} -rm[-3--1]                      # Find nearest fraction p/q to atan(angle).
  -if {!$p||!$q} -return -endif

  -repeat @# -l[$>]
    # Compute width and height of tile.
    theta={atan2($p,$q)}
    gcd=@{-gcd" "{h*$q},{w*$p}}
    pw={h*$q/$gcd}
    nw={round($pw*w/cos($theta))}
    gcd=@{-gcd" "{h*$p},{w*$q}}
    qh={w*$q/$gcd}
    nh={round($qh*h/cos($theta))}

    # Rotate and make tileable (may result in very large images!).
    -if {!$2" || "($nw<$2*w" && "$nh<$2*h)}
      -r {1.5*$nw},{1.5*$nh},1,100%,0,2
      -rotate {$theta*180/pi},1,2,50%,50%
      -r $nw,$nh,1,100%,0,2,0.5,0.5
    -else -v + -error[0--4] "Command '-rotate_tileable': Invalid image dimension "({w},{h},{d},{s}).
    -endif
  -endl -done -v +

#@gmic rows : { [image0] | y0[%] },_{ [image1] | y1[%] } : (+)
#@gmic : Keep only specified rows of selected images.
#@gmic : Dirichlet boundary is used when specified rows are out of range.
#@gmic : $ image.jpg -rows -25%,50%

#@gmic scale2x
#@gmic : Resize selected images using the Scale2x algorithm.
#@gmic : $ image.jpg -threshold 50% -resize 50%,50% --scale2x
scale2x :
  -e[^-1] "Double xy-dimensions of image$?, using Scale2x algorithm."
  -v - -repeat @# -l[$>]
    -r 200%,200%
    -f "dx=x&1;dy=y&1;A=j(0,-2,0,0,0,1);B=j(2,0,0,0,0,1);C=j(-2,0,0,0,0,1);D=j(0,2,0,0,0,1);"\
       "!dy*(!dx*if(C==A&&C!=D&&A!=B,A,i) + dx*if(A==B&&A!=C&&B!=D,B,i)) + dy*(dx*if(B==D&&B!=A&&D!=C,D,i) + !dx*if(D==C&&D!=B&&C!=A,C,i))"
  -endl -done -v +

#@gmic scale3x
#@gmic : Resize selected images using the Scale3x algorithm.
#@gmic : $ image.jpg -threshold 50% -resize 33%,33% --scale3x
scale3x :
  -e[^-1] "Triple xy-dimensions of image$?, using Scale3x algorithm."
  -v - -repeat @# -l[$>]
    -r 300%,300%
    -f "dx=x%3;dy=y%3;c0=!dx;c1=(dx==1);c2=(dx==2);"\
       "A=j(-3,-3,0,0,0,1);B=j(0,-3,0,0,0,1);C=j(3,-3,0,0,0,1);"\
       "D=j(-3,0,0,0,0,1);F=j(3,0,0,0,0,1);"\
       "G=j(-3,3,0,0,0,1);H=j(0,3,0,0,0,1);I=j(3,3,0,0,0,1);"\
       "!dy*(c0*if(D==B&&D!=H&&B!=F,D,i) + c1*if((D==B&&D!=H&&B!=F&&i!=C)||(B==F&&B!=D&&F!=H&&i!=A),B,i) + c2*if(B==F&&B!=D&&F!=H,F,i)) + "\
       "(dy==1)*(c0*if((H==D&&H!=F&&D!=B&&i!=A)||(D==B&&D!=H&&B!=F&&i!=G),D,i) + c1*i + c2*if((B==F&&B!=D&&F!=H&&i!=I)||(F==H&&F!=B&&H!=D&&i!=C),F,i)) + "\
       "(dy==2)*(c0*if(H==D&&H!=F&&D!=B,D,i) + c1*if((F==H&&F!=B&&H!=D&&i!=G)||(H==D&&H!=F&&D!=B&&i!=I),H,i) + c2*if(F==H&&F!=B&&H!=D,F,i))"
  -endl -done -v +

#@gmic seamcarve : _width[%]>=0,_height[%]>=0,_is_priority_channel={ 0 | 1 },_is_antialiasing={ 0 | 1 },_maximum_seams[%]>=0
#@gmic : Resize selected images with specified 2d geometry, using the seam-carving algorithm.
#@gmic : Default values: 'height=100%', 'is_priority_channel=0', 'is_antialiasing=1' and 'maximum_seams=25%'.
#@gmic : $ image.jpg --seamcarve 60%
# The main code of this algorithm has been done by Andy (Garagecoder).
seamcarve : -check "${2=100%}>=0 && ${5=25%}>=0" -skip ${3=0},${4=1}
  -e[^-1] "Resize image$? to $1x$2 using seam-carving algorithm, "@{-arg\ 1+!$3,with,without}" priority channel, "@{-arg\ 1+!$4,with,without}" anti-aliasing and maximum seams $5."
  -v - -repeat @# -l[$>]
    nw={max(1,round(if(@{-is_percent\ $1},$1*w,$1)))}
    nh={max(1,round(if(@{-is_percent\ $2},$2*h,$2)))}
    -if {$nw!=w} -_seamcarve $nw,$3,$4,$5 -endif
    -if {$nh!=h} -transpose -_seamcarve $nh,$3,$4,$5 -transpose -endif
  -endl -done -v +

# Subroutine to remove/add vertical seams/
# $1 = desired width.
# $2 = is_priority_channel={ 0 | 1 }
# $3 = is_antialiasing={ 0 | 1 }
# $4 = max number of seams added/removed at once.
_seamcarve :
  -do
    max_seams={max(1,round(if(@{-is_percent\ $4},$4*w,$4)))}
    ssms={max(min(round($1-w),w),1-w)}
    sms={min($max_seams,abs($ssms))}

    # Compute potential map.
    -if $2 -s[0] c,{1-s} -/[-1] 256 -endif
    --gradient[0] -a[-2,-1] c -abs[-1] -compose_channels[-1] + -n[-1] 0,1
    -if $2 -+[-1] [-2] -a[0,1] c -endif

    # Add x-coordinates channel for anti-aliasing.
    -if $3 100%,1,1,1,x -r[-1] [0],[0] -a[0,-1] c -endif

    # Calculate low matrix (backwards propagation).
    [-1]
    -repeat {h}
      --rows[-1] {$<+1} -erode[-1] 3
      -j[-2] [-1],0,$<,0,0,-1 -rm[-1]
    -done

    # Initialise seams, top matrix.
    100%,100% --rows[1] 0
    -nm[1] grad -nm[2] low -nm[3] seam -nm[4] top

    -repeat @{0,h-1} nr={$>+1}
      --rows[low] $nr

      # Find optimum matches between two 1d matrices.
      --*[4,5] --shift[4] 1 -*[-1] [5] --shift[5] 1 -*[-1] [4]
      -+[-2,-1] -j[5] [4] -a[-3--1] c
      -f[-1] ">if(c,i,max(j(-1)+j(0,0,0,1),j(-2)+j(0,0,0,2)))"
      -s[-1] c -shift[-3] 1 -+[-2] [-3] -shift[-3] 1 -+[-3,-1]
      ->[-2,-1] -f[-1] "<if(j(1)<0,1,-i)"

      # Add matched row to seams.
      -j[seam] [-1],0,$>

      # Distribute matched pixels in top matrix.
      -a[-2,-1] c -f[-1] "j(i,0,0,-1)" -channels[-1] 1

      # Add next energy row to top matrix.
      --rows[grad] $nr -+[top,-1]
    -done

    # Add / remove seams.
    max={iM*2} -repeat $sms -=[-1] $max,@{-1,xm} -done
    -j[grad] [-1],0,100% -rm[low,top] -a[-2,-1] c
    -f[-1] "<if(c,i,j(j(0,0,0,1),1,0,0,0,1))" -channels[-1] 0
    -+[0] 0.1 -!=[-1] $max
    w={w} h={h} s=@{0,s}
    -if {$ssms<0} -* -discard 0 -r {$w-$sms},$h,1,$s,-1  # Remove seams.
    -elif {$ssms>0}              # Add seams.
      --[-1] 2 -s[0] c
      -repeat $s -if {$><($s-1)} [-1] -endif -a[$>,-1] c -done
      -permute cxyz -a c -discard -1 -f "if(i<0,j(0,-1),i)"
      -r {$w+$sms},$h,1,$s,-1
    -endif

    # Perform anti-aliasing step.
    -if $3
      -s c,{1-s} -gradient[-1] x,1 -round -!=[-1] 1
      (0.5,0.5) --convolve[0] [-1] -rm[-2]
      -j[0] [-1],0,0,0,0,1,[1] -rm[-2,-1]
    -endif

    -rprogress {a=w/$1;if(a<1,a*100,100/a)}
  -while {w!=$1}

#@gmic shift : vx[%],_vy[%],_vz[%],_vc[%],_boundary : (+)
#@gmic : Shift selected images by specified displacement vector.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann | 2=periodic }.
#@gmic : Default value: 'boundary=0'.
#@gmic : $ image.jpg --shift[0] 50%,50%,0,0,0 --shift[0] 50%,50%,0,0,1 --shift[0] 50%,50%,0,0,2

#@gmic shrink_x : size_x>=0
#@gmic : Shrink selected images along the x-axis.
#@gmic : $ image.jpg -shrink_x 30
shrink_x : -check "$1>=0"
  -e[^-1] "Shrink image$? along the x-axis with size $1."
  -v - -repeat @# -z[$>] $1,@{$>,w-$1-1} -done -v +

#@gmic shrink_xy : size>=0
#@gmic : Shrink selected images along the xy-axes.
#@gmic : $ image.jpg -shrink_xy 30
shrink_xy : -check "$1>=0"
  -e[^-1] "Shrink image$? along the xy-axes with size $1."
  -v - -repeat @# -z[$>] $1,$1,@{$>,w-$1-1},@{$>,h-$1-1} -done -v +

#@gmic shrink_xyz : size>=0
#@gmic : Shrink selected images along the xyz-axes.
shrink_xyz : -check "$1>=0"
  -e[^-1] "Shrink image$? along the xyz-axes with size $1."
  -v - -repeat @# -z[$>] $1,$1,$1,@{$>,w-$1-1},@{$>,h-$1-1},@{$>,d-$1-1} -done -v +

#@gmic shrink_y : size_y>=0
#@gmic : Shrink selected images along the y-axis.
#@gmic : $ image.jpg -shrink_y 30
shrink_y : -check "$1>=0"
  -e[^-1] "Shrink image$? along the y-axis with size $1."
  -v - -repeat @# -z[$>] 0,$1,100%,@{$>,h-$1-1} -done -v +

#@gmic shrink_z : size_z>=0
#@gmic : Shrink selected images along the z-axis.
shrink_z : -check "$1>=0"
  -e[^-1] "Shrink image$? along the z-axis with size $1."
  -v - -repeat @# -z[$>] 0,0,$1,100%,100%,@{$>,d-$1-1} -done -v +

#@gmic slices : { [image0] | z0[%] },_{ [image1] | z1[%] } : (+)
#@gmic : Keep only specified slices of selected images.
#@gmic : Dirichlet boundary is used when specified slices are out of range.

#@gmic sort : _ordering={ + | - },_axis={ x | y | z | c } : (+)
#@gmic : Sort pixel values of selected images.
#@gmic : If 'axis' is specified, the sorting is done according to the data of the first column/row/slice/channel
#@gmic : of selected images.
#@gmic : Default values: 'ordering=+' and 'axis=(undefined)'.
#@gmic : $ 64 -rand 0,100 --sort -display_graph 400,300,3

#@gmic s : eq. to '-split'. : (+)

#@gmic split : { x | y | z | c }..{ x | y | z | c },_split_mode : keep_splitting_values={ + | - },_{ x | y | z | c }..{ x | y | z | c },value1,_value2,... : (no args) : (+)
#@gmic : Split selected images along specified axes, or regarding to a sequence of scalar values (optionally along specified axes too).
#@gmic : (eq. to '-s').
#@gmic : 'split_mode' can be { 0=split according to constant values | >0=split in N parts | <0=split in parts of size -N }.
#@gmic : Default value: 'split_mode=-1'.
#@gmic : $ image.jpg -split c
#@gmic : $ image.jpg -split y,3
#@gmic : $ image.jpg -split x,-128
#@gmic : $ 1,20,1,1,"1,2,3,4" --split -,2,3 -append[1--1] y
#@gmic : $ (1,2,2,3,3,3,4,4,4,4) --split x,0 -append[1--1] y

#@gmic split_tiles : M!=0,_N!=0,_is_homogeneous={ 0 | 1 }
#@gmic : Split selected images as a MxN array of tiles.
#@gmic : If M or N is negative, it stands for the tile size instead.
#@gmic : Default values: 'N=M' and 'is_homogeneous=0'.
#@gmic : $ image.jpg --local -split_tiles 5,4 -blur 3,0 -sharpen 700 -append_tiles 4,5 -endlocal
split_tiles : -skip ${2=$1},${3=0}
  -if $3 -e[^-1] "Split image$? as a $1x$2 array of homogeneous tiles."
  -else -e[^-1] "Split image$? as a $1x$2 array of tiles."
  -endif
  -v - -repeat @# -l[$<] -s y,$2 -s x,$1 -if $3 -r [0],[0],100%,100%,0 -endif -endl -done -v +

#@gmic y : eq. to '-unroll'. : (+)

#@gmic unroll : _axis={ x | y | z | c } : (+)
#@gmic : Unroll selected images along specified axis.
#@gmic : (eq. to '-y').
#@gmic : Default value: 'axis=y'.
#@gmic : $ (1,2,3;4,5,6;7,8,9) --unroll y

#@gmic upscale_smart : width[%],_height[%],_depth,_smoothness>=0,_anisotropy=[0,1],sharpening>=0
#@gmic : Upscale selected images with an edge-preserving algorithm.
#@gmic : Default values: 'height=100%', 'depth=100%', 'smoothness=2', 'anisotropy=0.4' and 'sharpening=10'.
#@gmic : $ image.jpg -resize2dy 100 --upscale_smart 500%,500% -append x
upscale_smart : -skip ${2=100%},${3=100%} -check "${4=2}>=0 && ${5=0.4}>=0 && $5<=1 && ${6=10}>=0"
  -e[^-1] "Upscale image$? to $1x$2x$3, with smoothness $4, anisotropy $5 and sharpening $6."
  -v - -repeat @# -l[$>]
    w={w} h={h}
    --r[-1] $1,$2,$3,1,0 # Compute desired dimensions.
    -if {w<$w" && "h<$h} # Test for downscaling
      -rm[-1] -r[-1] $1,$2,$3,100%,2
    -else
      -rm[-1] --diffusiontensors 0,$5,1.2,1.2
      -r[-2,-1] $1,$2,$3,100%,5
      -smooth[-2] [-1],$4 -rm[-1]
      -apply_channels "-sharpen[-1] $6,10",3,0
    -endif
  -endl -done -v +

#@gmic warp : [warping_field],_is_relative={ 0 | 1 },_interpolation,_boundary,_nb_frames>0 : (+)
#@gmic : Warp selected image with specified displacement field.
#@gmic : 'interpolation' can be { 0=nearest-neighbor | 1=linear | 2=cubic }.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann | 2=periodic }.
#@gmic : Default values: 'is_relative=0', 'interpolation=1', 'boundary=1' and 'nb_frames=1'.
#@gmic : $ image.jpg 100%,100%,1,2,'X=x/w-0.5;Y=y/h-0.5;R=(X*X+Y*Y)^0.5;A=atan2(Y,X);130*R*if(c==0,cos(4*A),sin(8*A))' -warp[-2] [-1],1,1,0 -quiver[-1] [-1],10,0.2,1,1,100
#@gmic : $$

#---------------------------------
#
#@gmic :: Filtering
#
#---------------------------------

#@gmic bandpass : _min_freq[%],_max_freq[%]
#@gmic : Apply bandpass filter to selected images.
#@gmic : Default values: 'min_freq=0' and 'max_freq=20%'.
#@gmic : $ image.jpg -bandpass 1%,3%
#@gmic : $$
bandpass : -skip ${1=0},${2=20%}
  -e[^-1] "Apply bandpass filter [$1,$2] to image$?."
  -v - -repeat @# -l[$>]
    100%,100%,100% -f[-1] "sqrt((x/w-0.5)^2 + (y/h-0.5)^2 + (z/d-0.5)^2)"
    -n[-1] 0,1 -ir[-1] $1,$2 -shift[-1] {int(w/2)},{int(h/2)},50%,0,2
    -fft[-2] -*[-3] [-1] -*[-2,-1] -ifft -rm[-1]
  -endl -done -v +

#@gmic bilateral : [guide],std_variation_s>0[%],std_variation_r[%]>0,_sampling_s>=0,_sampling_r>=0 : std_variation_s>0[%],std_variation_r[%]>0,_sampling_s>=0,_sampling_r>=0 : (+)
#@gmic : Blur selected images by anisotropic (eventually joint/cross) bilateral filtering.
#@gmic : If a guide image is provided, it is used for drive the smoothing filter.
#@gmic : A guide image must be of the same xyz-size as the selected images.
#@gmic : Set 'sampling' arguments to '0' for automatic adjustment.
#@gmic : $ image.jpg [0] -repeat 5 -bilateral[-1] 10,10 -done

#@gmic b : eq. to '-blur'. : (+)

#@gmic blur : std_variation>=0[%],_boundary,_kernel : axes,std_variation>=0[%],_boundary,_kernel : (+)
#@gmic : Blur selected images by a quasi-gaussian or gaussian filter (recursive implementation).
#@gmic : (eq. to '-b').
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann } and 'kernel' can be { 0=quasi-gaussian (faster) | 1=gaussian }.
#@gmic : When specified, argument 'axes' is a sequence of { x | y | z }.
#@gmic : Specifying one axis multiple times apply also the blur multiple times.
#@gmic : Default values: 'boundary=1' and 'kernel=0'.
#@gmic : $ image.jpg --blur 5,0 --blur[0] 5,1
#@gmic : $ image.jpg --blur y,10%
#@gmic : $$

#@gmic blur_angular : amplitude[%],_center_x[%],_center_y[%]
#@gmic : Apply angular blur on selected images.
#@gmic : Default values: 'center_x=center_y=50%'.
#@gmic : $ image.jpg --blur_angular 2%
#@gmic : $$
blur_angular : -skip ${2=50%},${3=50%}
  -e[^-1] "Apply angular blur on image$?, with amplitude $1 and center point ($2,$3)."
  -v - -euclidean2polar $2,$3,1.3,1 -expand_y 16,2 -blur_y $1 -shrink_y 16 -polar2euclidean $2,$3,1.3,1 -v +

#@gmic blur_linear : amplitude1[%],_amplitude2[%],_angle,_boundary={ 0=dirichlet | 1=neumann }
#@gmic : Apply linear blur on selected images, with specified angle and amplitudes.
#@gmic : Default values: 'amplitude2=0', 'angle=0' and 'boundary=1'.
#@gmic : $ image.jpg --blur_linear 10,0,45
#@gmic : $$
blur_linear : -skip ${2=0},${3=0},${4=1}
  -e[^-1] "Apply linear blur on image$?, with angle $3 deg. and amplitudes ($1,$2)."
  -v -
  std1={if(@{-is_percent\ $1},$1*max(w,h),$1)}
  std2={if(@{-is_percent\ $2},$2*max(w,h),$2)}
  stdM={round(1.25*max($std1,$std2))}
  -if {$stdM<=0} -return -endif
  -repeat @# -l[$>]
    -expand_xy $stdM,{$4!=0}
    {2*$stdM},{2*$stdM} -gaussian[-1] $1,$2,$3 -normalize_sum[-1]
    -convolve_fft[0] [1] -rm[-1] -shrink_xy $stdM
  -endl -done -v +

#@gmic blur_radial : amplitude[%],_center_x[%],_center_y[%]
#@gmic : Apply radial blur on selected images.
#@gmic : Default values: 'center_x=center_y=50%'.
#@gmic : $ image.jpg --blur_radial 2%
#@gmic : $$
blur_radial : -skip ${2=50%},${3=50%}
  -e[^-1] "Apply radial blur on image$?, with amplitude $1 and center point ($2,$3)."
  -v - -euclidean2polar $2,$3,5,1 -blur_x $1 -polar2euclidean $2,$3,5,1 -v +

#@gmic blur_selective : sigma>=0,_edges>0,_nb_scales>0
#@gmic : Blur selected images using selective gaussian scales.
#@gmic : Default values: 'sigma=5', 'edges=0.5' and 'nb_scales=5'.
#@gmic : $ image.jpg -noise 20 -cut 0,255 --local[-1] -repeat 4 -blur_selective , -done -endlocal
#@gmic : $$
blur_selective : -check "${1=5}>=0 && ${2=0.5}>=0 && isint(${3=5}) && $3>0"
  -e[^-1] "Blur image$? using $3 selective gaussian scales, with sigma $1 and edges $2."
  -v - -repeat @# -l[$>] nm=@{0,n}
    --gradient_norm -+[-1] 1 -^[-1] {-max(0.01,$2)} -quantize[-1] {$3+1},0,1 -min[-1] {$3-1} -r[-1] [-2] -/[-1] 100
    -repeat $3 --==[-1] {$>/100} -*[-1] [-3] -+[-2,-1] -b[-2] {$1/($3+1)} -done
  -rm[-2] -nm $nm,1 -endl -done -v +

#@gmic blur_x : amplitude[%]>=0,_boundary={ 0=dirichlet | 1=neumann }
#@gmic : Blur selected images along the x-axis.
#@gmic : Default value: 'boundary=1'.
#@gmic : $ image.jpg --blur_x 6
#@gmic : $$
blur_x : -skip ${2=1}
  -e[^-1] "Blur image$? along the x-axis, with sigma $1 and "@{-arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
  -v - -deriche $1,0,x,$2 -v +

#@gmic blur_xy : amplitude_x[%],amplitude_y[%],_boundary={ 0=dirichlet | 1=neumann }
#@gmic : Blur selected images along the X and Y axes.
#@gmic : Default value: 'boundary=1'.
#@gmic : $ image.jpg --blur_xy 6
#@gmic : $$
blur_xy : -skip ${2=$1},${3=1}
  -e[^-1] "Blur image$? along the xy-axes, with sigma $1 and "@{-arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
  -v - -deriche $1,0,x,$3 -deriche $2,0,y,$3 -v +

#@gmic blur_xyz : amplitude_x[%],amplitude_y[%],amplitude_z,_boundary={ 0=dirichlet | 1=neumann }
#@gmic : Blur selected images along the X, Y and Z axes.
#@gmic : Default value: 'boundary=1'.
#@gmic : $$
blur_xyz : -skip ${4=1}
  -e[^-1] "Blur image$? along the xyz-axes, with sigma $1 and "@{-arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
  -v - -deriche $1,0,x,$4 -deriche $2,0,y,$4 -deriche $3,0,z,$4 -v +

#@gmic blur_y : amplitude[%]>=0,_boundary={ 0=dirichlet | 1=neumann }
#@gmic : Blur selected images along the y-axis.
#@gmic : Default value: 'boundary=1'.
#@gmic : $ image.jpg --blur_y 6
#@gmic : $$
blur_y : -skip ${2=1}
  -e[^-1] "Blur image$? along the y-axis, with sigma $1 and "@{-arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
  -v - -deriche $1,0,y,$2 -v +

#@gmic blur_z : amplitude[%]>=0,_boundary={ 0=dirichlet | 1=neumann }
#@gmic : Blur selected images along the z-axis.
#@gmic : Default value: 'boundary=1'.
#@gmic : $$
blur_z : -skip ${2=1}
  -e[^-1] "Blur image$? along the z-axis, with sigma $1 and "@{-arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
  -v - -deriche $1,0,z,$2 -v +

#@gmic bokeh : _amplitude>=0,_smoothness>=0,0<=_density<=100,_bokeh_size>0,0<=_bokeh_outline_size<=100,_bokeh_outline_amplitude>=0,_bokeh_smoothness>=0
#@gmic : Create a Bokeh effect from selected images.
#@gmic : Default values: 'amplitude=200', 'smoothness=2', 'density=0.2', 'bokeh_size=24', 'bokeh_outline_size=10', 'bokeh_outline_amplitude=1' and 'bokeh_smoothness=0.1'.
#@gmic : $ image.jpg --bokeh ,
bokeh : -check "${1=200}>=0 && ${2=2}>=0 && ${3=0.2}>=0 && $3<=100 && ${4=24}>0 && ${5=10}>=0 && $5<=100 && ${6=2}>=0 && ${7=1}>=0 && ${8=0.1}>=0"
  -e[^-1] "Apply bokeh effect to image$?, with amplitude $1, smoothness $2, density $3%, bokeh size $4, bokeh outline size $5 "\
          "bokeh outline amplitude $6 and bokeh smoothness $7."
  -v -

  # Create bokeh kernel.
  256,256 -=[-1] 1,50%,50% -distance[-1] 1
  --<[-1] 70% -ir[-2] 70%,{70-$5*70/100}% -*[-2] $6 -+[-2,-1] -r[-1] $4,$4,1,1,2
  -expand_xy[-1] {3*$7},0 -b[-1] $7,0 -->[-1] 0.1 -*[-2,-1] -autocrop[-1]
  -normalize_sum[-1]

  # Apply bokeh effect.
  -repeat {@#-1} -l[$>,-1]
    --remove_pixels[0] {100-$3}% -convolve[-1] [-2],0 -n[-1] 0,$1
    -b[0] $2 -+[0,-1] -c[0] 0,255
  -endl -done -rm[-1]
  -v +

#@gmic compose_freq
#@gmic : Compose selected low and high frequency parts into new images.
#@gmic : $ image.jpg -split_freq 2% -mirror[-1] x -compose_freq
compose_freq :
  -e[^-1] "Compose low and high frequency part$? into new images."
  -v - -repeat {int(@#/2)} -+[$>,{$>+1}] -done -v +

#@gmic convolve : [mask],_boundary,_is_normalized={ 0 | 1 } : (+)
#@gmic : Convolve selected images by specified mask.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : Default values: 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg (0,1,0;1,-4,1;0,1,0) -convolve[-2] [-1] -keep[-2]
#@gmic : $ image.jpg (0,1,0) -resize[-1] 130,1,1,1,3 --convolve[0] [1]
#@gmic : $$

#@gmic convolve_fft : [mask]
#@gmic : Convolve selected images with specified mask, in the fourier domain.
#@gmic : $ image.jpg 100%,100% -gaussian[-1] 20,1,45 --convolve_fft[0] [1]
convolve_fft : -check @{-is_image_arg\ $1}
  -e[^-1] "Convolve image$? with mask $1, in the fourier domain."
  -v - -repeat @# -pass$1 0 -l[$>,-1]
    w2={int(@{0,w}/2)} h2={int(@{0,h}/2)} d2={int(@{0,d}/2)}
    -r[1] [0],[0],[0],1,0,0,0.5,0.5,0.5,0.5 -shift[1] -$w2,-$h2,-$d2,0,2
    -fft[0] -fft[2]
    --*[-4] [-1] --*[-4] [-3] -+[-2,-1]
    -*[-5,-3] -*[-3,-2] --[-3,-2]
    -ifft -rm[-1]
  -endl -done -v +

#@gmic correlate : [mask],_boundary,_is_normalized={ 0 | 1 } : (+)
#@gmic : Correlate selected images by specified mask.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : Default values: 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg (0,1,0;1,-4,1;0,1,0) -correlate[-2] [-1] -keep[-2]
#@gmic : $ image.jpg --crop 40%,40%,60%,60% --correlate[0] [-1],0,1

#@gmic cross_correlation : [mask]
#@gmic : Compute cross-correlation of selected images with specified mask.
#@gmic : $ image.jpg --shift -30,-20 --cross_correlation[0] [1]
cross_correlation : -check @{-is_image_arg\ $1}
  -e[^-1] "Compute cross-correlation of image$? with mask $1."
  -v - -repeat @# -pass$1 0 -l[$>,-1]
    -norm -fft[-2] -fft[-1] [-2,-1] -*[-2] [-5] -*[-1] [-6]
    --[-2,-1] -*[-5,-3] -*[-3,-2] -+[-3,-2] -ifft -rm[-1]
  -endl -done -v +

#@gmic curvature
#@gmic : Compute isophote curvatures on selected images.
#@gmic : $ image.jpg -blur 10 -curvature
curvature :
  -e[^-1] "Compute isophote curvatures on image$?."
  -v - -repeat @# -l[$>]
    -if {d==1}
      --g xy,0 -hessian[-3] xxxyyy                            # ixx ixy iyy ix iy
      -*[-3] [-2] -*[-4] [-1] -*[-4] -2                       # ixx -2iyixy ixiyy ix iy
      -+[-4,-3] -*[-3] [-2]                                   # ixx -2ixiyixy+ix^2iyy ix iy
      -sqr[-2,-1] -*[-4] [-1] -+[-4,-3]                       # iy^2ixx-2ixiyixy+ix^2iyy ix^2 iy^2
      -+[-2,-1] -+[-1] 0.1 -^[-1] 1.5 -/                      # (iy^2ixx+2ixiyixy+ix^2iyy)/(ix^2+iy^2)
    -else
      --inn --gradient_norm[-2] -laplacian[-3]                # inn+iee inn in
      --[-3,-2] -+[-1] 0.1 -/[-2,-1]                          # iee in
      --inn[-1] -laplacian[-2] --                             # iee/in
    -endif
  -endl -done -v +

#@gmic dct : _{ x | y | z }..{ x | y | z } : (no arg)
#@gmic : Compute the discrete cosine transform of selected images,
#@gmic : optionally along the specified axes only.
#@gmic : Default values: (no arg)
#@gmic : $ image.jpg --dct --idct[-1] -abs[-2] -+[-2] 1 -log[-2]
dct : -skip ${1=0}
  -v - ({'"$1"'})
  is_axes={im>={'x'}&&iM<={'z'}}
  -if $is_axes
    -v + -e[0--3] "Compute discrete cosine transform of image$? along axes '$1'." -v -
    -repeat {w}
      axis={i[$>]}
      -if {$axis=={'x'}} -repeat {@#-1} -l[$>] -if {w>1} -_dct -endif -endl -done
      -elif {$axis=={'y'}} -repeat {@#-1} -l[$>] -if {h>1} -permute yxzc -_dct -permute yxzc -endif -endl -done
      -elif {$axis=={'z'}} -repeat {@#-1} -l[$>] -if {d>1} -permute zxyc -_dct -permute yzxc -endif -endl -done
      -endif
    -done
  -else
    -rm[-1]
    -v + -e[0--3] "Compute discrete cosine transform of image$?." -v -
    -noarg
    -repeat @# -l[$>]
      -if {w>1} -_dct -endif
      -if {h>1} -permute yxzc -_dct -permute yxzc -endif
      -if {d>1} -permute zxyc -_dct -permute yzxc -endif
    -endl -done
  -endif
  -v +

# 1d direct transform (DCT-II) for a single image.
_dct :
  is_odd={w%2}
  -if $is_odd -r {w+1},100%,100%,100%,0,1 -endif
  -s x -l[1--1:2] -a x -mirror x -endl -mv[1] @# -a x
  -fft x
  100%,1,1,1,2*cos(-x*pi/(2*w)) -*[0,2]
  100%,1,1,1,2*sin(-x*pi/(2*w)) -*[1,2]
  --
  -if $is_odd -r {w-1},100%,100%,100%,0 -endif
  --z[0] 0,0 -/[-1] {sqrt(2)} -j[-2] [-1],0,0,0 -rm[-1] -* {sqrt(2/w)}  # Make the transform orthogonal.

#@gmic deblur : amplitude[%]>=0,_nb_iter>=0,_dt>=0,_regul>=0,_regul_type={ 0=Tikhonov | 1=meancurv. | 2=TV }
#@gmic : Deblur image using a regularized Jansson-Van Cittert algorithm.
#@gmic : Default values: 'nb_iter=10', 'dt=20', 'regul=0.7' and 'regul_type=1'.
#@gmic : $ image.jpg -blur 3 --deblur 3,40,20,0.01
deblur : -check "${2=10}>=0 && ${3=20}>=0 && ${4=0.7}>=0" -skip ${5=1}
  -e[^-1] "Deblur image$? with a regularized Jansson-Van Cittert algorithm, with sigma $1, $2 iterations, time step $3 and regularization $4." -v -
  -repeat @# -l[$>] nm=@{0,n}
    [0]
    -repeat $2
      -if {$5>=2} --curvature[-1]                         # TV regularization.
      -elif {$5>=1} --iee[-1]                             # Meancurv. regularization.
      -else --laplacian[-1]                               # Tikhonov regularization.
      -endif
      -*[-1] $4
      --b[-2] $1 --[-1] [-4]                              # Data fidelity term.
      --[-2,-1]
      -*[-1] {$3/(0.0001+max(abs(@{-1,m}),abs(@{-1,M})))} # Adaptive time step.
      -+[-2,-1]                                           # Update image.
      -done
    -rm[-2]
  -nm $nm,1 -endl -done -v +

#@gmic deblur_goldmeinel : sigma>=0, _nb_iter>=0, _acceleration>=0, _kernel_type={ 0=quasi-gaussian (faster) | 1=gaussian }.
#@gmic : Deblur selected images using Gold-Meinel algorithm
#@gmic : Default values: 'nb_iter=8', 'acceleration=1' and 'kernel_type=1'.
#@gmic : $ image.jpg --blur 1 --deblur_goldmeinel[-1] 1
###### : (contribution from Jrme Boulanger).
deblur_goldmeinel : -check "$1>=0 && ${2=8}>=0 && ${3=1}>=0" -skip ${4=1}
  -e[^-1] "Deblur image$? using Gold-Meinel algorithm, with sigma $1, $2 iterations, acceleration $3 and "@{-arg\ 1+!$4,"",quasi-}"gaussian kernel."
  -v - -repeat @# -l[$>]
    [0] -repeat $2
      --b[-1] $1,1,$4 --/[0,-1] -rm[-2] -^[-1] $3 -*[-1,-2] # u *= f / Hu
    -done -rm[0]
  -endl -done -v +

#@gmic deblur_richardsonlucy : sigma>=0, nb_iter>=0, _kernel_type={ 0=quasi-gaussian (faster) | 1=gaussian }.
#@gmic : Deblur selected images using Richardson-Lucy algorithm.
#@gmic : Default values: 'nb_iter=50' and 'kernel_type=1'.
#@gmic : $ image.jpg --blur 1 --deblur_richardsonlucy[-1] 1
###### : (contribution from Jrme Boulanger).
deblur_richardsonlucy : -check "$1>=0 && ${2=50}>=0" -skip ${3=1}
  -e[^-1] "Deblur image$? using Richardson-Lucy algorithm, with sigma $1, $2 iterations and "@{-arg\ 1+!$3,"",quasi-}"gaussian kernel."
  -v - -repeat @# -l[$>]
    [0] -repeat $2
      --b[-1] $1,1,{$3!=0} -max[-1] 1e-6 --/[0,-1] -rm[-2] -b[-1] $1,1,{$3!=0} -*[-1,-2] # u *= H ( f / Hu )
    -done -rm[0]
  -endl -done -v +

#@gmic deconvolve_fft :  [kernel],_regularization>=0
#@gmic : Deconvolve selected images by specified mask in the fourier space.
#@gmic : Default value: 'regularization>=0'.
#@gmic : $ image.jpg --gaussian 5 --convolve_fft[0] [1] --deconvolve_fft[-1] [1]
deconvolve_fft : -check @{-is_image_arg\ $1}" && ${2=.001}>=0"
  -e[^-1] "Deconvolve image$? with mask $1 and regularization $2, in the fourier domain."
  -v - -repeat @# -pass$1 0 -l[$>,-1]
    w2={int(@{0,w}/2)} h2={int(@{0,h}/2)} d2={int(@{0,d}/2)}
    -r[1] [0],[0],[0],1,0,0,0.5,0.5,0.5,0.5 -shift[1] -$w2,-$h2,-$d2,0,2
    -fft[0] -fft[2]                            # a b a' b'
    --l[-1,-2] -sqr -+ -+ $2 -endl             # a b a' b' (a'^2+b'^2+eps)
    --*[-4] [-3]                               # a b a' b' (a'^2+b'^2) ba'
    --*[-6] [-3]                               # a b a' b' (a'^2+b'^2) ba' ab'
    --[-2,-1]                                  # a b a' b' (a'^2+b'^2) ba'-ab'
    -*[-6,-4]                                  # aa' b b' (a'^2+b'^2) ba'-ab'
    -*[-4,-3]                                  # aa' bb' (a'^2+b'^2) ba'-ab'
    -+[-4,-3]                                  # aa'+bb' (a'^2+b'^2) ba'-ab'
    -/[-1] [-2] -/[-3,-2]                      # divide (aa'+bb') and (ba'-ab') by (a'^2+b'^2)
    -ifft -rm[-1]
  -endl -done -v +

#@gmic deinterlace : _method={ 0 | 1 }
#@gmic : Deinterlace selected images ('method' can be { 0=standard or 1=motion-compensated }).
#@gmic : Default value: 'method=0'.
#@gmic : $ image.jpg --rotate 3,1,1,50%,50% -resize 100%,50% -resize 100%,200%,1,3,4 -shift[-1] 0,1 -add --deinterlace 1
deinterlace : -skip ${1=0}
  -e[^-1] "Deinterlace image$? with "@{-arg\ 1+!$1,motion-compensated,standard}" method."
  -v - -repeat @# -l[$>]
    wh={w},{h}
    -s y -a[0--1:2] y -a[^0] y -r[-2] [-1],0 -r 100%,200%,1,100%,5
    -if {$1!=0} --displacement[-1] [-2],0.05 -warp[-3] [-1],1,1,1 -rm[-1] -endif
    -+ -/ 2 -c 0,255 -r $wh
  -endl -done -v +

#@gmic denoise : std_variation_s>=0,_std_variation_p>=0,_patch_size>=0,_lookup_size>=0,_smoothness,_fast_approx={ 0 | 1 } : (+)
#@gmic : Denoise selected images by non-local patch averaging.
#@gmic : Default values: 'std_variation_p=10', 'patch_size=5', 'lookup_size=6' and 'smoothness=1'.
#@gmic : $ image.jpg --denoise 5,5,8

#@gmic denoise_haar : _threshold>=0,_nb_scales>=0,_cycle_spinning>0
#@gmic : Denoise selected image using haar-wavelet thresholding with cycle spinning.
#@gmic : Set 'nb_scales==0' to automatically determine the optimal number of scales.
#@gmic : Default values: 'threshold=1.4', 'nb_scale=0' and 'cycle_spinning=10'.
#@gmic : $ image.jpg -noise 20 -c 0,255 --denoise_haar[-1] 0.8
denoise_haar : -check "${1=1.4}>=0 && isint(${2=0}) && $2>=0 && isint(${3=10}) && $3>0"
  -e[^-1] "Denoise image$? using haar-wavelet thresholding, with threshold $1, "\
          @{-arg\ 1+($2>0),auto,$2}" scales and $3 spinning cycles."
  -v - -repeat @# -l[$>] nm=@{0,n}
    nb_scales={min(if($2,$2,32),int(log2(min(w,h))-1))}
    w={w} h={h} d={d} sigma=@{-std_noise}
    -r {round(w,2^($nb_scales+1),1)},{round(h,2^($nb_scales+1),1)},{if(d==1,1,round(d,2^($nb_scales+1),1))},100%,0,0
    --f 0
    -repeat $3
      dx={round(?(0,{4*$nb_scales}))}
      dy={round(?(0,{4*$nb_scales}))}
      dz={if($d==1,0,round(?(0,{4*$nb_scales})))}
      --shift[0] $dx,$dy,$dz,0,2
      -haar[-1] $nb_scales
      -threshold[-1] {$1*$sigma},1
      -ihaar[-1] $nb_scales
      -shift[-1] {-$dx},{-$dy},{-$dz},0,2
      -+[-2,-1]
    -done
    -rm[0] -/ $3 -r $w,$h,$d,100%,0
  -nm $nm,1 -endl -done -v +

#@gmic deriche : std_variation>=0[%],order={ 0 | 1 | 2 },axis={ x | y | z | c },_boundary : (+)
#@gmic : Apply Deriche recursive filter on selected images, along specified axis and with
#@gmic : specified standard deviation, order and boundary conditions.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : Default value: 'boundary=1'.
#@gmic : $ image.jpg --deriche 3,1,x
#@gmic : $ image.jpg --deriche 30,0,x -deriche[-2] 30,0,y -add
#@gmic : $$

#@gmic dilate : size>=0 : size_x>=0,size_y>=0,size_z>=0 : [mask],_boundary,_is_normalized={ 0 | 1 } : (+)
#@gmic : Dilate selected images by a rectangular or the specified structuring element.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : Default values: 'size_z=1', 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg --dilate 10

#@gmic dilate_circ : _size>=0,_boundary,_is_normalized={ 0 | 1 }
#@gmic : Apply circular dilation of selected image by specified size.
#@gmic : Default values: 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg --dilate_circ 7
dilate_circ : -check $1>=0 -skip ${2=1},${3=0}
  -e[^-1] "Apply circular dilation of image$? by size $1, boundary $2 and is_normalized $3."
  -if {$1<2} -return -endif
  -v - -_dt_circle[] $1 -dilate[^-1] [-1],$2,$3 -rm[-1] -v +

#@gmic dilate_oct : _size>=0,_boundary,_is_normalized={ 0 | 1 }
#@gmic : Apply octagonal dilation of selected image by specified size.
#@gmic : Default values: 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg --dilate_oct 7
dilate_oct : -check $1>=0 -skip ${2=1},${3=0}
  -e[^-1] "Apply octagonal dilation of image$? by size $1, boundary $2 and is_normalized $3."
  -v -
  -if {$1<2} -return -endif
  -if {$1&1} ss={$1} -else ss={$1+1} -endif
  -i[0] (0,1,0;1,1,1;0,1,0) -i[1] (1,1,1;1,1,1;1,1,1)
  -repeat {@#-2}
    r={round(($ss-1)*sqrt(2)/(1+sqrt(2))/2)}
    q={round(($ss-1)/(1+sqrt(2))/2)}
    -if {$r>0} -repeat $r -dilate[-1] [0],$2,$3 -done -endif
    -if {$q>0} -repeat $q -dilate[-1] [1],$2,$3 -done -endif
  -mv[-1] 2 -done -rm[0,1] -v +

_kr_circle :
  -if {$1%2==0} -i 2,2,1,1,1 -else -i 1,1,1,1,1 -endif -r[-1] $1,$1,1,1,0,0,0.5,0.5
  -distance[-1] 1 -round[-1] 0.5 -ir[-1] 0,{$1/2}

_jf_circle :
  {round($1)},{round($1)}
  center={0.5*(w-1)}
  -f[-1] 'sqrt((x-$center)^2+(y-$center)^2)'
  -if {!(w%2)}
    -round[-1] 0.0001,-1
    t1={sqrt(((round($1)-1)/2)^2+0.25)}
    t2={sqrt(((round($1)+1)/2)^2+0.25)}
    k={$1-round($1)+0.5}
    t={$t1+($t2-$t1)*$k}
    -ir[-1] 0,$t
  -else -ir[-1] 0,{$1/2-0.25}
  -endif

_dt_circle :
 ir={round($1)}
 -if {!$ir} 1,1
 -elif {$ir<2} $ir,$ir,1,1,1
 -else
   {int($ir/2)+($ir%2)},{int($ir/2)+($ir%2)} -=[-1] 1,100%,100%
   -distance[-1] 1 -<=[-1] {(i+0.4)/sqrt(2)}
   --mirror[-1] x
   -if {$ir>1&&($ir%2)} -r[-1] {w-1},100%,1,1,0,0,1 -endif
   -a[-2,-1] x --mirror[-1] y
   -if {$ir>1&&($ir%2)} -r[-1] 100%,{h-1},1,1,0,0,0,1 -endif
   -a[-2,-1] y
 -endif

_dt_diamond :
 ir={round($1)}
 -if {$ir<2} $ir,$ir,1,1,1
 -else
   {int($ir/2)+($ir%2)},{int($ir/2)+($ir%2)} -=[-1] 1,100%,100%
   -distance[-1] 1,1 -<=[-1] {i/2}
   --mirror[-1] x
   -if {$ir>1&&($ir%2)} -r[-1] {w-1},100%,1,1,0,0,1 -endif
   -a[-2,-1] x --mirror[-1] y
   -if {$ir>1&&($ir%2)} -r[-1] 100%,{h-1},1,1,0,0,0,1 -endif
   -a[-2,-1] y
 -endif

#@gmic dilate_threshold : size_x>=1,size_y>=1,size_z>=1,_threshold>=0,_boundary
#@gmic : Dilate selected images in the (X,Y,Z,I) space.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : Default values: 'size_y=size_x', 'size_z=1', 'threshold=255' and 'boundary=1'.
dilate_threshold : -check "isint($1) && $1>=1 && isint(${2=$1}) && $2>=1 && isint(${3=1}) && $3>=1 && ${4=255}>=0 && isint(${5=1}) && $5>=0"
  -e[^-1] "Erode image$? with mask $1x$2x$3, threshold $4 and "@{-arg\ $5,dirichlet,neumann}" boundary conditions."
  -v - -l[]
    dx1={int($1/2)} dx2={$1-$dx1-1}
    dy1={int($2/2)} dy2={$2-$dy1-1}
    dz1={int($3/2)} dz2={$3-$dz1-1}
    (-$dx1,$dx1) (-$dy1;$dy1) (-$dz1/$dz1) -r $1,$2,$3,1,3 -a c -round -r {w*h*d},3,1,1,-1 -transpose[-1]
    -i[-2] 1,100%,1,1,254 1,100%,1,1,255 -a x
    ({'@-1'}) -rm[-2] -replace_str "254,","(v=j(" -replace_str ",255",",0,0,$5);if(abs(v-i)<=$4,v,-1e20))" list=@{-1,t}
    -rm
  -endl
  -f 'max($list)'
  -v +

#@gmic divergence
#@gmic : Compute divergence of selected vector fields.
#@gmic : $ image.jpg -luminance --gradient -append[-2,-1] c -divergence[-1]
divergence :
  -e[^-1] "Compute divergence of vector field$?."
  -v - -repeat @# -l[$>]
    -if {s==1} -g x,0
    -elif {s==2} -s c -g[-2] x,0 -g[-1] y,0 -+
    -elif {s==3} -s c -g[-3] x,0 -g[-2] y,0 -g[-1] z,0 -+
    -else -error[] "Command '-divergence': Cannot compute divergence of image ["$>"] (has "{s}">3 channels)."
    -endif
  -endl -done -v +

#@gmic dog : _sigma1>=0[%],_sigma2>=0[%]
#@gmic : Compute difference of gaussian on selected images.
#@gmic : Default values: 'sigma1=2%' and 'sigma2=3%'.
#@gmic : $ image.jpg --dog 2,3
dog : -check "${1=2%}>=0 && ${2=3%}>=0"
  -e[^-1] "Compute difference of gaussian on image$?, with standard deviations $1 and $2."
  -v - -repeat @# -l[$>]
    [0] -parallel "-b[0] $1","-b[1] $2" -- -norm
  -endl -done -v +

#@gmic diffusiontensors : _sharpness>=0,0<=_anisotropy<=1,_alpha[%],_sigma[%],is_sqrt={ 0 | 1 }
#@gmic : Compute the diffusion tensors of selected images for edge-preserving smoothing algorithms.
#@gmic : Default values: 'sharpness=0.7', 'anisotropy=0.3', 'alpha=0.6', 'sigma=1.1' and 'is_sqrt=0'.
#@gmic : $ image.jpg -diffusiontensors 0.8 -abs -pow 0.2
#@gmic : $$
diffusiontensors : -check "${1=0.7}>=0 && ${2=0.3}>=0 && $2<=1" -skip ${3=0.6},${4=1.1},${5=0}
  -e[^-1] "Compute diffusion tensors for image$?, with sharpness $1, anisotropy $2, alpha $3 and sigma $4."
  -v -
  p1={if($5,0.5,1)*max($1,1e-5)}
  p2={$p1/(1e-7+1-$2)}
  -b $3 -n 0,255 -structuretensors 2 -b $4
  -repeat @# -l[$>]
    -eigen -max[-2] 0
    -if {s==2} -s[-2] c -+[-3,-2] -+[-2] 1 --^[-2] -$p1 -^[-3] -$p2 -a[-3,-1] c                     # 2d
    -else -s[-2] c -+[-4--2] -+[-2] 1 --^[-2] -$p1 -r[-1] 100%,100%,100%,2 -^[-3] -$p2 -a[-3,-1] c  # 3d
    -endif
    -eigen2tensor
  -endl -done -v +

#@gmic edges : _threshold[%]>=0
#@gmic : Estimate contours of selected images.
#@gmic : Default value: 'edges=15%'
#@gmic : $ image.jpg --edges 15%
edges : -skip ${1=15%}
  -e[^-1] "Estimate image contours of image$?, with threshold $1."
  -v - -gradient_norm -b 0.5 ->= $1 -distance 0 -equalize -negative -c 30%,70% -n 0,1 -v +

#@gmic erode : size>=0 : size_x>=0,size_y>=0,_size_z>=0 : [mask],_boundary,_is_normalized={ 0 | 1 } : (+)
#@gmic : Erode selected images by a rectangular or the specified structuring element.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : Default values: 'size_z=1', 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg --erode 10

#@gmic erode_circ : _size>=0,_boundary,_is_normalized={ 0 | 1 }
#@gmic : Apply circular erosion of selected images by specified size.
#@gmic : Default values: 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg --erode_circ 7
erode_circ : -check $1>=0 -skip ${2=1},${3=0}
  -e[^-1] "Apply circular erosion of image$? by size $1, boundary $2 and is_normalized $3."
  -if {$1<2} -return -endif
  -v - -_dt_circle[] $1 -erode[^-1] [-1],$2,$3 -rm[-1] -v +

#@gmic erode_oct : _size>=0,_boundary,_is_normalized={ 0 | 1 }
#@gmic : Apply octagonal erosion of selected images by specified size.
#@gmic : Default values: 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg --erode_oct 7
erode_oct : -check $1>=0 -skip ${2=1},${3=0}
  -e[^-1] "Apply octagonal erosion of image$? by size $1, boundary $2 and is_normalized $3."
  -v -
  -if {$1<2} -return -endif
  -if {$1&1} ss={$1} -else ss={$1+1} -endif
  -i[0] (0,1,0;1,1,1;0,1,0) -i[1] (1,1,1;1,1,1;1,1,1)
  -repeat {@#-2}
    r={round(($ss-1)*sqrt(2)/(1+sqrt(2))/2)}
    q={round(($ss-1)/(1+sqrt(2))/2)}
    -if {$r>0} -repeat $r -erode[-1] [0],$2,$3 -done -endif
    -if {$q>0} -repeat $q -erode[-1] [1],$2,$3 -done -endif
  -mv[-1] 2 -done -rm[0,1] -v +

#@gmic erode_threshold : size_x>=1,size_y>=1,size_z>=1,_threshold>=0,_boundary
#@gmic : Erode selected images in the (X,Y,Z,I) space.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : Default values: 'size_y=size_x', 'size_z=1', 'threshold=255' and 'boundary=1'.
erode_threshold : -check "isint($1) && $1>=1 && isint(${2=$1}) && $2>=1 && isint(${3=1}) && $3>=1 && ${4=255}>=0 && isint(${5=1}) && $5>=0"
  -e[^-1] "Erode image$? with mask $1x$2x$3, threshold $4 and "@{-arg\ $5,dirichlet,neumann}" boundary conditions."
  -v - -l[]
    dx1={int($1/2)} dx2={$1-$dx1-1}
    dy1={int($2/2)} dy2={$2-$dy1-1}
    dz1={int($3/2)} dz2={$3-$dz1-1}
    (-$dx1,$dx1) (-$dy1;$dy1) (-$dz1/$dz1) -r $1,$2,$3,1,3 -a c -round -r {w*h*d},3,1,1,-1 -transpose[-1]
    -i[-2] 1,100%,1,1,254 1,100%,1,1,255 -a x
    ({'@-1'}) -rm[-2] -replace_str "254,","(v=j(" -replace_str ",255",",0,0,$5);if(abs(v-i)<=$4,v,1e20))" list=@{-1,t}
    -rm
  -endl
  -f 'min($list)'
  -v +

#@gmic fft : _{ x | y | z }..{ x | y | z } : (+)
#@gmic : Compute the direct fourier transform (real and imaginary parts) of selected images,
#@gmic : optionally along the specified axes only.
#@gmic : $ image.jpg -luminance --fft -append[-2,-1] c -norm[-1] -log[-1] -shift[-1] 50%,50%,0,0,2
#@gmic : $ image.jpg -fft -shift 50%,50%,0,0,2 -ellipse 50%,50%,30,30,0,1,0 -shift -50%,-50%,0,0,2 -ifft -remove[-1]
#@gmic : $$

#@gmic g : eq. to '-gradient'. : (+)

#@gmic gradient : { x | y | z }..{ x | y | z },_scheme : (no arg) : (+)
#@gmic : Compute the gradient components (first derivatives) of selected images.
#@gmic : (eq. to '-g').
#@gmic : 'scheme' can be { -1=backward | 0=centered | 1=forward | 2=sobel | 3=rotation-invariant (default) | 4=deriche | 5=vanvliet }.
#@gmic : (no arg) compute all significant 2d/3d components.
#@gmic : Default value: 'scheme=3'.
#@gmic : $ image.jpg -gradient
#@gmic : $$

#@gmic gradient_norm
#@gmic : Compute gradient norm of selected images.
#@gmic : $ image.jpg --gradient_norm -equalize[-1]
#@gmic : $$
gradient_norm :
  -e[^-1] "Compute gradient norm of image$?."
  -v - -repeat @# -l[$>]
    --g x -sqr[-1]
    --g[-2] y -sqr[-1] -+[-2,-1]
    -g[-2] z -sqr[-2] -+[-2,-1]
    s={s} -s[-1] c -+[-$s--1] -sqrt[-1]
  -endl -done -v +

#@gmic gradient_orientation : _dimension={1,2,3}
#@gmic : Compute N-d gradient orientation of selected images.
#@gmic : Default value: 'dimension=3'.
#@gmic : $ image.jpg --gradient_orientation 2
gradient_orientation : -check "${1=3}==1 || $1==2 || $1==3"
  -e[^-1] "Compute $1-d gradient orientation of image$?."
  -v - -repeat @# -l[$<]
    -if {$1==1} -g x --abs[-1] -+[-1] 1e-8 -/
    -elif {$1==2} -g xy --sqr -+[-2,-1] -+[-1] 1e-8 -sqrt[-1] -/[-3] [-1] -/[-2,-1]
    -else -g xyz --sqr -+[-3--1] -+[-1] 1e-8 -sqrt[-1] -/[-4,-3] [-1] -/[-2,-1]
    -endif
  -endl -done -v +

#@gmic guided : [guide],radius[%]>0,regularization>0 : radius[%]>0,regularization>0 : (+)
#@gmic : Blur selected images by guided image filtering.
#@gmic : If a guide image is provided, it is used to drive the smoothing process.
#@gmic : A guide image must be of the same xyz-size as the selected images.
#@gmic : This command implements the filtering algorithm described in:
#@gmic : He, Kaiming; Sun, Jian; Tang, Xiaoou, "Guided Image Filtering," Pattern Analysis and Machine Intelligence,
#@gmic : IEEE Transactions on , vol.35, no.6, pp.1397,1409, June 2013
#@gmic : $ image.jpg [0] --guided[-1] 5,400

#@gmic haar : scale>0
#@gmic : Compute the direct haar multiscale wavelet transform of selected images.
#@gmic : $$
haar : -check "isint(${1=1}) && $1>=0"
  -e[^-1] "Compute haar transform of image$? with $1 scales."
  -v - -repeat @# -l[$>]
    -_haar
    -repeat {$1-1}
      w={max(0,round(w/2^(1+$>))-1)}
      h={max(0,round(h/2^(1+$>))-1)}
      d={max(0,round(d/2^(1+$>))-1)}
      --z 0,0,0,$w,$h,$d -_haar[-1] -j[-2] [-1] -rm[-1]
    -done
  -endl -done -v +

_haar : # Mono-scale direct haar transform.
  -_haar_x -_haar_y -_haar_z

_haar_x : # Direct haar transform along the x-axis.
  -if {w<=1} -return -endif
  -if {w%2} -error[0--6] "Command '-haar': Invalid image width="{w}" (is not even)." -endif
  --shift -1 -r 50% ---[1] [0] -+[0,1] -/ {sqrt(2)} -a x

_haar_y : # Direct haar transform along the y-axis.
  -if {h<=1} -return -endif
  -if {h%2} -error[0--6] "Command '-haar': Invalid image height="{h}" (is not even)." -endif
  --shift 0,-1 -r 100%,50% ---[1] [0] -+[0,1] -/ {sqrt(2)} -a y

_haar_z : # Direct haar transform along the z-axis.
  -if {d<=1} -return -endif
  -if {d%2} -error[0--6] "Command '-haar': Invalid image depth="{h}" (is not even)." -endif
  --shift 0,0,-1 -r 100%,100%,50% ---[1] [0] -+[0,1] -/ {sqrt(2)} -a z

#@gmic heat_flow : _nb_iter>=0,_dt,_keep_sequence={ 0 | 1 }
#@gmic : Apply iterations of the heat flow on selected images.
#@gmic : Default values: 'nb_iter=10', 'dt=30' and 'keep_sequence=0'.
#@gmic : $ image.jpg --heat_flow 20
heat_flow : -skip ${1=10},${2=30},${3=0}
  -e[^-1] "Apply $1 iterations of the heat flow on image$?, with time step $2."
  -v - -pde_flow $1,$2,laplacian,$3 -v +

#@gmic hessian : { xx | xy | xz | yy | yz | zz }..{ xx | xy | xz | yy | yz | zz } : (no arg) : (+)
#@gmic : Compute the hessian components (second derivatives) of selected images.
#@gmic : (no arg) compute all significant components.
#@gmic : $ image.jpg -hessian

#@gmic idct : _{ x | y | z }..{ x | y | z } : (no arg)
#@gmic : Compute the inverse discrete cosine transform of selected images,
#@gmic : optionally along the specified axes only.
#@gmic : Default values: (no arg)
idct : -skip ${1=0}
  -v - ({'"$1"'})
  is_axes={im>={'x'}&&iM<={'z'}}
  -if $is_axes
    -v + -e[0--3] "Compute inverse discrete cosine transform of image$? along axes '$1'." -v -
    -repeat {w}
      axis={i[$>]}
      -if {$axis=={'x'}} -repeat {@#-1} -l[$>] -if {w>1} -_idct -endif -endl -done
      -elif {$axis=={'y'}} -repeat {@#-1} -l[$>] -if {h>1} -permute yxzc -_idct -permute yxzc -endif -endl -done
      -elif {$axis=={'z'}} -repeat {@#-1} -l[$>] -if {d>1} -permute zxyc -_idct -permute yzxc -endif -endl -done
      -endif
    -done
  -else
    -rm[-1]
    -v + -e[0--3] "Compute inverse discrete cosine transform of image$?." -v -
    -noarg
    -repeat @# -l[$>]
      -if {w>1} -_idct -endif
      -if {h>1} -permute yxzc -_idct -permute yxzc -endif
      -if {d>1} -permute zxyc -_idct -permute yzxc -endif
    -endl -done
  -endif
  -v +

# 1d inverse transform (DCT-III) for a single image.
_idct :
  is_odd={w%2}
  -/ {sqrt(2/w)} --z[0] 0,0 -*[-1] {sqrt(2)} -j[-2] [-1],0,0,0 -rm[-1] # Make the transform orthogonal.
  -if $is_odd -r {w+1},100%,100%,100%,0,0 -endif
  --mirror x -shift[-1] 1 -*[-1] -1
  100%,1,1,1,cos(x*pi/(2*w))
  100%,1,1,1,sin(x*pi/(2*w))
  --*[0,3] --*[1,2] -+[-2,-1]
  -*[0,2] -*[1,2] --[0,1]
  -ifft x -k[0] -/ 2
  -s x,2 -mirror[-1] x
  -r[0] 200%,100%,1,100%,4,0,0
  -r[1] 200%,100%,1,100%,4,0,1
  -+
  -if $is_odd -r {w-1},100%,100%,100%,0 -endif

#@gmic iee
#@gmic : Compute gradient-orthogonal-directed 2nd derivative of image(s).
#@gmic : $ image.jpg -iee
iee :
  -e[^-1] "Compute gradient-orthogonal-directed 2nd derivative of image$?."
  -v - -repeat @# -l[$>]
    -if {d==1}
      --g xy,0 -hessian[-3] xxxyyy         # ixx ixy iyy ix iy
      -*[-3] [-2] -*[-4] [-1] -*[-4] -2    # ixx -2iyixy ixiyy ix iy
      -+[-4,-3] -*[-3] [-2]                # ixx -2ixiyixy+ix^2iyy ix iy
      -sqr[-2,-1] -*[-4] [-1] -+[-4,-3]    # iy^2ixx-2ixiyixy+ix^2iyy ix^2 iy^2
      -+[-2,-1] -+[-1] 1e-8 -/             # (iy^2ixx+2ixiyixy+ix^2iyy)/(ix^2+iy^2)
    -else
      --inn -laplacian[-2] --
    -endif
  -endl -done -v +

#@gmic ifft : _{ x | y | z }..{ x | y | z } : (+)
#@gmic : Compute the inverse fourier transform (real and imaginary parts) of selected images.
#@gmic : optionally along the specified axes only.
#@gmic : $$ _fft

#@gmic ihaar : scale>0
#@gmic : Compute the inverse haar multiscale wavelet transform of selected images.
ihaar : -check "isint(${1=1}) && $1>=0"
  -e[^-1] "Compute inverse haar transform of image$? with $1 scales."
  -v - -repeat @# -l[$>]
    -repeat {$1-1}
      w={max(0,round(w/2^(1+$<))-1)}
      h={max(0,round(h/2^(1+$<))-1)}
      d={max(0,round(d/2^(1+$<))-1)}
      --z 0,0,0,$w,$h,$d -_ihaar[-1] -j[-2] [-1] -rm[-1]
    -done
    -_ihaar
  -endl -done -v +

_ihaar : # Mono-scale inverse haar transform.
  -_ihaar_x -_ihaar_y -_ihaar_z

_ihaar_x : # Inverse haar transform along the x-axis.
  -if {w<=1} -return -endif
  -if {w%2} -error[0--6] "Command '-ihaar': Invalid image width="{w}" (is not even)." -endif
  -s x,2 -r 200% (-1,1) -*[-2,-1] -+ -/ {sqrt(2)}

_ihaar_y : # Inverse haar transform along the y-axis.
  -if {h<=1} -return -endif
  -if {h%2} -error "Command '-ihaar': Invalid image height="{h}" (is not even)." -endif
  -s y,2 -r 100%,200% (-1;1) -r[-1] @{-2,w} -*[-2,-1] -+ -/ {sqrt(2)}

_ihaar_z : # Inverse haar transform along the z-axis.
  -if {d<=1} -return -endif
  -if {d%2} -error "Command '-ihaar': Invalid image depth="{h}" (is not even)." -endif
  -s z,2 -r 100%,100%,200% (-1/1) -r[-1] @{-2,w},@{-2,h} -*[-2,-1] -+ -/ {sqrt(2)}

#@gmic inn
#@gmic : Compute gradient-directed 2nd derivative of image(s).
#@gmic : $ image.jpg -inn
inn :
  -e[^-1] "Compute gradient-directed 2nd derivative of image$?."
  -v - -repeat @# -l[$>]
    -if {d==1}
      --g xy,0 -hessian[-3] xxxyyy         # ixx ixy iyy ix iy
      -*[-5] [-2] -*[-4] [-1] -*[-4] 2     # ixixx 2iyixy iyy ix iy
      -+[-5,-4] -*[-4] [-2]                # ix^2ixx+2ixiyixy iyy ix iy
      -sqr[-2,-1] -*[-3] [-1] -+[-4,-3]    # ix^2ixx+2ixiyixy+iy^2iyy ix^2 iy^2
      -+[-2,-1] -+[-1] 1e-8 -/             # (ix^2ixx+2ixiyixy+iy^2iyy)/(ix^2+iy^2)
    -else
      --g xyz,0 -hessian[-4] xxxyxzyyyzzz                     # ixx ixy ixz iyy iyz izz ix iy iz
      -*[-9] [-3] -*[-8] [-2] -*[-8] 2 -*[-7] [-1] -*[-7] 2   # ixixx 2iyixy 2izixz iyy iyz izz ix iy iz
      -+[-9--7] -*[-7] [-3]                                   # ix^2ixx+2ixiyixy+2ixizixy iyy iyz izz ix iy iz
      -*[-6] [-2] -*[-5] [-1] -*[-5] 2                        # ix^2ixx+2ixiyixy+2ixizixy iyiyy 2iziyz izz ix iy iz
      -+[-6,-5] -*[-5] [-2] -+[-6,-5]                         # ix^2ixx+2ixiyixy+2ixizixy+iy^2iyy+2iyiziyz izz ix iy iz
      -sqr[-3--1] -*[-4] [-1] -+[-5,-4]                       # ix^2ixx+2ixiyixy+2ixizixy+iy^2iyy+2iyiziyz+iz^2izz ix^2 iy^2 iz^2
      -+[-3--1] -+[-1] 1e-8 -/                                # (ix^2ixx+2ixiyixy+2ixizixy+iy^2iyy+2iyiziyz+iz^2izz)/(ix^2+iy^2+iz^2)
    -endif
  -endl -done -v +

#@gmic inpaint : [mask] : [mask],0,_fast_method : [mask],_patch_size>=1,_lookup_size>=1,_lookup_factor>=0,_lookup_increment!=0,_blend_size>=0,0<=_blend_threshold<=1,_blend_decay>=0,_blend_scales>=1,_is_blend_outer={ 0 | 1 } : (+)
#@gmic : Inpaint selected images by specified mask.
#@gmic : If no patch size (or 0) is specified, inpainting is done using a fast average or median algorithm.
#@gmic : Otherwise, it used a patch-based reconstruction method, that can be very time consuming.
#@gmic : 'fast_method' can be { 0=low-connectivity average | 1=high-connectivity average | 2=low-connectivity median | 3=high-connectivity median }.
#@gmic : Default values: 'patch_size=0', 'fast_method=1', 'lookup_size=22', 'lookup_factor=0.5', 'lookup_increment=1', 'blend_size=0', 'blend_threshold=0', 'blend_decay=0.05', 'blend_scales=10' and 'is_blend_outer=1'.
#@gmic : $ image.jpg 100%,100% -ellipse 50%,50%,30,30,0,1,255 -ellipse 20%,20%,30,10,0,1,255 --inpaint[-2] [-1] -remove[-2]
#@gmic : $ image.jpg 100%,100% -circle 30%,30%,30,1,255,0,255 -circle 70%,70%,50,1,255,0,255 --inpaint[0] [1],5,15,0.5,1,9,0 -remove[1]

#@gmic inpaint_flow : _nb_iter1>=0,_nb_iter2>=0,_dt>=0,_alpha,_sigma
#@gmic : Apply iteration of the inpainting flow on selected images.
#@gmic : Default values: 'nb_iter1=4', 'nb_iter2=15', 'dt=15', 'alpha=1' and 'sigma=3'.
#@gmic : $ image.jpg 100%,100% -ellipse[-1] 30%,30%,40,30,0,1,255 -reverse -inpaint_flow ,
inpaint_flow : -skip ${1=4},${2=15},${3=15},${4=1},${5=3}
  -e[^-1] "Apply $1 iteration of the inpainting flow on image$?."
  -v - -norm[0] -quantize[0] 2,1,1 -n[0] 0,1
  -repeat @# -if $> -l[0,$>]
    -r[0] [1] -inpaint[1] [0]
    -repeat $1 --diffusiontensors[1] 0,1,$4,$5,0 -*[2] [0] -smooth[1] [2],$2,$3,0 -rm[2] -done
  -endl -endif -done -v +

#@gmic inpaint_holes : maximal_area[%]>=0,_tolerance>=0,_is_high_connectivity={ 0 | 1 }
#@gmic : Inpaint all connected regions having an area less than specified value.
#@gmic : Default values: 'maximal_area=4', 'tolerance=0' and 'is_high_connectivity=0'.
#@gmic : $ image.jpg -noise 5%,2 --inpaint_holes 8,40
inpaint_holes : -check "${1=4}>=0 && ${2=0}>=0" -skip ${3=0}
  -e[^-1] "Inpaint holes wih area less than $1 pixels in image$?, with tolerance $2 and "@{-arg\ 1+!$3,high,low}" connectivity."
  -v - -repeat @# -l[$>]
    100%,100%,100%
    area={if(@{-is_percent\ $1},$1*w*h*d,$1)}
    -repeat @{0,s} -sh[0] $>,$> --area[-1] $2,$3 -<=[-1] $1 -or[1,-1] -rm[-1] -done
    -if {im} -k[0] whd={w},{h},{d} -r 1,1,1,100%,2 -r $whd,100%
    -else -inpaint[0] [1],0,{2*!$2+!!$3} -k[0] -endif
  -endl -done -v +

#@gmic kuwahara : size>0
#@gmic : Apply Kuwahara filter of specified size on selected images.
#@gmic : $ image.jpg --kuwahara 5
kuwahara : -check $1>0
  -e[^-1] "Apply Kuwahara filter of size $1 on image$?."
  -v - -repeat @# -l[$>]
    s={s}
    --dilate $1 -compose_channels[-1] min
    --erode[0] $1 -compose_channels[-1] max
    --[-2,-1]
    $1,1,1,1,{1/$1} -convolve[0] [-1] -transpose[-1] -convolve[0] [-1] -rm[-1]
    p={int($1/2)}
    -a[-2,-1] c
    -f "v1=i(x-"$p",y-"$p",0,"$s",0,1); \
        v2=i(x+"$p",y-"$p",0,"$s",0,1); \
        v3=i(x-"$p",y+"$p",0,"$s",0,1); \
        v4=i(x+"$p",y+"$p",0,"$s",0,1); \
        vm=min(v1,v2,v3,v4); \
        if(c>="$s",i, \
          if(vm==v1,i(x-"$p",y-"$p",0,c,0,1),
            if(vm==v2,i(x+"$p",y-"$p",0,c,0,1),
              if(vm==v3,i(x-"$p",y+"$p",0,c,0,1),
                i(x+"$p",y+"$p",0,c,0,1)))))"
    -channels 0,{s-2}
  -endl -done -v +

#@gmic laplacian
#@gmic : Compute Laplacian of selected images.
#@gmic : $ image.jpg -laplacian
laplacian :
  -e[^-1] "Compute Laplacian of image $?."
  -v - -repeat @# -l[$>]
    -hessian @{-arg\ 1+(d==1),xxyyzz,xxyy} -+
  -endl -done -v +

#@gmic lic : _amplitude>0,_channels>0
#@gmic : Render LIC representation of selected vector fields.
#@gmic : Default values: 'amplitude=30' and 'channels=1'.
#@gmic : $ 400,400,1,2,'if(c==0,x-w/2,y-h/2)' --lic 200,3 -quiver[-2] [-2],10,-13,1,1,255
lic : -skip ${1=30},${2=1}
  -e[^-1] "Render LIC representation of 2d vector field$?, with amplitude $1 and $2 channel(s)."
  -v - -repeat @# -l[$>] nm=@{0,n}
     -channels 0,1 -/ {max(abs(@{-1,m}),abs(@{-1,M}))} -vector2tensor
     100%,100%,100%,$2 -rand[-1] 0,255 -smooth[-1] [-2],$1 -rm[-2]
     -equalize
  -nm $nm,1 -endl -done -v +

#@gmic map_tones : _threshold>=0,_gamma>=0,_smoothness>=0,nb_iter>=0
#@gmic : Apply tone mapping operator on selected images, based on Poisson equation.
#@gmic : Default values: 'threshold=0.1', 'gamma=0.8', 'smoothness=0.5' and 'nb_iter=30'.
#@gmic : $ image.jpg --map_tones ,
map_tones : -skip ${1=0.1},${2=0.8},${3=0.5},${4=30}
  -e[^-1] "Apply tone mapping operator on image$?, with threshold $1, gamma $2, smoothness $3 and $4 iterations."
  -v - -repeat @# -l[$>]

    # Estimate target divergence for each channel.
    --l -s c -repeat @# -l[$>]
      -g xy,1 -a c --norm -orientation[-2]
      m={im} M={iM} -b[-1] $3 -n[-1] $m,$M
      -*[-1] 'alpha=$1*iM;(alpha/(1e-10+i))*(i/(1e-10+alpha))^$2'
      -* -s c -g[-2] x,-1 -g[-1] y,-1 -+
    -endl -done -a c -* 0.25 -endl

   # Start Poisson-PDE iterations
    -repeat $4 --laplacian[-2] -*[-1] 0.25 -+[-1] [-3] --[-1] [-2] -*[-1] 800 -+[-3,-1] -/[-2] 801 -c[-2] 0,255 -done -rm[-1]

  -endl -done  -v +

#@gmic map_tones_fast : _radius[%]>=0,_power>=0
#@gmic : Apply fast tone mapping operator on selected images.
#@gmic : Default values: 'radius=3%' and 'power=0.3'.
#@gmic : $ image.jpg --map_tones_fast ,
map_tones_fast : -check "${1=3%}>=0 && ${2=0.3}>=0"
  -e[^-1] "Apply fast tone mapping operator on image$?, with radius $1 and power $2."
  -v - -repeat @# -l[$>]
    --luminance -b[-1] $1 -n 0,1
    --*[-1] 2 --[-1] 1 -abs[-1] -*[-1] {$2*log(10)} -exp[-1]
    -<=[-2] 0.5 -r[-1] [-3]
    --*[-3] -1 -+[-1] 1 -^[-1] [-2] -*[-1] -1 -+[-1] 1 -*[-1] [-3]
    -^[-4,-2] -==[-2] 0 -*[-3,-2] -+
  -endl -done -n 0,255 -v +

#@gmic meancurvature_flow : _nb_iter>=0,_dt,_sequence_flag={ 0 | 1 }
#@gmic : Apply iterations of the mean curvature flow on selected images.
#@gmic : Default values: 'nb_iter=10', 'dt=30' and 'keep_sequence=0'.
#@gmic : $ image.jpg --meancurvature_flow 20
meancurvature_flow : -skip ${1=10},${2=30},${3=0}
  -e[^-1] "Apply $1 iterations of the mean curvature flow on image$?, with time step $2."
  -v - -pde_flow $1,$2,iee,$3 -v +

#@gmic median : size>=0,_threshold>0 : (+)
#@gmic : Apply (opt. thresholded) median filter on selected images with structuring element size x size.
#@gmic : $ image.jpg --median 5

#@gmic nlmeans : _patch_radius>0,_spatial_bandwidth>0,_tonal_bandwidth>0,_patch_measure_command
#@gmic : Apply non local means denoising of Buades et al, 2005. on selected images.
#@gmic : The patch is a gaussian function of 'std _patch_radius'.
#@gmic : The spatial kernel is a rectangle of radius 'spatial_bandwidth'.
#@gmic : The tonal kernel is exponential (exp(-d^2/_tonal_bandwidth^2))
#@gmic : with d the euclidiean distance between image patches.
#@gmic : Default values: 'patch_radius=4', 'spatial_bandwidth=4', 'tonal_bandwidth=10' and 'patch_measure_command=-norm'.
#@gmic : $ image.jpg --noise 10 -nlmeans[-1] 4,4,{0.6*@{-std_noise}}
nlmeans: -check "${1=4}>0 && ${2=4}>0 && ${3=10}>0" -skip "${4=-norm}"
  -e[^-1] "Apply non-local means denoising with patch size $1, spatial bandwidth $2, tonal bandwidth $3 and patch measure command '$4'."
  -v - -repeat @# -l[$>]
    # [1] preprocessed image used to compute weights.
    --l $4 -k[0] -endl

    # [2] compute a scaling.
    100%,100%,100%,100%,{-1.0/($3*$3)}
    # Apply the NLM denoising with image 1 and 2 as parameter.
    -nlmeans_core[0] [1],[2],$1,$2
    -rm[-1,-2] # Clean up.
  -endl -done -v +

#@gmic nlmeans_core: _reference_image,_scaling_map,_patch_radius>0,_spatial_bandwidth>0
#@gmic : Apply non local means denoising using a image for weigth and a map for scaling
nlmeans_core: -check @{-is_image_arg\ $1}" && "@{-is_image_arg\ $2}" && $3>0 && $4>0"
  -e[^-1] "Apply non-local means denoising using weight images $1, scaling map $2, patch size $3 and spatial bandwidth $4."
  -v - -pass$1 0 -pass$2 0
  -repeat {@#-2} -l[$>,-1,-2]
    # [0] original, [1] weights, [2] scaling [3] sum(weights * patch), [4] sum(weights), [5] max(weights)
    100%,100%,100%,@{0,s},0 100%,100%,100%,@{1,s},0 100%,100%,100%,@{1,s},0
    -if {@{0,d}==1}
      -repeat {2*$4+1} j={$>-$4-1} -repeat {2*$4+1} i={$>-$4-1}
        -if {$i!=0||$j!=0}
          # Compute shifted images [6] and weight [7]
          --shift[0,1] $i,$j,0,0,2 --[7] [1]
          -sqr[7] -blur[7] $3 -*[7] [2] -exp[7]
          # Accumulate weights
          -*[6] [7] -max[5] [7] -+[4,7] -+[3,6]
        -endif
      -done -done
    -else
      -repeat {2*$4+1} k={$>-$4-1} -repeat {2*$4+1} j={$>-$4-1} -repeat {2*$4+1} i={$>-$4-1}
        -if {$i!=0||$j!=0||$k!=0}
          # Compute shifted images [6] and weight [7]
          --shift[0,1] $i,$j,0,0,2 --[7] [1]
          -sqr[7] -blur[7] $3 -*[7] [2] -exp[7]
          # Accumulate weights
          -*[6] [7] -max[5] [7] -+[4,7] -+[3,6]
        -endif
      -done -done -done
    -endif
    -max[5] 1e-6 -rm[1,2]
    -*[0] [3] -+[1,0] -+[1,2] # Add central patch.
    -/ # Normalize.
  -endl -done -v +

#@gmic normalize_local : _amplitude>=0,_radius>0,_n_smooth>=0[%],_a_smooth>=0[%],_is_cut={ 0 | 1 },_min=0,_max=255
#@gmic : Normalize selected images locally.
#@gmic : Default values: 'amplitude=3', 'radius=16', 'n_smooth=4%', 'a_smooth=2%', 'is_cut=1', 'min=0' and 'max=255'.
#@gmic : $ image.jpg --normalize_local 8,10
normalize_local :
  -check "${1=3}>=0 && ${2=16}>0 && isbool(${5=1})" -skip ${3=4%},${4=2%},${6=0},${7=255}
  -e[^-1] "Normalize image$? locally, with amplitude $1, radius $2, neighborhood smoothness $3 and average smoothness $4."
  -v - -repeat @# -l[$>]
    --l -erode {2*$2+1} -s c -min -endl
    --l[-2] -dilate {2*$2+1} -s c -max -endl
    --b[-3] $4 -b[-3,-2] $3
    ---[-2] [-3] -+[-1] 0.01 --[-5] [-4] -/[-5,-1]
    -*[-3,-2] {$1+1} -*[-1] -$1 -+[-3] [-1] -+[-2,-1]
    -if $5 -max[-2] $6 -min[-1] $7 -endif
    --[-1] [-2] -*[-3,-1] -+
    -if $5 -c $6,$7 -endif
  -endl -done -v +

#@gmic normalized_cross_correlation : [mask]
#@gmic : Compute normalized cross-correlation of selected images with specified mask.
#@gmic : $ image.jpg --shift -30,-20 --normalized_cross_correlation[0] [1]
normalized_cross_correlation : -check @{-is_image_arg\ $1}
  -e[^-1] "Compute normalized cross-correlation of image$? with mask $1."
  -v - -pass$1 0 -norm -repeat {@#-1} [-1] -l[$>,-1]
    -fft[-2] -fft[-1] [-2,-1] -*[-2] [-5] -*[-1] [-6]
    --[-2,-1] -*[-5,-3] -*[-3,-2] -+[-3,-2] [-2,-1] -a[-2,-1] c -norm[-1]
    -/[-3] [-1] -/[-2,-1] -ifft -rm[-1]
  -endl -done -rm[-1] -v +

#@gmic peronamalik_flow : K_factor>0,_nb_iter>=0,_dt,_keep_sequence={ 0 | 1 }
#@gmic : Apply iterations of the Perona-Malik flow on selected images.
#@gmic : Default values: 'K_factor=20', 'nb_iter=5', 'dt=5' and 'keep_sequence=0'.
#@gmic : $ image.jpg --heat_flow 20
peronamalik_flow : -check "${1=20}>0 && ${2=5}>=0" -skip ${3=5},${4=0}
  -e[^-1] "Apply $2 iterations of the Perona-Malik flow on image$?, with K factor $1 and time step $3."
  -v -
  -m "_peronamalik_flow :
    --gradient xy,0 -a[-2,-1] c -norm[-1] -b[-1] 0.8 -/[-1] $1 -sqr[-1] -*[-1] -1 -exp[-1] -a[-2,-1] c
    -f[-1] '\"s1=s-1;
             C=i(x,y,z,s-1);
             if(c>=s1,0,
              (C+i(x+1,y,z,s-1,0,1))*(j(1,0,0,0,0,1)-i) -
              (C+i(x-1,y,z,s-1,0,1))*(i-j(-1,0,0,0,0,1)) +
              (C+i(x,y+1,z,s-1,0,1))*(j(0,1,0,0,0,1)-i) -
              (C+i(x,y-1,z,s-1,0,1))*(i-j(0,-1,0,0,0,1)))\"'"
  -pde_flow $2,$3,_peronamalik_flow,$4
  -uncommand _peronamalik_flow
  -v +

#@gmic phase_correlation : [destination]
#@gmic : Estimate translation vector between selected source images and specified destination.
#@gmic : $ image.jpg --shift -30,-20 --phase_correlation[0] [1] -unroll[-1] y
phase_correlation : -check @{-is_image_arg\ $1}
  -e[^-1] "Estimate shift between source image$? and destination $1."
  -v - -repeat @# -pass$1
    -normalized_cross_correlation[$>] [-1] -rm[-1]
    -l[$>]
      (@{-1,C}) -*[-1] 2 -s[-1] x -rm[-1]
      -if {@-3>@{-4,w}} --[-3] @{-4,w} --[-3] @{-4,w} -endif
      -if {@-2>@{-4,h}} --[-2] @{-4,h} --[-2] @{-4,h} -endif
      -if {@-1>@{-4,d}} --[-1] @{-4,d} --[-1] @{-4,d} -endif
      -a[-3--1] c -rm[-2] -/ 2 -* -1
      -nm [phase\ correlation]
  -endl -done -v +

#@gmic pde_flow : _nb_iter>=0,_dt,_velocity_command,_keep_sequence={ 0 | 1 }
#@gmic : Apply iterations of a generic PDE flow on selected images.
#@gmic : Default values: 'nb_iter=10', 'dt=30', 'velocity_command=laplacian' and 'keep_sequence=0'.
#@gmic : $ image.jpg --pde_flow 20
pde_flow : -skip ${1=10},${2=30},${3=laplacian},${4=0}
  -e[^-1] "Apply $1 iterations of the velocity flow '$3' on image$?, with time step $2."
  -v - -repeat @# -l[$<]
    -repeat $1
      --$3[-1] -*[-1] {$2/(0.01+max(abs(im),abs(iM)))}
      -if $4 -+[-1] [-2] -else -+[-2,-1] -endif
    -done
    -if $4 -rm[0] -endif
    -a x
  -endl -done
  -if $4 -s x,$1 -endif -v +

#@gmic periodize_poisson
#@gmic : Periodize selected images using a Poisson solver in Fourier space.
#@gmic : $ image.jpg --periodize_poisson -array 2,2,2
periodize_poisson :
  -e[^-1] "Periodize image$? using Poisson solver in Fourier space."
  -v - -repeat @# -l[$>]
    -s c -repeat @# -l[$>]
      mM={im},{iM} sum=@{0,+}
      -laplacian -fft[-1]
      -if {d==1} 100%,100%,1,1,'-(4-2*cos(2*x*pi/w)-2*cos(2*y*pi/h))' # 2d version.
      -else 100%,100%,100%,1,'-(6-2*cos(2*x*pi/w)-2*cos(2*y*pi/h)-2*cos(2*z*pi/d))' # 3d version.
      -endif
      -=[-1] 1 -/[-3,-2] [-1] -rm[-1] -=[-2] $sum -=[-1] 0
      -ifft -rm[-1] -c $mM
    -endl -done -a c
  -endl -done -v +

#@gmic red_eye : 0<=_threshold<=100,_smoothness>=0,0<=attenuation<=1
#@gmic : Attenuate red-eye effect in selected images.
#@gmic : Default values: 'threshold=75', 'smoothness=3.5' and 'attenuation=0.1'.
#@gmic : $ image.jpg --red_eye ,
red_eye : -skip ${1=75},${2=3.5},${3=0.1}
  -e[^-1] "Attenuate red-eye effect in image$?, with threshold $1, smoothness $2 and attenuation $3."
  -v - -to_rgb -rgb2ycbcr -repeat @# -l[$>]
    -s c --[-1] 128 -->=[-1] $1% -b[-1] $2 -sqrt[-1] -*[-1] -1 -+[-1] 1
    -n[-1] $3,1 -*[-2,-1] -+[-1] 128 -a c -ycbcr2rgb
  -endl -done -v +

#@gmic remove_hotpixels : _mask_size>0, _threshold[%]>0
#@gmic : Remove hot pixels in selected images.
#@gmic : Default values: 'mask_size=3' and 'threshold=10%'.
#@gmic : $ image.jpg -noise 10,2 --remove_hotpixels ,
remove_hotpixels : -check ${1=3}>0 -skip ${2=10%}
  -e[^-1] "Remove hot pixels in image$?, with mask size $1 and threshold $2."
  -v - -repeat @# -l[$>]
    --median $1 --- -abs[-1] ->=[-1] $2
    -*[-2] [-1] -==[-1] 0 -*[-3,-1] -+
  -endl -done -v +

#@gmic remove_pixels : number_of_pixels[%]>=0
#@gmic : Remove specified number of pixels (i.e. set them to 0) from the set of non-zero pixels in selected images.
#@gmic : $ image.jpg --remove_pixels 50%
remove_pixels : -check "$1>=0"
  -e[^-1] "Remove $1 of the non-zero pixels in image$?."
  -v - -repeat @# -l[$>]
    --norm -!=[-1] 0
    N=@{-1,+}                                   # Number of non-zero pixels.
    n={round(if(@{"-is_percent $1"},$N*$1,$1))} # Number of pixels to remove.
    -if {$n<=0} -rm[-1]         # No pixels to remove.
    -elif {$n>=$N} -rm[-1] -f 0 # All pixels to remove.
    -elif {$n>int($N/2)}        # More pixels to remove than to keep.
      -remove_pixels[-1] {$N-$n} -==[-1] 0 -*
    -else                       # Less pixels to remove than to keep.
      d={d} -r 100%,{d*h},1,100%,-1  # Force image to be in 2d.

      # Retrieve coordinates of all non-zero pixels.
      100%,1,1,1,x 1,@{-2,h},1,1,y -+[-2,-1] 1 -r[-2,-1] [-2],[-1]
      -*[-2,-1] [-3] -rm[-3]
      -y[-2,-1] -a[-2,-1] x -discard[-1] y,0

      # Generate a 1xN vector with at least n non-zero pixels.
      -do
        1,100%,1,1 -rand[-1] 0,{h} -<=[-1] {$n*1.25}
        -if {@{-1,+}>=$n} -break -else -rm[-1] -endif
      -while 1

      # Generate a 1xn vector of coordinates to 'remove'.
      -r[-1] 2 -*[-2,-1] -discard[-1] y,0
      -i[-2] 1,100% -rand[-2] 0,1 -a[-2,-1] x -sort[-1] +,y
      -rows[-1] 0,{$n-1} --[-1] 1 -z[-1] 1,3

      # Set those pixels to 0 using a 3d object.
      -i[-2] ({'CImg3d'},{h},{h})
      1,100%,1,1,1 1,100%,1,1,y -a[-2,-1] x
      3,100% 1,100%,1,1,1 -y[-5--1] -a[-5--1] y
      -if @{0,s<=3} -j3d[-2] [-1],0,0,0,1,0,0,0,0
      -else [0],[0],1,1,1 -j3d[-1] [-2],0,0,0,1,0,0,0,0 -*[0,-1]
      -endif
      -rm[-1]

      -r 100%,{h/$d},$d,100%,-1  # Resize to original dimension (eventually 3d).
    -endif
  -endl -done -v +

#@gmic sharpen : amplitude>=0 : amplitude>=0,edge>=0,_alpha,_sigma : (+)
#@gmic : Sharpen selected images by inverse diffusion or shock filters methods.
#@gmic : 'edge' must be specified to enable shock-filter method.
#@gmic : Default values: 'alpha=0' and 'sigma=0'.
#@gmic : $ image.jpg --sharpen 300
#@gmic : $ image.jpg -blur 5 --sharpen[-1] 300,1

#@gmic smooth : amplitude>=0,_sharpness>=0,_anisotropy,_alpha,_sigma,_dl>0,_da>0,_precision>0,interpolation,_fast_approx={ 0 | 1 } : nb_iterations>=0,_sharpness>=0,_anisotropy,_alpha,_sigma,_dt>0,0 : [tensor_field],_amplitude>=0,_dl>0,_da>0,_precision>0,_interpolation,_fast_approx={ 0 | 1 } : [tensor_field],_nb_iters>=0,_dt>0,0 : (+)
#@gmic : Smooth selected images anisotropically using diffusion PDE's, with specified field of
#@gmic : diffusion tensors.
#@gmic : 'anisotropy' must be in [0,1].
#@gmic : 'interpolation' can be { 0=nearest | 1=linear | 2=runge-kutta }.
#@gmic : Default values: 'sharpness=0.7', 'anisotropy=0.3', 'alpha=0.6', 'sigma=1.1', 'dl=0.8', 'da=30', 'precision=2', 'interpolation=0' and 'fast_approx=1'.
#@gmic : $ image.jpg [0] -repeat 3 -smooth[-1] 20 -done
#@gmic : $ image.jpg 100%,100%,1,2 -rand[-1] -100,100 -repeat 2 -smooth[-1] 100,0.2,1,4,4 -done --warp[0] [-1],1,1
#@gmic : $$

#@gmic split_freq : smoothness>0[%]
#@gmic : Split selected images into low and high frequency parts.
#@gmic : $ image.jpg -split_freq 2%
split_freq :
  -e[^-1] "Split image$? into low and high frequency parts, with smoothness $1."
  -v - -repeat @# -l[$>] --b $1 --[0] [1] -rv -endl -done -v +

#@gmic solidify
#@gmic : Replace transparent regions of a RGBA image by morphologically interpolated color.
#@gmic : $ image.jpg --luminance -ge[-1] 120 -*[-1] 255 -append c --solidify -display_rgba
solidify :
  -e[^-1] "Replace transparent regions of RGBA image$? by morphologically interpolated colors."
  -v - -repeat @# -l[$>] nm=@{0,n} -to_a
    [-1] -split_opacity[-2] ->=[-2] 50% -*[-1] [-2]
    -replace_color[-1] 0,0,0,0,0,0,-1,-1,-1,-1 -to_rgb[-1]
    -do
      --dilate[-1] 3
      -replace_color[-2] 0,0,-1,-1,-1,1000,1000,1000
      -erode[-2] 3
      -replace_color[-2] 0,0,1000,1000,1000,-1,-1,-1
      -+[-2,-1] -/[-1] 2
      -j[-1] [-3],0,0,0,0,1,[-2]
    -while {im<0}
    -k[-1]
  -nm $nm,1 -endl -done -v +

#@gmic solidify_linear : _sigma>=1,_dsigma>=1,0<=_precision<=1
#@gmic : Replace transparent regions of a RGBA image by linearly interpolated color.
#@gmic : Default values: 'sigma=1.5', 'dsigma=1' and 'precision=0.5'.
#@gmic : $ image.jpg --luminance -ge[-1] 120 -*[-1] 255 -append c --solidify_linear , -display_rgba
solidify_linear : -check "${1=1.5}>=1 && ${2=1}>=1 && ${3=0.5}>=0 && $3<=1"
  -e[^-1] "Replace transparent regions of RGBA image$? by linearly interpolated colors, with sigma $1, dsigma $2 and precision $3."
  -v - -repeat @# -l[$>]
    -split_opacity
    -if {@#>1}
      ->=[-1] 50% -*[-2] [-1]
      sigma=$1 -do
        N={v=round(3*$sigma);min(33,max(3,v+1-(v%2)))}
        $N,$N -=[-1] 1,50%,50% -distance[-1] 1 -*[-1] {-1/$sigma^2} -exp[-1] -normalize_sum[-1]
        --convolve[-3,-2] [-1] -rm[-3]
        -max[-1] 1e-5 -/[-2,-1]
        --dilate[-2] {v=round((1/3-$N/6)*$3+$N/2);max(3,v+1-(v%2))}
        --[-3] [-1] -*[-2] [-3] -rm[-3]
        --[-3,-2]
        sigma={$sigma*$2}
      -while {!im}
     -rm[-1]
   -endif
 -endl -done -v +

#@gmic solidify_watershed
#@gmic : Replace transparent regions of RGBA image by color propagation.
#@gmic : $ image.jpg --luminance -ge[-1] 120 -*[-1] 255 -append c --solidify_watershed -display_rgba
solidify_watershed :
  -e[^-1] "Replace transparent regions of RGBA image$? by color propagation."
  -v - -repeat @# -l[$>]
    -split_opacity
    -if {@#>1}
      -+[0] 1 ->=[1] 50% -*[0] [1] -distance[1] 1 -*[1] -1
      -watershed[0] [1] -rm[1]
    -endif
  -endl -done -v +

#@gmic solve_poisson : "laplacian_command",_nb_iterations>=0,_time_step>0,_nb_scales>=0
#@gmic : Solve Poisson equation so that applying '-laplacian[n]' is close to the result of '-laplacian_command[n]'.
#@gmic : Solving is performed using a multi-scale gradient descent algorithm.
#@gmic : If 'nb_scales=0', the number of scales is automatically determined.
#@gmic : Default values: 'nb_iterations=60', 'dt=5' and 'nb_scales=0'.
#@gmic : $ image.jpg -m "foo : -gradient x" --solve_poisson foo --foo[0] --laplacian[1]
solve_poisson : -check "${2=60}>=0 && ${3=5}>0 && ${4=0}>=0"
  -e[^-1] "Solve Poisson equation for image$?, for laplacian command '$1', with $2 iterations, time step $3 and "@{-arg\ 1+($4==0),$4,auto}" scales."
  -v - -repeat @# -l[$>]
    [0]
    -repeat {if($4,$4,int(max(log2(max(w,h))-1,1)))}
      f={2^$<}
      -r[1] @{0,max(1,w/$f)},@{0,max(1,h/$f)},1,100%,3
      --r[0] [1],2 -l[-1] -$1 -k[0] -endl
      -repeat $2 --laplacian[-2] --[-1] [-2] -*[-1] {$3/max(1e-8,abs(im),abs(iM))} -+[-3,-1] -done
      -rm[-1]
    -done
    -rm[0]
  -endl -done -v +

#@gmic split_details : _nb_scales>0,_base_scale[%]>=0,_detail_scale[%]>=0
#@gmic : Split selected images into 'nb_scales' spatial scales (gaussian pyramids).
#@gmic : Default values: 'nb_scales=4', 'base_scale=2%' and 'detail_scale=0.5%'.
#@gmic : $ image.jpg -split_details ,
split_details : -check "isint(${1=4}) && $1>0 && ${2=2%}>=0 && ${3=0.5%}>=0"
  -e[^-1] "Split image$? using $1 spatial scales with base scale $2 and detail scale $3."
  -v - -repeat @# -l[$<]
    ss={max(0.3,if(@{-is_percent\ $2},$2*max(w,h),$2))}
    se={max(0.3,if(@{-is_percent\ $3},$3*max(w,h),$3))}
    ds={$se-$ss}
    -repeat {$1-1} --b[-1] {$ss+$>*$ds/($1-2)} --[-2] [-1] -rv[-2,-1] -done
  -endl -done -v +

#@gmic structuretensors : _scheme : (+)
#@gmic : Compute the structure tensor field of selected images.
#@gmic : 'scheme' can be { 0=centered | 1=forward-backward1 | 2=forward-backward2 }.
#@gmic : Default value: 'scheme=2'.
#@gmic : $ image.jpg -structuretensors -abs -pow 0.2
#@gmic : $$

#@gmic syntexturize : _width[%]>0,_height[%]>0
#@gmic : Resynthetize 'width'x'height' versions of selected micro-textures by phase randomization.
#@gmic : The texture synthesis algorithm is a straightforward implementation of the method described in :
#@gmic : http://www.ipol.im/pub/art/2011/ggm_rpn/
#@gmic : Default values: 'width=height=100%'.
#@gmic : $ image.jpg -crop 2,282,50,328 --syntexturize 320,320
syntexturize : -check "${1=100%}>0 && ${2=$1}>0"
  -e[^-1] "Resynthetize $1x$2 versions of texture$? by phase randomization."
  -v - -repeat @# -l[$>]

    # Prepare input image data.
    mM={im},{iM} -repeat {s} -sh[-1] $>,$> sum$>=@{-1,+} var$>=@{-1,iv} -rm[-1] -done  # Retrieve some stats for post-normalization.
    nw={if(@{-is_percent\ $1},$1*w,$1)}
    nh={if(@{-is_percent\ $2},$2*h,$2)}
    -repeat {s} sum$>={${sum$>}*$nw*$nh/(w*h)} -done # Re-estimate output (0,0) frequency.

    -if {$nw>w||$nh>h} # Spot extension required when rendering on bigger image.
      -periodize_poisson
      100%,100% -rectangle[-1] 5,5,{w-6},{h-6},1,1 -b[-1] 2 -n[-1] 0,1
      $nw,$nh,1,@{-2,s} -fc[-1] @{-average_color[-3]}
      -j[-1] [-3],{(w-@{-2,w})/2},{(h-@{-2,h})/2},0,0,1,[-2]
      -rm[-3,-2]
    -else
      -r $nw,$nh,1,100%,0,0,0.5,0.5
      -periodize_poisson
    -endif
    -fft

    # Compute coherent random phase.
    100%,100% -rand[-1] {-pi},{pi}
    -=[-1] 0
    -if {!(w%2)} -=[-1] {(?<0.5)*pi},{int(w/2)} -endif
    -if {!(h%2)} -=[-1] {(?<0.5)*pi},0,{int(h/2)} -endif
    -if {!(h%2)&&!(h%2)} -=[-1] {(?<0.5)*pi},{int(w/2)},{int(h/2)} -endif

    # Add random phase to fft of input image.
    --sin[-1] -cos[-2]
    --*[-4,-1] --*[-4,-3] -+[-2,-1]
    -*[-5,-3] -*[-3,-2] --[-3,-2]

    # Get synthetized result and normalize it.
    -repeat {s} -=[-2] ${sum$>},0,0,0,$> -=[-1] 0,0,0,0,$> -done
    -ifft -rm[-1]
    -repeat {s} -sh[-1] $>,$> avg={ia} --[-1] $avg -*[-1] {sqrt(${var$>}/if(iv,iv,1))} -+[-1] $avg -rm[-1] -done
    -c $mM

  -endl -done -v +

#@gmic tv_flow : _nb_iter>=0,_dt,_sequence_flag={ 0 | 1 }
#@gmic : Apply iterations of the total variation flow on selected images.
#@gmic : Default values: 'nb_iter=10', 'dt=30' and 'keep_sequence=0'.
#@gmic : $ image.jpg --tv_flow 40
tv_flow : -skip ${1=10},${2=30},${3=0}
  -e[^-1] "Apply $1 iterations of the total variation flow on image$?, with time step $2."
  -v - -pde_flow $1,$2,curvature,$3 -v +

#@gmic unsharp : radius[%]>=0,_amount>=0,_threshold[%]>=0
#@gmic : Apply unsharp mask on selected images.
#@gmic : Default values: 'amount=2' and 'threshold=0'.
#@gmic : $ image.jpg -blur 3 --unsharp 1.5,15 -cut 0,255
unsharp : -check "${2=2}>=0" -skip ${3=0}
  -e[^-1] "Apply unsharp mask on image$?, with radius $1, amount $2 and threshold $3."
  -v - -repeat @#
    --b[$>] $1 --[-1] [$>]
    -if $3 --norm[-1] ->=[-1] $3 -*[-2,-1] -endif
    -*[-1] $2 --[$>,-1]
  -done -v +

#@gmic unsharp_octave : _nb_scales>0,_radius[%]>=0,_amount>=0,threshold[%]>=0
#@gmic : Apply octave sharpening on selected images.
#@gmic : Default values: 'nb_scales=4', 'radius=1', 'amount=2' and 'threshold=0'.
#@gmic : $ image.jpg -blur 3 --unsharp_octave 4,5,15 -cut 0,255
unsharp_octave : -check "${1=4}>0 && ${3=2}>=0" -skip ${2=1},${4=0}
  -e[^-1] "Apply octave sharpening on image$?, with $1 scales, radius $2, amount $3 and threshold $4."
  -v - -repeat @# -l[$>] nm=@{0,n}
    --f 0 weight=0 -repeat $1
      --unsharp[0] {$2*2^-@{<,-1}},$3,$4 -*[-1] {2^-$>} weight={$weight+2^-$>} -+[1,-1]
    -done -rm[0] -/ $weight
  -nm $nm,1 -endl -done -v +

#@gmic vanvliet : std_variation>=0[%],order={ 0 | 1 | 2 | 3 },axis={ x | y | z | c },_boundary : (+)
#@gmic : Apply Vanvliet recursive filter on selected images, along specified axis and with
#@gmic : specified standard deviation, order and boundary conditions.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : Default value: 'boundary=1'.
#@gmic : $ image.jpg --vanvliet 3,1,x
#@gmic : $ image.jpg --vanvliet 30,0,x -vanvliet[-2] 30,0,y -add

#@gmic watermark_fourier : text,_size>0
#@gmic : Add a textual watermark in the frequency domain of selected images.
#@gmic : Default value: 'size=33'.
#@gmic : $ image.jpg --watermark_fourier "Watermarked!" --display_fft -remove[-3,-1] -normalize 0,255 -append[-4,-2] y -append[-2,-1] y
watermark_fourier : -check ${2=33}>0
  -e[^-1] "Add textual watermark '$1' with size $2 in the frequency domain of image$?."
  -v - -i[0] 0 -t[0] "$1",0,0,$2,1,1 ->=[0] 0.5 -autocrop[0] 0
  -repeat {@#-1} w2={int(w/2)} h2={int(h/2)}
    -fft[-1]
    -shift[-2,-1] $w2,$h2,0,0,2
    [0],[0],1,{s}
    -j[-3,-2] [-1],3,3,0,0,1,[0]
    -mirror[0] x
    -j[-3,-2] [-1],{@{-2,w}-2-@{0,w}},3,0,0,1,[0]
    -mirror[0] y
    -j[-3,-2] [-1],{@{-2,w}-2-@{0,w}},{@{-2,h}-2-@{0,h}},0,0,1,[0]
    -mirror[0] x
    -j[-3,-2] [-1],3,{@{-2,h}-2-@{0,h}},0,0,1,[0]
    -mirror[0] y
    -rm[-1]
    -shift[-2,-1] -$w2,-$h2,0,0,2
    -ifft[-2,-1] -rm[-1]
  -mv[-1] 1 -done
  -rm[0] -v +

#@gmic watershed : [priority_image],_fill_lines={ 0 | 1 } : (+)
#@gmic : Compute the watershed transform of selected images.
#@gmic : Default value: 'fill_lines=1'.
#@gmic : $ 400,400 -noise 0.2,2 --distance 1 -mul[-1] -1 -label[-2] -watershed[-2] [-1] -mod[-2] 256 -map[-2] 0 -reverse

#---------------------------------
#
#@gmic :: Features extraction
#
#---------------------------------

#@gmic area : tolerance>=0,is_high_connectivity={ 0 | 1 }
#@gmic : Compute area of connected components in selected images.
#@gmic : Default values: 'is_high_connectivity=0'.
#@gmic : $ image.jpg -luminance -stencil[-1] 1 --area 0
area : -check "$1>=0" -skip ${2=0}
  -e[^-1] "Compute area of connected components in image$?, with tolerance $1 and "@{-arg\ 1+!$2,high,low}" connectivity."
  -v - -repeat @# -l[$>] -s c
    -repeat @# -label[$>] $1,$2 nb=@{$>,1+iM} --histogram[$>] $nb,0,{$nb-1} -map[$>] [-1] -rm[-1] -done
  -a c -endl -done -v +

#@gmic area_fg : tolerance>=0,is_high_connectivity={ 0 | 1 }
#@gmic : Compute area of connected components for non-zero values in selected images.
#@gmic : Similar to '-area' except that 0-valued pixels are not considered.
#@gmic : Default values: 'is_high_connectivity=0'.
#@gmic : $ image.jpg -luminance -stencil[-1] 1 --area_fg 0
area_fg : -check "$1>=0" -skip ${2=0}
  -e[^-1] "Compute area of foreground connected components in image$?, with tolerance $1 and "@{-arg\ 1+!$2,high,low}" connectivity."
  -v - -repeat @# -l[$>] -s c
    -repeat @# -label_fg[$>] $1,$2 nb=@{$>,1+iM} --histogram[$>] $nb,0,{$nb-1} -=[-1] 0 -map[$>] [-1] -rm[-1] -done
  -a c -endl -done -v +

#@gmic at_line : x0[%],y0[%],z0[%],x1[%],y1[%],z1[%]
#@gmic : Retrieve pixels of the selected images belonging to the specified line (x0,y0,z0)-(x1,y1,z1).
#@gmic : $ image.jpg --at_line 0,0,0,100%,100%,0
at_line : -check ${7=100%}>=0
  -e[^-1] "Retrieve pixels of image$?, belonging to line ($1,$2,$3)-($4,$5,$6)."
  -v - -repeat @# -l[$>]
    x0={if(@{-is_percent\ $1},(w-1)*$1,$1)}
    y0={if(@{-is_percent\ $2},(h-1)*$2,$2)}
    z0={if(@{-is_percent\ $3},(d-1)*$3,$3)}
    x1={if(@{-is_percent\ $4},(w-1)*$4,$4)}
    y1={if(@{-is_percent\ $5},(h-1)*$5,$5)}
    z1={if(@{-is_percent\ $6},(d-1)*$6,$6)}
    ($x0,$x1^$y0,$y1^$z0,$z1)
    -r[-1] {1+max(abs($x1-$x0),abs($y1-$y0),abs($z1-$z0))},1,1,3,3
    -round[-1] 1 -warp[0] [-1],0,0,0 -rm[-1]
  -endl -done -v +

#@gmic barycenter
#@gmic : Compute the barycenter vector of pixel values.
#@gmic : $ 256,256 -ellipse 50%,50%,20%,20%,0,1,1 -deform 20 --barycenter --ellipse[-2] @{-1,0,1},5,5,0,10
barycenter :
  -e[^-1] "Compute the barycenter vector of pixel values of image$?."
  -v - -norm -repeat @# -l[$>] nm=@{0,b}
    sum=@{-1,+}
    -if {$sum>0}
      -if {d>1} --* 'z' z=@{-1,+} -rm[-1] -else z=0 -endif
      -if {h>1} --* 'y' y=@{-1,+} -rm[-1] -else y=0 -endif
      -* 'x' x=@{-1,+} -rm[-1]
      ({$x/$sum};{$y/$sum};{$z/$sum})
    -else ({w/2},{h/2},{d/2}) -rm[-2]
    -endif
  -nm "[barycenter of '"$nm"']" -endl -done -v +

#@gmic detect_skin : 0<=tolerance<=1,_skin_x,_skin_y,_skin_radius>=0
#@gmic : Detect skin in selected color images and output an appartenance probability map.
#@gmic : Detection is performed using CbCr chromaticity data of skin pixels.
#@gmic : If arguments 'skin_x', 'skin_y' and 'skin_radius' are provided, skin pixels are learnt
#@gmic : from the sample pixels inside the circle located at ('skin_x','skin_y') with radius 'skin_radius'.
#@gmic : Default value: 'tolerance=0.5' and 'skin_x=skiny=radius=-1'.
detect_skin : -check "${1=0.5}>=0 && $1<=1" -skip ${2=-1},${3=-1},${4=-1}
  -if {$2<0||$3<=0||$4<=0}
    -e[0--3] "Detect skin in image$?, using tolerance $1."
    -v -
    m0=120.9292108800069
    m1=142.5745272918084
    A=0.09749985486268997
    B=0.06388871371746063
    C=0.05250053107738495
    -to_rgb -srgb2rgb -rgb2ycbcr -channels 1,2
    -repeat @# -l[$>]
      whd={w},{h},{d} -r {w*h*d},2,1,1,-1
      -s y --[0] $m0 --[1] $m1 -a y
      -i[0] ($A,$B;$B,$C) --** -rm[0]
      -* -s y -+ -*[-1] {$1-1} -exp[-1]
      -r $whd,1,-1
    -endl -done
  -else
    -e[0--3] "Detect skin in image$?, using tolerance $1 and target circle at ($2,$3) with radius $4."
    -v -
    -to_rgb -srgb2rgb -rgb2ycbcr -channels 1,2
    -repeat @# -l[$>]
      100%,100% -circle[1] $2,$3,$4,1,1 --f[1] 'if(i,y,-1)' -f[1] 'if(i,x,-1)' -discard[1,2] -1 -a[1,2] c
      --warp[0] [1],0,0 -rm[1]
      -s[1] c
      m0=@{1,ia} --[1] $m0
      m1=@{2,ia} --[2] $m1
      M={h} -a[1,2] x --transpose[1] -rv[1,2] -**[1,2] -/[1] $M -invert[1]
      -rv whd={w},{h},{d} -r[1] {w*h*d},2,1,1,-1
      -s[1] y --[1] $m0 --[2] $m1 -a[1,2] y --** -rm[0]
      -* -s y -+ -*[-1] {$1-1} -exp[-1]
      -r $whd,1,-1
    -endl -done
  -endif
  -v +

#@gmic displacement : [source_image],_smoothness,_precision>=0,_nb_scales>=0,iteration_max>=0,is_backward={ 0 | 1 } : (+)
#@gmic : Estimate displacement field between specified source and selected images.
#@gmic : If 'smoothness>=0', regularization type is set to isotropic, else to anisotropic.
#@gmic : If 'nbscales==0', the number of needed scales is estimated from the image size.
#@gmic : Default values: 'smoothness=0.1', 'precision=7', 'nb_scales=0', 'iteration_max=10000' and 'is_backward=1'.
#@gmic : $ image.jpg --rotate 3,1,0,50%,50%,0.9 --displacement[-1] [-2] -quiver[-1] [-1],15,-20,1,1,{1.5*iM}

#@gmic distance : isovalue[%],_metric : isovalue[%],[metric],_method : (+)
#@gmic : Compute the unsigned distance function to specified isovalue, opt. according to a custom metric.
#@gmic : 'metric' can be { 0=chebyshev | 1=manhattan | 2=euclidean | 3=squared-euclidean }.
#@gmic : 'method' can be { 0=fast-marching | 1=low-connectivity dijkstra | 2=high-connectivity dijkstra | 3=1+return path | 4=2+return path }.
#@gmic : Default value: 'metric=2' and 'method=0'.
#@gmic : $ image.jpg -threshold 20% -distance 0 -pow 0.3
#@gmic : $ 400,400 -set 1,50%,50% --distance[0] 1,2 --distance[0] 1,1 -distance[0] 1,0 -mod 32 -threshold 16 -append c
#@gmic : $$

#@gmic float2fft8
#@gmic : Convert selected float-valued images to 8bits fourier representations.
float2fft8 :
  -e[^-1] "Convert float-valued image$? to 8bits fourier representations."
  -v - -repeat @# -l[$>]
    -fftpolar -+[-2] 1 -log[-2] -float2int8[-2,-1] -a y
  -endl -done -v +

#@gmic fft82float
#@gmic : Convert selected 8bits fourier representations to float-valued images.
fft82float :
  -e[^-1] "Convert float-valued image$? to 8bits fourier representations."
  -v - -repeat @# -l[$>]
    -s y,2 -int82float -exp[-2] --[-2] 1 -ifftpolar
  -endl -done -v +

#@gmic fftpolar
#@gmic : Compute fourier transform of selected images, as centered magnitude/phase images.
#@gmic : $ image.jpg -fftpolar -ellipse 50%,50%,10,10,0,1,0 -ifftpolar
fftpolar :
  -e[^-1] "Compute fourier transform of image$?, as centered magnitude/phase images."
  -v - -repeat @# -l[$<]
    -fft -complex2polar -shift {-round(w/2)},{-round(h/2)},{-round(d/2)},0,2
  -endl -done -v +

#@gmic histogram : _nb_levels>0[%],_value0[%],_value1[%] : (+)
#@gmic : Compute the histogram of selected images.
#@gmic : If value range is set, the histogram is estimated only for pixels in the specified
#@gmic : value range. Argument 'value1' must be specified if 'value0' is set.
#@gmic : Default values: 'nb_levels=256', 'value0=0%' and 'value1=100%'.
#@gmic : $ image.jpg --histogram 64 -display_graph[-1] 400,300,3

#@gmic histogram_nd : nb_levels>0[%],_value0[%],_value1[%]
#@gmic : Compute the 1d,2d or 3d histogram of selected multi-channels images (having 1,2 or 3 channels).
#@gmic : If value range is set, the histogram is estimated only for pixels in the specified
#@gmic : value range.
#@gmic : Default values: 'value0=0%' and 'value1=100%'.
#@gmic : $ image.jpg -channels 0,1 --histogram_nd 256
histogram_nd : -check $1>0 -skip ${2=0%},${3=100%}
  -e[^-1] "Compute histogram of multi-channels image$?, using $1 levels in range [$1,$2]."
  -v -
  percent_nblevels=@{"-is_percent $1"}
  percent_min=@{"-is_percent $2"}
  percent_max=@{"-is_percent $3"}
  -repeat @# -l[$>] s={s}
    -r {w*h*d},{min(3,s)},1,1,-1
    vmin=$2 vmax=$3
    -if {$percent_min||$percent_max}
      im={im} iM={iM}
      vmin={if($percent_min,$im+($iM-$im)*$2,$2)}
      vmax={if($percent_max,$im+($iM-$im)*$3,$3)}
    -endif
    dv={$vmax-$vmin}
    nb_levels={max(1,round(if($percent_nblevels,$1*(1+$vmax-$vmin),$1)))}
    -f 'if(i>=$vmin&&i<=$vmax,if(i==$vmax,$nb_levels-1,int((i-$vmin)*$nb_levels/($vmax-$vmin))),-1)'
    -pointcloud 1,$nb_levels,{if($s>1,$nb_levels,1)},{if($s>2,$nb_levels,1)}
  -endl -done -v +

#@gmic histogram_cumul : _nb_levels>0,_is_normalized={ 0 | 1 },_val0[%],_val1[%]
#@gmic : Compute cumulative histogram of selected images.
#@gmic : Default values: 'nb_levels=256', 'is_normalized=0' and 'val0=val1=0'.
#@gmic : $ image.jpg --histogram_cumul 256 -histogram[0] 256 -display_graph 400,300,3
histogram_cumul : -check ${1=256}>0 -skip ${2=0} -skip ${3=0},${4=0}
  -arg 1+!$2,"normalized ",""
  -e[^-1] "Compute "@{}"cumulative histogram of image$?, using $1 levels."
  -v - -histogram $1,$3,$4 -cumulate -if $2 -repeat @# -/[$>] @{$>,M} -done -endif -v +

#@gmic histogram_pointwise : nb_levels>0[%],_value0[%],_value1[%]
#@gmic : Compute the histogram of each vector-valued point of selected images.
#@gmic : If value range is set, the histogram is estimated only for values in the specified
#@gmic : value range.
#@gmic : Default values: 'value0=0%' and 'value1=100%'.
histogram_pointwise : -skip ${2=0%},${3=100%}
  -e[^-1] "Compute the pointwise histogram of vector-valued points in image$?, with $1 levels."
  -v - -repeat @# -l[$>] nm=@{0,n}
    nb_levels={round(if(@{-is_percent\ $1},(iM-im)*$1,$1))}
    value0={if(@{-is_percent\ $2},im+(iM-im)*$2,$2)}
    value1={if(@{-is_percent\ $3},im+(iM-im)*$3,$3)}
    -- $value0 -* {$nb_levels/max(1,abs($value1-$value0))} -c 0,{$nb_levels-1} -round
    w={w} h={h} d={d} -r {w*h*d},{s},1,1,-1
    -i[-2] (0,{w-1}) -r[-2] [-1],[-1],1,1,3 -round[-2]
    -r[-2,-1] 300%,100%,1,1,4 -shift[-1] 1 -+[-2,-1] -y[-1]
    -i[-2] ({'CImg3d'},{h/3},{h/3})
    (1,0;1,{h/3-1}) -r[-1] 2,@{-2,h/3},1,1,3 -round[-1]
    3,100%,1,1,1 1,100%,1,1,-1 -y[-5,-3,-2] -a[-5--1] y
    {$w*$h*$d},$nb_levels -j3d[-1] [-2],0,0,0,1,0,0,0 -rm[-2]
    -r $w,$h,$d,$nb_levels,-1
  -nm $nm,1 -endl -done -v +

#@gmic hough : _width>0,_height>0,gradient_norm_voting={ 0 | 1 }
#@gmic : Compute hough transform (theta,rho) of selected images.
#@gmic : Default values: 'width=512', 'height=width' and 'gradient_norm_voting=1'.
#@gmic : $ image.jpg --blur[-1] 1.5 -hough[-1] 400,400 -blur[-1] 0.5 -+[-1] 1 -log[-1]
hough : -check "${1=512}>0 && ${2=$1}>0" -skip ${3=1}
  -e[^-1] "Compute $1x$2 hough transform of image$?, "@{-arg\ 1+!$3,with,without}" gradient norm voting."
  -v - -slices 50% -luminance -repeat @# -l[$>] nm=@{0,n}
    rhomax={sqrt(w^2+h^2)/2}
    -g (0,{w-1}) (0;{@{-2,h}-1}) -r[-2,-1] @{-3,w},@{-3,h},1,1,3 --[-2] {w/2} --[-1] {h/2}
    -complex2polar[-4--1] --[-1] [-3] -polar2complex[-2,-1] -rm[-1]
    --<[-1] 0 -*[-1] {pi} -+[-3,-1] -abs[-1] -%[-2] {2*pi}
    -*[-1] {$2/$rhomax} -*[-2] {0.5*$1/pi}
    -y[-3--1] x {w} -mv[-4] @# -if {!$3} -f[-1] 1 -endif
    -a y -pointcloud 1 -r $1,$2,1,1,0
  -nm $nm,1 -endl -done -v +

#@gmic ifftpolar
#@gmic : Compute inverse fourier transform of selected images, from centered magnitude/phase images.
ifftpolar :
  -e[^-1] "Compute inverse fourier transform of image$?, from centered magnitude/phase images."
  -v - -repeat {int(@#/2)} -l[$>,{$>+1}]
    -shift {round(w/2)},{round(h/2)},{round(d/2)},0,2 -polar2complex -ifft -rm[-1]
  -endl -done -v +

#@gmic isophotes : _nb_levels>0
#@gmic : Render isophotes of selected images on a transparent background.
#@gmic : Default value: 'nb_levels=64'
#@gmic : $ image.jpg -blur 2 -isophotes 6 -dilate_circ 5 -display_rgba
isophotes : -skip ${1=64}
  -e[^-1] "Render isophote maps from images$?, with $1 levels."
  -v - -to_rgba -repeat @# -l[$>]
    --luminance -repeat $1 --isoline3d[1] {$>*255/($1-1)} -done -rm[1] -+3d[^0] -col3d[-1] 1
    [0],[0] -j3d[-1] [-2],0,0,0,1,0,0,0 -rm[-2] -*
  -endl -done -v +

#@gmic label : _tolerance>=0,is_high_connectivity={ 0 | 1 } : (+)
#@gmic : Label connected components in selected images.
#@gmic : Default values: 'tolerance=0' and 'is_high_connectivity=0'.
#@gmic : $ image.jpg -luminance -threshold 60% -label -normalize 0,255 -map 0
#@gmic : $ 400,400 -set 1,50%,50% -distance 1 -mod 16 -threshold 8 -label -mod 255 -map 2
#@gmic : $$

#@gmic label_fg : tolerance>=0,is_high_connectivity={ 0 | 1 }
#@gmic : Label connected components for non-zero values (foreground) in selected images.
#@gmic : Similar to '-label' except that 0-valued pixels are not labeled.
#@gmic : Default value: 'is_high_connectivity=0'.
label_fg : -check "$1>=0" -skip ${2=0}
  -e[^-1] "Label foreground connected components on image [1], with tolerance $1 and "@{-arg\ 1+!$2,high,low}" connectivity."
  -v - -repeat @# -l[$>]
    -if {d>1} --z -1,-1,-1,{w-1},{h-1},{d-1} -label[-1] $1,$2 -z[-1] 1,1,1,{w-1},{h-1},{d-1}
    -else --z -1,-1,{w-1},{h-1} -label[-1] $1,$2 -z[-1] 1,1,{w-1},{h-1}
    -endif
    -!=[-2] 0 -* --histogram {1+iM} -=[-1] 0
    ->[-1] 0 -cumulate[-1] -map[-2] [-1] -rm[-1]
  -endl -done -v +

#@gmic max_patch : _patch_size>=1
#@gmic : Return locations of maximal values in local patch-based neighborhood of given size for selected images.
#@gmic : Default value: 'patch_size=16'.
#@gmic : $ image.jpg -norm --max_patch 16
max_patch : -check "isint(${1=16}) && $1>=1"
  -e[^-1] "Return locations of maximal values in local patch neighborhood of size $1, in image$?."
  -v - -repeat @# --dilate[$>] $1 -==[$>,-1] -done -v +

#@gmic min_patch : _patch_size>=1
#@gmic : Return locations of minimal values in local patch-based neighborhood of given size for selected images.
#@gmic : Default value: 'patch_size=16'.
#@gmic : $ image.jpg -norm --min_patch 16
min_patch : -check "isint(${1=16}) && $1>=1"
  -e[^-1] "Return locations of minimal values in local patch neighborhood of size $1, in image$?."
  -v - -repeat @# --erode[$>] $1 -==[$>,-1] -done -v +

#@gmic minimal_path : x0[%]>=0,y0[%]>=0,z0[%]>=0,x1[%]>=0,y1[%]>=0,z1[%]>=0,_is_high_connectivity={ 0 | 1 }
#@gmic : Compute minimal path between two points on selected potential maps.
#@gmic : Default value: 'is_high_connectivity=0'.
#@gmic : $ image.jpg --gradient_norm -fill[-1] 1/(1+i) -minimal_path[-1] 0,0,0,100%,100%,0 -pointcloud[-1] 0 -*[-1] 280 -to_rgb[-1] -resize[-1] [-2],0 -or
minimal_path : -check "$1>=0 && $2>=0 && $3>=0" -skip ${7=0}
  -e[^-1] "Compute minimal path between points ($1,$2,$3) and ($4,$5,$6) for potential map$?, with "@{-arg\ 1+$7,low,high}" connectivity."
  -v - -repeat @# -l[$>] nm=@{0,n}
    -- {im} -+ {iM/100}
    100%,100% -= 1,${4-6} -distance[-1] 1,[0],{if($7,4,3)} -k[-1]
    x={round(if(@{-is_percent\ $1},$1*(w-1),$1))}
    y={round(if(@{-is_percent\ $2},$2*(h-1),$2))}
    z={round(if(@{-is_percent\ $3},$3*(d-1),$3))}
    ($x;$y;$z)
    -do
      p=@{0,($x,$y,$z)}
      -if {$p&1} x={$x-1}
      -elif {$p&2} x={$x+1}
      -endif
      -if {$p&4} y={$y-1}
      -elif {$p&8} y={$y+1}
      -endif
      -if {$p&16} z={$z-1}
      -elif {$p&32} z={$z+1}
      -endif
      ($x;$y;$z)
    -while $p
    -rm[0,-1] -a x
  -nm $nm,1 -endl -done -v +

#@gmic mse : : (+)
#@gmic : Compute MSE (Mean-Squared Error) matrix between selected images.
#@gmic : $ image.jpg --noise 30 --noise[0] 35 --noise[0] 38 -cut[-1] 0,255 -mse

#@gmic patches : patch_width>0,patch_height>0,patch_depth>0,x0,y0,z0,_x1,_y1,_z1,...,_xN,_yN,_zN
#@gmic : Extract N+1 patches from selected images, centered at specified locations.
#@gmic : $ image.jpg --patches 64,64,1,153,124,0,184,240,0,217,126,0,275,38,0
patches : -check "isint($1) && $1>0 && isint($2) && $2>0 && isint($3) && $3>0"
  -e[^-1] "Extract $1x$2x$3 patches from image$?, at locations (${4--1})."
  -v -
  (${4--1}) -r[-1] 3,{w/3},1,1,-1 -permute[-1] yzcx N={w}
  H={int(sqrt(w))} W={round(w/$H,1,1)} -r[-1] {$W*$H},1,1,3,0 -r[-1] $W,$H,1,3,-1
  -r[-1] {w*$1},{h*$2},{d*$3}
  $1,$2,$3,1,x-{int($1/2)} --f[-1] y-{int($2/2)} --f[-1] z-{int($3/2)} -a[-3--1] c -r[-1] [-2],0,2 -+[-2,-1]
  -repeat {@#-1} -warp[$>] [-1],0,0,0 -done -rm[-1]
  -repeat @# -l[$<] -s y,$H -s x,$W -k[0-{$N-1}] -endl -done
  -v +

#@gmic plot2value
#@gmic : Retrieve values from selected 2d graph plots.
#@gmic : $ 400,300,1,1,'if(y>300*abs(cos(x/10+2*?)),1,0)' --plot2value --display_graph[-1] 400,300
plot2value :
  -e[^-1] "Retrieve values from 2d graph plot$?."
  -v - -repeat @# -l[$>]
    -s c ->= 50%
    -repeat @# -l[$>] (1,{w}) -r[1] [0],3 -* -histogram {w},1,{w} -endl -done
    -a c
  -endl -done -v +

#@gmic pointcloud : _type = { -X=-X-opacity | 0=binary | 1=cumulative | 2=label },_width,_height>0,_depth>0
#@gmic : Convert a Nx1, Nx2, Nx3 or NxM image as a point cloud in a 1d/2d or 3d binary image.
#@gmic : If 'M'>3, the 3-to-M lines sets the (M-3)-dimensional color at each point.
#@gmic : Parameters 'width','height' and 'depth' are related to the size of the final image :
#@gmic :   - If set to 0, the size is automatically set along the specified axis.
#@gmic :   - If set to N>0, the size along the specified axis is N.
#@gmic :   - If set to N<0, the size along the specified axis is at most N.
#@gmic : Points with coordinates that are negative or higher than specified ('width','height','depth')
#@gmic : are not plotted.
#@gmic : Default values: 'type=0' and 'max_width=max_height=max_depth=0'.
#@gmic : $ 3000,2 -rand 0,400 --pointcloud 0 -dilate[-1] 3
#@gmic : $ 3000,2 -rand 0,400 {w} {w},3 -rand[-1] 0,255 -append y --pointcloud 0 -dilate[-1] 3
pointcloud : -check "${1=0}<3" -skip ${2=0},${3=0},${4=0}
  -e[^-1] "Convert image$? to point clouds, in "@{-arg\ 2+($1>=0)*$1-($1<0),{-$1}-opacity,binary,cumulative,labeling}" mode,"\
          "with ($2,$3,$4) as maximal dimensions."
  -v - -repeat @# -l[$>] nm=@{0,n}
    -if {"d>1 || s>1"} -error "Command '-pointcloud': Invalid input image "{w}x{h}x{d}x{s}". Should be NxMx1x1." -endif

    # Retrieve coordinates and color infos.
    -rows 0,{max(2,h-1)}
    -sh[-1] 0,0,0,0 -round[-1] dx={round(if($2==0,iM+1,if($2<0,min(iM+1,-$2),$2)))}
    -sh[-2] 1,1,0,0 -round[-1] dy={round(if($3==0,iM+1,if($3<0,min(iM+1,-$3),$3)))}
    -sh[-3] 2,2,0,0 -round[-1] dz={round(if($4==0,iM+1,if($4<0,min(iM+1,-$4),$4)))}
    -*[-1] $dy -+[-2] [-1] -f[-1] 0 -rm[-3--1]

    # Create corresponding 3d object (manage large point clouds).
    -s x,-1000000
    -repeat @# -l[$>]
      nbp={w}
      -if {h>3} --rows 3,100% -rows[-2] 0,2 -else 100%,1,1,1,1 -if {$1==2} -f[-1] 1+x -endif -endif
      spectrum={h} -i[-2] (-128;1;1;{h}) -r[-2] {w} -a[-2,-1] y
      -i[-3] ({'CImg3d'}) -transpose[-3--1] -i[-3] ($nbp;$nbp) # Header
      -i[-2] 1,$nbp,1,1,1 -i[-2] 1,$nbp,1,1,y -a[-3,-2] x      # Vertices and primitives.
      1,$nbp,1,1,{if($1<0,-$1,if($1==1,-1,1))}                 # Opacities.
      -y[-4--2] -a y                                           # Merge object attributes.
    -endl -done
    -+3d

    # Draw corresponding point cloud.
    $dx,{$dy*$dz},1,$spectrum -j3d[-1] [-2],0,0,0,1,0,0,0 -rm[-2] -r[-1] $dx,$dy,$dz,100%,-1
  -nm $nm,1 -endl -done -v +

#@gmic psnr : _max_value : (+)
#@gmic : Compute PSNR (Peak Signal-to-Noise Ratio) matrix between selected images.
#@gmic : Default value: 'max_value=255'.
#@gmic : $ image.jpg --noise 30 --noise[0] 35 --noise[0] 38 -cut[-1] 0,255 -psnr 255 -replace_inf 0
psnr : -skip ${1=255}
  -e[^-1] "Compute the "@#x@#" matrix of PSNR values, from image$? with maximum value $1."
  -v - -mse -log10 -- {log10($1*$1)} -* -10 -nm[-1] [PSNR] -v +

#@gmic segment_watershed : _threshold>=0,_fill_lines={ 0 | 1 }
#@gmic : Apply watershed segmentation on selected images.
#@gmic : Default values: 'threshold=2' and 'fill_lines=1'.
#@gmic : $ image.jpg --segment_watershed 2,0
segment_watershed : -check "${1=2}>=0" -skip ${2=1}
  -e[^-1] "Apply watershed segmentation on image$?, with edge threshold $1."
  -v - -repeat @# -l[$>]
    -+ {1+@{-1,m}} --gradient_norm
    -if {d>1} --f[-1] "if(i<$1 && i<j(1) && i<j(-1) && i<j(0,1) && i<j(0,-1) && i<j(0,0,1) && i<j(0,0,-1),1,0)"
    -else --f[-1] "if(i<$1 && i<j(1) && i<j(-1) && i<j(0,1) && i<j(0,-1),1,0)"
    -endif
    -*[-3,-1] -*[-1] -1 -watershed[-2] [-1],$2 -rm[-1]
  -endl -done -v +

#@gmic skeleton : _smoothness[%]>=0
#@gmic : Compute skeleton of binary shapes using distance transform.
#@gmic : Default value: 'smoothness=0'.
#@gmic : $ image.jpg -threshold 50% --skeleton 0
skeleton : -check ${1=0}>=0
  -e[^-1] "Compute skeleton of binary image$?."
  -v - ->= 50% -distance 0 -b $1 -sharpen 1e10 ->= 100%
  -repeat @# --erode[$>] 2 --[$>,-1] -done -v +

#@gmic ssd_patch : [patch],_use_fourier={ 0 | 1 },_boundary_conditions={ 0=dirichlet | 1=neumann }
#@gmic : Compute fields of SSD between selected images and specified patch.
#@gmic : Argument 'boundary_conditions' is valid only when 'use_fourier=0'.
#@gmic : Default value: 'use_fourier=0' and 'boundary_conditions=0'.
#@gmic : $ image.jpg --crop 20%,20%,35%,35% --ssd_patch[0] [1],0,0
ssd_patch : -check @{-is_image_arg\ $1} -skip ${2=0},${3=0}
  -e[^-1] "Compute field of SSD between image$? and patch $1 using "@{-arg\ 1+!$2,fourier,spatial}" mode."
  -v - -repeat @# -pass$1 0 -l[$>,-1]
    -r 100%,100%,100%,@{-max_s} -s c
    -repeat {@#/2} -l[$>,{-1-$<}]
      --sqr[1] val=@{-1,+} -rm[-1] # Sum J(p,q)^2
      --sqr[0] --f[1] 1
      -if $2
        -convolve_fft[-2] [-1] -rm[-1] # Sum I(x+p,y+q)^2
        -mirror[1] xyz -convolve_fft[0] [1] -rm[1]  # Sum I(x+p,y+q).J(p,q)
      -else
        -correlate[-2] [-1],$3 -rm[-1] # Sum I(x+p,y+q)^2
        -correlate[0] [1],$3 -rm[1] # Sum I(x+p,y+q).J(p,q)
      -endif
      -*[0] -2 -+[0,1] -+ $val
    -endl -done -+
  -endl -done -v +

#@gmic thinning
#@gmic : Compute skeleton of binary shapes using morphological thinning
#@gmic : (This is a quite slow iterative proces)
#@gmic : $ image.jpg -threshold 50% --thinning
thinning :
  -e[^-1] "Compute skeleton of binary image$?, using morphological thinning."
  -v - ->= 50% -* 2 -- 1
  (-1,-1,-1;0,1,0;1,1,1) (0,-1,-1;1,1,-1;0,1,0) --rotate[-2,-1] 90 --rotate[-2,-1] 90 --rotate[-2,-1] 90
  -repeat {@#-8}  # Start skeleton refinement.
    bavg=@{-9,+}
    -repeat 99999
      --correlate[-9] [-8] ->=[-1] 7 -*[-1] 2 --[-10,-1]
      --correlate[-9] [-7] ->=[-1] 6 -*[-1] 2 --[-10,-1]
      --correlate[-9] [-6] ->=[-1] 7 -*[-1] 2 --[-10,-1]
      --correlate[-9] [-5] ->=[-1] 6 -*[-1] 2 --[-10,-1]
      --correlate[-9] [-4] ->=[-1] 7 -*[-1] 2 --[-10,-1]
      --correlate[-9] [-3] ->=[-1] 6 -*[-1] 2 --[-10,-1]
      --correlate[-9] [-2] ->=[-1] 7 -*[-1] 2 --[-10,-1]
      --correlate[-9] [-1] ->=[-1] 6 -*[-1] 2 --[-10,-1]
      aavg=@{-9,+} -if {$aavg==$bavg} -break -endif bavg=$aavg
    -done
  -mv[-9] 0 -done -rm[-8--1] -+ 1 -/ 2 -v +

#@gmic tones : N>0
#@gmic : Get N tones masks from selected images.
#@gmic : $ image.jpg --tones 3
tones : -check $1>0
  -e[^-1] "Get $1 tones masks from image$?."
  -v - -norm -n 0,{$1-1} -round 1 -repeat @# -l[$<]
    -repeat {$1-1} --==[0] {1+$>} -done -==[0] 0
  -endl -done -v +

#@gmic topographic_map : _nb_levels>0,_smoothness
#@gmic : Render selected images as topographic maps.
#@gmic : Default values: 'nb_levels=16' and 'smoothness=2'.
#@gmic : $ image.jpg --topographic_map 10
topographic_map : -check "isint(${1=16}) && $1>0" -skip ${2=2}
  -e[^-1] "Render topographic maps from image$?, with $1 levels and smoothness $2."
  -v - -repeat @# -l[$>]
    --b $2 -isophotes[-1] $1 -compose_channels[-1] + -==[-1] 0 -blend shapeaverage0
  -endl -done -v +

#@gmic variance_patch : _patch_size>=1
#@gmic : Compute variance of each images patch centered at (x,y), in selected images.
#@gmic : Default value: 'patch_size=16'
#@gmic : $ image.jpg --variance_patch
variance_patch : -check "isint(${1=16}) && $1>=1"
  -e[^-1] "Compute variance of image patches in image$?, with patch size $1."
  -v -
  $1,$1,1,1,1 -normalize_sum[-1]
  -repeat {@#-1} -l[$>,-1]
    --sqr[0] -convolve[0,2] [1]
    -sqr[0] -rv[0,2] --[0,2] -max[0] 0
  -endl -done -rm[-1] -v +

#---------------------------------
#
#@gmic :: Image drawing
#
#---------------------------------

#@gmic axes : x0,x1,y0,y1,_font_height>=0,_opacity,_pattern,_color1,.. : (+)
#@gmic : Draw xy-axes on selected images.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified.
#@gmic : To draw only one x-axis at row Y, set both 'y0' and 'y1' to Y.
#@gmic : To draw only one y-axis at column X, set both 'x0' and 'x1' to X.
#@gmic : Default values: 'font_height=13', 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@gmic : $ 400,400,1,3,255 -axes -1,1,1,-1

#@gmic ball : _size>0, _R,_G,_B,0<=_specular_light<=8,0<=_specular_size<=8,_shadow>=0
#@gmic : Input a 2d RGBA colored ball sprite.
#@gmic : Default values: 'size=64', 'R=255', 'G=R', 'B=R', 'specular_light=0.8', 'specular_size=1' and 'shading=1.5'.
#@gmic : $ -repeat 9 -ball {1.5^($>+2)},@{-RGB} -done -append x
ball : -check "${1=64}>0 && ${5=0.8}>=0 && $5<=8 && ${6=1}>=0 $6<=8 && ${7=1.5}>=0" -skip ${2=255},${3=$2},${4=$3}
  -e[^-1] "Input $1x$1 ball with color (${2-4}), specular light $5, specular size $6 and shadow factor $7."
  -v - -l[]
  {2*$1},{2*$1} -= 1,65%,30% -distance 1 -* -1
  --n 0,1 -^[1] $7 -*[1] 1.4 --*[1] $3 --*[1] $4 -*[1] $2 -a[^0] c
  ->=[0] {100-10*$6}% -b[0] {3*$6}% -n[0] 0,{$5*255} -rv -+ -c 0,255
  100%,100% -circle[1] 50%,50%,34%,1,1 -*[0] [1] -*[-1] 255 -a c
  -r $1,$1,1,4,2
  -endl -v +

#@gmic chessboard : size1>0,_size2>0,_offset1,_offset2,_angle,_opacity,_color1,..,_color2,..
#@gmic : Draw chessboard on selected images.
#@gmic : Default values: 'size2=size1', 'offset1=offset2=0', 'angle=0', 'opacity=1', 'color1=0' and 'color2=255'.
#@gmic : $ image.jpg -chessboard 32,32,0,0,25,0.3,255,128,0,0,128,255
chessboard : -check "$1>0 && ${2=$1}>0" -skip ${3=0},${4=0},${5=0},${6=1},${7=0},${8=255}
  -e[^-1] "Draw chessboard on image$?, with sizes ($1,$2), offsets ($3,$4), angle $5 deg., opacity $6 and colors (${7--1})."
  -v - -i[0] (${7--1}) -r[0] {@{0,w}/2},1,1,2,-1 -permute[0] cyzx
  -repeat {@#-1}
    w={w} h={h} theta={$5*pi/180}
    ($3,{$3+$w-1};$3,{$3+$w-1}^$4,$4;{$4+$h-1},{$4+$h-1}) -r[-1] $w,$h,1,2,3
    -r[-1] {$w*$h},2,1,1,-1
    -i[-2] ({cos($theta)},{-sin($theta)};{sin($theta)},{cos($theta)}) -**[-2,-1]
    -r[-1] $w,$h,1,2,-1
    -%[-1] {$1+$2} ->=[-1] $1 -s[-1] c -xor[-2,-1] -map[-1] [0] -r[-1] 100%,100%,1,[-2]
    -j[-2] [-1],0,0,0,0,$6 -rm[-1]
  -mv[-1] 1 -done -rm[0] -v +

#@gmic cie1931
#@gmic : Draw CIE-1931 chromaticity diagram on selected images.
#@gmic : $ 500,400,1,3 -cie1931
cie1931 :
  -e[^-1] "Draw CIE-1931 chromaticity diagram on image$?."
  -v -

  # Generate convex hull of visible colors, as a 3d object.
  (67.5;73.5;109.5;103.5;51.5;100.5;37;36)  # Header
  (280,420,0;171,829,0;158,820,0;153,816,0;147,811,0;140,804,0;132,794,0;121,776,0;106,747,0;88,701,0;\  # Vertices.
  65,633,0;42,539,0;20,421,0;5,295,0;0,179,0;4,115,0;10,83,0;16,61,0;25,38,0;35,21,0;47,10,0;58,3,0;\
  71,0,0;92,1,0;111,7,0;151,28,0;189,52,0;226,79,0;262,109,0;298,141,0;334,175,0;370,209,0;405,244,0;\
  441,279,0;475,313,0;509,347,0;731,568,0)
  xM=731 yM=829
  2,{h-1},1,1,3,0 1,{h},1,1,'y' --+[-1] 1 -%[-1] {h} -+[-2,-1] 1 -a[-3--1] x  # Primitives.
  3,{h},1,1,160 1,{h},1,1,1  # Colors + opacities.
  -y[-4--2] -a[-5--1] y -mv[-1] 0

  # Generate RGB triangle of displayable colors.
  xR=636 yR=504 xG=297 yG=234 xB=147 yB=774
  512,512,1,3 -triangle_shade[-1] 0,0,{w-1},0,0,{h-1},""255,0,0,""0,255,0,""0,0,255 -rgb2srgb[-1]
  --compose_channels[-1] max -+[-1] 1e-8 -/[-2,-1] -*[-1] 255
  -i[-2] (67.5;73.5;109.5;103.5;51.5;100.5;3;1;$xR;$yR;-0.01;$xG;$yG;-0.01;$xB;$yB;-0.01;9;0;1;2;0;0;511;0;0;511;-128;512;512;3)
  -y[-1] (1) -a[-3--1] y -mv[-1] 1

  # Draw chroma diagram.
  -repeat {@#-2}
    -to_rgb[-1] -fc[-1] 255,255,255 -grid[-1] 10%,10%,0,0,0.3,0xCCCCCCCC,1,0
    100%,100%,1,3
    --*3d[0,1] {(w-8)/$xM},{(h-32)/$yM}
    -j3d[-3] [-1],2,30,0,1,2
    --!=[-3] 0 -distance[-1] 1 -*[-1] -1 -watershed[-4] [-1] -rm[-1] -/[-3] 1.5
    -j3d[-3] [-1],2,30,0,1,2
    -p3d[-1] 1 -p3d[-1] 2 -col3d[-1] 128 -j3d[-3] [-1],2,30,0,1,1 -rm[-1]
    @{-2,w},@{-2,h} -j3d[-1] [-2],2,30,0,1,2 -rm[-2]
    --erode[-1] 4 --[-1] [-2] -==[-1] 0 -*[-3,-1]
    -a[-2,-1] c -blend[-2,-1] alpha
    100%,100%,1,1,255 -axes[-1] 0,0.75,0.85,0,13,1 --erode[-1] 3 -negative[-1] -to_rgb[-2]
    -j[-3] [-2],0,0,0,0,1,[-1],400 -rm[-2,-1]
  -mv[-1] 2 -done -rm[0,1] -v +

#@gmic circle : x[%],y[%],R[%],_opacity,_pattern,_color1,..
#@gmic : Draw specified colored circle on selected images.
#@gmic : A radius of '100%' stands for 'sqrt(width^2+height^2)'.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified. If a pattern is specified, the circle is
#@gmic : drawn outlined instead of filled.
#@gmic : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@gmic : $ image.jpg -repeat 300 -circle {?(100)}%,{?(100)}%,{?(30)},0.3,@{-RGB} -done -circle 50%,50%,100,0.7,255
circle : -skip ${4=1},${5=0}
  -v - ({'"$5"'}) is_pattern={@{-1,0-1}'=='{'0x'}} -rm[-1] -v +
  -if $is_pattern
    -e[0--3] "Draw outlined circle at ($1,$2) with radius $3 on image$?, with opacity $4 and color (${6--1})."
  -else
    -e[0--3] "Draw filled circle at ($1,$2) with radius $3 on image$?, with opacity $4 and color (${5--1})."
  -endif
  -v - -ellipse $1,$2,$3,$3,0,${4--1} -v +

#@gmic ellipse : x[%],y[%],R[%],r[%],_angle,_opacity,_pattern,_color1,.. : (+)
#@gmic : Draw specified colored ellipse on selected images.
#@gmic : A radius of '100%' stands for 'sqrt(width^2+height^2)'.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified. If a pattern is specified, the ellipse is
#@gmic : drawn outlined instead of filled.
#@gmic : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@gmic : $ image.jpg -repeat 300 -ellipse {?(100)}%,{?(100)}%,{?(30)},{?(30)},{?(180)},0.3,@{-RGB} -done -ellipse 50%,50%,100,100,0,0.7,255

#@gmic flood : x[%],_y[%],_z[%],_tolerance>=0,_is_high_connectivity={ 0 | 1 },_opacity,_color1,.. : (+)
#@gmic : Flood-fill selected images using specified value and tolerance.
#@gmic : Default values: 'y=z=0', 'tolerance=0', 'is_high_connectivity=0', 'opacity=1' and 'color1=0'.
#@gmic : $ image.jpg -repeat 1000 -flood {?(100)}%,{?(100)}%,0,20,0,1,@{-RGB} -done

#@gmic gaussian : _sigma1[%],_sigma2[%],_angle
#@gmic : Draw a centered gaussian on selected images, with specified standard deviations and orientation.
#@gmic : Default values: 'sigma1=3', 'sigma2=sigma1' and 'angle=0'.
#@gmic : $ 400,400 -gaussian 100,30,45
#@gmic : $$
gaussian : -skip ${1=3},${2=$1},${3=0}
  -e[^-1] "Draw centered gaussian on image$? with standard deviations ($1,$2) and angle $3 deg."
  -v -
  u={cos($3*pi/180)}
  v={sin($3*pi/180)}
  dmax={max(w,h)}
  -if {isval($1)} l1=$1 -else l1={${1}10000*$dmax/100} -endif
  -if {isval($2)} l2=$2 -else l2={${2}10000*$dmax/100} -endif
  l1={1/(2*max(1/3,$l1)^2)}
  l2={1/(2*max(1/3,$l2)^2)}
  A={$l1*$u*$u+$l2*$v*$v}
  B={($l1-$l2)*$u*$v}
  C={$l1*$v*$v+$l2*$u*$u}
  -repeat @# -l[$>] nm=@{0,n}
    w={w} h={h} ds={d},{s} -rm
    $w,$h,1,1,'X=x-{($w-1)/2};Y=y-{($h-1)/2};$A*X*X+2*$B*X*Y+$C*Y*Y'
    -* -1 -exp -r $w,$h,$ds
  -nm $nm,1 -endl -done -v +

#@gmic graph : [function_image],_plot_type,_vertex_type,_ymin,_ymax,_opacity,_pattern,_color1,.. : 'formula',_resolution>=0,_plot_type,_vertex_type,_xmin,xmax,_ymin,_ymax,_opacity,_pattern,_color1,.. : (+)
#@gmic : Draw specified function graph on selected images.
#@gmic : 'plot_type' can be { 0=none | 1=lines | 2=splines | 3=bar }.
#@gmic : 'vertex_type' can be { 0=none | 1=points | 2,3=crosses | 4,5=circles | 6,7=squares }.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified.
#@gmic : Default values: 'plot_type=1', 'vertex_type=1', 'ymin=ymax=0 (auto)', 'opacity=1', 'pattern=(undefined)'
#@gmic : and 'color1=0'.
#@gmic : $ image.jpg --rows 50% -blur[-1] 3 -split[-1] c -div[0] 1.5 -graph[0] [1],2,0,0,0,1,255,0,0 -graph[0] [2],2,0,0,0,1,0,255,0 -graph[0] [3],2,0,0,0,1,0,0,255 -keep[0]

#@gmic grid : size_x[%]>=0,size_y[%]>=0,_offset_x[%],_offset_y[%],_opacity,_pattern,_color1,..
#@gmic : Draw xy-grid on selected images.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified.
#@gmic : Default values: 'offset_x=offset_y=0', 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@gmic : $ image.jpg -grid 10%,10%,0,0,0.5,255
#@gmic : $ 400,400,1,3,255 -grid 10%,10%,0,0,0.3,0xCCCCCCCC,128,32,16
grid : -check "$1>=0 && $2>=0" -skip ${3=0},${4=0},${5=1},${6=0}
  -v - ({'"$6"'}) is_pattern={@{-1,0-1}'=='{'0x'}} -rm[-1] -v +
  -if $is_pattern
    -e[0--3] "Draw xy-grid on image$?, with sizes ($1,$2), offsets ($3,$4), opacity $5, pattern $6 and color (${7--1})."
    -v - pattern=$6 color=${7--1}
  -else
    -e[0--3] "Draw xy-grid on image$?, with sizes ($1,$2), offsets ($3,$4), opacity $5, and color (${6--1})."
    -v - pattern=0xFFFFFFFF color=${6--1}
  -endif
  is_percentsx=@{-is_percent\ $1} is_percentsy=@{-is_percent\ $2}
  is_percentox=@{-is_percent\ $3} is_percentoy=@{-is_percent\ $4}

  -repeat @# -l[$>]
    w={w} h={h} s={s}

    # Draw grid along x-axis.
    size={if($is_percentsx,max(1,w*$1),$1)}
    -if {$size>=1}
      offset={if($is_percentox,$size*$3,$3)}
      ({'CImg3d'}) -+[-1] 0.5 # Header
      1,{1+int($w/$size)},1,1,'y' -*[-1] $size -+[-1] {$offset%$size} # Points
      1,{h},1,1,{$h/2} -a[-2,-1] x -z[-1] 0,2 n={h} -i[-2] ($n;$n)
      (1,0;1,{$n-1}) -r[-1] 2,$n,1,1,3 -round[-1] # Primitives
      (-128;1;$h;$s) 1,$h,1,$s -line[-1] 0,0,0,100%,1,$pattern,$color # Colors.
      -if {$n>1} 1,{4*($n-1)},1,1,-128,0,0,0 -endif
      (-128;1;$h;1) 1,$h,1,1 -line[-1] 0,0,0,100%,1,$pattern,1 # Opacities.
      -if {$n>1} 1,{4*($n-1)},1,1,-128,0,0,0 -endif
      -y[^0] -a[^0] y -j3d[0] [1],0,0,0,$5,0,0,0 -rm[1] # Merge and draw.
    -endif

    # Draw grid along y-axis.
    size={if($is_percentsy,max(1,h*$2),$2)}
    -if {$size>=1}
      offset={if($is_percentoy,$size*$4,$4)}
      ({'CImg3d'}) -+[-1] 0.5 # Header
      1,{1+int($h/$size)},1,1,'y' -*[-1] $size -+[-1] {$offset%$size} # Points.
      -i[-2] 1,{h},1,1,{$w/2} -a[-2,-1] x -z[-1] 0,2 n={h} -i[-2] ($n;$n)
      (1,0;1,{$n-1}) -r[-1] 2,$n,1,1,3 -round[-1] # Primitives.
      (-128;$w;1;$s) $w,1,1,$s -line[-1] 0,0,100%,0,1,$pattern,$color # Colors.
      -if {$n>1} 1,{4*($n-1)},1,1,-128,0,0,0 -endif
      (-128;$w;1;1) $w,1,1,1 -line[-1] 0,0,100%,0,1,$pattern,1 # Opacities
      -if {$n>1} 1,{4*($n-1)},1,1,-128,0,0,0 -endif
      -y[^0] -a[^0] y -j3d[-2] [-1],0,0,0,$5,0,0,0 -rm[-1]  # Merge and draw.
    -endif

  -endl -done -v +

#@gmic j : eq. to '-image'. : (+)

#@gmic image : [sprite],_x[%],_y[%],_z[%],_c[%],_opacity,_[sprite_mask],_max_opacity_mask : (+)
#@gmic : Draw specified sprite image on selected images.
#@gmic : (eq. to '-j').
#@gmic : Default values: 'x=y=z=c=0', 'opacity=1', 'sprite_mask=(undefined)' and 'max_opacity_mask=1'.
#@gmic : $ image.jpg --crop 40%,40%,60%,60% -resize[-1] 200%,200%,1,3,5 -frame[-1] 2,2,0 -image[0] [-1],30%,30% -keep[0]

#@gmic line : x0[%],y0[%],x1[%],y1[%],_opacity,_pattern,_color1,.. : (+)
#@gmic : Draw specified colored line on selected images.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified.
#@gmic : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@gmic : $ image.jpg -repeat 500 -line 50%,50%,{?(w)},{?(h)},0.5,@{-RGB} -done -line 0,0,100%,100%,1,0xCCCCCCCC,255 -line 100%,0,0,100%,1,0xCCCCCCCC,255

#@gmic mandelbrot : z0r,z0i,z1r,z1i,_iteration_max>=0,_is_julia={ 0 | 1 },_c0r,_c0i,_opacity : (+)
#@gmic : Draw mandelbrot/julia fractal on selected images.
#@gmic : Default values: 'iteration_max=100', 'is_julia=0', 'c0r=c0i=0' and 'opacity=1'.
#@gmic : $ 400,400 -mandelbrot -2.5,-2,2,2,1024 -map 0 --blur 2 -elevation3d[-1] -0.2

#@gmic marble : _image_weight,_pattern_weight,_angle,_amplitude,_sharpness>=0,_anisotropy>=0,_alpha,_sigma,_cut_low>=0,_cut_high>=0
#@gmic : Render marble like pattern on selected images.
#@gmic : Default values: 'image_weight=0.2', 'pattern_weight=0.1', 'angle=45', 'amplitude=0', 'sharpness=0.4', 'anisotropy=0.8',
#@gmic : 'alpha=0.6', 'sigma=1.1' and 'cut_low=cut_high=0'.
#@gmic : $ image.jpg --marble ,
marble : -skip ${1=0.2},${2=0.1},${3=45},${4=0},${5=0.4},${6=0.8},${7=0.6},${8=1.1},${9=0%},${10=100%}
  -e[^-1] "Render marble like pattern on image$?, with image weight $1, pattern weight $2, angle $3 deg., amplitude $4, "\
          "sharpness $5, anisotropy $6, alpha $7, sigma $8, and cut ($9,$10)."
  -v - sx={$2*sin($3*pi/180)} sy={$2*cos($3*pi/180)} -f sin(x*$sx+y*$sy+i*$1)
  -if {$4} -smooth $4,$5,$6,$7,$8 -endif
  -c $9,$10 -n 0,255
  -v +

#@gmic maze : _width>0,_height>0,_cell_size>0
#@gmic : Input maze with specified size.
#@gmic : $ -maze 30,20 -negative -normalize 0,255
maze : -check "isint(${1=15}) && $1>0 && isint(${2=$1}) && $2>0 && isint(${3=24}) && $3>0"
  -e[^-1] "Input $1x$2 maze."
  -v -
  ({round(?($1-1))},{round(?($2-1))})  # Starting cell.
  $1,$2,1,1,15 --f[-1] 0 -a[-2,-1] c   # Starting maze data.
  -_generate_maze $1,$2
  -_render_maze[-1] $3 -nm[-1] [maze]
  -v +

_generate_maze :

  # Start opening walls.
  -do
    x=@{-2,-2} y=@{-2,-1}  # Coords of the current cell.
    -=[-1] 1,$x,$y,0,1     # Mark current cell as visited.

    # Check for neighboring cells that are candidate for opening wall, and select one random.
    is_candidate=0
    up=-1 -if {i($x,$y)&8" && "$y>0" && "!i($x,$y-1,0,1)} up=$x,{$y-1},8 is_candidate=1 -endif          # Up.
    down=-1 -if {i($x,$y)&4" && "$y<$2-1" && "!i($x,$y+1,0,1)} down=$x,{$y+1},4 is_candidate=1 -endif   # Down.
    left=-1 -if {i($x,$y)&2" && "$x>0" && "!i($x-1,$y,0,1)} left={$x-1},$y,2 is_candidate=1 -endif      # Left.
    right=-1 -if {i($x,$y)&1" && "$x<$1-1" && "!i($x+1,$y,0,1)} right={$x+1},$y,1 is_candidate=1 -endif # Right.
    -if $is_candidate
      ($up,$down,$left,$right) -discard[-1] -1 -r[-1] 3,{h/3},1,1,-1 -shift[-1] 0,{?(4)},0,0,2 -rows[-1] 0,0 -mv[-1] -2
    -endif

    # Remove wall between the current and chosen neighboring cells.
    -if $is_candidate
      -if {@{-2,-1}==8}   -=[-1] {i($x,$y)&7},$x,$y -=[-1] {i($x,$y-1)&11},$x,{$y-1}   # Remove up wall.
      -elif {@{-2,-1}==4} -=[-1] {i($x,$y)&11},$x,$y -=[-1] {i($x,$y+1)&7},$x,{$y+1}   # Remove down wall.
      -elif {@{-2,-1}==2} -=[-1] {i($x,$y)&13},$x,$y -=[-1] {i($x-1,$y)&14},{$x-1},$y  # Remove left wall.
      -else               -=[-1] {i($x,$y)&14},$x,$y -=[-1] {i($x+1,$y)&13},{$x+1},$y  # Remove right wall.
      -endif
      -z[-2] 0,1 -a[-3,-2] y  # Add neighboring cell to stack of cells to explore.
    -else # No candidate : remove current cell from cells to explore.
      -if {@{-2,h}==1} -break -endif
      -rows[-2] 0,{@{-2,h}-2}
    -endif
  -while 1
  -rm[-2] -channels[-1] 0

_render_maze :
  # Create the 16 configurations of walls.
  -i[0] $1,$1 -i[1] [0]x15
  -line[8-15] 0,0,100%,0,1,1
  -line[4-7,12-15] 0,100%,100%,100%,1,1
  -line[2-3,6-7,10-11,14-15] 0,0,0,100%,1,1
  -line[1-15:2] 100%,0,100%,100%,1,1
  # Map the wall data with them.
  -a[0-15] x -r[-1] {w*$1},{h*$1} -*[-1] $1 -channels[-1] 0,1
  $1,$1,1,1,x $1,$1,1,1,y -a[-2,-1] c -r[-1] [-2],[-2],1,2,0,2 -+[-2,-1]
  -warp[-2] [-1],0,0,0 -rm[-1]

#@gmic maze_mask : _cellsize>0
#@gmic : Input maze according to size and shape of selected mask images.
#@gmic : Mask may contain disconnected shapes.
#@gmic : $ 0 -text "G'MIC",0,0,53,1,1 -dilate 3 -autocrop 0 -frame 1,1,0 -maze_mask 8 -dilate 3 -negative -* 255
maze_mask : -check "isint(${1=24}) && $1>0"
  -e[^-1] "Input masked maze from image$? with cell size $1."
  -v - -norm ->= 50% -repeat @# -l[$>]
    -do
      --rand[0] 0,1 -*[-1] [0] ({xM},{yM}) -rm[-2]  # Select one starting point in the mask.
      --flood[0] @-1,0,0,0,1,2 ->=[-1] 2 --negative[-1] -*[-2] 15 -a[-2,-1] c
      -flood[0] @-2,0,0,0,1,0
      -_generate_maze {w},{h}
    -while @{0,M}
    -rm[0] -+ -_render_maze[-1] $1 -nm[-1] [maze]
  -endl -done -v +

#@gmic j3d : eq. to '-object3d'. : (+)

#@gmic object3d : [object3d],_x[%],_y[%],_z,_opacity,_rendering_mode,_is_double_sided={ 0 | 1 },_is_zbuffer={ 0 | 1 },_focale,_light_x,_light_y,_light_z,_specular_lightness,_specular_shininess : (+)
#@gmic : Draw specified 3d object on selected images.
#@gmic : (eq. to '-j3d').
#@gmic : 'rendering_mode' can be { 0=dots | 1=wireframe | 2=flat | 3=flat-shaded | 4=gouraud-shaded | 5=phong-shaded }.
#@gmic : Default values: 'x=y=z=0', 'opacity=1' and 'is_zbuffer=1'. All other arguments take their default values from the 3d environment variables.
#@gmic : $ image.jpg -torus3d 100,10 -cone3d 30,-120 -add3d[-2,-1] -rotate3d[-1] 1,1,0,60 -object3d[0] [-1],50%,50% -keep[0]

#@gmic pack_sprites : _nb_scales>=0,0<=_min_scale<=100,_allow_rotation={ 0=0 deg. | 1=180 deg. | 2=90 deg. | 3=any },_spacing,_precision>=0,max_iterations>=0
#@gmic : Try to randomly pack as many sprites as possible onto the 'empty' areas of an image.
#@gmic : Sprites can be eventually rotated and scaled during the packing process.
#@gmic : First selected image is the canvas that will be filled with the sprites.
#@gmic : Its last channel must be a binary mask whose zero values represent potential locations for drawing the sprites.
#@gmic : All other selected images represent the sprites considered for packing.
#@gmic : Their last channel must be a binary mask that represents the sprite shape (i.e. a 8-connected component).
#@gmic : The order of sprite packing follows the order of specified sprites in the image list.
#@gmic : Sprite packing is done on random locations and iteratively with decreasing scales.
#@gmic : 'nb_scales' sets the number of decreasing scales considered for all specified sprites to be packed.
#@gmic : 'min_scale' (in %) sets the minimal size considered for packing (specified as a percentage of the original sprite size).
#@gmic : 'spacing' can be positive or negative.
#@gmic : 'precision' tells about the desired number of failed trials before ending the filling process.
#@gmic : Default values: 'nb_scales=5', 'min_scale=25', 'allow_rotation=3', 'spacing=1', 'precision=7' and 'max_iterations=256'.
#@gmic : $ 512,512,1,3,"min(255,y*c/2)" 100%,100% -circle 50%,50%,100,1,255 -append c image.jpg -resize2dy[-1] 24 -to_rgba -pack_sprites 3,25
pack_sprites : -check "isint(${1=5}) && $1>=0 && ${2=25}>=0 && $2<=100 && isint(${3=3}) && $3>=0 && $3<=3 && isint(${4=1}) && isint(${5=7}) && $5>=0 && isint(${6=256}) && $6>=0"
  -e[^-1] "Randomly pack image$? with $1 scales, minimum scale $2%, "@{-arg\ 1+$3,no,180\"\ \"deg.,90\"\ \"deg.,any}" rotation, spacing $4, precision $5 and $6 maximum iterations."
  -v - N={@#-1} is_first_time=1
  -repeat @# -r[$>] 100%,100%,1,{max(2,@{$>,s})} -done   # Ensure all images have a binary shape mask.

  # Start iterations over scales.
  -repeat $1
    -rprogress {$>*100/$1}
    nb_attempts=0

    # Generate all sprites for current scale.
    ratio={if($1>1,$2+(100-$2)*$</($1-1),100)}%
    -repeat $N --l[{1+$>}]
      w={w*$ratio} h={h*$ratio}
      -if {$w<1||$h<1} -rm
      -else -r $w,$h,1,100%,2 -sh[-1] 100%,100% -!=[-1] 0 area{1+$>}=@{-1,+} -rm[-1]
      -endif
    -endl -done

    # Pack rescaled sprites together.
    -l[0,{$N+1}--1] -repeat $6

      # Compute reference sprite.
      ind={1+($>%$N)} area=${area$ind}
      -if {$3==0} [$ind]
      -elif {$3==1} --rotate[$ind] {round(?)*180}
      -elif {$3==2} --rotate[$ind] {round(?(3))*90}
      -else --rotate[$ind] {?*360} -sh[-1] 100%,100% -!=[-1] 0 area=@{-1,+} -rm[-1]
      -endif

      # Get binary map of possible locations.
      --channels[0] 100% -==[-1] 0
      -if {$4>1} -erode[-1] {2*$4-1}
      -elif {$4<1} -dilate[-1] {-2*$4+3}
      -endif

      # Generate random skeleton-oriented point cloud.
      --rectangle[-1] 0,0,100%,100%,1,0xFFFFFFFF,0
      -if $is_first_time -noise[-1] 0.1,2 -endif
      -distance[-1] 0 -noise[-1] 1,1
      -max_patch[-1] {round(1.5*@{$ind,max(w,h)})}
      -*[-1] [-2] -pointcloud3d[-1]

      # Subdivide point cloud if multiple sprites.
      -if {$N>1} -l[-1]
        -s3d -/[1] $N -round[1] -max[1] 1 n=@{1,0}
        -r[2] 3,{@{2,h}/3},1,1,-1
        -i[2] 1,@{2,h} -rand[2] 0,1 -a[2,3] x -sort[2] +,y -z[2] 1,3 -r[2] 3,$n,1,1 -y[2]
        -r[3] 1,{2*$n},1,1,0 -r[4] 1,{3*$n},1,1,0 -r[5] 1,$n,1,1,0 -a y
      -endl -endif

      # Create 3d cloud of sprites.
      n=@{-1,7}
      -if $n
        -s3d[-1] -rm[-2,-1]
        -if {$3==0} # No rotation allowed.
          [-6] -i[-2] (-128;{w};{h};{s})
          -if {$n>1} 4,{$n-1},1,1,-128,0,0,0 -endif
          --channels[-2] 100% -i[-2] (-128;{w};{h};{s})
          -if {$n>1} [-3] -endif
        -elif {$3==1} # 180 deg. rotation allowed.
          --rotate[-6] {round(?(1))*180} -i[-2] (-128;{w};{h};{s})
          -if {$n>1} --rotate[-1] 180 -i[-2] (-128;{w};{h};{s}) -endif
          -if {$n>2} 4,{$n-2},1,1,-128,0,0,0 1,100% -rand[-1] 0,1 -round[-1] 1 -j[-2] [-1],1 -rm[-1] -endif
          --channels[-4] 100% -i[-2] (-128;{w};{h};{s})
          -if {$n>1} --channels[-4] 100% -i[-2] (-128;{w};{h};{s}) -endif
          -if {$n>2} [-5] -endif
        -else # 90 deg. rotation (or more) allowed.
          --rotate[-6] {round(?(3))*90} -i[-2] (-128;{w};{h};{s})
          -if {$n>1} --rotate[-1] 90 -i[-2] (-128;{w};{h};{s}) -endif
          -if {$n>2} --rotate[-1] 90 -i[-2] (-128;{w};{h};{s}) -endif
          -if {$n>3} --rotate[-1] 90 -i[-2] (-128;{w};{h};{s}) -endif
          -if {$n>4} 4,{$n-4},1,1,-128,0,0,0 1,100% -rand[-1] 0,3 -round[-1] 1 -j[-2] [-1],1 -rm[-1] -endif
          --channels[-8] 100% -i[-2] (-128;{w};{h};{s})
          -if {$n>1} --channels[-8] 100% -i[-2] (-128;{w};{h};{s}) -endif
          -if {$n>2} --channels[-8] 100% -i[-2] (-128;{w};{h};{s}) -endif
          -if {$n>3} --channels[-8] 100% -i[-2] (-128;{w};{h};{s}) -endif
          -if {$n>4} [-9] -endif
        -endif
        -y[{$N+3}--1] -a[{$N+3}--1] y
      -endif
      -rm[-3] # Delete reference sprite.

      # Draw cloud and detect non-intersecting sprites.
      [0] -sh[-1] 100%,100% -f[-1] 1 --[-1] [-4]
      -j3d[-2] [-3],0,0,0,1,2,0,0 -rm[-3,-1]
      -sh[-1] 100%,100% -area_fg[-1] 0,1 -==[-1] $area
      -*[-1] [-3] -rm[-3] -sh[-2] 0,@{-2,s-2} -*[-1] [-2] -rm[-1]

      # Draw selected sprites on rendering image.
      -if {iM} -j[0] [-2],0,0,0,0,1,[-1] -rm[-2,-1]
      -else
        -rm[-2,-1]
        nb_attempts={$nb_attempts+1}
        -if {$nb_attempts>$5} -break -else -continue -endif
      -endif

    -done -k[0] -endl

  -done -k[0] -v +

#@gmic piechart : label_height>=0,label_R,label_G,label_B,"label1",value1,R1,G1,B1,...,"labelN",valueN,RN,GN,BN
#@gmic : Draw pie chart on selected (RGB) images.
#@gmic : $ image.jpg -piechart 25,0,0,0,"Red",55,255,0,0,"Green",40,0,255,0,"Blue",30,128,128,255,"Other",5,128,128,128
piechart : -check $1>=0
  -e[^-1] "Draw pie chart on image$?, with label height $1 and color ($2,$3,$4)."
  -v - $=arg -repeat @# -l[$>]
    -ellipse 50%,50%,{w/2-1},{h/2-1},0,1,1
    -ellipse 50%,50%,{w/2-1},{h/2-1},0,1,0xFFFFFFFF
    (${6--1:5}) -normalize_sum[-1]
    theta=0
    -if {w>1} -repeat {w}
      xe={0.5*@{-2,w}*(1+cos($theta))}
      ye={0.5*@{-2,h}*(1+sin($theta))}
      -line[-2] 50%,50%,$xe,$ye
      theta={$theta-2*pi*i($>)}
    -done -endif
    theta=0
    -repeat {w} -if {i($>)}
      ntheta={$theta-2*pi*i($>)}
      xc={0.5*@{-2,w}*(1+0.5*cos(0.5*($ntheta+$theta)))}
      yc={0.5*@{-2,h}*(1+0.5*sin(0.5*($ntheta+$theta)))}
      xf={0.5*@{-2,w}*(1+0.8*cos(0.5*($ntheta+$theta)))}
      yf={0.5*@{-2,h}*(1+0.8*sin(0.5*($ntheta+$theta)))}
      -flood[-2] $xf,$yf,0,0,0,1,${arg{7+5*$>}},${arg{8+5*$>}},${arg{9+5*$>}}
      -if {abs($ntheta-$theta)>0.1}
        0 -t[-1] ${arg{5+5*$>}},0,0,$1,1,1
        ($2^$3^$4) -r[-1] [-2],[-2],1,3 -*[-1] [-2]
        -j[-4] [-1],{$xc-w/2},{$yc-h/2},0,0,1,[-2]
        -rm[-2,-1]
      -endif
      theta=$ntheta
    -endif -done
    -rm[-1]
  -endl -done -v +

#@gmic plasma : _alpha,__beta,_scale>=0 : (+)
#@gmic : Draw a random colored plasma fractal on selected images.
#@gmic : This command implements the so-called 'Diamond-Square' algorithm.
#@gmic : Default values: 'alpha=1', 'beta=1' and 'scale=8'.
#@gmic : $ 400,400,1,3 -plasma
#@gmic : $$

#@gmic point : x[%],y[%],_z[%],_opacity,_color1,.. : (+)
#@gmic : Set specified colored pixel on selected images.
#@gmic : Default values: 'z=0', 'opacity=1' and 'color1=0'.
#@gmic : $ image.jpg -repeat 10000 -point {?(100)}%,{?(100)}%,0,1,@{-RGB} -done

#@gmic polka_dots : diameter>=0,_density,_offset1,_offset2,_angle,_aliasing,_shading,_opacity,_color,...
#@gmic : Draw dots pattern on selected images.
#@gmic : Default values: 'density=20', 'offset1=offset2=50', 'angle=0', 'aliasing=10', 'shading=1', 'opacity=1' and 'color=255'.
#@gmic : $ image.jpg -polka_dots 10,15,0,0,20,10,1,0.5,0,128,255
polka_dots : -check $1>=0 -skip ${2=20},${3=50},${4=50},${5=0},${6=10},${7=1},${8=1},${9=255}
  -e[^-1] "Draw polka dots on image$?, with diameter $1, density $2, angle $3 deg., shift ($4,$5), aliasing $6 and shading $7."
  -v - theta={$5*pi/180} ct={cos($theta)} st={sin($theta)} mid1={$1/2} mid2={$2/2}
  -i[0] (${9--1}) -y[0] c
  -repeat {@#-1}
    WH={max(w,h)}
    100%,100%,100%,1,"xn = 100*x/"$WH"-$3; yn = 100*y/"$WH"-$4; \
                      xr = xn*"$ct"-yn*"$st"; yr = xn*"$st"+yn*"$ct"; \
                      xc = xr%$2-"$mid2"; yc = yr%$2-"$mid2"; \
                      "$mid1"-sqrt(xc*xc+yc*yc)"
    -*[-1] $6 -c[-1] 0,$7 -n[-1] 0,$8 (${9--1}) -y[-1] c -r[-1] [-2],[-2],[-2]
    -j[-3] [-1],0,0,0,0,1,[-2] -rm[-2,-1]
  -mv[-1] 1 -done -rm[0] -v +

#@gmic polygon : N>=1,x1[%],y1[%],..,xN[%],yN[%],_opacity,_pattern,_color1,.. : (+)
#@gmic : Draw specified colored N-vertices polygon on selected images.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified. If a pattern is specified, the polygon is
#@gmic : drawn outlined instead of filled.
#@gmic : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@gmic : $ image.jpg -polygon 4,20%,20%,80%,30%,80%,70%,20%,80%,0.3,0,255,0 -polygon 4,20%,20%,80%,30%,80%,70%,20%,80%,1,0xCCCCCCCC,255
#@gmic : $ image.jpg 2,16,1,1,'?(if(x,@{-1,h},@{-1,w}))' -polygon[-2] {h},@-1,0.6,255,0,255 -remove[-1]

#@gmic quiver : [function_image],_sampling>0,_factor,_is_arrow={ 0 | 1 },_opacity,_pattern,_color1,.. : (+)
#@gmic : Draw specified 2d vector/orientation field on selected images.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified.
#@gmic : Default values: 'sampling=25', 'factor=-20', 'is_arrow=1', 'opacity=1', 'pattern=(undefined)'
#@gmic : and 'color1=0'.
#@gmic : $ 100,100,1,2,'if(c==0,x-w/2,y-h/2)' 500,500,1,3,255 -quiver[-1] [-2],10
#@gmic : $ image.jpg --resize2dy 600 -luminance[0] -gradient[0] -mul[1] -1 -reverse[0,1] -append[0,1] c -blur[0] 8 -orientation[0] -quiver[1] [0],10,10,1,0.8,255

#@gmic rectangle : x0[%],y0[%],x1[%],y1[%],_opacity,_pattern,_color1,..
#@gmic : Draw specified colored rectangle on selected images.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified. If a pattern is specified, the rectangle is
#@gmic : drawn outlined instead of filled.
#@gmic : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@gmic : $ image.jpg -repeat 30 -rectangle {?(100)}%,{?(100)}%,{?(100)}%,{?(100)}%,0.3,@{-RGB} -done
rectangle : -skip ${5=1},${6=0}
  -v - ({'"$5"'}) is_pattern={@{-1,0-1}'=='{'0x'}} -rm[-1] -v +
  -if $is_pattern
    -e[0--3] "Draw outlined rectangle from ($1,$2) to ($3,$4) on image$?, with opacity $5 and color (${7--1})."
  -else
    -e[0--3] "Draw filled rectangle from ($1,$2) to ($3,$4) on image$?, with opacity $5 and color (${6--1})."
  -endif
  -v - -polygon 4,$1,$2,$3,$2,$3,$4,$1,$4,${5--1} -v +

#@gmic rorschach : 'smoothness[%]>=0','mirroring={ 0=none | 1=x | 2=y | 3=xy }
#@gmic : Render rorschach-like inkblots on selected images.
#@gmic : Default values: 'smoothness=5%' and 'mirroring=1'.
#@gmic : $ 400,400 -rorschach 3%
rorschach : -check "${1=5%}>=0 && isint(${2=1}) && $2>=0 && $2<=3"
  -e[^-1] "Render rorschach-like inkblots on image$?, with smoothness $1 and "@{-arg\ 1+$2,no,x,y,xy}"-mirroring."
  -v -
  -if {$2==0} # No mirroring.
   -rand -1,1 -b $1 ->= 0
  -elif {$2==1} # X-mirroring.
    -repeat @# -l[$>]
      w={w}
      -columns 0,{w/2-1} -rand -1,1 -b $1 ->= 0
      --mirror x -if {$w%2} -columns[-1] 1,100% -endif -a x
    -endl -done
  -elif {$2==2} # Y-mirroring.
    -repeat @# -l[$>]
      h={h}
      -rows 0,{h/2-1} -rand -1,1 -b $1 ->= 0
      --mirror y -if {$h%2} -rows[-1] 1,100% -endif -a y
    -endl -done
  -elif {$2==3} # XY-mirroring.
    -repeat @# -l[$>]
      w={w} h={h}
      -z 0,0,{w/2-1},{h/2-1} -rand -1,1 -b $1 ->= 0
      --mirror x -if {$w%2} -columns[-1] 1,100% -endif -a x
      --mirror y -if {$h%2} -rows[-1] 1,100% -endif -a y
    -endl -done
  -endif
  -v +

#@gmic sierpinski : recursion_level>=0
#@gmic : Draw Sierpinski triangle on selected images.
#@gmic : Default value: 'recursion_level=7'.
#@gmic : $ image.jpg -sierpinski 7
sierpinski : -check ${1=7}>=0 -skip ${2=50},${3=0},${4=0},${5=100},${6=100},${7=100}
  -e[^-1] "Draw Sierpinski triangle of degree $1 on image$?."
  -v - -_sierpinski ${2-7},$1  -v +

_sierpinski :
  -if {$7<=0} -polygon 3,$1%,$2%,$3%,$4%,$5%,$6%,1,255 -return -endif
  -_sierpinski $1,$2,{($1+$3)/2},{($2+$4)/2},{($1+$5)/2},{($2+$6)/2},{$7-1}
  -_sierpinski {($1+$3)/2},{($2+$4)/2},$3,$4,{($3+$5)/2},{($4+$6)/2},{$7-1}
  -_sierpinski {($1+$5)/2},{($2+$6)/2},$5,$6,{($3+$5)/2},{($4+$6)/2},{$7-1}

#@gmic snowflake : _recursion>=0,_x0,_y0,_x1,_y1,_x2,_y2,_opacity,_col1,..._colN
#@gmic : Draw a Koch snowflake on selected images.
#@gmic : Default values: 'recursion=4', 'x0=20', 'y0=70', 'x1=80', 'y1=70', 'x2=50', 'y2=10', 'opacity=1' and 'col1=255'.
#@gmic : $ image.jpg -snowflake 4
snowflake : -check ${1=4}>=0 -skip ${2=20},${3=70},${4=80},${5=70},${6=50},${7=10},${8=1},${9=255}
  -v -
  -polygon 3,$2%,$3%,$4%,$5%,$6%,$7%,${8--1}
  -_snowflake $1,$2,$3,$6,$7,${8--1}
  -_snowflake $1,$6,$7,$4,$5,${8--1}
  -_snowflake $1,$4,$5,$2,$3,${8--1}
  -v +

_snowflake :
  x0={$2+($4-$2)/3} y0={$3+($5-$3)/3}
  x1={$2+2*($4-$2)/3} y1={$3+2*($5-$3)/3}
  c={cos(-pi/3)} s={sin(-pi/3)}
  x2={$x0+($x1-$x0)*$c-($y1-$y0)*$s} y2={$y0+($x1-$x0)*$s+($y1-$y0)*$c}
  -polygon 3,$x0%,$y0%,$x1%,$y1%,$x2%,$y2%,${6--1}
  -if $1
    -_snowflake {$1-1},$2,$3,$x0,$y0,${6--1}
    -_snowflake {$1-1},$x0,$y0,$x2,$y2,${6--1}
    -_snowflake {$1-1},$x2,$y2,$x1,$y1,${6--1}
    -_snowflake {$1-1},$x1,$y1,$4,$5,${6--1}
  -endif

#@gmic spiralbw
#@gmic : Draw (squared) spiral on selected images.
#@gmic : $ 16,16 -spiralbw
spiralbw :
  -e[^-1] "Draw (squared) black and white spiral on image$?."
  -v - -channels 0
  -f "r=min(x,y,w-1-x,h-1-y); 2*r*(w+h-2*r-1) + if(min(x,h-1-y)>=min(w-1-x,y),x+y,2*(w+h-2-2*r)-x-y)"
  -v +

#@gmic spline : x0[%],y0[%],u0[%],v0[%],x1[%],y1[%],u1[%],v1[%],_nb_vertices>=2,_opacity,_color1,..
#@gmic : Draw specified colored spline curve on selected images (cubic hermite spline).
#@gmic : Default values: 'nb_vertices=256', 'opacity=1' and 'color1=0'.
#@gmic : $ image.jpg -repeat 30 -spline {?(100)}%,{?(100)}%,{?(-600,600)},{?(-600,600)},{?(100)}%,{?(100)}%,{?(-600,600)},{?(-600,600)},256,0.3,255 -done
spline : -skip ${9=256},${10=1},${11=0}
  -e[^-1] "Draw spline from ($1,$2) [$3,$4] to ($5,$6) [$7,$8] on image$?, with $9 vertices, opacity $10 and color (${11--1})."
  -v - -repeat @# -l[$>]
    x0={if(@{"-is_percent $1"},$1*(w-1),$1)}
    y0={if(@{"-is_percent $2"},$2*(h-1),$2)}
    u0={if(@{"-is_percent $3"},$3*(w-1),$3)}
    v0={if(@{"-is_percent $4"},$4*(h-1),$4)}
    x1={if(@{"-is_percent $5"},$5*(w-1),$5)}
    y1={if(@{"-is_percent $6"},$6*(h-1),$6)}
    u1={if(@{"-is_percent $7"},$7*(w-1),$7)}
    v1={if(@{"-is_percent $8"},$8*(h-1),$8)}
    -spline3d $x0,$y0,0,$u0,$v0,0,$x1,$y1,0,$u1,$v1,0,$9
    -sh[-1] 8,{8+3*$9-1},0,0 -round[-1] -rm[-1]
    -col3d[1] ${11--1} -j3d[0] [1],0,0,0,$10,1,0,0 -rm[1]
  -endl -done -v +

#@gmic t : eq. to '-text'. : (+)

#@gmic text : text,_x[%],_y[%],_font_height[%]>=0,_opacity,_color1,.. : (+)
#@gmic : Draw specified colored text string on selected images.
#@gmic : (eq. to '-t').
#@gmic : Exact pre-defined sizes are '13','23','53' and '103'. Using these sizes ensures you draw binary letters without anti-aliasing.
#@gmic : Any other font size is interpolated from an exact size (the upper when possible).
#@gmic : Specifying an empty target image resizes it to new dimensions such that the image contains
#@gmic : the entire text string.
#@gmic : Default values: 'opacity=1' and 'color1=0'.
#@gmic : $ image.jpg -resize2dy 600 y=0 -repeat 30 -text {2*$>}" : This is a nice text, isn't it ?",10,$y,{2*$>},0.9,255 y={$y+2*$>} -done
#@gmic : $ 0 -text "G'MIC",0,0,23,1,255

#@gmic text_outline : text,_x[%],_y[%],_font_height>0,_outline>=0,_opacity,_color1,..
#@gmic : Draw specified colored and outlined text string on selected images.
#@gmic : Default values: 'x=y=2', 'font_height=13', 'outline=2', 'opacity=1' and 'color1=255'.
#@gmic : $ image.jpg -text_outline "Hi there!",10,10,63,3
text_outline : -skip ${2=2},${3=2},${4=13},${5=2},${6=1},${7=255}
  -e[^-1] "Draw outlined text '$1' at position ($2,$3) on image$?, with font height $4, outline $5, opacity $6 and color ${7--1}."
  -v - -if $5
    0 -t[-1] "$1",0,0,$4,1,${7--1},1 -expand_xy[-1] {1+$5},0
    -s[-1] c,{-narg(${7--1})} -dilate[-1] {2*$5+1}
    -repeat {@#-2} -l[$>,-2,-1]
      -if @{0,w}
        -if {@{0,s}==@{1,s}} -j[0] [1],$2,$3,0,0,$6,[2]
        -else --r[1] 100%,100%,1,@{0,s},0,1 -j[0] [3],$2,$3,0,0,$6,[2] -rm[3]
        -endif
      -else -rm[0] -i[0] [0] -endif
    -endl -done
    -rm[-2,-1]
  -else -t "$1",${2-4},${6--1}
  -endif -v +

#@gmic triangle_shade : x0,y0,x1,y0,x2,y2,R0,G0,B0,...,R1,G1,B1,...,R2,G2,B2,....
#@gmic : Draw triangle with interpolated colors on selected images.
#@gmic : $ image.jpg -triangle_shade 20,20,400,100,120,200,255,0,0,0,255,0,0,0,255
triangle_shade :
  -e[^-1] "Draw triangle ($1,$2)-($3,$4)-($5,$6) with interpolated colors on image$?."
  -v -
  # Find mapping coefficients for each color.
  -l[] ($1,$2,1;$3,$4,1;$5,$6,1) (${7--1}) -r[-1] {w/3},3,1,1,-1 -s[-1] x -solve[^0] [0] -rm[0] -a c -endl
  -polygon[^-1] 3,${1-6},1,-65535 # Mask images with triangle.
  -repeat {@#-1} -l[$>,-1] -repeat @{0,s}
    a={i(0,0,0,$>)} b={i(0,1,0,$>)} c={i(0,2,0,$>)}
    -sh[0] $>,$> -f[-1] 'if(i==-65535,$a*x+$b*y+$c,i)' -rm[-1]
  -done -endl -done
  -rm[-1] -v +

#@gmic truchet : _scale>0,_radius>=0,_pattern_type={ 0=straight | 1=curved }
#@gmic : Fill selected images with random truchet patterns.
#@gmic : Default values: 'scale=32', 'radius=5' and 'pattern_type=1'.
#@gmic : $ 400,300 -truchet ,
truchet : -check "isint(${1=32}) && $1>0 && ${2=3}>=0" -skip ${3=1}
  -e[^-1] "Render "@{-arg\ 1+!$3,curved,straight}" truchet patterns in image$?, with scale $1 and radius $2."
  -v - -repeat @# -l[$>] nm=@{0,n}
    w={w} h={h} s={s} -rm
    $1,$1 -= 1,0,0 -= 1,100%,100% -distance 1,{1+$3} M={int(iM/2)} # Generate truchet pattern and its mirrored version.
    -ir {$M-$2/2-($1%2)},{$M+$2/2} --mirror y -a x
    {round($w/$1,1,1)},{round($h/$1,1,1)} -rand[-1] 0,1 ->=[-1] 50% -r[-1] {w*$1},{h*$1} -*[-1] $1
    -channels[-1] 0,1 (0,{$1-1}) -r[-1] $1,$1,1,1,3 --transpose[-1] -a[-2,-1] c -r[-1] [-2],0,2 -+[-2,-1]
    -warp[-2] [-1] -rm[-1] ->= 50% -r $w,$h,1,1,0 -r 100%,100%,1,$s
  -nm $nm,1 -endl -done -v +

#@gmic turbulence : _radius>0,_octaves={1,2,3...,12},_alpha>0,_difference={-10,10},_mode={0,1,2,3}
#@gmic : Render fractal noise or turbulence on selected images.
#@gmic : Default values: 'radius=32', 'octaves=6', 'alpha=3', 'difference=0' and 'mode=0'.
#@gmic : $ 400,400,1,3 -turbulence 16
#@gmic : $$
turbulence : -check "${1=32}>0 && ${2=6}>0" -skip ${3=3},${4=0},${5=0}
  -e[^-1] "Render fractal noise or turbulence on image$?, with radius $1, octaves $2, damping per octave $3, difference $4 and mode $5."
  -v - -repeat @# -l[$>] nm=@{0,n}
    -if {$4} [-1] -endif
    -f[-1] 0 --noise[-1] 10,0 -b[-1] $1,0
    -if {$5==0||$5==1} --[-1] @{-1,a} -abs[-1]
    -elif {$5==3||$5==4} -^[-1] 2
    -elif {$5==5} -^[-1] 3
    -endif
    -repeat {$2-1}
      --noise[-2] 10,0 -b[-1] {$1/2^$>},0
      -if {$5==0} --[-1] @{-1,a} -abs[-1]
      -elif {$5==4} -^[-1] 2
      -elif {$5==5} -^[-1] 3
      -endif
      -*[-2] $3 -+[-2--1]
    -done
    -n[-1] 0,255
    -rm[-2]
    -if {$4} -*[-1] $4 -mv[-2] 2 -- -n[-1] 0,255 -endif
  -nm $nm,1 -endl -done -v +

#@gmic yinyang
#@gmic : Draw a yin-yang symbol on selected images.
#@gmic : $ 400,400 -yinyang
yinyang :
  -e[^-1] "Draw yin-yang symbol on image$?."
  -v - -f 0 -repeat @# -l[$>]
    s={s} -channels 0
    r={round(0.95*min(w,h)/4)}
    --line 50%,0,50%,50%,1,2 -ellipse[-1] 50%,{h/2-$r},$r,$r,0,1,2
    -line[-1] 50%,50%,50%,100%,1,1 -ellipse[-1] 50%,{h/2+$r},$r,$r,0,1,1
    -flood[-1] {w/2-$r},50%,0,0,0,1,2
    -flood[-1] {w/2+$r},50%,0,0,0,1,1
    -ellipse[-2] 50%,50%,{2*$r},{2*$r},0,1,1
    -*
    -ellipse[-1] 50%,{h/2-$r},{$r/3},{$r/3},0,1,1
    -ellipse[-1] 50%,{h/2+$r},{$r/3},{$r/3},0,1,2
    -r 100%,100%,1,$s
  -endl -done -v +

#---------------------------------
#
#@gmic :: Matrix computation
#
#---------------------------------

#@gmic dijkstra : starting_node>=0,ending_node>=0 : (+)
#@gmic : Compute minimal distances and pathes from specified adjacency matrices by the Dijkstra algorithm.

#@gmic eigen : (+)
#@gmic : Compute the eigenvalues and eigenvectors of selected symmetric matrices or matrix fields.
#@gmic : If one selected image has 3 or 6 channels, it is regarded as a field of 2x2 or 3x3 symmetric matrices,
#@gmic : whose eigen elements are computed at each point of the field.
#@gmic : $ (1,0,0;0,2,0;0,0,3) --eigen
#@gmic : $ image.jpg -structuretensors -blur 2 -eigen -split[0] c
#@gmic : $$

#@gmic invert : (+)
#@gmic : Compute the inverse of the selected matrices.
#@gmic : $ (0,1,0;0,0,1;1,0,0) --invert

#@gmic solve : [image] : (+)
#@gmic : Solve linear system AX = B for selected B-vectors and specified A-matrix.
#@gmic : If the system is under- or over-determined, least square solution is returned.
#@gmic : $ (0,1,0;1,0,0;0,0,1) (1;2;3) --solve[-1] [-2]

#@gmic svd : (+)
#@gmic : Compute SVD decomposition of selected matrices.
#@gmic : $ 10,10,1,1,'if(x==y,x+?(-0.2,0.2),0)' --svd

#@gmic transpose
#@gmic : Transpose selected matrices.
#@gmic : $ image.jpg --transpose
transpose :
  -e[^-1] "Transpose image$?."
  -v - -permute yxzc -v +

#@gmic trisolve : [image] : (+)
#@gmic : Solve tridiagonal system AX = B for selected B-vectors and specified tridiagonal A-matrix.
#@gmic : Tridiagonal matrix must be stored as a 3 column vector, where 2nd column contains the
#@gmic : diagonal coefficients, while 1st and 3rd columns contain the left and right coefficients.
#@gmic : $ (0,0,1;1,0,0;0,1,0) (1;2;3) --trisolve[-1] [-2]

#---------------------------------
#
#@gmic :: 3d rendering
#
#---------------------------------

#@gmic +3d : eq. to '-add3d'. : (+)

#@gmic add3d : tx,_ty,_tz : [object3d] : (no arg) : (+)
#@gmic : Shift selected 3d objects with specified displacement vector, or merge them with specified
#@gmic : 3d object, or merge all selected 3d objects together.
#@gmic : (eq. to '-+3d').
#@gmic : Default values: 'ty=tz=0'.
#@gmic : $ -sphere3d 10 -repeat 5 --add3d[-1] 10,{?(-10,10)},0 -color3d[-1] @{-RGB} -done -add3d
#@gmic : $ -repeat 20 -torus3d 15,2 -color3d[-1] @{-RGB} -mul3d[-1] 0.5,1 -if {$>%2} -rotate3d[-1] 0,1,0,90 -endif -add3d[-1] 70 -add3d -rotate3d[-1] 0,0,1,18 -done -double3d 0

#@gmic animate3d : _width>0,_height>0,_angle_dx,_angle_dy,_angle_dz,_zoom_factor>=0,_filename
#@gmic : Animate selected 3d objects in a window.
#@gmic : If argument 'filename' is provided, each frame of the animation is saved as a numbered filename.
#@gmic : Default values: 'width=640', 'height=480', 'angle_dx=0', 'angle_dy=1', 'angle_dz=0', 'zoom_factor=1' and 'filename=(undefined)'.
animate3d : -skip ${1=640},${2=480},${3=0},${4=1},${5=0},"${7=""}" -check ${6=1}>=0
  -e[^-1] "Animate 3d object$?, in a $1x$2 window with angle velocities ($3,$4,$5)."
  -v - is_multi={@#>1} -repeat @# --l[$>]
    -n3d -*3d {$6*min($1,$2)/1.5} -c3d
    ax=0 ay=0 az=0 frame=0
    -do
       --r3d 1,0,0,$ax -r3d[-1] 0,1,0,$ay -r3d[-1] 0,0,1,$az
       ax={$ax+$3} ay={$ay+$4} az={$az+$5}
       $1,$2,1,3,-1 -j3d[-1] [-2],50%,50%,0,1
       -if {narg("$7")}
         -to_rgba[-1] -replace_color[-1] 0,0,-1,-1,-1,255,64,64,64,0
         -if $is_multi filename=@{-filename\ "$7",$>,$frame} -else filename=@{-filename\ "$7",$frame} -endif
         -o[-1] $filename frame={$frame+1}
       -else
         -replace[-1] -1,64
       -endif
       -w[-1] {w},{h},0,0,-1,-1,@{0,n} -wait 20 -k[0]
    -while {@!" && "!@{!,ESC}" && "!@{!,Q}} -rm -w 0
  -endl -done -v +

#@gmic apply_camera3d : pos_x,pos_y,pos_z,target_x,target_y,target_z,up_x,up_y,up_z
#@gmic : Apply 3d camera matrix to selected 3d objects.
#@gmic : Default values: 'target_x=0', 'target_y=0', 'target_z=0', 'up_x=0', 'up_y=-1' and 'up_z=0'.
apply_camera3d : -skip ${4=0},${5=0},${6=0},${7=0},${8=-1},${9=0}
  -e[^-1] "Apply 3d camera matrix to 3d object$?, with camera position ($1,$2,$3), target position ($4,$5,$6) and up-vector ($7,$8,$9)."
  -v -
  ({$4-$1}^{$5-$2}^{$6-$3})  # f.
  ($7^$8^$9)                 # up.
  -orientation[-2,-1]        # f/|f| and up/|up|.
  -_cross3d @-2,@-1          # s = f x up
  -_cross3d @-1,@-3          # u = s x f
  -rm[-3] -y[-3--1] x -mv[-2,-1] -3
  -a[-3--1] y -z[-1] 0,3  # Rotation matrix R.
  --3d[^-1] $1,$2,$3 -pose3d[^-1] @-1 -rm[-1] --3d 0,0,800
  -v +

_cross3d :
  ({$2*$6-$3*$5}^{$3*$4-$1*$6}^{$1*$5-$2*$4}) -orientation[-1] -y[-1]

#@gmic array3d : size_x>=1,_size_y>=1,_size_z>=1,_offset_x[%],_offset_y[%],_offset_y[%]
#@gmic : Duplicate a 3d object along the X,Y and Z axes.
#@gmic : Default values: 'size_y=1', 'size_z=1' and 'offset_x=offset_y=offset_z=100%'.
#@gmic : $ -torus3d 10,1 --array3d 5,5,5,110%,110%,300%
array3d : -check "isint($1) && $1>0 && isint(${2=1}) && $2>0 && isint(${3=1}) && $3>0" -skip ${4=100%},${5=100%},${6=100%}
  -e[^-1] "Duplicate 3d object$? along X,Y,Z axes with factors ($1,$2,$3) and offsets ($4,$5,$6)."
  -v - -repeat @# -l[$>]

    # Retrieve object dimensions.
    --rows 8,{8+3*i[6]} -r[-1] 3,{h/3},1,1,-1 -s[-1] x,3
    dx=@{-3,if(@{-is_percent\ $4},$4*(iM-im),$4)}
    dy=@{-2,if(@{-is_percent\ $5},$5*(iM-im),$5)}
    dz=@{-1,if(@{-is_percent\ $6},$6*(iM-im),$6)}
    -rm[-3--1]

    # Duplicate along X.
    off=0 -repeat {int(log2($1))}
      --+3d[-1] {2^$>*$dx} -+3d[-1] [-2]
      -if {!($1&(2^$>))} -rm[-2] -else -+3d[-2] $off off={$off+2^$>*$dx} -endif
    -done -+3d[-1] $off -+3d

    # Duplicate along Y.
    off=0 -repeat {int(log2($2))}
      --+3d[-1] 0,{2^$>*$dy} -+3d[-1] [-2]
      -if {!($2&(2^$>))} -rm[-2] -else -+3d[-2] 0,$off off={$off+2^$>*$dy} -endif
    -done -+3d[-1] 0,$off -+3d

    # Duplicate along Z.
    off=0 -repeat {int(log2($3))}
      --+3d[-1] 0,0,{2^$>*$dz} -+3d[-1] [-2]
      -if {!($3&(2^$>))} -rm[-2] -else -+3d[-2] 0,0,$off off={$off+2^$>*$dz} -endif
    -done -+3d[-1] 0,0,$off -+3d
  -endl -done -v +

#@gmic arrow3d : x0,y0,z0,x1,y1,z1,_radius[%]>=0,_head_length[%]>=0,_head_radius[%]>=0
#@gmic : Input 3d arrow with specified starting and ending 3d points.
#@gmic : Default values: 'radius=5%', 'head_length=25%' and 'head_radius=15%'.
#@gmic : $ -repeat 10 a={$>*2*pi/10} -arrow3d 0,0,0,{cos($a)},{sin($a)},-0.5 -done -+3d
arrow3d : -check "${7=5%}>=0 && ${8=25%}>=0 && ${9=15%}>=0"
  -e[^-1] "Input 3d arrow, from (${1-3}) to (${4-6}), with radius $7, head length $8 and head radius $9."
  -v -

  # Create 3d object.
  L={sqrt(($4-$1)^2+($5-$2)^2+($6-$3)^2)}
  R={if(@{-is_percent\ $7},$7*$L,$7)}
  l={if(@{-is_percent\ $8},$8*$L,$8)}
  r={if(@{-is_percent\ $9},$9*$L,$9)}
  L={$L-$l} -cylinder3d $R,$L -cone3d $r,$l -+3d[-1] 0,0,$L -+3d[-2,-1]

  # Compute rotation matrix for arrow orientation.
  ({$4-$1}^{$5-$2}^{$6-$3}) (0.01^-0.02^0.03) -orientation[-2,-1]
  -_cross3d @-2,@-1 -_cross3d @-1,@-3 -rm[-3] -y[-3--1] x -mv[-2,-1] -3
  -a[-3--1] y

  # Rotate and translate the arrow at specified coordinates.
  -s3d[-2] -r[-5] 3,@{-5,h/3},1,1,-1 -**[-5,-1]
  -y[-4] -a[-6--1] y -+3d[-1] ${1-3} -rv3d[-1]
  -v +

#@gmic axes3d : _size_x,_size_y,_size_z,_font_size>0,_label_x,_label_y,_label_z
#@gmic : Input 3d axes with specified sizes along the x,y and z orientations.
#@gmic : Default values: 'size_x=size_y=size_z=1', 'font_size=23', 'label_x=X', 'label_y=Y' and 'label_z=Z'.
#@gmic : $ -axes3d ,
axes3d : -check ${4=23}>0 -skip ${1=1},${2=$1},${3=$2},"${5=X},${6=Y},${7=Z}"
  -e[^-1] "Input 3d axes with sizes ($1,$2,$3)."
  -v - -l[]
  m={max(abs($1),abs($2),abs($3))/40} m2={2*$m} m3={1.2*$m2}
  -_axes3d "O",$4 --3d[-1] $m3,$m3,$m3
  -if $1
    -line3d 0,0,0,$1,0,0
    -cone3d $m,{2*$m},16 -r3d[-1] 0,1,0,-90 -+3d[-1] {$1-$m2},0,0
    -_axes3d "$5",$4 -+3d[-1] {$1+$m3},0,0
  -endif
  -if $2
    -line3d 0,0,0,0,$2,0
    -cone3d $m,{2*$m},16 -r3d[-1] 1,0,0,90 -+3d[-1] 0,{$2-$m2},0
    -_axes3d "$6",$4 -+3d[-1] 0,{$2+$m3},0
  -endif
  -if $3
    -line3d 0,0,0,0,0,$3
    -cone3d $m,{2*$m},16 -+3d[-1] 0,0,{$3-$m2}
    -_axes3d "$7",$4 -+3d[-1] 0,0,{$3+$m3}
  -endif
  -+3d -nm [3d\ axes]
  -endl -v +

_axes3d :
  0 -t[-1] "$1",2,0,$2,1,1 --dilate[-1] 3 -*[-2] 255 -r[-2] 100%,100%,1,3
  -i[-3] (67.5;73.5;109.5;103.5;51.5;100.5;1;1;0;0;0;1;0;-128;{w};{h};3)
  -i[-2] (-128;{w};{h};1) -y[-3,-1] -a[-4--1] y

#@gmic box3d : _size_x,_size_y,_size_z
#@gmic : Input 3d box at (0,0,0), with specified geometry.
#@gmic : Default values: 'size_x=1' and 'size_z=size_y=size_x'.
#@gmic : $ -box3d 100,40,30 --primitives3d 1 -color3d[-2] @{-RGB}
box3d : -skip ${1=1},${2=$1},${3=$2}
  -e[^-1] "Input 3d box, with size ($1,$2,$3)."
  -v -
  1,86,1,1,\
  67.5,73.5,109.5,103.5,51.5,100.5,8,6,\
  0,0,0,$1,0,0,$1,$2,0,0,$2,0,\
  0,0,$3,$1,0,$3,$1,$2,$3,0,$2,$3,\
  4,0,3,2,1,4,4,5,6,7,4,0,1,5,4,4,3,7,6,2,4,0,4,7,3,4,1,2,6,5,\
  200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,\
  1,1,1,1,1,1
  -nm[-1] [3d\ box]
  -v +

#@gmic c3d : eq. to '-center3d'.
c3d :
  -_center3d

#@gmic center3d
#@gmic : Center selected 3d objects at (0,0,0).
#@gmic : (eq. to '-c3d').
#@gmic : $ -repeat 100 -circle3d {?(100)},{?(100)},{?(100)},2 -done -add3d -color3d[-1] 255,0,0 --center3d -color3d[-1] 0,255,0 -add3d
center3d :
  -_$0

_center3d :
  -e[0--3] "Center 3d object$?."
  -v - -check3d 0 -repeat @# -l[$>]
    -if {i[6]}
      -s3d -r[2] 3,@{2,h/3},1,1,-1 -s[2] x
      --[2] @{2,(iM+im)/2} --[3] @{3,(iM+im)/2} --[4] @{4,(iM+im)/2}
      -a[2-4] x -y[2] -a y
    -endif
  -endl -done -v +

#@gmic circle3d : _x0,_y0,_z0,_radius>=0
#@gmic : Input 3d circle at specified coordinates.
#@gmic : Default values: 'x0=y0=z0=0' and 'radius=1'.
#@gmic : $ -repeat 500 a={$>*pi/250} -circle3d {cos(3*$a)},{sin(2*$a)},0,{$a/50} -color3d[-1] @{-RGB},0.4 -done -add3d
circle3d : -skip ${1=0},${2=0},${3=0},${4=1}
  -e[^-1] "Input 3d circle at position ($1,$2,$3) with radius $4."
  -v -
  r={$4/sqrt(3)}
  1,24,1,1,\
  67.5,73.5,109.5,103.5,51.5,100.5,2,1,\
  {$1-$r},{$2-$r},{$3-$r},\
  {$1+$r},{$2+$r},{$3+$r},\
  5,0,1,0,0,0,200,200,200,1
  -nm[-1] [3d\ circle]
  -v +

#@gmic circles3d : _radius>=0,_is_filled={ 0 | 1 }
#@gmic : Convert specified 3d objects to sets of 3d circles with specified radius.
#@gmic : Default values: 'radius=1' and 'is_filled=1'.
#@gmic : $ image.jpg -luminance -resize2dy 40 -threshold 50% -* 255 -pointcloud3d -color3d[-1] 255,255,255 -circles3d 0.7
circles3d : -check ${1=1}>=0 -skip ${2=1}
  -e[^-1] "Convert 3d object$? to sets of 3d "@{-arg\ 1+$2,wireframe,filled}" circles with radius $1."
  -v - -p3d 0 -repeat @# -l[$>]
    nbv=@{-1,6} nbp=@{-1,7}
    -if {$nbv&&$nbp}
      --3d {$1/2},0,0 --+3d $1,0,0 -+3d nbp2=@{-1,7}
      -s3d -=[1] $nbp,0,1
      -r[3] 2,$nbp2,1,1,-1 -columns[3] 1,1 -s[3] y,2 -i[3] 1,$nbp,1,1,5
      -i[6] 1,$nbp,1,1,{!$2} -a[3-6] x -columns[3] 0,5
      -y[3]
      -rows[4] 0,{3*$nbp-1} -rows[5] 0,{$nbp-1} -a y
    -endif
  -endl -done -v +

#@gmic col3d : eq. to '-color3d'. : (+)

#@gmic color3d : R,_G,_B,_opacity : (+)
#@gmic : Set color and opacity of selected 3d objects.
#@gmic : (eq. to '-col3d').
#@gmic : Default value: 'B=G=R' and 'opacity=(undefined)'.
#@gmic : $ -torus3d 100,10 -double3d 0 -repeat 7 --rotate3d[-1] 1,0,0,20 -color3d[-1] @{-RGB} -done -add3d

#@gmic colorcube3d
#@gmic : Input 3d color cube.
#@gmic : $ -colorcube3d -mode3d 2 --primitives3d 1
colorcube3d :
  -e[^-1] "Input 3d RGB-color cube."
  -v -
  (67.5;73.5;109.5;103.5;51.5;100.5;8;6)
  (0;0;0;\
   255;0;0;\
   255;255;0;\
   0;255;0;\
   0;0;255;\
   255;0;255;\
   255;255;255;\
   0;255;255)
  (12;0;3;2;1;0;0;0;63;63;63;63;0;\
   12;1;2;6;5;0;0;0;63;63;63;63;0;\
   12;0;4;7;3;0;0;63;0;63;63;0;63;\
   12;4;5;6;7;0;0;63;0;63;63;0;63;\
   12;0;1;5;4;0;0;63;0;63;63;0;63;\
   12;3;7;6;2;0;0;0;63;63;63;63;0)
  (0,255;0,255^0,0;255,255^0,0;0,0)
  (255,255;255,255^0,0;255,255^0,255;0,255)
  (0,0;0,0^0,0;255,255^0,255;0,255)
  (0,255;0,255^0,0;255,255^255,255;255,255)
  (0,255;0,255^0,0;0,0^0,0;255,255)
  (0,255;0,255^255,255;255,255^0,0;255,255)
  -r[-6--1] 64,64,1,3,3 -y[-6--1] -i[-7--2] (-128;64;64;3)
  (1;1;1;1;1;1)
  -a[-16--1] y -nm[-1] [3d\ colorcube]
  -v +

#@gmic cone3d : _radius,_height,_nb_subdivisions>0
#@gmic : Input 3d cone at (0,0,0), with specified geometry.
#@gmic : Default value: 'radius=1','height=1' and 'nb_subdivisions=24'.
#@gmic : $ -cone3d 10,40 --primitives3d 1 -color3d[-2] @{-RGB}
cone3d : -check ${3=24}>0 -skip ${1=1},${2=1}
  -e[^-1] "Input 3d cone, with radius $1, height $2 and $3 subdivisions."
  -v -
  # Header.
  (67.5;73.5;109.5;103.5;51.5;100.5)
  ({$3+2};{2*$3})

  # Vertices.
  (0,0,0;0,0,$2)
  (0;{2*pi}) -r[-1] 1,{$3+1},1,1,3 -rows[-1] 0,{$3-1} --sin[-1] -cos[-2] -*[-2,-1] $1 -a[-2,-1] x -z[-1] 0,2 -a[-2,-1] y

  # Primitives.
  1,$3,1,1,'y' --shift[-1] 0,-1 -+[-2,-1] 2
  2,$3,1,1,3,0 [-2] [-4] -a[-3--1] x
  -i[-4] 2,$3,1,1,3,1 -a[-4--2] x
  -a[-2,-1] y

  # Colors / opacities.
  3,{h},1,1,200
  1,{h},1,1,1
  -y[-4--2] -a[-6--1] y -nm[-1] [3d\ cone]
  -v +

#@gmic cubes3d : _size>=0
#@gmic : Convert specified 3d objects to sets of 3d cubes with specified size.
#@gmic : Default value: 'size=1'.
#@gmic : $ image.jpg -luminance -resize2dy 40 -threshold 50% -* 255 -pointcloud3d -color3d[-1] 255,255,255 -cubes3d 1
cubes3d : -check ${1=1}>=0
  -e[^-1] "Convert 3d object$? to sets of 3d cubes with size $1."
  -v - -p3d 0 -repeat @# -l[$>]
    nbv=@{-1,6} nbp=@{-1,7}
    -if {$nbv&&$nbp}
      -s3d
      -l[1] -= {8*i[0]} -= {6*i[1]},0,1 -endl  # Header.
      -l[2] -r 3,{h/3},1,1,-1                  # Vertices.
      half={$1/2}
      -- '$half,0,0' --+ '$1,0,0' -a x
      -- '0,$half,0' --+ '0,$1,0' -a x
      -- '0,0,$half' --+ '0,0,$1' -a x
      -endl
      -l[3] -r 2,{h/2},1,1,-1                  # Primitives.
      -z 1,1 -* 8 -r 4,100% -i[0] 1,100%,1,1,4 -a x [-1]x5 -a x
      -+ '"0,0,2,3,1, 0,4,5,7,6, 0,0,1,5,4, 0,2,6,7,3, 0,0,4,6,2, 0,1,3,7,5"'
      -endl
      -l[4] -r 3,{h/3},1,1,-1 -r 18,100%,1,1,0,2 -endl -r[5] 6,100% # Colors & opacities.
      -y -a y
    -endif
  -endl -done -v +

#@gmic cup3d : _resolution>0
#@gmic : Input 3d cup object.
#@gmic : $ -cup3d ,
cup3d : -check ${1=128}>0
  -e[^-1] "Input 3d cup, with resolution $1."
  -v -
  100,200
  -ellipse[-1] 0%,0%,40%,40%,0,1,1
  -ellipse[-1] 0,0,35%,35%,0,1,0
  -polygon[-1] 4,0,45%,8%,45%,20%,90%,0,90%,1,1
  -ellipse[-1] 0%,100%,30%,10%,0,1,1 -b[-1] 0.1%
  -lathe3d[-1] $1,2 -nm[-1] [3d\ cup]
  -v +

#@gmic cylinder3d : _radius,_height,_nb_subdivisions>0
#@gmic : Input 3d cylinder at (0,0,0), with specified geometry.
#@gmic : Default value: 'radius=1','height=1' and 'nb_subdivisions=24'.
#@gmic : $ -cylinder3d 10,40 --primitives3d 1 -color3d[-2] @{-RGB}
cylinder3d : -check ${3=24}>0 -skip ${1=1},${2=1}
  -e[^-1] "Input 3d cylinder, with radius $1, height $2 and $3 subdivisions."
  -v -
  # Header.
  (67.5;73.5;109.5;103.5;51.5;100.5)
  ({2*$3+2};{3*$3})

  # Vertices.
  (0,0,0;0,0,$2)
  (0;{2*pi}) -r[-1] 1,{$3+1},1,1,3 -rows[-1] 0,{$3-1} --sin[-1] -cos[-2] -*[-2,-1] $1 -a[-2,-1] x
  --z[-1] 0,2 1,$3,1,1,$2 -a[-3,-1] x
  -a[-3--1] y

  # Primitives.
  1,$3,1,1,'y' --shift[-1] 0,-1 -+[-2,-1] 2
  2,$3,1,1,3,1 [-3] [-3] -a[-3--1] x
  2,$3,1,1,3,0 [-3] [-5] -+[-2,-1] $3 -a[-3--1] x
  --+[-4,-3] $3 -i[-7] 1,$3,1,1,4 -rv[-6,-5] -a[-7--5,-2,-1] x

  # Colors / opacities.
  3,{3*$3},1,1,200
  1,{h},1,1,1
  -y[-6--2] -a[-8--1] y -nm[-1] [3d\ cylinder]
  -v +

#@gmic delaunay3d
#@gmic : Generate 3d delaunay triangulations from selected images.
#@gmic : One assumes that the selected input images are binary images containing the set of points to mesh.
#@gmic : The output 3d object is a mesh composed of non-oriented triangles.
#@gmic : $ 500,500 -noise 0.05,2 -* 255 --delaunay3d -color3d[1] 255,128,0 -dilate_circ[0] 5 -to_rgb[0] --object3d[0] [1],0,0,0,1,1 -max[-1] [0]
delaunay3d :
  -e[^-1] "Generate 3d delaunay triangulation from image$?."
  -v - -repeat @# -l[$>]
    -channels 0 -neq 0

    # Label each point separatly
    whd={w},{h},{d} --r 1,{w*h*d},1,1,-1 -cumulate[-1] -*[-1] [-2] -r[-1] $whd,1,-1

    # Compute voronoi diagram of point cloud.
    --distance[0] 1 -*[2] -1 -watershed[1] [2] -rm[2]

    # Get redondant set of delaunay triangles from the voronoi diagram.
    -r[1] 100%,100%,100%,3
    -if {d>1} # Add detection cases for 3d images.
      --_delaunay3d[1] 1,0,0,0,0,1 --_delaunay3d[1] -1,0,0,0,0,-1
      --_delaunay3d[1] 0,1,0,0,0,1 --_delaunay3d[1] 0,-1,0,0,0,-1
    -endif
    --_delaunay3d[1] 1,0,0,0,1,0 -_delaunay3d[1] -1,0,0,0,-1,0 # 2d detection.
    -a[^0] x -transpose[-1] --[-1] 1

    # Build 3d mesh.
    -pointcloud3d[0]
    -s3d[0] -rm[3-5] -i[-2] 1,100%,1,1,3 -a[-2,-1] x
    3,100%,1,1,200 1,100%,1,1,1 -=[1] {h},0,1 -y -a y
  -endl -done -v +

_delaunay3d :
  -f[-1] "A=j($1,$2,$3,0,0,1); B=j($4,$5,$6,0,0,1);
          if (i!=A && i!=B && A!=B, kth(1+c,i,A,B),0)"
    -discard[-1] 0 -r[-1] {h/3},3,1,1,-1

#@gmic distribution3d
#@gmic : Get 3d color distribution of selected images.
#@gmic : $ image.jpg -distribution3d -colorcube3d -primitives3d[-1] 1 -add3d
distribution3d :
  -e[^-1] "Get 3d color distribution of image$?."
  -v - -to_rgb -permute "cxyz" -y
  -repeat @# -l[$>]
    nbp={round(h/3)}
    -i[-2] (67.5;73.5;109.5;103.5;51.5;100.5;\               # Magick number for CImg3d.
            $nbp;$nbp)                                       # Number of vertices and primitives.
    1,$nbp,1,1,1 --f[-1] y -a[-2,-1] x -y[-1]                # Primitives.
    [-2]                                                     # Colors.
    1,$nbp,1,1,1                                             # Opacities.
    -a y -nm[-1] [3d\ distribution]                          # Build 3d object.
  -endl -done -v +

#@gmic /3d : eq. to '-div3d'. : (+)

#@gmic div3d : factor : factor_x,factor_y,_factor_z : (+)
#@gmic : Scale selected 3d objects isotropically or anisotropically, with the inverse of specified
#@gmic : factors.
#@gmic : (eq. to '-/3d').
#@gmic : Default value: 'factor_z=0'.
#@gmic : $ -torus3d 5,2 -repeat 5 --add3d[-1] 12,0,0 -div3d[-1] 1.2 -color3d[-1] @{-RGB} -done -add3d

#@gmic db3d : eq. to '-double3d'. : (+)

#@gmic double3d : _is_double_sided={ 0 | 1 } : (+)
#@gmic : Enable/disable double-sided mode for 3d rendering.
#@gmic : (eq. to '-db3d').
#@gmic : Default value: 'is_double_sided=1'.
#@gmic : $ -mode3d 1 -repeat 2 -torus3d 100,30 -rotate3d[-1] 1,1,0,60 -double3d $> -snapshot3d[-1] 400 -done

#@gmic elevation3d : z-factor : [elevation_map] : 'formula' : (no arg) : (+)
#@gmic : Build 3d elevation of selected images, with a specified elevation map.
#@gmic : When invoked with (no arg) or 'z-factor', the elevation map is computed as the pointwise L2 norm of the
#@gmic : pixel values. Otherwise, the elevation map is taken from the specified image or formula.
#@gmic : $ image.jpg -blur 5 -elevation3d 0.5
#@gmic : $ 128,128,1,3,?(255) -plasma 10,3 -blur 4 -sharpen 10000 -elevation3d[-1] 'X=(x-64)/6;Y=(y-64)/6;100*exp(-(X^2+Y^2)/30)*abs(cos(X)*sin(Y))'

#@gmic empty3d
#@gmic : Input empty 3d object.
#@gmic : $ -empty3d
empty3d :
  -e[^-1] "Input empty 3d object."
  -v - (67.5;73.5;109.5;103.5;51.5;100.5;0;0) -nm[-1] [3d\ empty] -v +

#@gmic extrude3d : _depth>0,_resolution>0,_smoothness[%]>=0
#@gmic : Generate extruded 3d object from selected binary XY-profiles.
#@gmic : Default values: 'depth=16', 'resolution=1024' and 'smoothness=0.5%'.
#@gmic : $ image.jpg -threshold 50% -extrude3d 16
extrude3d : -check "${1=16}>0 && ${2=1024}>0 && ${3=0.5%}>=0"
  -e[^-1] "Generate extruded 3d object from XY-profile$?, with depth $1, resolution $2 and smoothness $3."
  -v - -norm -n 0,1 -autocrop 0 -repeat @# -l[$>] nm=@{0,n}
    wr={round(max(1,if(w>h,min($2,w),min($2,h)*w/h)))}
    hr={round(max(1,if(w>h,min($2,w)*h/w,min($2,h))))}
    fact={$1/max(w/$wr,h/$hr)}
    -b $3,0 -r $wr,$hr,1,1,2 -expand_xyz 1,0
    -isosurface3d 50% -*3d 1,1,$fact -rv3d
  -nm $nm,1 -endl -done -v +

#@gmic f3d : eq. to '-focale3d'. : (+)

#@gmic focale3d : focale : (+)
#@gmic : Set 3d focale.
#@gmic : (eq. to '-f3d').
#@gmic : Set 'focale' to 0 to enable parallel projection (instead of perspective).
#@gmic : Set negative 'focale' will disable 3d sprite zooming.
#@gmic : Default value: 'focale=700'.
#@gmic : $ -repeat 5 -torus3d 100,30 -rotate3d[-1] 1,1,0,60 -focale3d {$<*90} -snapshot3d[-1] 400 -done -remove[0]

#@gmic gaussians3d : _size>0,_opacity
#@gmic : Convert selected 3d objects into set of 3d gaussian-shaped sprites.
#@gmic : $ image.jpg -r2dy 32 -distribution3d -gaussians3d 20 -colorcube3d -primitives3d[-1] 1 -+3d
gaussians3d : -check "${1=32}>0" -skip ${2=0.3}
  -e[^-1] "Convert 3d object$? into sets of gaussian-shaped 3d sprites, with size $1 and opacity $2."
  -v - -p3d 2 -p3d 0 -repeat @# -l[$>] nm=@{0,n} -s3d
    nbv={h} -rm[-1] (-128;$1;$1;1)
    $1,$1 -gaussian[-1] 35%,35%,0 -c[-1] 30%,100% -n[-1] 0,$2 -y[-1] -a[-2,-1] y  # First opacity is generated.
    -if {$nbv>1} 4,{$nbv-1},1,1,-128,0,0,0 -y[-2,-1] -a[-2,-1] y -endif           # Other ones are shared copies of the first one.
    -a y
  -nm $nm,1 -endl -done -v +

#@gmic gmic3d
#@gmic : Input a 3d G'MIC logo.
#@gmic : $ -gmic3d --primitives3d 1
gmic3d :
  -e[^-1] "Input 3d G\47MIC logo."
  -v -
  -text3d G,60,20,2 -col3d[-1] 16,64,255
  -text3d \',60,20,2 -+3d[-1] 40 -col3d[-1] 64,128,255
  -text3d M,60,20,2 -+3d[-1] 50 -col3d[-1] 96,196,255
  -text3d I,60,20,2 -+3d[-1] 90 -col3d[-1] 64,128,255
  -text3d C,60,20,2 -+3d[-1] 100 -col3d[-1] 16,64,255
  -sphere3d 8 -+3d[-1] 102,-3,15 -col3d[-1] 192,128,255
  -+3d[-6--1] -c3d[-1]
  -repeat 30
    -box3d {min(3+@{<,-1}/2,10)} -col3d[-1] {30*$>},{20+80*$>},{10*$>},0.5
    -r3d[-1] 1,1,1,{$>*12}
    -+3d[-1] {80*cos(0.5+1.02*$>*12*pi/180)},{30*sin(0.8+$>*12*pi/180)},{2*$>-60}
  -done
  -+3d[-30--1] -+3d[-1] 0,5,30 -+3d[-2--1] -nm[-1] [3d\ gmic]
  -v +

#@gmic gyroid3d : _resolution>0,_zoom
#@gmic : Input 3d gyroid at (0,0,0), with specified resolution.
#@gmic : Default values: 'resolution=32' and 'zoom=5'.
#@gmic : $ -gyroid3d 48 --primitives3d 1
gyroid3d : -check ${1=32}>0 -skip ${2=5}
  -e[^-1] "Input 3d gyroid, with resolution $1 and range $2."
  -v -
  -isosurface3d "'0.49*(\
    cos( 2*x + y + z - pi) + cos( 2*x - y + z - pi)\
    + cos(- 2*x + y - z - pi) + cos(- 2*x - y - z - pi)\
    + cos( x + 2*y + z - pi) + cos( x + 2*y - z - pi)\
    + cos(- x - 2*y + z - pi) + cos(- x - 2*y - z - pi)\
    + cos( x + y + 2*z - pi) + cos(- x + y + 2*z - pi)\
    + cos( x - y - 2*z - pi) + cos(- x - y - 2*z - pi)\
    + cos(- 2*x + y + z) + cos( 2*x + y - z)\
    + cos(- 2*x - y + z) + cos( 2*x - y - z)\
    + cos(- x + 2*y + z) + cos( x - 2*y + z)\
    + cos(- x + 2*y - z) + cos( x - 2*y - z)\
    + cos( x - y + 2*z) + cos( x + y - 2*z)\
    + cos(- x - y + 2*z) + cos(- x + y - 2*z)\
    ) + 0.27*( \
    cos(- 2*x + 2*y - pi) + cos( 2*x - 2*y - pi)\
    + cos( 2*x + 2*y - pi) + cos(- 2*x - 2*y - pi)\
    + cos(- 2*y + 2*z - pi) + cos( 2*y - 2*z - pi)\
    + cos( 2*y + 2*z - pi) + cos(- 2*y - 2*z - pi)\
    + cos(- 2*z + 2*x - pi) + cos( 2*z - 2*x - pi)\
    + cos( 2*z + 2*x - pi) + cos(- 2*z - 2*x - pi)\
    ) - 0.69'",0,{-$2},{-$2},{-$2},$2,$2,$2,$1,$1,$1
  -c3d[-1] -n3d[-1] -nm[-1] [3d\ gyroid]
  -v +

#@gmic histogram3d
#@gmic : Get 3d color histogram of selected images.
#@gmic : $ image.jpg -histogram3d -colorcube3d -primitives3d[-1] 1 -add3d
histogram3d :
  -e[^-1] "Get 3d color histogram of image$?."
  -v - -to_rgb -repeat @# -l[$>]
    -r {w*h},3,1,1,-1 -pointcloud 1 -n 0,255 -map 3 -pointcloud3d -nm "[3d histogram]"
  -endl -done -v +

#@gmic image6cube3d
#@gmic : Generate 3d mapped cubes from 6-sets of selected images.
#@gmic : $ image.jpg -animate flower,"30,0","30,5",6 -image6cube3d
image6cube3d :
  -e[^-1] "Generate 3d mapped cubes from image$?."
  -v - M={max(@{-max_wh})} -r $M,$M,1,3 -imageplane3d -n3d -c3d -repeat {int(@#/6)}
    -+3d[-6] 0,0,-0.5
    -r3d[-5] 1,0,0,180 -+3d[-5] 0,0,0.5
    -r3d[-4] 0,1,0,-90 -+3d[-4] -0.5,0,0
    -r3d[-3] 0,1,0,90 -+3d[-3] 0.5,0,0
    -r3d[-2] 1,0,0,90 -+3d[-2] 0,-0.5,0
    -r3d[-1] 1,0,0,-90 -+3d[-1] 0,0.5,0
    -+3d[-6--1] -nm[-1] "[3d image cube]"
  -mv[-1] 0 -done -v +

#@gmic imageblocks3d : _maximum_elevation,_smoothness[%]>=0
#@gmic : Generate 3d blocks from selected images.
#@gmic : Transparency of selected images is taken into account.
#@gmic : Default values: 'maximum_elevation=10' and 'smoothness=0'.
#@gmic : $ image.jpg -resize2dy 32 -imageblocks3d -20 -m3d 3
imageblocks3d : -check ${2=0}>=0 -skip ${1=10},${3=0}
  -e[^-1] "Generate 3d blocks from image$?, with maximum elevation $1 and smoothness $2."
  -v - -repeat @# -l[$>]
    w={w} h={h}
    -split_opacity -to_rgb[0] is_opacity={@#==2}

    # Create 3d object template.
    -l[] -box3d 1,1,0
    -repeat {$w-1} --+3d[-1] 1,0,0 -done -+3d
    -repeat {$h-1} --+3d[-1] 0,1,0 -done -+3d
    -endl
    -s3d[-1]

    # Set vertex altitudes.
    --norm[0] -b[-1] $2
    -y[-1] -n[-1] 0,$1
    -r[-5] 24,@{-5,round(w*h/24)},1,1,-1
    -if {$1<0} -j[-5] [-1],2 -j[-5] [-1],5 -j[-5] [-1],8 -j[-5] [-1],11
    -else -j[-5] [-1],14 -j[-5] [-1],17 -j[-5] [-1],20 -j[-5] [-1],23
    -endif
    -rm[-1] -y[-4]

    # Set primitive colors.
    -rm[-2] -r[0] @{0,w*h},1,1,100%,-1 -permute[0] cxyz -r[0] 600%,100%,1,1,0,2 -y[0] -mv[0] -1

    # Set primitive opacities.
    -if $is_opacity -rm[-1] -mv[0] @# -/[-1] 255 -y[-1] -r[-1] 6,100%,1,1 -y[-1] -endif

    -a y
  -endl -done -v +

#@gmic imagecube3d
#@gmic : Generate 3d mapped cubes from selected images.
#@gmic : $ image.jpg -imagecube3d
imagecube3d :
  -e[^-1] "Generate 3d mapped cubes from image$?."
  -v - -slices 50% -to_rgb -repeat @# -l[$>] nm=@{0,n}
    -i[-2] (67.5;73.5;109.5;103.5;51.5;100.5;\  # Magick number for CImg3d.
            8;6;\                               # Number of vertices and primitives.
            -0.5;-0.5;-0.5;\                    # Vertex coordinates.
            0.5;-0.5;-0.5;\
            0.5;0.5;-0.5;\
            -0.5;0.5;-0.5;\
            -0.5;-0.5;0.5;\
            0.5;-0.5;0.5;\
            0.5;0.5;0.5;\
            -0.5;0.5;0.5;\
            12;0;3;2;1;0;0;0;{h};{w};{h};{w};0;\    # Primitives description.
            12;1;2;6;5;0;0;0;{h};{w};{h};{w};0;\
            12;5;6;7;4;0;0;0;{h};{w};{h};{w};0;\
            12;4;7;3;0;0;0;0;{h};{w};{h};{w};0;\
            12;4;0;1;5;0;0;0;{h};{w};{h};{w};0;\
            12;3;7;6;2;0;0;0;{h};{w};{h};{w};0;\
            -128;{w};{h};{s})       # Texture map for the first face.
    -y[-1]
    (-128;0;0;0;-128;0;0;0;-128;0;0;0;-128;0;0;0;-128;0;0;0;1;1;1;1;1;1)  # Other faces and opacities.
    -a y
  -nm $nm,1 -endl -done -v +

#@gmic imageplane3d
#@gmic : Generate 3d mapped planes from selected images.
#@gmic : $ image.jpg -imageplane3d
imageplane3d :
  -e[^-1] "Generate 3d mapped planes from image$?."
  -v - -slices 50% -to_color -repeat @# -l[$>] nm=@{0,n}
    -i[-2] (67.5;73.5;109.5;103.5;51.5;100.5;\   # Magick number for CImg3d.
            4;1;\                                # Number of vertices and primitives.
            0;0;0;\                              # Vertex coordinates.
            {w};0;0;\
            {w};{h};0;\
            {0};{h};0;\
            12;0;3;2;1;0;0;0;{h};{w};{h};{w};0;\ # Primitives description.
            -128;{w};{h};{s})                    # Texture map.
    -y[-1]
    (1)  # Opacity.
    -a y
  -nm $nm,1 -endl -done -v +

#@gmic imagepyramid3d
#@gmic : Generate 3d mapped pyramides from selected images.
#@gmic : $ image.jpg -imagepyramid3d
imagepyramid3d :
  -e[^-1] "Generate 3d mapped pyramids from image$?."
  -v - -to_rgb -repeat @# -l[$>] nm=@{0,n}
    w2={w/2}
    -i[-2] (67.5;73.5;109.5;103.5;51.5;100.5;\  # Magick number for CImg3d.
            5;5;\                               # Number of vertices and primitives.
            -0.5;-0.5;-0.5;\                    # Vertex coordinates.
            0.5;-0.5;-0.5;\
            0.5;0.5;-0.5;\
            -0.5;0.5;-0.5;\
            0;0;0.5;\
            12;0;3;2;1;0;0;0;{h};{w};{h};{w};0;\    # Primitives description.
            9;0;4;3;0;{h};$w2;0;{w};{h};\
            9;1;4;0;0;{h};$w2;0;{w};{h};\
            9;2;4;1;0;{h};$w2;0;{w};{h};\
            9;3;4;2;0;{h};$w2;0;{w};{h};\
            -128;{w};{h};{s})                   # Texture map for the first face.
    -y[-1]
    (-128;0;0;0;-128;0;0;0;-128;0;0;0;-128;0;0;0;1;1;1;1;1)  # Other faces and opacities.
    -a y
  -nm $nm,1 -endl -done -v +

#@gmic imagerubik3d : _xy_tiles>=1,0<=xy_shift<=100,0<=z_shift<=100
#@gmic : Generate 3d mapped rubik's cubes from selected images.
#@gmic : Default values: 'xy_tiles=3', 'xy_shift=5' and 'z_shift=5'.
#@gmic : $ image.jpg -imagerubik3d ,
imagerubik3d : -check "${1=3}>=1 && ${2=5}>=0 && $2<=100 && ${3=5}>=0 && $3<=100"
  -e[^-1] "Generate 3d mapped rubik\47s cubes from image$? with $1 xy-tiles, xy-shift $2 and z-shift $3."
  -v - -repeat @# -l[$>] nm=@{0,n}
    # Generate primary 3d side.
    ({'CImg3d'}) -+[-1] 0.5
    (8,5)
    (0,0,0;\
     100,0,0;\
     100,100,0;\
     0,100,0;\
     $2,$2,{-$3};\
     {100-$2},$2,{-$3};\
     {100-$2},{100-$2},{-$3};\
     $2,{100-$2},{-$3})
    (4,4,7,6,5;\
     4,0,4,5,1;\
     4,3,2,6,7;\
     4,0,3,7,4;\
     4,1,5,6,2)
    3,5,1,1,200
    1,5,1,1,1
    -y[-6--1] -a[-6--1] y
    -repeat {$1-1} --+3d[-1] 100 -done -+3d[-$1--1]   # Duplicate along X
    -repeat {$1-1} --+3d[-1] 0,100 -done -+3d[-$1--1] # Duplicate along Y
    -t3d[-1] [-2] -rm[-2]
    -/3d[-1] $1 --3d[-1] 50,50,50
    --r3d[-1] 0,1,0,-90 --r3d[-1] 0,1,0,-90 --r3d[-1] 0,1,0,-90  # Generate the 5 other sides.
    --r3d[-1] 0,0,1,-90 --r3d[-1] 0,0,1,180
    -+3d
  -nm $nm,1 -endl -done -v +

#@gmic imagesphere3d : _resolution1>=3,_resolution2>=3
#@gmic : Generate 3d mapped sphere from selected images.
#@gmic : Default values: 'resolution1=32' and 'resolutions2=16'.
#@gmic : $ image.jpg -imagesphere3d 32,16
imagesphere3d : -check "${1=32}>=3 && ${2=16}>=3"
  -e[^-1] "Generate 3d mapped sphere from image$?, with resolutions ($1,$2)."
  -v - -to_rgb -repeat @# -l[$>] nm=@{0,n}

    # Generate object header.
    tw={w-1} th={h-1}                    # Maximum texture xy-coordinates.
    nbv={2+$1*($2-2)}                    # Number of vertices.
    nbp={$1*($2-1)}                      # Number of primitives.
    (67.5;73.5;109.5;103.5;51.5;100.5;\  # Magick number for CImg3d.
     $nbv;$nbp)                          # Number of vertices and primitives.

    # Define sphere vertices.
    (0;0;1) (0;0;-1) (0,{2*pi};0,{2*pi}^0,0;{pi},{pi})
    -r[-1] {$1+1},$2,1,2,3 -z[-1] 0,1,{w-2},{h-2} -s[-1] c
    --sin[-1] --sin[-3] -*[-2,-1] --cos[-2] -sin[-3] -cos[-4] -*[-4,-3]
    -a[-3--1] c -permute[-1] cxyz -y[-1] -a[-3--1] y

    # Define sphere primitives (triangles and quadrangles).
    -repeat $1
      tx0={$>*$tw/$1} tx1={($>+1)*$tw/$1} ty1={$th/($2-1)}
      (9;0;{2+$>};{2+($>+1)%$1};{$tw/2};0;$tx0;$ty1;$tx1;$ty1) # Textured triangle from 1st pole.
      -repeat {$2-3}
        ty0=$ty1 ty1={($>+2)*$th/($2-1)} i0={2+$>*$1+@{>,-2}} i1={2+$>*$1+(@{>,-2}+1)%$1}
        (12;$i0;{$i0+$1};{$i1+$1};$i1;$tx0;$ty0;$tx0;$ty1;$tx1;$ty1;$tx1;$ty0) # Textured quadrangle.
      -done
      (9;1;{2+$1*($2-3)+($>+1)%$1};{2+$1*($2-3)+$>};{$tw/2};$th;$tx1;$ty1;$tx0;$ty1) # Textured triangle from 2nd pole.
    -done
    -a[-$nbp--1] y

    # Define sphere textures, opacities and generate object.
    -mv[-4] @# -i[-2] (-128;{w};{h};3) -y[-1] 1,{4*($nbp-1)},1,1,-128,0,0,0 1,$nbp,1,1,1 -a y
  -nm $nm,1 -endl -done -v +

#@gmic isoline3d : isovalue[%] : 'formula',value,_x0,_y0,_x1,_y1,_size_x>0[%],_size_y>0[%] : (+)
#@gmic : Extract 3d isolines with specified value from selected images or from specified formula.
#@gmic : Default values: 'x0=y0=-3', 'x1=y1=3' and 'size_x=size_y=256'.
#@gmic : $ image.jpg -blur 1 -isoline3d 50%
#@gmic : $ -isoline3d 'X=x-w/2;Y=y-h/2;(X^2+Y^2)%20',10,-10,-10,10,10

#@gmic isosurface3d : isovalue[%] : 'formula',value,_x0,_y0,_z0,_x1,_y1,_z1,_size_x>0[%],_size_y>0[%],_size_z>0[%] : (+)
#@gmic : Extract 3d isosurfaces with specified value from selected images or from specified formula.
#@gmic : Default values: 'x0=y0=z0=-3', 'x1=y1=z1=3' and 'size_x=size_y=size_z=32'.
#@gmic : $ image.jpg -resize2dy 128 -luminance -threshold 50% -expand_z 2,0 -blur 1 -isosurface3d 50% -mul3d 1,1,30
#@gmic : $ -isosurface3d 'x^2+y^2+abs(z)^abs(4*cos(x*y*z*3))',3

#@gmic label_points3d : _label_size>0,_opacity
#@gmic : Add a numbered label to all vertices of selected 3d objects.
#@gmic : Default values: 'label_size=13' and 'opacity=0.8'.
#@gmic : $ -torus3d 100,40,6,6 -label_points3d 23,1 -mode3d 1
label_points3d : -check ${1=13}>0 -skip ${2=0.8}
  -e[^-1] "Label vertices of 3d object$?."
  -v - -repeat @#
    --p3d[$>] 0 -l[-1] -s3d -rm[-3--1]
    nbp=@{-2,0} -=[-2] $nbp,0,1                                 # Set correct number of primitives
    (1,0;1,{$nbp-1}) -r[-1] 2,$nbp,1,1,3 -r[-1] 1,{2*h},1,1,-1  # Create new primitive data
    -repeat $nbp                                                # Create texture labels as primitive colors.
      0 -t[-1] $>,0,0,$1,1,255,255,255 -autocrop[-1] 0
      -i[-2] (-128;{w};{h};3) -y[-1]
    -done
    -repeat $nbp                                                # Create texture masks as primitive opacities.
      0 -t[-1] $>,0,0,$1,1,$2 -autocrop[-1] 0
      -i[-2] (-128;{w};{h};1) -y[-1]
    -done
    -a y  # Merge final object data.
    -endl
    -+3d[$>,-1]
  -done -v +

#@gmic lathe3d : _resolution>0,_smoothness[%]>=0,_max_angle>=0
#@gmic : Generate 3d object from selected binary XY-profiles.
#@gmic : Default values: 'resolution=128', 'smoothness=0.5%' and 'max_angle=361'.
#@gmic : $ 300,300 -rand -1,1 -blur 40 -sign -normalize 0,255 -lathe3d ,
lathe3d : -check "${1=128}>0 && ${2=0.5%}>=0 && ${3=361}>=0"
  -e[^-1] "Generate lathed 3d object from XY-profile$?, with resolution $1, smoothness $2 and maximum angle $3 deg."
  -v - tmax={($3-180)*pi/180} -norm -n 0,1 -autocrop 0 -repeat @# -l[$>]
    wr={max(1,w2=2*w;if(w2>h,min($1,w2),min($1,h)*w2/h))}
    hr={max(1,w2=2*w;if(w2>h,min($1,w2)*h/w2,min($1,h)))}
    rmax={sqrt(($wr)^2+($hr)^2)/2}
    $wr,1,$wr,1,"xc=x-w/2; zc=z-d/2; t=atan2(zc,xc); if(t>"$tmax","$rmax",sqrt(xc*xc+zc*zc))"
    -*[-1] {2*(@{-2,w}-1)/(w-1)} -r[-1] $wr,$hr,$wr
    (0;{@{-2,h}-1}) -r[-1] $wr,$hr,$wr,1,3 -a[-2--1] c
    -warp[-2] [-1],0,1,0 -rm[-1]
    -expand_xyz 10,0 -b $2 -isosurface3d 50% -rv3d
  -endl -done -v +

#@gmic l3d : eq. to '-light3d'. : (+)

#@gmic light3d : position_x,position_y,position_z : [texture] : (no arg) : (+)
#@gmic : Set the light coordinates or the light texture for 3d rendering.
#@gmic : (eq. to '-l3d').
#@gmic : (no arg) resets the 3d light to default.
#@gmic : $ -torus3d 100,30 -double3d 0 -specs3d 1.2 -repeat 5 -light3d {$>*100},0,-300 --snapshot3d[0] 400 -done -remove[0]

#@gmic line3d : x0,y0,z0,x1,y1,z1
#@gmic : Input 3d line at specified coordinates.
#@gmic : $ -repeat 100 a={$>*pi/50} -line3d 0,0,0,{cos(3*$a)},{sin(2*$a)},0 -color3d[-1] @{-RGB} -done -add3d
line3d :
  -e[^-1] "Input 3d line (${1-3})-(${4-6})."
  -v - 1,21,1,1,67.5,73.5,109.5,103.5,51.5,100.5,2,1,${1-6},2,0,1,200,200,200,1 -nm[-1] [3d\ line] -v +

#@gmic lissajous3d : resolution>1,a,A,b,B,c,C
#@gmic : Input 3d lissajous curves (x(t)=sin(a*t+A*2*pi),y(t)=sin(b*t+B*2*pi),z(t)=sin(c*t+C*2*pi)).
#@gmic : Default values: 'resolution=1024', 'a=2', 'A=0', 'b=1', 'B=0', 'c=0' and 'C=0'.
#@gmic : $ -lissajous3d ,
lissajous3d : -check ${1=1024}>1 -skip ${2=2},${3=0},${4=1},${5=0},${6=0},${7=0}
  -e[^-1] "Input 3d lissajous curve, with resolution $1, (a,A)=($2,$3), (b,B)=($4,$5) and (c,C)=($6,$7)."
  -v -
  res={round($1)}

  # Define object header and vertices.
  (67.5;73.5;109.5;103.5;51.5;100.5;$res;{$res-1})
  (0,{2*pi}) -r[-1] $res,1,1,1,3 [-1]x2
  -*[-3] $2 -+[-3] {$3*2*pi} -*[-2] $4 -+[-2] {$5*2*pi} -*[-1] $6 -+[-1] {$7*2*pi}
  -a[-3--1] y -sin[-1] -transpose[-1] -r[-1] 1,{w*h},1,1,-1

  # Define object primitives, colors and opacities.
  1,{$res-1},1,1,2 (0;{$res-2}) -r[-1] 1,{$res-1},1,1,3 --+[-1] 1 -a[-3--1] x -round[-1] 1 -r[-1] 1,{w*h},1,1,-1
  1,{3*($res-1)},1,1,200 1,{$res-1},1,1,1 -a[-5--1] y -nm[-1] [3d\ lissajou]
  -v +

#@gmic m3d : eq. to '-mode3d'. : (+)

#@gmic mode3d : _mode : (+)
#@gmic : Set static 3d rendering mode.
#@gmic : (eq. to '-m3d').
#@gmic : 'mode' can be { -1=bounding-box | 0=dots | 1=wireframe | 2=flat | 3=flat-shaded | 4=gouraud-shaded | 5=phong-shaded }.");
#@gmic : Bounding-box mode ('mode==-1') is active only for the interactive 3d viewer.
#@gmic : Default value: 'mode=4'.
#@gmic : $ (0,1,2,3,4,5) -double3d 0 -repeat {w} -torus3d 100,30 -rotate3d[-1] 1,1,0,60 -mode3d @{0,$>} -snapshot3d[-1] 300 -done -remove[0]

#@gmic md3d : eq. to '-moded3d'. : (+)

#@gmic moded3d : _mode : (+)
#@gmic : Set dynamic 3d rendering mode for interactive 3d viewer.
#@gmic : (eq. to '-md3d').
#@gmic : 'mode' can be { -1=bounding-box | 0=dots | 1=wireframe | 2=flat | 3=flat-shaded | 4=gouraud-shaded | 5=phong-shaded }.
#@gmic : Default value: 'mode=-1'.

#@gmic *3d : eq. to '-mul3d'. : (+)

#@gmic mul3d : factor : factor_x,factor_y,_factor_z : (+)
#@gmic : Scale selected 3d objects isotropically or anisotropically, with specified factors.
#@gmic : (eq. to '-*3d').
#@gmic : Default value: 'factor_z=0'.
#@gmic : $ -torus3d 5,2 -repeat 5 --add3d[-1] 10,0,0 -mul3d[-1] 1.2 -color3d[-1] @{-RGB} -done -add3d

#@gmic n3d : eq. to '-normalize3d'.
n3d :
  -_normalize3d

#@gmic normalize3d
#@gmic : Normalize selected 3d objects to unit size.
#@gmic : (eq. to '-n3d').
#@gmic : $ -repeat 100 -circle3d {?(3)},{?(3)},{?(3)},0.1 -done -add3d -color3d[-1] 255,0,0 --normalize3d[-1] -color3d[-1] 0,255,0 -add3d
normalize3d :
  -_$0

_normalize3d :
  -e[0--3] "Normalize size of 3d object$?."
  -v - -check3d 0 -repeat @# -l[$>]
    -if {i[6]}
      -s3d -r[2] 3,@{2,h/3},1,1,-1 -s[2] x
      factor={v=max(@{2,iM-im},@{3,iM-im},@{4,iM-im});if(v,v,1)}
      -a[2-4] x -/[2] $factor -y[2] -a y
    -endif
  -endl -done -v +

#@gmic o3d : eq. to '-opacity3d'. : (+)

#@gmic opacity3d : _opacity : (+)
#@gmic : Set opacity of selected 3d objects.
#@gmic : (eq. to '-o3d').
#@gmic : Default value: 'opacity=1'.
#@gmic : $ -torus3d 100,10 -double3d 0 -repeat 7 --rotate3d[-1] 1,0,0,20 -opacity3d[-1] {?} -done -add3d

#@gmic parametric3d : _x(a,b),_y(a,b),_z(a,b),_amin,_amax,_bmin,_bmax,_res_a>0,_res_b>0,_res_x>0,_res_y>0,_res_z>0,_smoothness>=0,_isovalue>=0
#@gmic : Input 3d object from specified parametric surface (x(a,b),y(a,b),z(a,b)).
#@gmic : Default values: 'x=(2+cos(b))*sin(a)', 'y=(2+cos(b))*cos(a)', 'c=sin(b)', 'amin=-pi', 'amax='pi', 'bmin=-pi', 'bmax='pi',
#@gmic : 'res_a=512', 'res_b=res_a', 'res_x=64', 'res_y=res_x', 'res_z=res_y', 'smoothness=2%' and 'isovalue=10%'.
#@gmic : $ -parametric3d ,
parametric3d : -skip "${1=(2+cos(b))*sin(a)}","${2=(2+cos(b))*cos(a)}","${3=sin(b)}"
               -skip ${4={-pi}},${5={pi}},${6={-pi}},${7={pi}}
               -check "${8=512}>0 && ${9=$8}>0 && ${10=64}>0 && ${11=$10}>0 && ${12=$11}>0 && \
                       ${13=2%}>=0 && ${14=10%}>=0"
  -e[^-1] "Input 3d object from parametric surface ($1,$2,$3)."
  -v -
  # Compute (x(a,b),y(a,b),z(a,b)) and normalize it.
  ($4,$5;$4,$5^$6,$6;$7,$7) -r[-1] $8,$9,1,2,3 -channels[-1] 0,2
  -f[-1] "a=i(x,y,0,0);b=i(x,y,0,1);if(c==0,$1,if(c==1,$2,$3))"
  -sh[-1] 0,0 xmin={im} xmax={iM} -n[-1] 16,{$10-17} -rm[-1]
  -sh[-1] 1,1 ymin={im} ymax={iM} -n[-1] 16,{$11-17} -rm[-1]
  -sh[-1] 2,2 zmin={im} zmax={iM} -n[-1] 16,{$12-17} -rm[-1]
  -r[-1] {w*h},3,1,1,-1

  # Extract 3d surface.
  -pointcloud[-1] 1 -r[-1] $10,$11,$12,1,0 -b[-1] $13,0
  -isosurface3d[-1] $14
  -c3d[-1] -n3d[-1] -*3d[-1] {$xmax-$xmin},{$ymax-$ymin},{$zmax-$zmin} -nm[-1] [3d\ parametric]
  -v +

#@gmic pca_patch3d : _patch_size>0,_M>0,_N>0,_normalize_input={ 0 | 1 },_normalize_output={ 0 | 1 },_lambda_xy
#@gmic : Get 3d patch-pca representation of selected images.
#@gmic : The 3d patch-pca is estimated from M patches on the input image, and displayed as a cloud of N 3d points.
#@gmic : Default values: 'patch_size=7', 'M=1000', 'N=3000', 'normalize_input=1', 'normalize_output=0', and 'lambda_xy=0'.
#@gmic : $ image.jpg -pca_patch3d 7
pca_patch3d : -check "isint(${1=7}) && $1>0 && isint(${2=1000}) && $2>0 && isint(${3=3000}) && $3>0" -skip ${4=1},${5=0},${6=0}
  -e[^-1] "Get 3d patch-pca representation"@{-arg\ 1+(@#>1),s,""}" of image$?, from $2 $1x$1 input patchs, "\
          "with $3 output patchs, input normalization "@{-arg\ 1+!$4,enabled,disabled}", output normalization "\
          @{-arg\ 1+!$5,enabled,disabled}" and lambda_xy $6."
  -v -
  P1={int($1/2)}       # Backward half-patch size.
  P2={$1-$P1-1}        # Forward half-patch size.

  -n 0,255 -round 1
  -repeat @# -l[$>] nm=@{0,n}
    s={s}

    # Pick set of M random located patchs.
    1,$2 -rand[-1] 0,@{0,w-1} --rand[-1] 0,@{0,h-1} --f[-1] 0 -a[-3--1] x -round[-1] 1 --patches[0] $1,$1,1,@-1 -y[2--1] -a[2--1] x
    -z[1] 0,1 -transpose[1] -*[1] $6 -a[1,2] y -s[^0] x

    # Normalize patch coordinates by using average and standard deviation.
    --+[^0] -/[-1] $2 --[1--2] [-1] -rm[-1]
    -a[^0] x
    -if $4 -l[-1] -s y -/ 'sqrt(1e-8+iv)' -a y -endl -endif

    # Do PCA for dimension reduction.
    --transpose[-1] -**[-2,-1]
    -eigen[-1] -rows[-2] 0,2 -columns[-1] 0,2 -transpose[-1]
    -if $5 -sqrt[-2] -/[-2] @{-2,M} -r[-2] [-1] -/[-1] [-2] -endif
    -rm[-2]

    # Pick set of N random located patchs.
    -repeat $3
      x={round(?(@{0,w}))}
      y={round(?(@{0,h}))}
      ({$6*$x};{$6*$y})
      --z[0] {$x-$P1},{$y-$P1},{$x+$P2},{$y+$P2},1
      -y[-1] -a[-2,-1] y
    -done

    # Generate 3d representation of the projected patch set.
    --a[2--1] x -**[1,-1] -transpose[1]                    # Vertex coordinates.
    -rows[2--1] 2,100%                                     # Colors
    -if {$s!=3}
      -r[2--1] $1,$1,1,{min(3,$s)},-1
      -r[2--1] $1,$1,1,3,{if($s!=1,0,1)}
      -y[2--1]
    -endif
    -i[2--2] (-128;$1;$1;3) -a[2--1] y
    -rm[0]                                                 # Remove input image (now useless).
    -i[0] ({'CImg3d'})                                     # Header.
    -i[1] ($3;$3)                                          # Geometry.
    -i[3] 2,$3,1,1,if(x==0,1,y)                            # Primitives.
    1,$3,1,1,1                                             # Opacities.
    -y -a[-6--1] y                                         # Merge as a 3d object.

  -nm $nm,1 -endl -done -v +

#@gmic plane3d : _size_x,_size_y,_nb_subdivisions_x>0,_nb_subdisivions_y>0
#@gmic : Input 3d plane at (0,0,0), with specified geometry.
#@gmic : Default values: 'size_x=1', 'size_y=size_x' and 'nb_subdivisions_x=nb_subdivisions_y=24'.
#@gmic : $ -plane3d 50,30 --primitives3d 1 -color3d[-2] @{-RGB}
plane3d : -check "${3=24}>0 && ${4=24}>0" -skip ${1=1},${2=$1}
  -e[^-1] "Input 3d plane, with size (${1,2}) and subdivisions (${3,4})."
  -v - {$3+1},{$4+1} -elevation3d[-1] 0 -*3d[-1] {$1/$3},{$2/$4} -col3d[-1] 200 -nm[-1] [3d\ plane] -v +

#@gmic point3d : x0,y0,z0
#@gmic : Input 3d point at specified coordinates.
#@gmic : $ -repeat 1000 a={$>*pi/500} -point3d {cos(3*$a)},{sin(2*$a)},0 -color3d[-1] @{-RGB} -done -add3d
point3d :
  -e[^-1] "Input 3d point ($1,$2,$3)."
  -v - 1,17,1,1,67.5,73.5,109.5,103.5,51.5,100.5,1,1,${1-3},1,0,200,200,200,1 -nm[-1] [3d\ point] -v +

#@gmic pointcloud3d
#@gmic : Convert selected planar or volumetric images to 3d point clouds.
#@gmic : $ image.jpg -luminance -resize2dy 100 -threshold 50% -* 255 -pointcloud3d -color3d[-1] 255,255,255
pointcloud3d :
  -e[^-1] "Convert image$? to 3d point clouds."
  -v - -repeat @# -l[$>] nm=@{0,n}
    -s z -repeat @# -l[$>]
      --norm -!=[-1] 0
      -i[-2] (1,{w};1,{w}^1,1;{h},{h}) -r[-2] [-1],[-1],1,2,3 -*[-2,-1] -round[-1] -permute[-1] cxyz
      -l[-1] -s -,0 -a y is_points=@# -endl
      -if $is_points
        --[-1] 1 -r[-1] 2,{h/2},1,1,-1 -permute[-1] cyzx --warp[-2] [-1],0,0 -rm[-3]
        -permute[-2] cyzx -i[-2] 1,{h},1,1,$> -a[-3,-2] x    # Coordinates.
        -i[-3] ({'CImg3d'}) -i[-3] ({h},{h})                 # Header and size.
        -i[-2] 1,{h},1,1,1 -i[-2] 1,{h},1,1,y -a[-3,-2] x    # Primitives.
        -permute[-1] cyzx                                    # Colors.
        -if {w==1} -r[-1] 3,{h},1,1
        -elif {w>3} -i[-2] 4,{h},1,1,-128,1,1,{w} -a[-2,-1] x
        -else -r[-1] 3,{h},1,1,0
        -endif
        1,{h},1,1,1                                          # Opacities.
        -y[-6--1] -a[-6--1] y
      -else -rm -empty3d
      -endif
      -endl -done
    -+3d
  -nm $nm,1 -endl -done -v +

#@gmic pose3d : p1,..,p12
#@gmic : Apply 3d pose matrix to selected 3d objects.
#@gmic : $ -torus3d 100,20 -pose3d 0.152437,1.20666,-0.546366,0,-0.535962,0.559129,1.08531,0,1.21132,0.0955431,0.548966,0,0,0,-206,1 -snapshot3d 400
pose3d :
  -e[^-1] "Apply 3d pose matrix [ $1,$2,$3,$4; $5,$6,$7,$8; $9,$10,$11,$12 ] to 3d object$?."
  -v - -repeat @# -l[$>] -if @{-is_3d}
    -s3d -r[2] 3,@{2,h/3},1,1,-1 -i[3] 1,@{2,h},1,1,1 -a[2,3] x
    -i[3] ($1,$5,$9;$2,$6,$10;$3,$7,$11;$4,$8,$12) -**[2,3]
    -r[2] 1,@{2,3*h},1,1,-1 -a y
  -else -error "Command '-pose3d': Image ["{@#-$>-1}"] does not represent a 3d object."
  -endif -endl -done -v +

#@gmic p3d : eq. to '-primitives3d'. : (+)

#@gmic primitives3d : mode : (+)
#@gmic : Convert primitives of selected 3d objects.
#@gmic : (eq. to '-p3d').
#@gmic : 'mode' can be { 0=points | 1=segments | 2=non-textured }.
#@gmic : $ -sphere3d 30 -primitives3d 1 -torus3d 50,10 -color3d[-1] @{-RGB} -add3d

#@gmic projections3d : _x[%],_y[%],_z[%],_is_bounding_box={ 0 | 1 }
#@gmic : Generate 3d xy,xz,yz projection planes from specified volumetric images.
projections3d : -skip ${1=50%},${2=50%},${3=50%},${4=1}
  -e[^-1] "Generate 3d xy,xz,yz projection planes from image$?."
  -v - -n 0,255 -repeat @# -l[$>]
    w={w} h={h} d={d}
    x={if(@{-is_percent\ $1},$1*w,$1)}
    y={if(@{-is_percent\ $2},$2*h,$2)}
    z={if(@{-is_percent\ $3},$3*d,$3)}
    --rows $2,$2 -r[-1] {w},{d},1,100%,-1
    --columns[-2] $1,$1 -permute[-1] zyxc
    -slices[-3] $3,$3 -r[-3--1] 100%,100%,1,3
    -imageplane3d[-3--1]
    -r3d[-1] 0,1,0,90 -r3d[-2] 1,0,0,-90
    -+3d[-3] 0,0,$z -+3d[-2] 0,$y,0 -+3d[-1] $x,0,0
    -+3d[-3--1] -o3d[-1] 0.8
    -if $4 -box3d $w,$h,$d -p3d[-1] 1 -o3d[-1] 0.4 -+3d[-2,-1] -endif
  -endl -done -v +

#@gmic pyramid3d : width,height
#@gmic : Input 3d pyramid at (0,0,0), with specified geometry.
#@gmic : $ -pyramid3d 100,100 --primitives3d 1 -color3d[-2] @{-RGB}
pyramid3d :
  -e[^-1] "Input new 3d pyramid, with width $1 and height $2."
  -v -
  (67.5;73.5;109.5;103.5;51.5;100.5;\  # Magick number for CImg3d.
   5;5;\                               # Number of vertices and primitives.
   {-$1/2};{-$1/2};{-$2/2};\           # Vertex coordinates.
   {$1/2};{-$1/2};{-$2/2};\
   {$1/2};{$1/2};{-$2/2};\
   {-$1/2};{$1/2};{-$2/2};\
   0;0;{$2/2};\
   4;0;3;2;1;\                         # Primitives description.
   3;0;4;3;\
   3;1;4;0;\
   3;2;4;1;\
   3;3;4;2)
  1,15,1,1,200 1,5,1,1,1 -a[-3--1] y -nm[-1] [3d\ pyramid]
  -v +

#@gmic quadrangle3d : x0,y0,z0,x1,y1,z1,x2,y2,z2,x3,y3,z3
#@gmic : Input 3d quadrangle at specified coordinates.
#@gmic : $ -quadrangle3d -10,-10,10,10,-10,10,10,10,10,-10,10,10 -repeat 10 --rotate3d[-1] 0,1,0,30 -color3d[-1] @{-RGB},0.6 -done -add3d -mode3d 2
quadrangle3d :
  -e[^-1] "Input 3d quadrangle ($1,$2,$3)-($4,$5,$6)-($7,$8,$9)-($10,$11,$12)."
  -v - 1,29,1,1,67.5,73.5,109.5,103.5,51.5,100.5,4,1,${1-12},4,0,1,2,3,200,200,200,1 -nm[-1] [3d\ quadrangle] -v +

#@gmic rv3d : eq. to '-reverse3d'. : (+)

#@gmic reverse3d : (+)
#@gmic : Reverse primitive orientations of selected 3d objects.
#@gmic : (eq. to '-rv3d').
#@gmic : $ -torus3d 100,40 -double3d 0 --reverse3d

#@gmic r3d : eq. to '-rotate3d'. : (+)

#@gmic rotate3d : u,v,w,angle : (+)
#@gmic : Rotate selected 3d objects around specified axis with specified angle (in deg.).
#@gmic : (eq. to '-r3d').
#@gmic : $ -torus3d 100,10 -double3d 0 -repeat 7 --rotate3d[-1] 1,0,0,20 -done -add3d

#@gmic rotation3d : u,v,w,angle
#@gmic : Input 3x3 rotation matrix with specified axis and angle (in deg).
#@gmic : $ -rotation3d 1,0,0,0 -rotation3d 1,0,0,90 -rotation3d 1,0,0,180
rotation3d :
  -e[^-1] "Input 3d rotation matrix around axis ($1,$2,$3) with angle $4 deg."
  -v -
  ($1^$2^$3^0) -orientation[-1] -y[-1] x -*[-1] {sin($4*pi/360)} -=[-1] {cos($4*pi/360)},3
  xx={i(0)*i(0)} xy={i(0)*i(1)} xz={i(0)*i(2)} xw={i(0)*i(3)}
  yy={i(1)*i(1)} yz={i(1)*i(2)} yw={i(1)*i(3)}
  zz={i(2)*i(2)} zw={i(2)*i(3)}
  -rm[-1]
  ({1-2*($yy+$zz)},{2*($xy+$zw)},{2*($xz-$yw)};\
   {2*($xy-$zw)},{1-2*($xx+$zz)},{2*($yz+$xw)};\
   {2*($xz+$yw)},{2*($yz-$xw)},{1-2*($xx+$yy)})
  -nm[-1] [3d\ rotation]
  -v +

#@gmic sierpinski3d : _recursion_level>=0,_width,_height
#@gmic : Input 3d Sierpinski pyramid.
#@gmic : $ -sierpinski3d 3 --primitives3d 1 -color3d[-2] @{-RGB}
sierpinski3d : -check ${1=4}>=0 -skip ${2=1},${3=1}
-e[^-1] "Input 3d Sierpinski pyramid of degree $1, with width $2 and height $3."
  -v - -l[] -_sierpinski3d {-$2/2},{-$2/2},{-$3/2},{$2/2},{-$2/2},{-$3/2},{$2/2},{$2/2},{-$3/2},{-$2/2},{$2/2},{-$3/2},0,0,{$3/2},$1 -+3d -endl
  -nm[-1] [3d\ sierpinski] -v +

_sierpinski3d :
  -if {$16<=0}
    (67.5;73.5;109.5;103.5;51.5;100.5;\
     5;5;\
     $1;$2;$3;\
     $4;$5;$6;\
     $7;$8;$9;\
     $10;$11;$12;\
     $13;$14;$15;\
     4;0;3;2;1;\
     3;0;4;3;\
     3;1;4;0;\
     3;2;4;1;\
     3;3;4;2)
    1,15,1,1,200 1,5,1,1,1 -a[-3--1] y
  -return -endif
  -_sierpinski3d $1,$2,$3,\
                 {($1+$4)/2},{($2+$5)/2},{($3+$6)/2},\
                 {($1+$4+$7+$10)/4},{($2+$5+$8+$11)/4},{($3+$6+$9+$12)/4},\
                 {($1+$10)/2},{($2+$11)/2},{($3+$12)/2},\
                 {($1+$13)/2},{($2+$14)/2},{($3+$15)/2},\
                 {$16-1}
  -_sierpinski3d {($1+$4)/2},{($2+$5)/2},{($3+$6)/2},\
                 $4,$5,$6,\
                 {($4+$7)/2},{($5+$8)/2},{($6+$9)/2},\
                 {($1+$4+$7+$10)/4},{($2+$5+$8+$11)/4},{($3+$6+$9+$12)/4},\
                 {($4+$13)/2},{($5+$14)/2},{($6+$15)/2},\
                 {$16-1}
  -_sierpinski3d {($1+$4+$7+$10)/4},{($2+$5+$8+$11)/4},{($3+$6+$9+$12)/4},\
                 {($4+$7)/2},{($5+$8)/2},{($6+$9)/2},\
                 $7,$8,$9,\
                 {($7+$10)/2},{($8+$11)/2},{($9+$12)/2},\
                 {($7+$13)/2},{($8+$14)/2},{($9+$15)/2},\
                 {$16-1}
  -_sierpinski3d {($1+$10)/2},{($2+$11)/2},{($3+$12)/2},\
                 {($1+$4+$7+$10)/4},{($2+$5+$8+$11)/4},{($3+$6+$9+$12)/4},\
                 {($7+$10)/2},{($8+$11)/2},{($9+$12)/2},\
                 $10,$11,$12,\
                 {($10+$13)/2},{($11+$14)/2},{($12+$15)/2},\
                 {$16-1}
  -_sierpinski3d {($1+$13)/2},{($2+$14)/2},{($3+$15)/2},\
                 {($4+$13)/2},{($5+$14)/2},{($6+$15)/2},\
                 {($7+$13)/2},{($8+$14)/2},{($9+$15)/2},\
                 {($10+$13)/2},{($11+$14)/2},{($12+$15)/2},\
                 $13,$14,$15,\
                 {$16-1}

#@gmic size3d
#@gmic : Return bounding box size of the last selected 3d object.
size3d :
  -v - --rows[-1] 8,{8+3*i[6]} -r[-1] 3,{h/3},1,1,-1 -s[-1] x,3
  -u @{-3,(iM-im)},@{-2,(iM-im)},@{-1,(iM-im)}
  -rm[-3--1] -v +

#@gmic skeleton3d : _metric,_frame_type={ 0=squares | 1=diamonds | 2=circles | 3=auto },_skeleton_opacity,_frame_opacity,_is_frame_wireframe={ 0 | 1 }
#@gmic : Build 3d skeletal structure object from 2d binary shapes located in selected images.
#@gmic : 'metric' can be { 0=chebyshev | 1=manhattan | 2=euclidean }.
#@gmic : Default values: 'metric=2', 'bones_type=3', 'skeleton_opacity=1' and 'frame_opacity=0.1'.
#@gmic : $ -cupid 480 --skeleton3d ,
skeleton3d : -check "isint(${1=2}) && $1>=0 && $1<=2 && isint(${2=3}) && $2>=0 && $2<=3" -skip ${3=1},${4=0.1},${5=1}
  -e[^-1] "Build 3d skeletal structure object from image$?, with "@{-arg\ 1+$1,chebyshev,manhattan,euclidean}" metric, "\
          @{-arg\ 1+$2,squares,diamonds,circles,auto}" bones, skeleton opacity $3 and frame opacity $4 ."
  -v - -repeat @# -l[$>] -channels 0

    # Construct skeleton representation.
    --distance 0,$1
    --f[-1] "(i>j(-1)&&i>j(1)) || (i>j(0,-1)&&i>j(0,1)) || (i>j(-1,-1)&&i>j(1,1)) || (i>j(-1,1)&&i>j(1,-1))"
    -if $3 --slices[-1] -1,0 -isosurface3d[-1] 0.5 -o3d[-1] $3 -col3d[-1] 255,0,0 -endif
    -*[0-2] -pointcloud3d[0]

    # Construct bones from skeleton.
    -if $4 -l[0] -s3d 1
      n=@{1,0}
      -if $n
        -r[2] 3,$n,1,1,-1 -r[3] 2,$n,1,1,-1 -r[4] 3,$n,1,1,-1

        -if {$2==0" || "($2==3" && "$1==0)} # Frame with squares.
          -=[1] {4*$n}
          -i[3] [2]x3 --z[-2] 0,1 -z[-1] 0,2 --[2] [-1] -+[4] [-1]
          -s[-1] x -*[-2] -1 -a[-3--1] x -+[3] [-1] --[5,-1] -a[2-5] x
          -rm[3] 1,$n,1,1,4 --f[-1] 4*y --+[-1] 1 --+[-1] 1 --+[-1] 1 -rv[-3,-1] -a[-5--1] x -mv[-1] 3

        -elif {$2==1" || "($2==3" && "$1==1)} # Frame with diamonds.
          -=[1] {4*$n}
          -i[3] [2]x3 --z[-2] 0,0 -z[-1] 0,2 --[2] [-1] -+[4] [-1]
          -shift[-1] 1,0 --[3] [-1] -+[5,-1] -a[2-5] x
          -rm[3] 1,$n,1,1,4 --f[-1] 4*y --+[-1] 1 --+[-1] 1 --+[-1] 1 -rv[-3,-1] -a[-5--1] x -mv[-1] 3

        -elif {$2==2" || "($2==3" && "$1==2)} # Frame with circles.
          -=[1] {2*$n}
          --z[4] 0,0 -z[-1] 0,2 --+[2,-1] --[2,-2] -a[2,-1] x
          -rm[3] 1,$n,1,1,5 --f[-1] 2*y --+[-1] 1 3,100% -a[-4--1] x -mv[-1] 3
        -endif
        -y -a y -o3d $4 -if $5 -p3d 1 -endif -col3d 200
      -else -rm -empty3d -endif
    -endl -else -rm[0] -endif
    -+3d
  -endl -done -v +

#@gmic snapshot3d : _size>0,_zoom>=0,_backgroundR,_backgroundG,_backgroundB,_backgroundA : [background_image],zoom>=0
#@gmic : Take 2d snapshots of selected 3d objects.
#@gmic : Set 'zoom' to 0 to disable object auto-scaling.
#@gmic : Default values: 'size=512', 'zoom=1' and '[background_image]=(default)'.
#@gmic : $ -torus3d 100,20 -rotate3d 1,1,0,60 -snapshot3d 400,1.2,128,64,32
#@gmic : $ -torus3d 100,20 -rotate3d 1,1,0,60 -testimage2d 400 --snapshot3d[0] [1],1.2
snapshot3d : -check "${2=1}>=0" -skip ${1=512},${3=""}
  -if @{"-is_image_arg $1"} # Background image specified.
    -e[0--3] "Take $1x$1 snapshot$? of 3d object$?, with zoom factor $2 and background image $3."
    -v - -pass$1 0 -to_color[-1]
  -elif {isval($3)} # Background color specified.
    -e[0--3] "Take $1x$1 snapshot$? of 3d object$?, with zoom factor $2 and background color ${3--1}."
    -v - (${3--1}) -y[-1] c -r[-1] $1,$1 -to_color[-1]
  -else # Default background color.
    -e[0--3] "Take $1x$1 snapshot$? of 3d object$?, with zoom factor $2 and default background."
    -v - 1,2,1,3,32,64,32,116,64,96 -r[-1] $1,$1,1,3,3
  -endif
  -repeat {@#-1} [-1] -l[$>,-1]
    -if {$2!=0} -c3d[0] -n3d[0] -*3d[0] {3*min(w,h)*$2/4} -endif
    -if {s>3} # RGBA rendering.
      100%,100%,1,3,-1 -j3d[-1] [0],50%,50%,0,1
      -to_rgba[-1] -replace_color[-1] 0,0,-1,-1,-1,255,0,0,0,0 -blend[-2,-1] alpha
    -else # RGB rendering.
      -j3d[1] [0],50%,50%,0,1
    -endif
   -nm[1] @{-2,n},1 -rm[0]
  -endl -done -rm[-1] -v +

#@gmic sl3d : eq. to '-specl3d'. : (+)

#@gmic specl3d : value>=0 : (+)
#@gmic : Set lightness of 3d specular light.
#@gmic : (eq. to '-sl3d').
#@gmic : Default value: 'value=0.15'.
#@gmic : $ (0,0.3,0.6,0.9,1.2) -repeat {w} -torus3d 100,30 -rotate3d[-1] 1,1,0,60 -color3d[-1] 255,0,0 -specl3d @{0,$>} -snapshot3d[-1] 400 -done -remove[0]

#@gmic ss3d : eq. to '-specs3d'. : (+)

#@gmic specs3d : value>=0 : (+)
#@gmic : Set shininess of 3d specular light.
#@gmic : (eq. to '-ss3d').
#@gmic : Default value: 'value=0.8'.
#@gmic : $ (0,0.3,0.6,0.9,1.2) -repeat {w} -torus3d 100,30 -rotate3d[-1] 1,1,0,60 -color3d[-1] 255,0,0 -specs3d @{0,$>} -snapshot3d[-1] 400 -done -remove[0]

#@gmic sphere3d : radius,_nb_recursions>=0 : (+)
#@gmic : Input 3d sphere at (0,0,0), with specified geometry.
#@gmic : Default value: 'nb_recursions=3'.
#@gmic : $ -sphere3d 100 --primitives3d 1  -color3d[-2] @{-RGB}

#@gmic spherical3d : _nb_azimuth>=3,_nb_zenith>=3,_radius_function(phi,theta)
#@gmic : Input 3d spherical object at (0,0,0), with specified geometry.
#@gmic : Default values: 'nb_zenith=nb_azimut=64' and 'radius_function="abs(1+0.5*cos(3*phi)*sin(4*theta))"'.
#@gmic : $ -spherical3d 64 --primitives3d 1
spherical3d : -check "${1=64}>=3 && ${2=$1}>=3" -skip "${3=abs(1+0.5*cos(3*phi)*sin(4*theta))}"
  -e[^-1] "Input 3d spherical object, with subdivisions ($1,$2) and height function '$3'."
  -v -
  ({'CImg3d'}) -y[-1] # Magic number.
  n1={round($1)} n2={round($2)}

  # Define 3d vertices.
  $n1,{$n2-1},1,3,"phi=2*pi*(x+0.5)/w;\
                   theta=-pi/2+pi*(y+0.5)/h;\
                   cp=cos(phi);\
                   sp=sin(phi);\
                   ct=cos(theta);\
                   ($3)*if(c==0,ct*cp,if(c==1,ct*sp,sin(theta)))"
  -r[-1] {w*h},3,1,1,-1 -permute[-1] yxzc
  -i[-2] (0,0,{phi=0;theta=-pi/2;-$3};0,0,{phi=0;theta=pi/2;$3}) -a[-2,-1] y  # Add the two poles.
  nbv={h} -y[-1]

  # Define 3d primitives.
  $n1,{$n2-2},1,4,"nx=(x+1)%w;ny=(y+1);2+if(c==0,x+y*"$n1",if(c==1,nx+y*"$n1",if(c==2,nx+ny*"$n1",x+ny*"$n1")))"
  -r[-1] {w*h},4,1,1,-1 -permute[-1] yxzc -i[-2] 1,{h},1,1,4 -a[-2,-1] x
  2,$n1,1,1,3,0 1,$n1,1,1,'y' --+[-1] 1 -%[-1] {h} 2,$n1,1,1,3,1 [-3,-2]  # Connect the two poles.
  -+[-5,-4] 2 -rv[-5,-4] -+[-2,-1] {$nbv-$n1} -a[-3--1] x -a[-4--2] x
  nbp={h+@{-2,h}+@{-3,h}}
  -y[-3--1] -a[-3--1] y

  # Define other object information (properties, colors and opacities).
  -i[-3] ($nbv;$nbp)
  1,{3*$nbp},1,1,200 1,$nbp,1,1,1 -a[-2,-1] y

  # Append as a 3d object.
  -a[-5--1] y -nm[-1] "[3d spherical surface '$3']"
  -v +

#@gmic spline3d : x0[%],y0[%],z0[%],u0[%],v0[%],w0[%],x1[%],y1[%],z1[%],u1[%],v1[%],w1[%],_nb_vertices>=2
#@gmic : Input 3d spline with specified geometry.
#@gmic : Default values: 'nb_vertices=128'.
#@gmic : $ -repeat 100 -spline3d {?},{?},{?},{?},{?},{?},{?},{?},{?},{?},{?},{?},128 -color3d[-1] @{-RGB} -done -box3d 1 -primitives3d[-1] 1 -+3d
spline3d : -check ${13=128}>=2
  -e[^-1] "Input new 3d spline from (${1-3}) [${4-6}] to (${7-9}) [${10-12}] with $13 vertices."
  -v -
  ({'CImg3d'}) -+[-1] 0.5   # Header.
  ($13;{$13-1})             # Nb vertices / primitives.
  # Define vertices.
  1,$13,1,1,1 (0;1) -r[-1] 1,$13,1,1,3 --sqr[-1] --*[-2,-1] -a[-4--1] x
  --*[-1] '$2,$5,{3*(($8)-($2))-2*($5)-($11)},{($5)+($11)+2*(($2)-($8))}' -l[-1] -s x -+ -endl
  --*[-2] '$3,$6,{3*(($9)-($3))-2*($6)-($12)},{($6)+($12)+2*(($3)-($9))}' -l[-1] -s x -+ -endl
  -*[-3] '$1,$4,{3*(($7)-($1))-2*($4)-($10)},{($4)+($10)+2*(($1)-($7))}' -l[-3] -s x -+ -endl
  -a[-3--1] x
  1,{$13-1},1,1,2 (0,1;{$13-2},{$13-1}) -r[-1] 2,[-2],1,1,3 -round[-1] -a[-2,-1] x # Primitives.
  1,{3*($13-1)},1,1,200 1,{$13-1},1,1,1 # Colors / opacities.
  -y[-3,-4,-6] -a[-6--1] y
  -v +

#@gmic s3d : eq. to '-split3d'. : (+)

#@gmic split3d : _keep_shared_data={ 0 | 1 } : (+)
#@gmic : Split selected 3d objects into 6 feature vectors :
#@gmic : { header, sizes, vertices, primitives, colors, opacities }.
#@gmic : (eq. to '-s3d').
#@gmic : To recreate the 3d object, append these 6 images along the y-axis.
#@gmic : Default value: 'keep_shared_data=1'.
#@gmic : $ -box3d 100 --split3d

#@gmic sprite3d
#@gmic : Convert selected images as 3d sprites.
#@gmic : Selected image with alpha channels are managed.
#@gmic : $ image.jpg -sprite3d
sprite3d :
  -e[^-1] "Convert image$? as 3d sprites."
  -v - -repeat @# -l[$>] nm=@{0,n}
    -split_opacity
    -i[0] (67.5;73.5;109.5;103.5;51.5;100.5;1;1;0;0;0;1;0;-128;{w};{h};@{0,s}) -y[1]
    -if {@#==2} (1) -a y
    -else -/[-1] 255 -i[-2] (-128;{w};{h};{s}) -y[-1]
    -endif
    -a y
  -nm $nm,1 -endl -done -v +

#@gmic sprites3d
#@gmic : Convert selected 3d objects as sprites clouds, where the specified 2d sprite is the last selected image.
#@gmic : If the selected sprite has a 4th channel, it stands for the sprite alpha-channel (in [0,255]).
#@gmic : $ -torus3d 100,20 image.jpg -resize2dy[-1] 64 100%,100% -gaussian[-1] 30%,30% -*[-1] 255 -append[-2,-1] c --sprites3d -drgba[-2]
sprites3d :
  -e[^-1] "Convert image$? as 3d sprites clouds."
  -v - -repeat {@#-1}
    -if {!@{$>,(0,7)}} -continue -endif # Do nothing if 3d object is empty.
    [-1] -l[$>,-1]
    -s3d[0] N=@{1,0} -=[1] $N,0,1
    -rm[3-5] -i[3] (1,0;1,{$N-1}) -r[3] 2,$N,1,1,3 -round[3]
    -if {s==4}
      -s[-1] c,-3 -/[-1] 255
      -i[-3] (-128;{w};{h};3)
      -if {$N>1} -i[-2] 1,{4*($N-1)},1,1,-128,0,0,0 -endif
      -i[-2] (-128;{w};{h};1)
      -if {$N>1} 1,{4*($N-1)},1,1,-128,0,0,0 -endif
    -else
      -i[-2] (-128;{w};{h};{s}) -y[-3,-1]
      -if {$N>1} 1,{4*($N-1)},1,1,-128,0,0,0 -endif
      1,$N,1,1,1
    -endif
    -y -a y
  -endl -done -rm[-1] -v +

#@gmic star3d : _nb_branches>0,0<=_thickness<=1
#@gmic : Input 3d star at (0,0,0), with specified geometry.
#@gmic : Default values: 'nb_branches=5' and 'thickness=0.38'.
#@gmic : $ -star3d , --primitives3d 1 -color3d[-2] @{-RGB}
star3d : -check "${1=5}>0 && ${2=0.38}>=0 && $2<=1"
  -e[^-1] "Input 3d star, with $1 branches and thickness $2."
  -v -
  N={2*$1} ({'CImg3d'}) -+[-1] 0.5 ({$N+1};$N)
  ({-pi/2};{3*pi/2}) -r[-1] 1,{$N+1},1,1,3 -rows[-1] 0,{h-2} --sin[-1] -cos[-2] -a[-2,-1] x
  (1,1;$2,$2) -*[-2,-1] -z[-1] 0,2 -r[-1] 3,{h+1},1,1,0
  (3,$N,1,0;3,$N,$N,{$N-1}) -r[-1] 4,$N,1,1,3 -round[-1] -=[-1] 0,2,100%
  3,$N,1,1,200 1,$N,1,1,1 -y[-6,-4--2] -a[-6--1] y -nm[-1] [3d\ star]
  -v +

#@gmic streamline3d : x[%],y[%],z[%],_L>=0,_dl>0,_interpolation,_is_backward={ 0 | 1 },_is_oriented={ 0 | 1 } : 'formula',x,y,z,_L>=0,_dl>0,_interpolation,_is_backward={ 0 | 1 },_is_oriented={ 0 | 1 } : (+)
#@gmic : Extract 3d streamlines from selected vector fields or from specified formula.
#@gmic : 'interpolation' can be { 0=nearest integer | 1=1st-order | 2=2nd-order | 3=4th-order }.
#@gmic : Default values: 'dl=0.1', 'interpolation=2', 'is_backward=0' and 'is_oriented=0'.
#@gmic : $ 100,100,100,3 -rand -10,10 -blur 3 -repeat 300 --streamline3d[0] {?(100)},{?(100)},{?(100)},1000,1,1 -color3d[-1] @{-RGB} -done -remove[0] -box3d 100 -primitives3d[-1] 1 -add3d

#@gmic -3d : eq. to '-sub3d'. : (+)

#@gmic sub3d : tx,_ty,_tz : (+)
#@gmic : Shift selected 3d objects with the opposite of specified displacement vector.
#@gmic : (eq. to '--3d').
#@gmic : Default values: 'ty=tz=0'.
#@gmic : $ -sphere3d 10 -repeat 5 --sub3d[-1] 10,{?(-10,10)},0 -color3d[-1] @{-RGB} -done -add3d

#@gmic superformula3d : resolution>1,m>=1,n1,n2,n3
#@gmic : Input 2d superformula curve as a 3d object.
#@gmic : Default values: 'resolution=1024', 'm=8', 'n1=1', 'n2=5' and 'n3=8'.
#@gmic : $ -superformula3d ,
superformula3d : -check "${1=1024}>1 && ${2=8}>=1" -skip ${3=1},${4=5},${5=8}
  -e[^-1] "Input 2d superformula curve, with resolution $1, m=$2 and (n1,n2,n3)=($3,$4,$5)."
  -v -
  res={round($1)}

  # Define object header and vertices.
  (67.5;73.5;109.5;103.5;51.5;100.5;$res;{$res-1})
  (0,{2*pi}) -r[-1] $res,1,1,1,3 [-1]

  -*[-1] {$2/4} --sin[-1] -cos[-2] -abs[-2,-1]
  -^[-2] $4 -^[-1] $5 -+[-2,-1] -^[-1] {-1/$3}
  --sin[-2] -cos[-3] -*[-1] [-2] -*[-3,-2] -n[-2,-1] -1,1
  -a[-2,-1] y -rows[-1] 0,2 -transpose[-1] -r[-1] 1,{w*h},1,1,-1

  # Define object primitives, colors and opacities.
  1,{$res-1},1,1,2 (0;{$res-2}) -r[-1] 1,{$res-1},1,1,3 --+[-1] 1 -a[-3--1] x -round[-1] 1 -r[-1] 1,{w*h},1,1,-1
  1,{3*($res-1)},1,1,200 1,{$res-1},1,1,1 -a[-5--1] y -nm[-1] [3d\ superformula]
  -v +

#@gmic text_pointcloud3d : _"text1",_"text2",_smoothness
#@gmic : Input 3d text pointcloud from the two specified strings.
#@gmic : Default values: 'text1="text1"', 'text2="text2"' and 'smoothness=1'.
#@gmic : $ -text_pointcloud3d "G'MIC","Rocks!"
text_pointcloud3d : -skip ${1="text1"},${2="text2"},${3=1}
  -e[^-1] "Input 3d pointcloud text object from strings '$1' and '$2', with smoothness $3."
  -v -
  0 -t[-1] "$1",0,0,53,1,1
  0 -t[-1] "$2",0,0,53,1,1 -mirror[-1] y
  -autocrop[-2,-1] 0
  -expand_xy[-2,-1] 2,0 -dilate[-2,-1] 2
  -permute[-1] zyxc -r[-2,-1] @{-max_whd} -and[-2,-1]

  100%,100% -rand[-1] 0,{@{-2,d}-1} -round[-1] -r[-1] [-2] -f[-1] 'if(z==i,1,0)'
  -distance[-1] 1 -+[-1] 1 --f[-1] 1 -rv[-2,-1] -/[-2,-1] -*[-1] [-2]
  --dilate[-1] 0,0,{d} -==[-2,-1] -*[-1] [-2]

  1,100%,100% -rand[-1] 0,{@{-2,w}-1} -round[-1] -r[-1] [-2] -f[-1] 'if(x==i,1,0)'
  -distance[-1] 1 -+[-1] 1 --f[-1] 1 -rv[-2,-1] -/[-2,-1] -*[-1] [-3]
  --dilate[-1] 0,0,{d} -==[-2,-1] -*[-3,-1]

  -or[-2,-1]

  -b[-1] $3 -isosurface3d[-1] 25%
  -c3d[-1] -n3d[-1] -nm[-1] "[3d text pointcloud]" -v +

#@gmic text3d : text,_font_height>0,_depth>0,_smoothness
#@gmic : Input a 3d text object from specified text.
#@gmic : Default values: 'font_height=53', 'depth=10' and 'smoothness=1.5'.
#@gmic : $ -text3d "G'MIC as a\n3D logo!"
text3d : -skip ${2=53},${3=10},${4=1.5}
  -e[^-1] "Input 3d text object '$1' with size $2, depth $3 and smoothness $4."
  -v - 0 -t[-1] "$1",0,0,$2,1,1 -autocrop[-1] 0 -r[-1] 100%,100%,$3 -expand_xyz[-1] 10,0
  -b[-1] $4 -isosurface3d[-1] 40% -rv3d[-1] -nm[-1] "[3d text '$1']" -v +

#@gmic t3d : eq. to '-texturize3d'. : (+)

#@gmic texturize3d : [ind_texture],_[ind_coords] : (+)
#@gmic : Texturize selected 3d objects with specified texture and coordinates.
#@gmic : (eq. to '-t3d').
#@gmic : When '[ind_coords]' is omitted, default XY texture projection is performed.
#@gmic : Default value: 'ind_coords=(undefined)'.
#@gmic : $ image.jpg -torus3d 100,30 -texturize3d[-1] [-2] -keep[-1]

#@gmic torus3d : _radius1,_radius2,_nb_subdivisions1>2,_nb_subdivisions2>2
#@gmic : Input 3d torus at (0,0,0), with specified geometry.
#@gmic : Default values: 'radius1=1', 'radius2=0.3', 'nb_subdivisions1=24' and 'nb_subdivisions2=12'.
#@gmic : $ -torus3d 10,3 --primitives3d 1 -color3d[-2] @{-RGB}
torus3d : -check "${3=24}>2 && ${4=12}>2" -skip ${1=1},${2=0.3}
  -e[^-1] "Input 3d torus, with radii ($1,$2) and subdivisions ($3,$4)."
  -v -
  # Header.
  nbp={$3*$4}
  1,8,1,1,67.5,73.5,109.5,103.5,51.5,100.5,$nbp,{$4*$3}

  # Vertices.
  (0;{2*pi}) --y[-1] x
  -r[-2] 1,{$3+1},1,1,3 -z[-2] 0,0,0,{$3-1}
  -r[-1] {$4+1},1,1,1,3 -z[-1] 0,{$4-1}
  --sin[-2,-1] -cos[-4,-3] -r[-4--1] $4,$3
  -*[-3] $2 -+[-3] $1 -*[-1] $2 -*[-4] [-3] -*[-3,-2]
  -y[-3--1] -a[-3--1] x

  # Primitives.
  1,$3,1,1,'y' -*[-1] $4 --shift[-1] 0,-1 $4,1,1,1,'x' --shift[-1] -1 -r[-4--1] $4,$3
  --+[-4,-1] -+[-2] [-4] -+[-5] [-3] -+[-4,-3] -y[-4--1] -i[-5] 1,{h},1,1,4 -a[-5--1] x

  # Colors / opacities.
  3,{h},1,1,200 1,{h},1,1,1 -y[-4--2] -a[-5--1] y
  -nm[-1] [3d\ torus]
  -v +

#@gmic triangle3d : x0,y0,z0,x1,y1,z1,x2,y2,z2
#@gmic : Input 3d triangle at specified coordinates.
#@gmic : $ -repeat 100 a={$>*pi/50} -triangle3d 0,0,0,0,0,3,{cos(3*$a)},{sin(2*$a)},0 -color3d[-1] @{-RGB} -done -add3d
triangle3d :
  -e[^-1] "Input 3d triangle ($1,$2,$3)-($4,$5,$6)-($7,$8,$9)."
  -v - 1,25,1,1,67.5,73.5,109.5,103.5,51.5,100.5,3,1,${1-9},3,0,1,2,200,200,200,1 -nm[-1] [3d\ triangle] -v +

#@gmic volume3d
#@gmic : Transform selected 3d volumetric images as 3d parallelepipedic objects.
#@gmic : $ image.jpg -animate blur,0,5,30 -a z -volume3d
volume3d :
  -e[^-1] "Transform image$? as 3d parallelepipedic objects."
  -v - -repeat @# -l[$>]
    w={w} h={h} d={d}
    --slices 0 --slices[0] 100% -mirror[-1] y
    --columns[0] 0 --columns[0] 100% -permute[-2,-1] zyxc -mirror[-2] x
    --rows[0] 0 --rows[0] 100% -permute[-2,-1] xzyc -mirror[-2] y
    -rm[0] -image6cube3d -*3d $w,$h,$d
  -endl -done -v +

#@gmic weird3d : _resolution>0
#@gmic : Input 3d weird object at (0,0,0), with specified resolution.
#@gmic : Default value: 'resolution=32'.
#@gmic : $ -weird3d 48 --primitives3d 1 -color3d[-2] @{-RGB}
weird3d : -skip ${1=32}
  -e[^-1] "Input 3d weird object, with resolution $1."
  -v -
  -isosurface3d "'\
    T = 1.61803399;\
    2 - (cos(x + T*y) + cos(x - T*y) + cos(y + T*z) + cos(y - T*z) + cos(z - T*x) + cos(z + T*x))\
    '",0,-4.7,-4.7,-4.7,4.7,4.7,4.7,$1,$1,$1
  -c3d[-1] -n3d[-1] -nm[-1] [3d\ weird]
  -v +

#-------------------------------
#
#@gmic :: Program control
#
#-------------------------------

#@gmic ap : eq. to '-apply_parallel'.
ap :
  -v - _gmic_s="$?" -v +
  -_apply_parallel "$*"

#@gmic apply_parallel : "command"
#@gmic : Apply specified command on each of the selected images, by parallelizing it for all image of the list.
#@gmic : (eq. to '-ap').
#@gmic : $ image.jpg --mirror x --mirror y -apply_parallel "-blur 3"
apply_parallel :
  -v - _gmic_s="$?" -v +
  -_$0 "$*"

_apply_parallel :
  -e[0--3] "Execute command '$*' on all image"$_gmic_s" in parallel, using "@*" threads."
  -v -
  -if {@#" && "narg("$*")}
    -m "_ap : -repeat @# -l[$>] $* -if @# -k[0] -else 0 -endif -endl -done"
    command=
    N={min(@#,@*)} S=0 sep=""
    -repeat $N
      E={round(($>+1)*@#/$N)-1}
      command=$command$sep-_ap[$S-$E]
      S={$E+1} sep=,
    -done
    -parallel $command
    -uncommand _ap
  -endif
  -v +

#@gmic apply_parallel_channels : "command"
#@gmic : Apply specified command on each of the selected images, by parallelizing it for all channel of the images independently.
#@gmic : $ image.jpg -apply_parallel_channels "-blur 3"
apply_parallel_channels :
  -e[^-1] "Execute command '$*' on all channels of image$? in parallel, using "@*" threads."
  -v - N=@# -repeat $N s$>=@{$>,s} -done -s c
  -ap "$1"
  -repeat $N -a[$>-{$>+${s$>}-1}] c -done -v +

#@gmic apply_parallel_overlap : "command",overlap[%],nb_threads={ 0=auto | 1 | 2 | 4 | 8 | 16 }
#@gmic : Apply specified command on each of the selected images, by parallelizing it on 'nb_threads' overlapped sub-images.
#@gmic : 'nb_threads' must be a power of 2.
#@gmic : Default values: 'overlap=0','nb_threads=0'.
#@gmic : $ image.jpg --apply_parallel_overlap "-smooth 500,0,1",16
apply_parallel_overlap : -check "${2=0}>=0 && isint(${3=0}) && $3>=0"
  -v - N={if($3,max(1,round($3)),@*)} N={2^int(log2(min(16,$N)))} -v +
  -e[^-1] "Apply parallelized command '$1' on image$?, with overlap $2 and "$N" threads."
  -v -
  -m "_check1 : -if {@#!=1} -error[0--9] \"Command '-apply_parallel_overlap': Specified command '$1' changes the size of the image stack.\" -endif"
  -repeat @# -l[$>]
    -_apply_parallel_overlap$N "$1",$2
  -endl -done
  -uncommand _check1
  -v +

_apply_parallel_overlap1 :
  $1

_apply_parallel_overlap2 :
  -if {w>=h}
    ovx={round(if(@{"-is_percent $2"},w*$2,$2))} w2={int(w/2)}
    --z[0] {$w2-$ovx},100% -z[0] 0,{$w2+$ovx-1}
    -parallel "-l[0] $1 -_check1 -endl","-l[1] $1 -_check1 -endl"
    -z[0] 0,@{0,w-1-$ovx} -z[1] $ovx,100% -a x
  -else
    ovy={round(if(@{"-is_percent $2"},h*$2,$2))} h2={int(h/2)}
    --rows[0] {$h2-$ovy},100% -rows[0] 0,{$h2+$ovy-1}
    -parallel "-l[0] $1 -_check1 -endl","-l[1] $1 -_check1 -endl"
    -rows[0] 0,@{0,h-1-$ovy} -rows[1] $ovy,100% -a y
  -endif

_apply_parallel_overlap4 :
  -if {max(w,h)/min(w,h)>=3}
    -_apply_parallel_overlap2 "-_apply_parallel_overlap2 \"$1\",$2",$2
  -else
    ovx={round(if(@{"-is_percent $2"},w*$2,$2))} w2={int(w/2)}
    ovy={round(if(@{"-is_percent $2"},h*$2,$2))} h2={int(h/2)}
    --z[0] {$w2-$ovx},0,100%,{$h2+$ovy-1} --z[0] 0,{$h2-$ovy},{$w2+$ovx-1},100%
    --z[0] {$w2-$ovx},{$h2-$ovy},100%,100% -z[0] 0,0,{$w2+$ovx-1},{$h2+$ovy-1}
    -parallel "-l[0] $1 -_check1 -endl","-l[1] $1 -_check1 -endl","-l[2] $1 -_check1 -endl","-l[3] $1 -_check1 -endl"
    -z[0] 0,0,@{0,w-1-$ovx},@{0,h-1-$ovy} -z[1] $ovx,0,100%,@{1,h-1-$ovy}
    -z[2] 0,$ovy,@{2,w-1-$ovx},100% -z[3] $ovx,$ovy,100%,100%
    -a[0,1] x -a[1,2] x -a y
  -endif

_apply_parallel_overlap8 :
  -_apply_parallel_overlap2 "-_apply_parallel_overlap4 \"$1\",$2",$2

_apply_parallel_overlap16 :
  -_apply_parallel_overlap2 "-_apply_parallel_overlap8 \"$1\",$2",$2

#@gmic check : expression : (+)
#@gmic : Evaluate specified expression and display an error message if evaluated to false.
#@gmic : If 'expression' is not evaluable, it is regarded as a filename and checked if it exists.

#@gmic check3d : _is_full_check={ 0 | 1 } : (+)
#@gmic : Check validity of selected 3d vector objects, and display an error message
#@gmic : if one of the selected image is not a valid 3d vector object.
#@gmic : Full 3d object check is slower but more precise.
#@gmic : Default value: 'is_full_check=1'.

#@gmic continue : (+)
#@gmic : Go to end of current block 'repeat..done', 'do..while' or 'local..endlocal'.
#@gmic : $ image.jpg -repeat 10 -blur 1 -if {1==1} -continue -endif -deform 10 -done

#@gmic break : (+)
#@gmic : Break current 'repeat..done', 'do..while' or 'local..endlocal' block.
#@gmic : $ image.jpg -repeat 10 -blur 1 -if {1==1} -break -endif -deform 10 -done

#@gmic do : (+)
#@gmic : Start a 'do..while' block.
#@gmic : $ image.jpg -luminance i={ia+2} -do -set 255,{?(100)}%,{?(100)}% -while {ia<$i}

#@gmic done : (+)
#@gmic : End a 'repeat..done' block, and go to associated '-repeat' position, if iterations remain.

#@gmic elif : boolean : filename : (+)
#@gmic : Start a 'elif..[else]..endif' block if previous '-if' was not verified
#@gmic : and test if specified boolean is true, or if specified filename exists.
#@gmic : 'boolean' can be a float number standing for { 0=false | other=true }.

#@gmic else : (+)
#@gmic : Execute following commands if previous '-if' or '-elif' conditions failed.

#@gmic endif : (+)
#@gmic : End a 'if..[elif]..[else]..endif' block.

#@gmic endl : eq. to '-endlocal'. : (+)

#@gmic endlocal : (+)
#@gmic : End a 'local..endlocal' block.
#@gmic : (eq. to '-endl').

#@gmic error : message : (+)
#@gmic : Print specified error message on the standard error (stderr) and exit interpreter, except
#@gmic : if error is caught by a '-onfail' command.
#@gmic : Command selection (if any) stands for displayed scope indices instead of image indices.

#@gmic x : eq. to '-exec'. : (+)

#@gmic exec : command : (+)
#@gmic : Execute external command using a system call.
#@gmic : The status value is then set to the error code returned by the system call.
#@gmic : (eq. to '-x').

#@gmic if : boolean : filename : (+)
#@gmic : Start a 'if..[elif]..[else]..endif' block and test if specified boolean is true,
#@gmic : or if specified filename exists.
#@gmic : 'boolean' can be a float number standing for { 0=false | other=true }.
#@gmic : $ image.jpg -if {ia<64} -add 50% -elif {ia<128} -add 25% -elif {ia<192} -sub 25% -else -sub 50% -endif -cut 0,255

#@gmic l : eq. to '-local'. : (+)

#@gmic local : (+)
#@gmic : Start a 'local..[onfail]..endlocal' block, with selected images.
#@gmic : (eq. to '-l').
#@gmic : $ image.jpg -local[] 300,300,1,3 -rand[0] 0,255 -blur 4 -sharpen 1000 -endlocal
#@gmic : $ image.jpg --local -repeat 3 -deform 20 -done -endlocal
#@gmic : $$

#@gmic mutex : indice,_action={ 0=unlock | 1=lock } : (+)
#@gmic : Lock or unlock specified mutex for multi-threaded programming.
#@gmic : A locked mutex can be unlocked only by the same thread. All mutexes are unlocked by default.
#@gmic : 'indice' designates the mutex indice, in [0,255].
#@gmic : Default value: 'action=1'.

#@gmic noarg : (+)
#@gmic : Used in a custom command, '-noarg' tells the command that its argument list have not been used
#@gmic : finally, and so they must be evaluated next in the G'MIC pipeline, just as if the custom
#@gmic : command takes no arguments at all.
#@gmic : Use this command to write a custom command which can decide if it takes arguments or not.

#@gmic onfail : (+)
#@gmic : Execute following commands when an error is encountered in the body of the 'local..endlocal' block.
#@gmic : The status value is set with the corresponding error message.
#@gmic : $ image.jpg --local -blur -3 -onfail -mirror x -endlocal

#@gmic parallel : _wait_threads,"command1","command2",... : (+)
#@gmic : Execute specified commands in parallel, each in a different thread.
#@gmic : Parallel threads share the list of images.
#@gmic : 'wait_threads' can be { 0=when current environment ends | 1=immediately }.
#@gmic : Default value: 'wait_threads=1'.
#@gmic : $ image.jpg [0] -parallel "-blur[0] 3","-mirror[1] c"

# The implementation below allows to use parallel as a regular command with selections.
parallel :
  -if {$1==0||$1==1||$1==2} -e[0--3] "Execute "{$#-1}" commands '${2--1}' in parallel on image$?."
  -else -e[0--3] "Execute "$#" commands '$*' in parallel on image$?."
  -endif
  -v - -parallel $"*" -v +

#@gmic progress : 0<=value<=100 : -1 : (+)
#@gmic : Set the progress indice of the current processing pipeline.
#@gmic : This command is useful only when G'MIC is used by an embedding application.

#@gmic q : eq. to '-quit'. : (+)

#@gmic quit : (+)
#@gmic : Quit interpreter.
#@gmic : (eq. to '-q').

#@gmic repeat : nb_iterations : (+)
#@gmic : Start iterations of a 'repeat..done' block.
#@gmic : $ image.jpg -split y -repeat @# -shift[$>] $<,0,0,0,2 -done -append y
#@gmic : $ image.jpg -mode3d 2 -repeat 4 -imagecube3d -rotate3d 1,1,0,40 -snapshot3d 400,1.4 -done
#@gmic : $$

#@gmic return : (+)
#@gmic : Return from current custom command.

#@gmic rprogress : 0<=value<=100 | -1 | "command",0<=value_min<=100,0<=value_max<=100
#@gmic : Set the progress indice of the current processing pipeline (relatively to
#@gmic : previously defined progress bounds), or call the specified command with
#@gmic : specified progress bounds.
rprogress : -skip ${2=""}
  -v -
  -if {!narg($_progress_bounds)} _progress_bounds=0,100 -endif
  m={arg(-2,$_progress_bounds)} M={arg(-1,$_progress_bounds)}
  -if {$#==2&&!narg($2)} # 1 argument -> Set progress bar.
    -v + -e[0--3] "Set relative progress indice to $1%." -v -
    -progress {if($1<0,-1,min(100,max(0,$m+($M-$m)*$1%)))}
  -elif {$#==3} # 3 arguments -> Call command with specified bounds.
    nm={min($2,$-1)} nM={max($2,$-1)}
    -v + -e[0--3] "Call command '$1' with progress bounds ["$nm,$nM"]." -v -
    -progress $m _progress_bounds=$_progress_bounds,{$m+$nm*($M-$m)/100},{$m+$nM*($M-$m)/100}  # Push new bounds.
    -_rprogress "$1"
    -progress $M ($_progress_bounds) _progress_bounds=@{-1,0--3} -rm[-1] # Pop bounds.
  -else -error[0--3] "Command '-rprogress': Invalid argument '$*'."
  -endif
  -v +

_rprogress : $*

#@gmic skip : item : (+)
#@gmic : Do nothing but skip specified item.

#@gmic u : eq. to '-status'. : (+)

#@gmic status : value : (+)
#@gmic : Set current status value. Used to define a returning value in a function.
#@gmic : (eq. to '-u').
#@gmic : $ image.jpg -command "foo : u0=Dark u1=Bright -status ${u{ia>=128}}" -text_outline @{-foo},2,2,23,2,1,255

#@gmic while : boolean : filename : (+)
#@gmic : End a 'do..while' block and go back to associated '-do'
#@gmic : if specified boolean is true or if specified filename exists.
#@gmic : 'boolean' can be a float number standing for { 0=false | other=true }.

#----------------------------------
#
#@gmic :: Arrays, tiles and frames
#
#----------------------------------

#@gmic array : M>0,_N>0,_expand_type={ 0=min | 1=max | 2=all }
#@gmic : Create MxN array from selected images.
#@gmic : Default values: 'N=M' and 'expand_type=0'.
#@gmic : $ image.jpg -array 3,2,2
array : -check "isint($1) && $1>0 && isint(${2=$1}) && $2>0" -skip ${3=0}
  -e[^-1] "Create $1x$2 array from image$?, with expand type $3."
  -v - r0={100/max($1,$2)} r1={100/min($1,$2)} r2=100
  -r ${r$3}%,${r$3}%,1,100%,2 -r {$1*100}%,{$2*100}%,1,100%,0,2 -v +

#@gmic array_fade : M>0,_N>0,0<=_fade_start<=100,0<=_fade_end<=100,_expand_type={0=min | 1=max | 2=all}
#@gmic : Create MxN array from selected images.
#@gmic : Default values: 'N=M', 'fade_start=60', 'fade_end=90' and 'expand_type=1'.
#@gmic : $ image.jpg -array_fade 3,2
array_fade : -skip ${2=$1},${3=60},${4=90},${5=1}
  -e[^-1] "Create $1x$2 array of ($3%,$4%) faded tiles from image$?, with expand type $5."
  -v - -repeat @# -l[$>] [-1] -shift[-2] 50%,50%,1,1,2 -fade_diamond $3,$4 -endl -done
  -array $1,$2,$5
  -v +

#@gmic array_mirror : N>=0,_dir={ 0=x | 1=y | 2=xy | 3=tri-xy },_expand_type={ 0 | 1 }
#@gmic : Create 2^Nx2^N array from selected images.
#@gmic : Default values: 'dir=2' and 'expand_type=0'.
#@gmic : $ image.jpg -array_mirror 2
array_mirror : -skip ${2=2},${3=0}
  -e[^-1] "Create a 2^$1x2^$1 mirrored-array from image$?, with expand type $2."
  -v - -repeat $1
    -if {$3==0}
      -if {$2>=3} -r 33%,33%,100%,100%,2
      -else -r 50%,50%,100%,100%,2
      -endif
    -endif
    -repeat @# -l[$>]
      -if {$2==0} --mirror x -a x
      -elif {$2==1} --mirror y -a y
      -else --mirror x -a x --mirror y -a y -if {$2==3} -r 150%,150%,1,100%,0,2,1,1 -endif
      -endif
    -endl -done
  -done -v +

#@gmic array_random : Ms>0,_Ns>0,_Md>0,_Nd>0
#@gmic : Create MdxNd array of tiles from selected MsxNs source arrays.
#@gmic : Default values: 'Ns=Ms', 'Md=Ms' and 'Nd=Ns'.
#@gmic : $ image.jpg --array_random 8,8,15,10
array_random : -skip ${2=$1},${3=$1},${4=$2}
  -e[^-1] "Create $3x$4 array of tiles from $1x$2 array$?."
  -v - -repeat @# -l[$>] nm=@{0,n}
    -split_tiles $1,$2
    -repeat $3 -repeat $4 [{?($1*$2-1)}] -done -done
    -rm[0-{$1*$2-1}] -append_tiles $3,$4
  -nm $nm,1 -endl -done -v +

#@gmic frame : eq. to '-frame_xy'.
frame : -skip ${2=$1}>=0,${3=255},${4=$3},${5=$4},${6=255}
  -v - _gmic_s="?" -v +
  -_frame_xy ${1--1}

#@gmic frame_blur : _sharpness>0,_size>=0,_smoothness,_shading,_blur
#@gmic : Draw RGBA-colored round frame in selected images.
#@gmic : Default values: 'sharpness=10', 'size=30', 'smoothness=0', 'shading=1' and 'blur=3%'.
#@gmic : $ image.jpg -frame_blur 3,30,8,10%
frame_blur : -skip ${1=10},${2=30},${3=0},${4=1},${5=3%}
  -e[^-1] "Draw round frame on image$?, with sharpness $1, size $2, smoothness $3, shading $4 and blur $5."
  -v - -to_rgba -repeat @# -l[$>] nm=@{0,n}
    100%,100%,1,1,"-(abs(x/w-0.5)^$1 + abs(y/h-0.5)^$1)^(1/$1)" ->=[-1] $2%
    -if $4 -distance[-1] 1 -n[-1] 0,1 -*[-1] -1 -+[-1] 1 -^[-1] {1/$4} -endif
    -b[-1] $3 --b[-2] $5 -mv[-1] -3 -blend_fade[0,1] [-1] -rm[-1]
  -nm $nm,1 -endl -done -v +

#@gmic frame_cube : _depth>=0,_centering_x,_centering_y,_left_side={0=normal | 1=mirror-x | 2=mirror-y | 3=mirror-xy},_right_side,_lower_side,_upper_side
#@gmic : Insert 3d frames in selected images.
#@gmic : Default values: 'depth=1', 'centering_x=centering_y=0' and 'left_side=right_side,lower_side=upper_side=0'.
#@gmic : $ image.jpg -frame_cube ,
frame_cube : -check "${1=1}>=0" -skip ${2=0},${3=0},${4=0},${5=0},${6=0},${7=0}
  -e[^-1] "Insert 3d frame in image$?, with depth $1, centering point ($2,$3) and orientations (${4--1})."
  -v - -repeat @# -l[$>] nm=@{0,n} -split_opacity
    -if {@#==2} -frame_cube ${1--1} -a c  # Manage image with alpha-channel.
    -else
      m={max(w,h)} w={w} h={h} s={s}
      -imageplane3d -c3d -/3d[-1] $w,$h,1
      --_frame_cube[0] $4 -r3d[-1] 0,1,0,90 -+3d[-1] -0.5,0,-0.5  # Left side.
      --_frame_cube[0] $5 -r3d[-1] 0,1,0,-90 -+3d[-1] 0.5,0,-0.5  # Right side.
      --_frame_cube[0] $6 -r3d[-1] 1,0,0,90 -+3d[-1] 0,0.5,-0.5   # Lower side.
      --_frame_cube[0] $7 -r3d[-1] 1,0,0,-90 -+3d[-1] 0,-0.5,-0.5 # Upper side.
      -+3d 0,0,1 -+3d -*3d $w,$h,$m  # Append sides together.
      f=1000
      cx=$2*$w/2*($f+$m*$1)/$f
      cy=$3*$h/2*($f+$m*$1)/$f
      -s3d -r[2] 3,{@{2,h}/3},1,1,-1
      -f[2] "if(i(2,y)<0.5,i,i+if(x==0,"$cx",if(x==1,"$cy",($1-1)*"$m")))"
      -y[2] -a y
      -*3d 2 {2*$w},{2*$h},1,$s -f3d {2*$f}
      -j3d[-1] [-2],50%,50%,0,1,2,0,0 -rm[-2]
      -r $w,$h,1,100%,2
    -endif
  -nm $nm,1 -endl -done
  -v +

_frame_cube :
  -if {$1==1} -r3d[-1] 0,1,0,180 -rv3d[-1]
  -elif {$1==2} -r3d[-1] 1,0,0,180 -rv3d[-1]
  -elif {$1==3} -r3d[-1] 0,0,1,180
  -endif

#@gmic frame_fuzzy : size_x[%]>=0,_size_y[%]>=0,_fuzzyness>=0,_smoothness[%]>=0,_R,_G,_B,_A
#@gmic : Draw RGBA-colored fuzzy frame in selected images.
#@gmic : Default values: 'size_y=size_x', 'fuzzyness=5', 'smoothness=1' and 'R=G=B=A=255'.
#@gmic : $ image.jpg -frame_fuzzy 20
frame_fuzzy : -skip ${2=$1},${3=5},${4=1},${5=255},${6=$5},${7=$6},${8=255}
  -e[^-1] "Draw $1x$2 fuzzy frame on image$?, with fuzzyness $3, smoothness $4 and RGBA color ($5,$6,$7,$8)."
  -v - -to_rgba -repeat @# -l[$>]
    100%,100%,1,1,1
    padx={if(@{"-is_percent $1"},$1*(w-1)/2,$1)}
    pady={if(@{"-is_percent $2"},$2*(h-1)/2,$2)}
    -rectangle[-1] $padx,$pady,{w-1-$padx},{h-1-$pady}
    -spread[-1] $3 -b[-1] $4 100%,100%,1,4 -fc[-1] ${5-8}
    -j[0] [2],0,0,0,0,1,[1] -k[0]
  -endl -done -v +

#@gmic frame_painting : _size[%]>=0,0<=_contrast<=1,_profile_smoothness[%]>=0,_R,_G,_B,_vignette_size[%]>=0,_vignette_contrast>=0,_defects_contrast>=0,0<=_defects_density<=100,_defects_size>=0,_defects_smoothness[%]>=0,_serial_number
#@gmic : Add a painting frame to selected images.
#@gmic : Default values: 'size=10%', 'contrast=0.4', 'profile_smoothness=6%', 'R=225', 'G=200', 'B=120', 'vignette_size=2%', 'vignette_contrast=400', 'defects_contrast=50', 'defects_density=10', 'defects_size=1', 'defects_smoothness=0.5%' and 'serial_number=123456789'.
#@gmic : $ image.jpg -frame_painting ,
frame_painting :
  -check "${1=10%}>=0 && ${2=0.4}>=0 && $2<=1 && ${3=6%}>=0 && ${7=2%}>=0 && ${8=400}>=0 && ${9=50}>=0 && ${10=10}>=0 && $10<=100 && ${11=1}>=0 && ${12=0.5%}>=0"
  -skip ${4=225},${5=200},${6=120},${13=123456789}
  -e[^-1] "Add painting frame to image$?, with size $1, contrast $2, profile smoothness $3, color (${4-6}), vignette size $7, "\
          "vignette strength $8, defects contrast $9, defects density $10, defects size $11, defects smoothness $12 and serial number $13."
  -v - -repeat @# -l[$>]
    -if {!$1} -return -endif
    $1,$1 s={max(w,h)} -rm[-1]                                # Determine size of the frame.
    ({'@{-dec2bin\ $13}'}) --[-1] {'0'} -r[-1] $s             # Generate frame profile from serial number.
    -transpose[-1] -b[-1] $3 -n[-1] {1-$2},{1+$2}
    --r[-1] {@{-2,w}+2*$s},100%,1,1                           # Upper frame.
    --mirror[-1] y                                            # Lower frame.
    -mv[-3] @# -transpose[-1] -r[-1] 100%,{@{-4,h}+2*$s},1,1  # Left frame.
    --mirror[-1] x                                            # Right frame.
    [-3],[-3],1,1,1 -polygon[-1] 3,0,0,{$s-1},{$s-1},0,{$s-1},1,0 -polygon[-1] 3,100%,0,{w-$s},100%,100%,100%,1,0 # Upper/lower mask.
    [-2],[-2],1,1,1 -polygon[-1] 3,1,0,100%,{$s-2},100%,0 -polygon[-1] 3,1,100%,100%,{h-$s+1},100%,100%,1,0 # Left/right mask.
    -_frame_painting[-6--3] ${4-6},${9-12}                    # Add colors + defects.

    # Build full frame picture.
    {@{-7,w}+2*$s},{@{-7,h}+2*$s},1,3
    -j[-1] [-7],0,0,0,0,1,[-3],1 -rm[-7] -mirror[-3] y
    -j[-1] [-6],0,{h-$s},0,0,1,[-3],1 -rm[-6,-3]
    -j[-1] [-4],0,0,0,0,1,[-2],1 -rm[-4] -mirror[-2] x
    -j[-1] [-3],{w-$s},0,0,0,1,[-2],1 -rm[-3,-2]
    [-2],[-2],1,1,-255 -r[-1] [-2],[-2],1,1,0,0,0.5,0.5 -+[-1] 255 --b[-1] $7 -n[-1] 0,$8 -max[-2,-1] -c[-1] 0,255 # Frame opacity.
    -a[-2--1] c
    -r[-2] [-1],[-1],1,100%,0,0,0.5,0.5 -blend alpha # Insert initial image into frame picture.
  -endl -done -v +

_frame_painting : # Add color + texture to each frame part.
  -repeat @# -l[$>]
    --*[-1] $2 --*[-2] $3 -*[-3] $1 -a[-3--1] c
    100%,100%
    i=0 -do -rand[-1] 0,1 -remove_pixels[-1] {100-$5}% -b[-1] $6 ->=[-1] 50% i={$i+1} -while {"m=$5/200;(ia<m-0.2 || ia>m+0.2) && "$i"<10"}
    -b[-1] $7 -g[-1] -+[-2,-1] -n[-1] -$4,$4
    -+[-2,-1] -c[-1] 0,255
  -endl -done

#@gmic frame_pattern : M>=3,_constrain_size={ 0 | 1 } : M>=3,_[frame_image],_constrain_size={ 0 | 1 }
#@gmic : Insert selected pattern frame in selected images.
#@gmic : Default values: 'pattern=0' and 'constrain_size=0'.
#@gmic : $ image.jpg -frame_pattern 8
frame_pattern : -check $1>=3 -skip ${2=0},${3=}
  -v - -to_colormode 0
  -if @{"-is_image_arg $2"} # Frame from specified image.
    -v + -e[^-1] "Insert $1x$1 pattern frame on image$?, using frame image$2." -v -
    -pass$2 0 -repeat {@#-1} -l[$>,-1]
      wh=@{0,w},@{0,h}
      --r[1] @{0,w/($1-2)},@{0,h/($1-2)},1,100%,2
      -r[0] {@{0,w}+2*w},{@{0,h}+2*h},1,100%,0,0,0.5,0.5
      [-1]x{$1+2} -a[{-$1-2}--1] x -j[0] [-1],0,0 -j[0] [-1],0,{@{0,h}-1-h} -rm[-1]
      [-1]x{$1+1} -a[{-$1-2}--1] y -j[0] [-1],0,0 -j[0] [-1],{@{0,w}-1-w} -rm[-1]
      -if $3 -r[0] $wh,1,100%,2 -endif
    -endl -done -rm[-1]
  -else # Self-frame.
    -v + -e[^-1] "Insert $1x$1 self-pattern frame on image$?." -v -
    -repeat @# -l[$>]
      wh={w},{h}
      --r {w/($1-2)},{h/($1-2)},1,100%,2 -r[-2] {$1*w},{$1*h},1,100%,0,0,0.5,0.5
      [-1]x{$1+2} -a[{-$1-2}--1] x -j[-3] [-1],0,0 -j[-3] [-1],0,{@{-3,h}-1-h} -rm[-1]
      [-1]x{$1+1} -a[{-$1-2}--1] y -j[-2] [-1],0,0 -j[-2] [-1],{@{-2,w}-1-w} -rm[-1]
      -if $3 -r $wh,1,100%,2 -endif
    -endl -done
  -endif
  -v +

#@gmic frame_round : _sharpness>0,_size>=0,_smoothness,_shading,_R,_G,_B,_A
#@gmic : Draw RGBA-colored round frame in selected images.
#@gmic : Default values: 'sharpness=10', 'size=10', 'smoothness=0', 'shading=0' and 'R=G=B=A=255'.
#@gmic : $ image.jpg -frame_round 10
frame_round : -skip ${1=10},${2=10},${3=0},${4=0},${5=255},${6=$5},${7=$6},${8=255}
  -e[^-1] "Draw round frame on image$?, with sharpness $1, size $2, smoothness $3, shading $4 and RGBA color ($5,$6,$7,$8)."
  -v - -to_rgba -repeat @# -l[$>] nm=@{0,n}
    100%,100%,1,1,"-(abs(x/w-0.5)^$1 + abs(y/h-0.5)^$1)^(1/$1)" ->=[-1] $2%
    -if $4 -distance[-1] 1 -n[-1] 0,1 -*[-1] -1 -+[-1] 1 -^[-1] {1/$4} -endif
    -b[-1] $3 -i[-3] 100%,100%,1,4 -fc[-3] $5,$6,$7,$8 -blend_fade[0,1] [-1] -rm[-1]
  -nm $nm,1 -endl -done -v +

#@gmic frame_x : size_x[%],_col1,...,_colN
#@gmic : Insert colored frame along the x-axis in selected images.
#@gmic : Default values: 'col1=col2=col3=255' and 'col4=255'.
#@gmic : $ image.jpg -frame_x 20,255,0,255
frame_x : -skip ${2=255},${3=$2},${4=$3},${5=255}
  -e[^-1] "Insert $1 outer frame in image$? along the x-axis, with color (${2--1})."
  -_frame $1,0,0,${2--1}

#@gmic frame_xy : size_x[%],_size_y[%],_col1,...,_colN
#@gmic : Insert colored frame along the x-axis in selected images.
#@gmic : Default values: 'size_y=size_x', 'col1=col2=col3=255' and 'col4=255'.
#@gmic : (eq. to '-frame').
#@gmic : $ image.jpg -frame_xy 1,1,0 -frame_xy 20,10,255,0,255
frame_xy : -skip ${2=$1},${3=255},${4=$3},${5=$4},${6=255}
  -v - _gmic_s="$?" -v +
  -_$0 ${1--1}

_frame_xy :
  -e[0--3] "Insert $1x$2 outer frame in image"$_gmic_s" along the xy-axes, with color (${3--1})."
  -_frame $1,$2,0,${3--1}

#@gmic frame_xyz : size_x[%],_size_y[%],_size_z[%]_col1,...,_colN
#@gmic : Insert colored frame along the x-axis in selected images.
#@gmic : Default values: 'size_y=size_x=size_z', 'col1=col2=col3=255' and 'col4=255'.
frame_xyz : -skip ${2=$1},${3=$2},${4=255},${5=$4},${6=$5},${7=255}
  -e[^-1] "Insert $1x$2x$3 outer frame in image$? along the xyz-axes, with color (${4--1})."
  -_frame $1,$2,$3,${4--1}

#@gmic frame_y : size_y[%],_col1,...,_colN
#@gmic : Insert colored frame along the y-axis in selected images.
#@gmic : Default values: 'col1=col2=col3=255' and 'col4=255'.
#@gmic : $ image.jpg -frame_y 20,255,0,255
frame_y : -skip ${2=255},${3=$2},${4=$3},${5=255}
  -e[^-1] "Insert $1 outer frame in image$? along the y-axis, with color (${2--1})."
  -_frame 0,$1,0,${2--1}

_frame :
  -v - -repeat @# -l[$>]
    name=@{0,n}
    w={round($1*if(@{-is_percent\ $1},w,1))}
    h={round($2*if(@{-is_percent\ $2},h,1))}
    d={round($3*if(@{-is_percent\ $3},d,1))}
    {w+2*$w},{h+2*$h},{d+2*$d},100% -fc[1] ${4--1}
    -j[1] [0],$w,$h,$d -rm[0] -nm $name
  -endl -done -v +

#@gmic img2ascii : _charset,_analysis_scale>0,_analysis_smoothness[%]>=0,_synthesis_scale>0,_output_ascii_filename
#@gmic : Render selected images as binary ascii art.
#@gmic : This command returns the corresponding the list of widths and heights (expressed as a number of characters) for each selected image.
#@gmic : Default values: 'charset=[ascii charset]', 'analysis_scale=16', 'analysis_smoothness=20%', 'synthesis_scale=16' and '_output_ascii_filename=[undefined]'.
#@gmic : $ image.jpg --img2ascii , -r[0] [1],[1],1,3 --mul
img2ascii : -skip "${1= !\042\#$%&\047()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\133\\\135^_\140abcdefghijklmnopqrstuvwxyz\173|\174~}","${5=}" -check "${2=16}>0 && ${3=20%}>=0 && ${4=16}>0"
  -e[^-1] "Render image$? as binary ascii art, with charset '$1', analysis scale $2, analysis smoothness $3, synthesis scale $4 and output ascii filename '$5'."
  -v -
  is_multi={@#>1}

  # Generate dictionnaries for image analysis and synthesis.
  -l[]
    ({'"$1"'}) -repeat {w}
      C={`92`}@{-dec2oct\ @{0,$>}}
      0 -t[-1] $C,0,0,$2,1,1
      0 -t[-1] $C,0,0,$4,1,1
    -done -rm[0]
    -= -1 -= -1,0,100% -autocrop -= 0 -= 0,0,100%
    -l[0--2:2] -r {@{-max_w}+1},100%,1,1,0,0,0.5 -b $3 -n 0,255 -a z -endl
    -l[1--1] -r {@{-max_w}+1},100%,1,1,0,0,0.5 -a z -endl
  -endl
  w=@{-2,w} h=@{-2,h}

  # Transform selected image to ascii art.
  -repeat {@#-2} -l[$>,-2,-1]
    -luminance[0] -n[0] 0,255
    nw=@{0,round(w/$w,1,1)}
    nh=@{0,round(h/$h,1,1)}
    -if $> list_wh=$list_wh,$nw,$nh -else list_wh=$nw,$nh -endif

    -s[0] y,-$h -s[0--3] x,-$w -r[0--3] $w,$h,1,1,0,0
    -repeat {@#-2} -l[$>,-2,-1]
      -rprogress {$>*100/(@#-2)}
      -r[0] [1] --[0] [1] -sqr[0] -r[0] 1,1,100%,1,2 -y[0]
      C=@{0,ym} -rm[0]
      --slices[1] $C -mv[-1] 0
      -if {narg("$5")} --f[0] $C -a[0,-1] c -endif
    -endl -done
    -append_tiles[0--2] $nw,$nh

    -if {narg("$5")} -s[0] c -l[1]  # Export as ascii file.
       -r $nw,$nh,1,1,1
       ({'"$1"'}) -map[0] [-1] -k[0]
       -s y -i[1-@#] ({'\n'})
       -a x
       -if $is_multi filename=@{-filename\ "$5",$>} -else filename="$5" -endif
       -o raw:$filename,char -rm
    -endl -endif

  -endl -done
  -rm[-2,-1] -u $list_wh -v +

#@gmic imagegrid : M>0,_N>0
#@gmic : Create MxN image grid from selected images.
#@gmic : Default value: 'N=M'.
#@gmic : $ image.jpg -imagegrid 16
imagegrid : -skip ${2=$1}
  -e[^-1] "Create $1x$2 image grid from image$?."
  -v - -repeat @# -l[$>]
    ({w},{h}) ($1,$2) -/[-2,-1] -round[-1] 1 -r[-2] @-1,[-2],[-2],2 -rm[-1]
    ({w},{h}) ($1,$2) -*[-2,-1] -r[-2] @-1,[-2],[-2],2 -rm[-1]
    $1,$2,1,[-1],1 -shift[-1] 1,1 -r[-1] [-2],0,2 -*
  -endl -done -v +

#@gmic imagegrid_hexagonal : _resolution_y>0,1<=_outline<=0,_is_antialiasing={ 0 | 1 }
#@gmic : Create hexagonal grids from selected images.
#@gmic : Default values: 'resolution_y>0', 'outline=0.1' and 'is_antialiasing=1'.
imagegrid_hexagonal : -check "isint(${1=32}) && $1>0 && ${2=0.1}>=0 && $2<=1" -skip ${3=1}
  -v - s0="" s1="no " -v +
  -e[^-1] "Create hexagonal grid(s) from image$?, with resolution $1, outline $2 and "${s{!$3}}"anti-aliasing."
  -v - -repeat @# -l[$>]

    # Generate hexagonal grid.
    -l[]
      # Generate hexagon.
      ({'CImg3d'},6,6)
      (0;{2*pi}) --[-1] {pi/2} -r[-1] 1,7,1,1,3 --sin[-1] -cos[-2] -a[-2,-1] x -rows[-1] 0,5 -z[-1] 0,2
      2,6,1,1,3,0 1,100%,1,1,y --+[-1] 1 -%[-1] 6 -rv[-2,-1] -a[-3--1] x
      3,100%,1,1,1 1,100%,1,1,1 -y -a y
      -*3d[-1] {1-$2}

      # Generate minimal pattern (2x2 hexagons).
      --+3d {sqrt(3)} --+3d {sqrt(3)/2},1.5
      -col3d[-3] 2 -col3d[-2] 3 -col3d[-1] 4 -+3d
      -/3d 1.5
    -endl

    # Duplicate it to get a grid with correct size.
    ny={1+round(0.5*$1,1,1)}
    nx=@{0,1+round($1*w/h*3/(sqrt(3)*4),1,1)}
    -array3d[-1] $nx,$ny,1,{4*sqrt(3)/3},2
    -c3d[-1] -*3d[-1] @{0,h/$1}

    # Fill grid with image colors.
    -if $3 -r[0] 200%,200% -*3d[-1] 2 -endif
    [0],[0] -j3d[-1] [-2],50%,50%,0,1,2,0,0 -rm[-2]
    -blend shapeaverage0
    -if $3 -r 50%,50%,1,100%,2 -endif

  -endl -done -v +

#@gmic linearize_tiles : M>0,_N>0
#@gmic : Linearize MxN tiles on selected images.
#@gmic : Default value: 'N=M'.
#@gmic : $ image.jpg --linearize_tiles 16
linearize_tiles : -check "$1>0 && ${2=$1}>0"
  -e[^-1] "Linearize $1x$2 tiles on image$?."
  -v - -repeat @# -l[$>] nm=@{0,n}
    s={s} -split_tiles $1,$2 -s c # Split as tiles for all channels.
    -repeat @# -l[$>]
      wh={w},{h}
      --f x --f[-1] y --f[-1] 1 -y -a[^0] x -solve[-2] [-1] -rm[-1]
      $wh,1,1,@{-1,0}"*x + "@{-1,1}"*y + "@{-1,2} -rm[-2]
    -endl -done
    -repeat {int(@#/$s)} -a[-$s--1] c -mv[-1] 0 -done -append_tiles $1,$2
  -nm $nm,1 -endl -done -v +

#@gmic map_sprites : _nb_sprites>=1,_allow_rotation={ 0=none | 1=90 deg. | 2=180 deg. }
#@gmic : Map set of sprites (defined as the 'nb_sprites' latest images of the selection) to other selected images,
#@gmic : according to the luminosity of their pixel values.
#@gmic : $ image.jpg -r2dy 48 -repeat 16 -ball {8+2*$>},@{-RGB} -*[-1] {(1+$>)/16} -done -map_sprites 16
map_sprites : -check "isint($1) && $1>0 && isint(${2=0}) && $2>=0 && $2<=2"
  -e[^-1] "Map set of $1 sprites to image selection$?."
  -v - -norm[0--{$1+1}] -quantize[0--{$1+1}] $1,0,1
  -slices[-$1--1] 0 -r[-$1--1] @{-max_wh[-$1--1]},1,100%,0,0,0.5,0.5
  -if {$2==1}
    N={4*$1}
    -repeat {@#-$1} -*[$>] 4 --rand[$>] 0,3 -round[-1] -+[$>,-1] -done
    -repeat $1 -l[{1+$<}] --mirror xy --rotate 90 -endl -done
  -elif {$2==2}
    N={2*$1}
    -repeat {@#-$1} -*[$>] 2 --rand[$>] 0,1 -round[-1] -+[$>,-1] -done
    -repeat $1 -l[{1+$<}] --mirror xy -endl -done
  -else N=$1 -endif
  -r[-$N--1] 100%,100%,1,@{-max_s[-$N--1]} w={w} h={h} -a[-$N--1] x
  -r[^-1] ${w}00%,${h}00%,1,1 -*[^-1] $w
  (0,{$w-1};0,{$w-1}^0,0;{$h-1},{$h-1}) -r[-1] $w,$h,1,2,3 -round[-1]
  -repeat {@#-2} --r[-1] [$>],[$>],1,2,0,2 -r[$>] 100%,100%,1,2,0 -+[$>,-1] --warp[-2] [$>],0,0 -rv[$>,-1] -rm[-1] -done -rm[-2,-1] -v +

#@gmic puzzle : _width>0,_height>0,_M>=1,_N>=1,_curvature,_centering,_connectors_variability,_resolution>=1
#@gmic : Input puzzle binary mask with specified size and geometry.
#@gmic : Default values: 'width=height=512', 'M=N=5', 'curvature=0.5', 'centering=0.5', 'connectors_variability=0.5' and 'resolution=64'.
#@gmic : $ -puzzle ,
puzzle : -check "isint(${1=512}) && $1>0 && isint(${2=$1}) && $2>0 && isint(${3=5}) && $3>0 && isint(${4=$3}) && $4>0 && isint(${8=64}) && $8>0"
         -skip ${5=0.5},${6=0.5},${7=0.5}
  -e[^-1] "Draw $3x$4 puzzle pattern on image$?, with curvature $5, centering $6, connectors variability $7 and resolution $8."
  -v - -l[]
    -if {$4>=2} -_puzzle[] $3,{$4-1},${5-8} -+3d[-1] 0,1 -endif
    -if {$3>=2} -_puzzle[] $4,{$3-1},${5-8} -r3d[-1] 0,0,1,90 -+3d[-1] 1,$4 -endif
    -*3d {$1/$3},{$2/$4} -quadrangle3d 0,0,0,{$1-1},0,0,{$1-1},{$2-1},0,0,{$2-1},0 -p3d[-1] 1 -+3d -col3d 1
    $1,$2 -j3d[-1] [-2],0,0,0,1,1,0,0 -rm[-2]
  -endl -v +

_puzzle :
  R={$6*$1}
  -repeat $2
    ({'CImg3d'},$R,{$R-1})
    -repeat $1
      sign={if(?<=0.5,-1,1)}
      center={$4*?(-0.25,0.25)}
      knob={$5*?(-0.05,0.12)}
      ($>,0;\
       {0.2+$center+$>},{-$sign*$3*0.1};\
       {0.4+$center+$>},0;\
       {0.35+$center+$>},{0.1*$sign};\
       {0.45+$center+$>},{(0.15+$knob)*$sign};\
       {0.55+$center+$>},{(0.15+$knob)*$sign};\
       {0.65+$center+$>},{0.1*$sign};\
       {0.6+$center+$>},0;\
       {0.8+$center+$>},{-$sign*$3*0.1})
    -done
    ($1,0) -a[-{$1+1}--1] y -r[-1] 2,$R,1,1,5 -z[-1] 0,2
    (2,0,1;2,{$R-2},{$R-1}) -r[-1] 3,{$R-1},1,1,3 -round[-1]
    3,{h},1,1,255 1,{h},1,1,255 -y[-5--1] y -a[-5--1] y -+3d[-1] 0,$>
  -done -+3d

#@gmic quadratize_tiles : M>0,_N>0
#@gmic : Quadratize MxN tiles on selected images.
#@gmic : Default value: 'N=M'.
#@gmic : $ image.jpg --quadratize_tiles 16
quadratize_tiles : -check "$1>0 && ${2=$1}>0"
  -e[^-1] "Quadratize $1x$2 tiles on image$?."
  -v - -repeat @# -l[$>] nm=@{0,n}
    s={s} -split_tiles $1,$2 -s c # Split as tiles for all channels.
    -repeat @# -l[$>]
      wh={w},{h}
      --f x^2 --f[-1] y^2 --f[-1] x*y --f[-1] x --f[-1] y --f[-1] 1 -y -a[^0] x
      -solve[-2] [-1] -rm[-1]
      $wh,1,1,@{-1,0}"*x^2 + "@{-1,1}"*y^2 + "@{-1,2}"*x*y +"@{-1,3}"*x + "@{-1,4}"*y + "@{-1,5} -rm[-2]
    -endl -done
    -repeat {int(@#/$s)} -a[-$s--1] c -mv[-1] 0 -done -append_tiles $1,$2
  -nm $nm,1 -endl -done -v +

#@gmic rotate_tiles : angle,_M>0,N>0
#@gmic : Apply MxN tiled-rotation effect on selected images.
#@gmic : Default values: 'M=8' and 'N=M'.
#@gmic : $ image.jpg -to_rgba -rotate_tiles 10,8 -drop_shadow 10,10 -display_rgba
rotate_tiles : -skip ${2=8},${3=$2}
  -e[^-1] "Apply $2x$3 tiled-rotation effect on image$?, with angle $1 deg."
  -v - -split_tiles $2,$3,1 -rotate $1 -append_tiles $2,$3 -v +

#@gmic shift_tiles : M>0,_N>0,_amplitude
#@gmic : Apply MxN tiled-shift effect on selected images.
#@gmic : Default values: 'N=M' and 'amplitude=20'.
#@gmic : $ image.jpg --shift_tiles 8,8,10
shift_tiles : -check "${2=$1}>=0" -skip ${3=20}
  -e[^-1] "Apply $1x$2 tiled-shift effect on image$?, with amplitude $3."
  -v - -repeat @# -l[$>]
    $1,$2,1,2 -noise[-1] $3 -r[-1] [-2],[-2],1,2 -warp[-2] [-1],1,1,0 -rm[-1]
  -endl -done -v +

#@gmic taquin : M>0,_N>0,_remove_tile={ 0=none | 1=first | 2=last | 3=random },_relief,_border_thickness[%],_border_outline[%],_outline_color
#@gmic : Create MxN taquin puzzle from selected images.
#@gmic : Default value: 'N=M', 'relief=50', 'border_thickness=5', 'border_outline=0' and 'remove_tile=0'.
#@gmic : $ image.jpg --taquin 8
taquin : -check "isint($1) && $1>0 & isint(${2=$1}) && $2>0" -skip ${3=0},${4=50},${5=5%},${6=0},${7=0},${8=$7},${9=$8},${10=255}
 -e[^-1] "Create $1x$2 taquin puzzle from image $?, with relief $4, border thickness $5, border outline $6 and outline color (${7--1})."
 -v - -repeat @# -l[$>] nm=@{0,n}
   -split_tiles $1,$2 -r @{-min_wh},100%,100%,0
   100%,100%,1,1,1
   -if @{"-is_percent $5"} -rectangle[-1] {100*$5/2}%,{100*$5/2}%,{100-50*$5}%,{100-50*$5}%,1,0
   -else -rectangle[-1] $5,$5,{w-1-$5},{h-1-$5},1,0 -endif
   -*[-1] '1-2*(x<y)' -*[-1] $4
   -repeat {@#-1} -l[$>,-1] -split_opacity[0] -+[0] [-1] -a[^-1] c -endl -done -rm[-1] -c 0,255
   -frame $6,$6,${7-10}
   -if {$3==3} -f[-1] 0 -endif
   -repeat @# -mv[$>] {?(@#)} -done
   -if {$3==1} -f[0] 0 -elif {$3==2} -f[-1] 0 -endif
   -append_tiles $1,$2
 -nm $nm,1 -endl -done -v +

#@gmic tunnel : _level>=0,_factor>0,_centering_x,_centering_y,_opacity,_angle
#@gmic : Apply tunnel effect on selected images.
#@gmic : Default values: 'level=9', 'factor=80%', 'centering_x=centering_y=0.5', 'opacity=1' and 'angle=0'
#@gmic : $ image.jpg --tunnel 20
tunnel : -check "${1=9}>=0 && ${2=80%}>0" -skip ${3=0.5},${4=0.5},${5=0.1},${6=0}
  -e[^-1] "Apply tunnel effect on image$?, with depth $1, factor $2, centering ($3,$4), opacity $5 and angle $6."
  -v - -repeat @# -l[$>]
    -repeat $1 --r[-1] $2,$2,1,100%,5
    -if $6 100%,100%,1,1,1 -rotate[-2,-1] $6,1,0 -erode[-1] 3 -j[-3] [-2],{(@{-3,w}-w)*$3},{(@{-3,h}-h)*$4},0,0,$5,[-1] -rm[-2,-1]
    -else -j[-2] [-1],{(@{-2,w}-w)*$3},{(@{-2,h}-h)*$4},0,0,$5 -rm[-1] -endif
    -done
  -endl -done -c 0,255 -v +

#-----------------------------
#
#@gmic :: Artistic
#
#-----------------------------

#@gmic boxfitting : _min_box_size>=1,_max_box_size>=0,_initial_density>=0,_nb_attempts>=1
#@gmic : Apply box fitting effect on selected images, as displayed the web page:
#@gmic : [http://www.complexification.net/gallery/machines/boxFittingImg/]
#@gmic : Default values: 'min_box_size=1', 'max_box_size=0', 'initial_density=0.1' and 'nb_tries=3'.
#@gmic : $ image.jpg --boxfitting ,
boxfitting : -check "isint(${1=3}) && $1>=1 && isint(${2=0}) && $2>=0 && ${3=0.1}>=0 && isint(${4=3}) && $4>=1"
  -e[^-1] "Apply box fitting effect on image$?, with box sizes ($1,$2), density $3 and $4 attempts."
  -v -
  min_size=$1
  max_size={if($2,$2,max(w,h))}
  -repeat @# -l[$>]
    nb_attempts=0 prec=5
    100%,100%
    -repeat 1e8

      # Add random non-intersecting squares with min size.
      -if {$><1} # Takes random points for the first iteration.
        100%,100% -noise[-1] {max(1e-3,$3)},2
      -else # Then, try to take points near the median axis of the distance function otherwise.
        --distance[-1] 1 --rand[-1] 0,1 -*[-2,-1] -max_patch[-1] {round($prec*$min_size)}
        prec={max(1,$prec*0.9)}
      -endif

      # Discard new squares that intersect something.
      -dilate[-1] $min_size -area_fg[-1] 0,1 -==[-1] {($min_size)^2}
      --dilate[-2] 3 -==[-1] 0 -*[-2,-1] -area_fg[-1] 0,1 -==[-1] {($min_size)^2}
      -if {!iM} nb_attempts={$nb_attempts+1} -if {$nb_attempts>$4} -rm[-1] -break -endif # If no new squares have been placed.
      -else nb_attempts=0 -endif
      -+[-2,-1]

      # Make current squares grown until max square size is reached.
      -repeat {int(($max_size-$min_size)/2)}
        --dilate[-1] 3 -area_fg[-1] 0,1 -==[-1] {($min_size+2*$>+2)^2}
        -if {!iM} -rm[-1] -break -endif  # No more squares to grow.
        -or[-2,-1]
      -done

    -done
    -blend shapeaverage0
  -endl -done -v +

#@gmic cartoon : _smoothness,_sharpening,_threshold>=0,_thickness>=0,_color>=0,quantization>0
#@gmic : Apply cartoon effect on selected images.
#@gmic : Default values: 'smoothness=3', 'sharpening=150', 'threshold=20', 'thickness=0.25', 'color=1.5' and 'quantization=8'.
#@gmic : $ image.jpg --cartoon 3,80,15
cartoon : -skip ${1=3},${2=150},${3=20},${4=0.25},${5=1.5},${6=8}
  -e[^-1] "Apply cartoon effect on image$?, with smoothness $1, sharpening $2, threshold $3, thickness $4, color $5 and quantization $6."
  -v - -repeat @# -l[$>] -split_opacity -l[0] -to_rgb
    -b $1 -sharpen $2,1 -c 0,255 -n 0,255
    --edges $3 -b[-1] $4 ->=[-1] 0.9
    -rgb2lab[-2] -s[-2] c -*[-3,-2] $5 -a[-4--2] c -lab2rgb[-2] -quantize[-2] $6,1,0 -n[-2] 0,255 -*
  -endl -a c -endl -done -v +

#@gmic circlism : _radius_min>0,_radius_max>0,_smoothness[%]>=0,_radius_linearity>=0,_location_linearity>=0,_shape={0=squares | 1=diamonds | 2=circle }
#@gmic : Apply circlism effect on selected images (effect inspired by Ben Heine).
#@gmic : Default values: 'radius_min=2', 'radius_max=20', 'smoothness=1', 'radius_linearity=0.4', 'location_linearity=3' and 'shape=1'.
#@gmic : $ image.jpg --circlism ,
circlism : -check "${1=2}>0 && ${2=20}>0 && ${3=1}>=0 && ${4=0.4}>0 && ${5=3}>=0" -skip ${6=2}
  -e[^-1] "Apply circlism effect on image$?, with radii ($1,$2), smoothness $3, radius linearity $4 and location linearity $5.\n"
  -v - -repeat @# -l[$>]
    --gradient_norm -b[-1] $3 -n[-1] 0,1 --^[-1] $5 -^[-2] $4 sumg0=@{-1,+} 100%,100%
    it=0 failed=0 noedges=0 svg="-1,-1"
    -do
      --distance[-1] 1,3
      -if $noedges xyzc=@{-1,C} -else --*[-3,-1] xyzc=@{-1,C} -rm[-1] -endif
      n=@{-4,($xyzc)}
      x={arg(1,$xyzc)}
      y={arg(2,$xyzc)}
      r={min(max($1,$2*(1-$n)),sqrt(@{-1,($xyzc)})-2)}
      -rm[-1]
      -if {$r>=$1}
        -if {$6==2}  # Fill with circles.
          -ellipse[-1] $x,$y,$r,$r,0,1,1 -ellipse[-2] $x,$y,{$r+$1},{$r+$1},0,1,-1
        -elif {$6==1} # Fill with squares.
          x0={$x-$r/2} y0={$y-$r/2} x1={$x+$r/2} y1={$y+$r/2}
          -rectangle[-1] $x0,$y0,$x1,$y1,1,1
          x0={$x-($r+$1)/2} y0={$y-($r+$1)/2} x1={$x+($r+$1)/2} y1={$y+($r+$1)/2}
          -rectangle[-2] $x0,$y0,$x1,$y1,1,-1
        -else # Fill with diamonds.
          x0={round($x-$r/2)} y0={round($y-$r/2)} x1={round($x+$r/2)} y1={round($y+$r/2)}
          -polygon[-1] 4,$x0,$y,$x,$y0,$x1,$y,$x,$y1,1,1
          x0={round($x-($r+$1)/2)} y0={round($y-($r+$1)/2)} x1={round($x+($r+$1)/2)} y1={round($y+($r+$1)/2)}
          -polygon[-2] 4,$x0,$y,$x,$y0,$x1,$y,$x,$y1,1,-1
        -endif
        failed=0
      -else
        -=[-2] -1,$x,$y
        failed={$failed+1}
        -if {$failed==100} failed=0 -if $noedges n=-1 -else noedges=1 -endif -endif
      -endif
      it={$it+1}
      -if {!($it%50)}
        p={round(100*(($sumg0-@{-2,+})/@{-2,wh})^3)}
        -rprogress $p -v + -e[] "\r  "$p% -v -
      -endif
    -while {$n>=0}
    -rm[-3,-2] -rprogress -1
    -blend shapeaverage0
  -endl -done -v +

#@gmic color_ellipses : _count>0,_radius>=0,_opacity>=0
#@gmic : Add random color ellipses to selected images.
#@gmic : Default values: 'count=400', 'radius=5' and 'opacity=0.1'.
#@gmic : $ image.jpg --color_ellipses ,,0.15
color_ellipses : -skip ${1=1400},${2=5},${3=0.1}
  -e[^-1] "Add $1 random color ellipses to image$?, with maximum radius $2 and opacity $1."
  -v - -repeat $1 -ellipse {?(0,100)}%,{?(0,100)}%,{?(0,$2)}%,{?(0,$2)}%,{?(0,360)},$3,{?(60,255)},{?(60,255)},{?(60,255)},255 -done -v +

#@gmic cubism : _density>=0,0<=_thickness<=50,_max_angle,_opacity,_smoothness>=0
#@gmic : Apply cubism effect on selected images.
#@gmic : Default values: 'density=50', 'thickness=10', 'max_angle=75', 'opacity=0.7' and 'smoothness=0'.
#@gmic : $ image.jpg --cubism ,
cubism : -check "${1=50}>=0 && ${2=10}>=0 && $2<=50 && ${5=0}>=0" -skip ${3=75},${4=0.7}
  -e[^-1] "Apply cubism effect on image$?, with density $1, thickness $2, maximum angle $3 deg., opacity $4 and smoothness $5."
  -if {"!$1 || !$2 || !$3 || !$4"} -return -endif
  -v - -repeat @# -l[$>]
    w={w} h={h} s={s}
    P={round($2*max(w,h)/200)}
    N={round(1.5*$1*w*h/(4*$P)/100)}

    # Define Header + nb vertices / primitives.
    ({'CImg3d'}) -+[-1] 0.5 ({4*$N};$N)

    # Generate list of random points.
    1,$N -rand[-1] $P,{$w-1-$P} --rand[-1] $P,{$h-1-$P} -a[-2,-1] x -round[-1]

    # Generate list of primitives.
    --+[-1] '-$P,-$P' --+[-2] '$P,-$P' --+[-3] '$P,$P' --+[-4] '-$P,$P'
    -a[-4--1] x -i[-2] (12,0,1,2,3;12,{4*($N-1)},{4*($N-1)+1},{4*($N-1)+2},{4*($N-1)+3})
    -r[-2] 5,$N,1,1,3 -round[-2] 1 -a[-2,-1] x

    # Generate list of vertices.
    1,$N -rand[-1] {225-$3},{225+$3} -*[-1] {pi/180}
    --sin[-1] -cos[-2] --*[-1] -1 [-3] -a[-4--3] x -a[-2,-1] x -z[-4,-2,-1] 0,2 --*[-2,-1] -1 -a[-4--1] x -*[-1] {sqrt(2)*$P}
    -r[-3] 400%,100%,1,1,0,2 -+[-3,-1]

    # Generate materials.
    (-128;$w;$h;$s) --b[0] $5
    -if {$N>1} 4,{$N-1},1,1,-128,0,0,0 -endif
    1,$N,1,1,1

    # Apply effect on current image.
    -y[1--1] -a[1--1] y -rv3d[-1]
    -if {$4>=1} -j3d[0] [1],0,0,0,1,2,0,0 -rm[1]
    -else --j3d[0] [1],0,0,0,1,2,0,0 -rm[1] -blend alpha,$4
    -endif

  -endl -done -v +

#@gmic draw_whirl : _amplitude>=0
#@gmic : Apply whirl drawing effect on selected images.
#@gmic : Default value: 'amplitude=100'.
#@gmic : $ image.jpg --draw_whirl ,
draw_whirl : -skip ${1=100}
  -e[^-1] "Apply whirl drawing effect on image$? with amplitude $1."
  -v - -repeat @# -l[$>]
    100%,100% -noise[-1] 70,2 -*[-1] 255 -r[-1] [-2] -and[-1,-2] -smooth[-1] $1,0,1,2,2
    -sqrt[-1] -n[-1] 0,255 -equalize[-1]
  -endl -done -v +

#@gmic drawing : _amplitude>=0
#@gmic : Apply drawing effect on selected images.
#@gmic : Default value: 'amplitude=200'.
#@gmic : $ image.jpg --drawing ,
drawing : -skip ${1=200}
  -e[^-1] "Apply drawing effect on image$? with amplitude $1."
  -v - -repeat @# -l[$>] -split_opacity -l[0] -to_rgb
    -smooth $1,0.2,1,3,3 -b 2 -sharpen 1000 [0]
    -r[0] 20,20,1,3,2 -equalize[0] -index[1] [0],1,1
    -nm[1] @{0,n},1 -rm[0]
  -endl -a c -endl -done -v +

#@gmic drop_shadow : _offset_x[%],_offset_y[%],_smoothness[%]>=0,0<=_curvature<=1,_expand_size={ 0 | 1 }
#@gmic : Drop shadow behind selected images.
#@gmic : Default values: 'offset_x=20', 'offset_y=offset_x', 'smoothness=5', 'curvature=0' and 'expand_size=1'.
#@gmic : $ image.jpg -drop_shadow 10,20,5,0.5 -expand_xy 20,0 -display_rgba
drop_shadow : -check "${3=5}>=0 && ${4=0}>=0 && $4<=1" -skip ${1=20},${2=$1},${5=1}
  -e[^-1] "Drop shadow behind image$?, with offsets ($1,$2), smoothness $3 and curvature $4."
  -v - -to_a -repeat @# -l[$>]
    dx={if(@{-is_percent\ $1},w*$1,$1)}
    dy={if(@{-is_percent\ $2},h*$2,$2)}
    sigma={if(@{-is_percent\ $3},max(w,h)*$3,$3)}
    w={w} h={h} s={s} --channels 100% coords=@{-autocrop_coords[-1]\ 0} -rm[-1] -z $coords  # Crop part with opaque pixels.
    -r {w+abs($dx)},{h+abs($dy)},1,100%,0,0,{if($dx>0,0,1)},{if($dy>0,0,1)} -r[-1] {w+4*$sigma},{h+4*$sigma},1,100%,0,0,0.5,0.5
    --channels[-1] 100%
    -if {!$4} -shift[-1] $dx,$dy # Flat shadow.
    -else # Curved shadow.
      (0;{pi}) -r[-1] [-2],3 -sin[-1] -*[-1] -$4 -+[-1] 1 -*[-1] $dx
      (0,{pi}) -r[-1] [-2],3 -sin[-1] -*[-1] -$4 -+[-1] 1 -*[-1] $dy
      -a[-2,-1] c -warp[-2] [-1],1,0,0 -rm[-1]
    -endif
    -b[-1] $sigma,0
    -r[-1] 100%,100%,1,2,0,0,0,0,0,1 -mv[-1] 0 -blend alpha
    --channels[-1] 100% ->=[-1] 1 -* -autocrop 0
    -if {!$5} $w,$h,1,$s -j[-1] [-2],{arg(1,$coords)},{arg(2,$coords)} -rm[-2] -endif
  -endl -done -v +

#@gmic ellipsionism : _R>0[%],_r>0[%],_smoothness>=0[%],_opacity,_outline>0,_density>0
#@gmic : Apply ellipsionism filter to selected images.
#@gmic : Default values: 'R=10', 'r=3', 'smoothness=1%', 'opacity=0.7', 'outlise=8' and 'density=0.6'.
#@gmic : $ image.jpg --ellipsionism ,
ellipsionism : -check "${1=10}>0 && ${2=3}>0 && ${5=8}>0 && ${6=0.6}>0" -skip ${3=1%},${4=0.7}
  -e[^-1] "Apply ellipsionism filter to image$?, with radii ($1,$2), smoothness $3, opacity $4 and outline $5."
  -v - -to_rgba -repeat @# -l[$>]

    # Compute contour angle.
    --luminance -g[-1] xy -a[-2,-1] c -b[-1] $3 -orientation[-1]
    -sh[-1] 0,0 -sh[-2] 1,1 -atan2[-1] [-2] -*[-1] {180/pi} -+[-1] 90 -rm[-2,-1] -channels[-1] 1,1

    # Render ellipses.
    [-2],[-2],1,[-2]
    -repeat {$6*w*h/max($1,$2)}
      xy={?(w)},{?(h)}
      -ellipse[-1] $xy,$1,$2,@{-2,($xy)},$4,\
                   @{-3,($xy,0,0)},@{-3,($xy,0,1)},@{-3,($xy,0,2)},@{-3,($xy,0,3)}
      -ellipse[-1] $xy,$1,$2,@{-2,($xy)},$4,0x1,\
                   {@{-3,($xy,0,0)}/$5},{@{-3,($xy,0,1)}/$5},{@{-3,($xy,0,2)}/$5},{@{-3,($xy,0,3)}/$5}
    -done -rm[-2]

    # Renormalize and prepare next image.
    -n[-1] [-2] -blend alpha
  -endl -done -v +

#@gmic fire_edges : _edges>=0,0<=_attenuation<=1,_smoothness>=0,_threshold>=0,_nb_frames>0,_starting_frame>=0,frame_skip>=0
#@gmic : Generate fire effect from edges of selected images.
#@gmic : Default values: 'edges=0.7', 'attenuation=0.25', 'smoothness=0.5', 'threshold=25', 'nb_frames=1', 'starting_frame=20' and 'frame_skip=0'.
#@gmic : $ image.jpg -fire_edges ,
fire_edges : -check "${1=0.7}>=0 && ${2=0.25}>=0 && $2<=1 && ${3=0.5}>=0 && ${4=25}>=0 && ${5=1}>0 && ${6=20}>=0 && ${7=0}>=0"
  -e[^-1] "Generate fire effect from edges of image$?, with edges $1, attenuation $2, smoothness $3, threshold $4, "\
          "$5 frames, starting frame $6 and frame skip $7."
  -v - -repeat @# -l[$>] nm=@{0,n}
    -norm --gradient_norm -n[-1] 0,1 -roundify[-1] $1 -f[0] 0
    (0,0,0;0,0,0;1,1,1;0,1,0) -*[-1] {(1-$2^4)/4}
    -repeat {$5*(1+$7)+$6}
      @{0,w},@{0,h} -rand[-1] 0,255 -*[-1] [1]
      -b[-1] $3
      -if $4 ->=[-1] $4% -else -equalize[-1] -endif
      -n[-1] 0,255
      -j[0] [-1],0,0,0,0,1,[1],1 -rm[-1]
      -correlate[0] [2]
      -if {$>>=$6" && "($>-$6)%($7+1)==0} [0] -endif
    -done -rm[0-2]
  -nm $nm,1 -endl -done
  (0,255,255,255,255^0,0,255,255,255^0,0,0,128,255) -r[-1] 256,1,1,3,3
  -map[^-1] [-1] -rm[-1] -v +

#@gmic fractalize : 0<=detail_level<=1
#@gmic : Randomly fractalize selected images.
#@gmic : Default value: 'detail_level=0.8'
#@gmic : $ image.jpg --fractalize ,
fractalize : -check "${1=0.8}>=0 && $1<=1"
  -e[^-1] "Randomly fractalize image$?, with detail level $1."
  -v -
  xc=0.4433
  yc=0.2645
  delta=0.1
  c0r=0.317
  c0i=0.03
  -repeat @# -l[$>]
    -luminance -equalize 256 -b 0.25% -n 0,255
    100%,100%
    dx={$delta*w/max(w,h)}
    dy={$delta*h/max(w,h)}
    x0={$xc-$dx/2}
    y0={$yc-$dy/2}
    x1={$xc+$dx/2}
    y1={$yc+$dy/2}
    -mandelbrot[-1] $x0,$y0,$x1,$y1,256,1,$c0r,$c0i
    --==[-1] 0 -inpaint[-2] [-1] -rm[-1]
    -n[-1] 0,256
    16,1,1,3 -rand[-1] 0,255 -r[-1] 256,1,1,3,3 -map[-2] [-1] -rm[-1]
    -s[-1] c
    -i[2,3] [0]
    s={0.1*(1-$1)}
    -parallel "-register_nonrigid[1] [0],"$s",5","-register_nonrigid[3] [2],"$s",5","-register_nonrigid[5] [4],"$s",5"
    -rm[0,2,4] -a c
  -endl -done -v +

#@gmic glow : _amplitude>=0
#@gmic : Add soft glow on selected images.
#@gmic : Default value: 'amplitude=1%'.
#@gmic : $ image.jpg --glow ,
glow : -skip ${1=1%}
  -e[^-1] "Add soft glow on image$?, with amplitude $1."
  -v - -repeat @# -l[$>] -split_opacity --b[0] $1 -n[-1] [0] -blend_edges[0,-1] 1 -a c -endl -done -v +

#@gmic halftone : nb_levels>=2,_size_dark>=2,_size_bright>=2,_shape={ 0=square | 1=diamond | 2=circle | 3=inv-square | 4=inv-diamond | 5=inv-circle },_smoothness[%]>=0
#@gmic : Apply halftone dithering to selected images.
#@gmic : Default values: 'nb_levels=5', 'size_dark=8', 'size_bright=8', 'shape=5' and 'smoothnesss=0'.
#@gmic : $ image.jpg --halftone ,
halftone : -check "${1=5}>=2 && ${2=8}>=2 && ${3=8}>=2 && ${5=0}>=0" -skip ${4=5}
  -v - s0="square" s1="diamond" s2="circle" s3="inv-square" s4="inv-diamond" s5="inv-circle" -v +
  -e[^-1] "Apply halftone dithering to image$?, with $1 levels, dark size $3, bright size $4, "${s$4}" shape and smoothness $5."
  -v - -repeat @# -l[$>] -s c -repeat @# -l[$>]
    (0,255) -a y -quantize $1,0 -rows 0,{h-2}
    -repeat $1
      s={round(($2*$<+$3*$>)/($1-1))}
      $s,$s -=[-1] 1,50%,50% -distance[-1] 1,{$4%3} --shift[-1] 50%,50%,0,0,2 -min[-2,-1]
      -if {$4>=3} -<[-1] {100*$</($1-1.1)}% -*[-1] {-255} -+[-1] {255-$>}
      -else -<[-1] {100*$>/($1-1.1)}% -*[-1] 255 --[-1] $>
      -endif
      -r[-1] [-2],0,2 -b[-1] $5 --==[-2] $> -*[-2,-1] -+[-2,-1]
    -done -endl -done -a c
  -endl -done -v +

#@gmic hardsketchbw : _amplitude>=0,_density>=0,_opacity,0<=_edge_threshold<=100,_is_fast={ 0 | 1 }
#@gmic : Apply hard B&W sketch effect on selected images.
#@gmic : Default values: 'amplitude=1000', 'sampling=3', 'opacity=0.1', 'edge_threshold=20' and 'is_fast=0'.
#@gmic : $ image.jpg --hardsketchbw 200,70,0.1,10 -median[-1] 2 --local -reverse -blur[-1] 3 -blend[-2,-1] overlay -endlocal
hardsketchbw : -skip ${1=300},${2=50},${3=0.1},${4=20},${5=0}
  -e[^-1] "Apply hard B&W sketch effect on image$?, with amplitude $1, density $2, opacity $3 and edge threshold $4."
  -if {!$2} -channels 0 -f 255 -return -endif
  -v - -luminance -n 0,1

  -if $5 # Fast version.
    -repeat @# -l[$>] nm=@{0,n}
      -g xy -rv -*[-2] -1 -a c
      -if $4 --norm ->=[-1] $4% -* -endif
      100%,100%,1,1,255 -quiver[-1] [-2],{max(1,10-$2/6)},$1,0,$3 -rm[-2]
    -nm $nm,1 -endl -done

  -else # Slower version.
    -repeat @# -l[$>] nm=@{0,n}

      # Isolate starting points and tangents.
      w={w} h={h} -g xy -rv -*[-2] -1 -a c -* $1
      --norm ->=[-1] $4% 100%,100% -noise[-1] $2,2 -*[-2,-1]

      # Retrieve points coordinates and corresponding tangents.
      -pointcloud3d[-1] -s3d[-1] -rm[-6--5,-3--1] -r[-1] 3,{h/3},1,1,-1 -s[-1] x -rm[-1] -a[-2,-1] c
      -warp[-2] [-1],0,0 ---[-1] [-2] -+[-3,-2] -s[-2,-1] c

      # Convert as a 3d object and render on white background.
      -i[-3] 1,{h} 1,{h} -a[-6--1] x
      -i[-2] ({'CImg3d'}) -i[-2] ({2*h},{h})
      1,{h},1,1,2 1,{h},1,1,2*y --+[-1] 1 -a[-3--1] x
      3,{h} 1,{h},1,1,$3 -y[-6--1] -a[-6--1] y
      $w,$h,1,1,255 -j3d[-1] [-2],0,0,0,1,1,0,0 -rm[-2]
    -nm $nm,1 -endl -done
  -endif -v +

#@gmic hearts : _density>=0
#@gmic : Apply heart effect on selected images.
#@gmic : Default value: 'density=10'.
#@gmic : $ image.jpg --hearts ,
hearts : -skip ${1=10}
  -e[^-1] "Apply heart filter on image$?, with density $1."
  -v - -repeat @# -l[$>]
    100%,100%,1 -noise[-1] $1,2 -r[-1] [-2] -n[-1] 0,1 -*[-1,-2] -_heart9x7
    -mirror[-1] y -dilate[-2] [-1] -rm[-1]
  -endl -done -v +

_heart9x7 :
  (0,1,1,0,0,0,1,1,0;1,1,1,1,0,1,1,1,1;1,1,1,1,1,1,1,1,1;0,1,1,1,1,1,1,1,0;0,0,1,1,1,1,1,0,0;0,0,0,1,1,1,0,0,0;0,0,0,0,1,0,0,0,0)

#@gmic houghsketchbw : _density>=0,_radius>0,0<=_threshold<=100,0<=_opacity<=1,_votesize[%]>0
#@gmic : Apply hough B&W sketch effect on selected images.
#@gmic : Default values: 'density=8', 'radius=5', 'threshold=80', 'opacity=0.1' and 'votesize=100%'.
#@gmic : $ image.jpg --houghsketchbw ,
houghsketchbw : -check "${1=8}>=0 && ${2=5}>=0 && ${3=80}>=0 && $3<=100 && ${4=0.1}>=0 && $4<=1 && ${5=100%}>0"
  -e[^-1] "Apply hough B&W sketch effect on image$?, with density $1, radius $2, threshold $3, opacity $4 and votesize $5."
  -v - -luminance -repeat @# -l[$>] nm=@{0,n}

    # Compute normalized Hough transform.
    res={round(if(@{-is_percent\ $5},$5*max(w,h),$5))} w={w} h={h} rhomax={sqrt(w^2+h^2)/2}
    -hough $res,$res -n 0,255

    # Retrieve coordinates of maximas in hough space.
    -normalize_local[-1] $1,$2 ->=[-1] $3% -pointcloud3d[-1]
    -s3d[-1] -rm[-6--5,-3--1] -r[-1] 3,{h/3},1,1,-1 -columns[-1] 0,1

    # Convert to (x0,y0)-(x1,y1) line coordinates.
    -s[-1] x,2
    -*[-2] {2*pi/$res}                   # theta
    -*[-1] {$rhomax/$res}                # rho
    --cos[-2] -*[-1] [-2] -+[-1] {$w/2}  # x
    --sin[-3] -*[-1] [-3] -+[-1] {$h/2}  # y
    -rm[-3]                              # Remove rho
    -i[-3] [-3]
    -cos[-4] -sin[-3] -*[-4,-3] 10000    # cos(t) sin(t)
    --+[-2] [-3]                         # x + sin(t)
    ---[-2] [-5]                         # y - cos(t)
    --[-4] [-5]                          # x - sin(t)
    -+[-3] [-6]                          # y + cos(t)
    -rm[-6,-5]

    # Transform as a 3d object.
    -i[-3] 1,{h} 1,{h} -a[-6--1] x                  # Vertices
    -i[-2] ({'CImg3d'}) -i[-2] ({2*h},{h})          # Header and size.
    1,{h},1,1,2 1,{h},1,1,2*y --+[-1] 1 -a[-3--1] x # Primitives.
    3,{h},1,1,0 1,{h},1,1,$4                        # Colors and opacities
    -y[-6--1] -a[-6--1] y

    # Render on a white image.
    $w,$h,1,1,255 -j3d[-1] [-2],0,0,0,1,1,0,0 -rm[-2]
  -nm $nm,1 -endl -done -v +

#@gmic lightrays : 100<=_density<=0,_center_x[%],_center_y[%],_ray_length>=0,_ray_attenuation>=0
#@gmic : Generate ray lights from the edges of selected images.
#@gmic : Defaults values : 'density=50%', 'center_x=50%', 'center_y=50%', 'ray_length=0.9' and 'ray_attenuation=0.5'.
#@gmic : $ image.jpg --lightrays , -+ -c 0,255
lightrays : -check "${1=50}>=0 && $1<=100 && ${4=1} && ${5=1}>=0" -skip ${2=50%},${3=50%}
  -e[^-1] "Generate ray lights from image$?, with density $1, center point ($2,$3), ray length $4 and attenuation $5."
  -v - -repeat @# -l[$>]
    -gradient_norm -* -1 -< $1% -euclidean2polar $2,$3
    -repeat {log2(w)} --shift[-1] {2^$>} -+[-2,-1] -done
    -function1d 0.5,0,1,{$4*w},1,{1+($4+1-$5)*w},0 -r[-1] @{-2,w},1,1,1,0
    (1,{w}) -r[-1] @{-2,w},1,1,1,3 -/[-2,-1]
    -r[-1] [-2] -*[-2,-1] -polar2euclidean $2,$3 -n 0,255
  -endl -done -v +

#@gmic light_relief : _ambient_light,_specular_lightness,_specular_size,_light_smoothness,_darkness,_xl,_yl,_zl,_zscale,_opacity_is_heightmap={ 0 | 1 }
#@gmic : Apply relief light to selected images.
#@gmic : Default values(s) : 'ambient_light=0.3', 'specular_lightness=0.5', 'specular_size=0.2', 'darkness=0', 'xl=0.2', 'yl=zl=0.5',
#@gmic : 'zscale=1', 'opacity=1' and 'opacity_is_heightmap=0'.
#@gmic : $ image.jpg --blur 2 -light_relief[-1] 0.3,4,0.1,0
light_relief : -skip ${1=0.3},${2=0.5},${3=0.2},${4=0},${5=0.2},${6=0.5},${7=0.5},${8=1},${9=1},${10=0}
  -e[^-1] "Apply relief light to image$?."
  -v - -repeat @# -l[$>]
    ({-$6},{1-$6};{-$6},{1-$6}^{-$7},{-$7};{1-$7},{1-$7}^$8,$8;$8,$8) -r[-1] [-2],[-2],1,3,3  # Create light vector field.
    -if $10 --channels[-2] 3 -to_rgb[-3] -else --to_rgb[-2] -norm[-1] -endif
    -b[-1] $5% -g[-1] xy 100%,100%,1,1,$9  -a[-3--1] c                                        # Create normal vector field.
    -orientation[-2,-1] -*[-2,-1] -s[-1] c -+[-3--1]                                          # Normalized scalar product.
    100%,100% -=[-1] 1,{$6*100}%,{$7*100}% -distance[-1] 1 -sqr[-1] -*[-1] -1                 # Compute specular attenuation.
    -/[-1] {($3*max(w,h))^2} -exp[-1] -*[-1] $2 -+[-1] $1
    -*[-2,-1] --[-1] $4 -*[-1] @{-2,M}
    -split_opacity[0] -+[0,-1] -a c -c 0,255
  -endl -done -v +

#@gmic mosaic : _density>=0,_edges={ 0 | 1 }
#@gmic : Create random mosaic from selected images.
#@gmic : Default values: 'density=0.8' and 'edges=1'.
#@gmic : $ image.jpg --mosaic ,
mosaic : -skip ${1=0.8},${2=1}
  -e[^-1] "Apply mosaic effect on image$?, with density $1."
  -v - -repeat @# -l[$>]
    label0={1+im} -+ $label0
    100%,100% -noise[-1] {$1*2},2 -*[-2] [-1] -distance[-1] 1 -*[-1] -1 -watershed[-2] [-1],{if($2,0,1)} -rm[-1]
    -if $2 --l[-1] -> 0 -s c -and -endl --[-2] $label0 -*[-2,-1] -else --[-1] $label0 -endif
  -endl -done -v +

#@gmic old_photo
#@gmic : Apply old photo effect on selected images.
#@gmic : $ image.jpg --old_photo
old_photo :
  -e[^-1] "Apply old photo effect on image$?."
  -v - -noise 20 -bilateral 30,60 -b 2 -sharpen 100 -frame_fuzzy 8%,8%,6,3 -to_rgb -shadow_patch 0.75 -n 0,255 -sepia -v +

#@gmic pencilbw : _size>=0,_amplitude>=0
#@gmic : Apply B&W pencil effect on selected images.
#@gmic : Default values: 'size=0.3' and 'amplitude=60'.
#@gmic : $ image.jpg --pencilbw ,
pencilbw : -skip ${1=0.3},${2=60}
  -e[^-1] "Apply B&W pencil effect on image$?, with size $1 and amplitude $2."
  -v - -repeat @# -l[$>] -split_opacity -l[0] -norm -b $1 -sharpen 4000 -smooth $2,0,1 -equalize -sqrt -n 0,255 -endl -a c -endl -done -v +

#@gmic polaroid : _size1>=0,_size2>=0
#@gmic : Create polaroid effect in selected images.
#@gmic : Default values: 'size1=10' and 'size2=20'.
#@gmic : $ image.jpg -to_rgba -polaroid 5,30 -rotate 20 -drop_shadow , -display_rgba
polaroid : -check "${1=10}>=0 && ${2=20}>=0"
  -e[^-1] "Create polaroid effect in image$?, with borders sizes $1 and $2."
  -v - -- 255 -r {100+$1}%,{100+$1}%,1,100%,0,0,0.5,0.5 -r 100%,{100+$2}%,1,100%,0,0,0 -+ 255 -v +

#@gmic polygonize : _warp_amplitude>=0,_smoothness[%]>=0,_min_area[%]>=0,_resolution_x[%]>0,_resolution_y[%]>0
#@gmic : Apply polygon effect on selected images.
#@gmic : Default values: 'warp_amplitude=300', 'smoothness=2%', 'min_area=0.1%', 'resolution_x=resolution_y=10%'.
#@gmic : $ image.jpg --polygonize ,
polygonize : -check "${1=300}>=0 && ${2=2%}>=0 && ${3=0.1%}>=0 && ${4=10%}>0 && ${5=$4}>0"
  -e[^-1] "Polygonize image$? with warp amplitude $1, smoothness $2, minimal area $3 and resolutions ($4,$5)."
  -v -  -repeat @# -l[$>]
    --b $2 -gradient_norm[-1] -g[-1] -a[-2,-1] c -channels[-1] 0,2 -*[-1] {1/0.1+max(abs(im),abs(iM))}
    resx={max(1,round(if(@{-is_percent\ $4},w*$4,w/$4)-1))}
    resy={max(1,round(if(@{-is_percent\ $5},h*$5,h/$5)-1))}
    -plane3d 1,1,$resx,$resy -*3d[-1] @{0,w-1},@{0,h-1},1
    -s3d[-1] -rm[-2] -i[-2] (0;{h-1}) -r[-2] 3,{h},1,1,3 -round[-2] -y[-2]
    [-4] -a[-7--2] y -r[-1] 3,{h/3},1,1,-1 -z[-1] 0,1 -permute[-1] yzcx
    -repeat $1 --warp[1] [-1],0,0 -+[-2,-1] -done
    -permute[-1] cxyz -z[-1] 0,2 -y[-1] -j[2] [-1],0,8 -rm[-3,-1]
    [0],[0] -j3d[-1] [1],0,0,0,1,2 -rm[1]
    -if {$3>0}
      min_area=@{0,if(@{-is_percent\ $3},$3*w*h,$3)}
      --area[-1] 0,1 ->=[-1] $min_area -+[-2] 1 -*[-2] [-1] -distance[-1] 1 -*[-1] -1 -watershed[-2] [-1] -rm[-1]
    -endif
    -blend shapeaverage
  -endl -done -v +

#@gmic poster_edges : 0<=_edge_threshold<=100,0<=_edge_shade<=100,_edge_thickness>=0,_edge_antialiasing>=0,0<=_posterization_level<=15,_posterization_antialiasing>=0
#@gmic : Apply poster edges effect on selected images.
#@gmic : Default values: 'edge_threshold=40', 'edge_shade=5', 'edge_thickness=0.5', 'edge_antialiasing=10', 'posterization_level=12' and 'posterization_antialiasing=0'.
#@gmic : $ image.jpg --poster_edges ,
poster_edges : -check "${1=40}>=0 && $1<=100 && ${2=5}>=0 && $2<=100 && ${3=0.5}>=0 && ${4=10}>=0 && ${5=12}>=0 && $5<=15 && ${6=0}>=0"
  -e[^-1] "Apply poster edge on image$?, with edge threshold $1, edge shade $2, edge thickness $3, edge antialiasing $4, $5 level of posterization and posterization antialiasing $6."
  -v - -repeat @# -l[$>] -split_opacity -l[0]
    --g xy,1 -a[-2,-1] c -norm[-1] -b[-1] $3 -n[-1] 0,255
    -apply_curve[-1] 1,0,1,{max(0,(100-($1%)^0.1*100)*255%)},0.99,{min(255,(101-($1%)^0.1*100+$2)*255%)},0.01,255,0 -c[-1] 0,1
    -if $4 -smooth[-1] {min(50,$4)},0,1,{$4/40},{$4/40},0.8,90 -endif
    -if $5 -autoindex[0] {round((4-sqrt($5+1))*32+2)} -endif
    -if $6 -smooth[0] {min(50,$6)},0,1,{$6/40},{$6/40},0.8,90 -endif
    -*
  -endl -a c -endl -done -v +

#@gmic poster_hope : _smoothness>=0
#@gmic : Apply Hope stencil poster effect on selected images.
#@gmic : Default value: 'smoothness=3'.
#@gmic : $ image.jpg --poster_hope ,
poster_hope : -check "${1=3}>=0"
  -e[^-1] "Apply Hope stencil poster effect on image$?, with smoothness $1."
  -v - -repeat @# -l[$>] -to_rgb
    -apply_parallel_channels "-smooth 200,0,1,$1,1"
    -quantize 7,0 -f 'if(i!=5,i,i+1-2*(y%2))'
    (0,32,47;0,32,47;209,1,23;209,1,23;90,141,145;-1,-1,-1;253,221,138) -permute[-1] yzcx
    -map[0] [1] -rm[1]
  -endl -done -v +

#@gmic rodilius : 0<=_amplitude<=100,_0<=thickness<=100,_sharpness>=0,_nb_orientations>0,_offset,_color_mode={ 0=darker | 1=brighter }
#@gmic : Apply rodilius (fractalius-like) filter on selected images.
#@gmic : Default values: 'amplitude=10', 'thickness=10', 'sharpness=400', 'nb_orientations=7', 'offset=0' and 'color_mode=1'.
#@gmic : $ image.jpg --rodilius 12,10,300,10 -normalize_local[-1] 10,6
rodilius : -check "${1=10}>=0 && $1<=200 && ${2=10}>=0 && $2<=100 && ${3=400}>=0 && ${4=7}>0" -skip ${5=0},${6=1}
  -e[^-1] "Apply rodilius filter on image$? with amplitude $1, thickness $2, sharpness $3, $4 orientations, offset $5 and "\
    @{-arg\ 1+!$6,brighter,darker}" color mode."
  -v - -repeat @# -l[$>] -split_opacity -rv
    -if {!$6} -negative[-1] -endif
    --f[-1] 0 -nm[-1] @{-2,n}
    -repeat {round($4)}
      angle={$5+$>*180/round($4)}
      --blur_linear[-2] $1%,{$1*$2/100}%,$angle,1 -b[-1] 0.7 -sharpen[-1] $3 -max[-2,-1]
    -done -rm[-2]
    -if {!$6} -negative[-1] -endif
  -rv -a c -endl -done -v +

#@gmic stained_glass : _edges[%]>=0, shading>=0, is_thin_separators={ 0 | 1 }
#@gmic : Generate stained glass from selected images.
#@gmic : Default values: 'edges=40%', 'shading=0.2' and 'is_precise=0'.
#@gmic : $ image.jpg --stained_glass ,
stained_glass : -check "${1=40%}>=0 && ${2=0.2}>=0" -skip ${3=0}
  -e[^-1] "Apply stained glass effect on image$?, with edges $1, shading $2 and thin-separators "@{-arg\ 1+!$3,enabled,disabled}"."
  -v - -repeat @# -l[$>]
    im={im-1} -- $im  # Ensure strict positiveness of image labels.
    --gradient_norm ->=[-1] $1 -*[-2] [-1]
    -distance[-1] 1 -sharpen[-1] 1e10 -!=[-1] 0
    -if $3 -skeleton[-1] 0 -endif
    -distance[-1] 1 -watershed[-2] [-1] -+[-2] $im
    -n[-1] 0,1  -^[-1] $2 -*
  -endl -done -v +

#@gmic star : _width>0,_height>0,_nb_branches>0,0<=_thickness<=1
#@gmic : Input star binary mask with specified size.
#@gmic : Default values: 'width=height=512', 'nb_branches=5' and 'thickness=0.38'.
#@gmic : $ -star ,
star : -check "${1=512}>=1 && ${2=$1}>=1 && ${3=5}>0 && ${4=0.5}>=0 && $4<=1"
  -e[^-1] "Input $1x$2 star binary mask, with $3 branches and thickness $4."
  -v - -l[]
    -star3d $3,$4 -col3d 1 -c3d -n3d -*3d $1,$2
    $1,$2 -j3d[-1] [-2],50%,50%,0,1,2 -rm[-2]
    -nm "[Heart binary mask]"
  -endl -v +

#@gmic stars : _density[%]>=0,_depth>=0,_size>0,_nb_branches>=1,0<=_thickness<=1,_smoothness[%]>=0,_R,_G,_B,_opacity
#@gmic : Add random stars to selected images.
#@gmic : Default values: 'density=10%', 'depth=1', 'size=32', 'nb_branches=5', 'thickness=0.38', 'smoothness=0.5', 'R=G=B=200' and 'opacity=1'.
#@gmic : $ image.jpg -stars ,
stars : -check "${1=10%}>=0 && ${2=1}>=0 && ${3=32}>0 && ${4=5}>=1 && ${5=0.38}>=0 && $5<=1 && ${6=0.5}>=0" -skip ${7=200},${8=$7},${9=$8},${10=1}
  -e[^-1] "Add $1 random stars to image$?, with depth $2, size $3, $4 branches, thickness $5, smoothness $6, color ($7,$8,$9) and opacity $10."
  -if {!$1} -return -endif
  -v -

  # Generate star sprites.
  -star3d $4,$5 -col3d[-1] 255 -*3d[-1] $3
  -l[-1] -repeat 4 {round(2*$3)},{round(2*$3)} -j3d[-1] [0],50%,50%,0,1,2,0,0 -r3d[0] 0,0,1,90 -done -rm[0] -endl
  -autocrop[-4--1] 0 -r2dy[-4--1] $3 -b[-4--1] $6,0 -r[-4--1] 100%,100%,1,4
  -repeat 4 -sh[{-1-$>}] 0,2 -fc[-1] $7,$8,$9 -rm[-1] -done

  # Draw stars on selected images.
  -repeat {@#-1} [-4--1] -l[$>,-4--1]
    N={round(if(@{-is_percent\ $1},w*h*$1,$1)/4,1,1)}
    -repeat 4
      2,$N -rand[-1] -1,1 1,$N -rand[-1] 0,1 -a[-2,-1] x
      -i[-2] ({'CImg3d'}) -+[-2] 0.5 -i[-2] ($N;$N)
      (1,0;1,{$N-1}) -r[-1] 2,$N,1,1,3 -round[-1] 4,$N,1,1,1 -y[-5,-3--1] -a[-5--1] y
      -rv[-2,-1] -sprites3d[-2,-1] -*3d[-1] {0.75*@{0,w}},{0.75*@{0,h}},{1000*$2}
      -j3d[0] [-1],50%,50%,0,$10,0,0,0 -rm[-1]
    -done
  -endl -done
  -rm[-4--1] -v +

#@gmic sketchbw : _nb_orients>0,_start_angle,_angle_range>=0,_length>=0,_threshold>=0,_opacity,_bgfactor>=0,_density>0,_sharpness>=0,_anisotropy>=0,_smoothness>=0,_coherence>=0,_is_boost={ 0 | 1 },_is_curved={ 0 | 1 }
#@gmic : Apply sketch effect to selected images.
#@gmic : Default values: 'nb_orients=2', 'start_angle=45', 'angle_range=180', 'length=30', 'threshold=1', 'opacity=0.03',
#@gmic : 'bgfactor=0', 'density=0.6', 'sharpness=0.1', 'anisotropy=0.6', 'smoothness=0.25', 'coherence=1', 'is_boost=0' and 'is_curved=1'.
#@gmic : $ image.jpg --sketchbw 1 --local -reverse -blur[-1] 3 -blend[-2,-1] overlay -endlocal
sketchbw :
  -check "${1=2}>0 && ${3=180}>=0 && ${4=30}>=0 && ${5=1}>=0 && ${7=0}>=0 && ${8=0.6}>0 && ${9=0.1}>=0 && ${10=0.6}>=0 && ${11=0.25}>=0 && ${12=1}>=0"
  -skip ${2=45},${6=0.03},${13=0},${14=1}
  -e[^-1] "Apply B&W sketch effect on image$?."
  -v - -diffusiontensors $9,$10,$11,$12
  w=1 h=1 -i[0] 1 -m3d 0

  -repeat {@#-1}
    -/[-1] {max(iM,im)} -s[-1] c        # Normalize and split tensor coefficients.
    100%,100%,1,1,255 -nm[-1] @{-4,n},1 # Create rendering B&W image.

    -if {$w!=w||$h!=h}               # Create set of random coordinates, if necessary.
      -rm[0] {$8*w*h/($1*sqrt($4))}
      --rand[-1] 0,{@{-2,h}-1} -rand[-2] 0,{@{-3,w}-1} -a[-2,-1] y -mv[-1] 0
      w={w} h={h}
    -endif

    -if $14 # Render sketch with curved strokes
      -repeat $1
        alpha={($2+$>*$3/$1)*pi/180}
        --*[-4] {cos($alpha)} --*[-4] {sin($alpha)} -+[-2,-1]
        --*[-4] {cos($alpha)} --*[-4] {sin($alpha)} -+[-2,-1]
        -a[-2,-1] c -channels[-1] 0,2
        -if $13 -orientation[-1] -endif
        -repeat @{0,w}
          xy=@{0,($>,0)},@{0,($>,1)}
          -if {@{-5,($xy)}+@{-3,($xy)}<$5} opac=$6 -else opac={$7*$6} -endif
          -if $opac
            --streamline3d[-1] $xy,0,$4,0.8,0,0,1 -col3d[-1] 0 -j3d[-3] [-1],0,0,0,$opac,1,0,0 -rm[-1]
            --streamline3d[-1] $xy,0,$4,0.8,0,1,1 -col3d[-1] 0 -j3d[-3] [-1],0,0,0,$opac,1,0,0 -rm[-1]
          -endif
        -done
        -rm[-1]
      -done

    -else # Render sketch with straight strokes
      -repeat $1
        alpha={($2+$>*$3/$1)*pi/180}
        --*[-4] {cos($alpha)} --*[-4] {sin($alpha)} -+[-2,-1]
        --*[-4] {cos($alpha)} --*[-4] {sin($alpha)} -+[-2,-1]
        -a[-2,-1] c
        -if $13 -orientation[-1] -endif
        -repeat @{0,w}
          x=@{0,($>,0)} y=@{0,($>,1)}
          -if {@{-5,($x,$y)}+@{-3,($x,$y)}<$5} opac=$6 -else opac={$7*$6} -endif
          -if $opac
            -line[-2] {$x-$4*@{-1,($x,$y,0,0)}},{$y-$4*@{-1,($x,$y,0,1)}},\
                      {$x+$4*@{-1,($x,$y,0,0)}},{$y+$4*@{-1,($x,$y,0,1)}},\
                      {3*$opac},0
          -endif
        -done
        -rm[-1]
      -done

    -endif
    -rm[-4--2]
  -mv[-1] 1 -done -rm[0] -v +

#@gmic sponge : _size>0
#@gmic : Apply sponge effect on selected images.
#@gmic : Default value: 'size=13'.
#@gmic : $ image.jpg --sponge ,
sponge : -skip ${1=13}
  -e[^-1] "Apply sponge filter on image$?, with brush size $1."
  -v - -repeat @# -l[$>]
    100%,100%,1,1 -noise[-1] 20,2 -r[-1] [-2] -n[-1] 0,1 -*[-1,-2]
    -_circle $1 -dilate[-2] [-1] -rm[-1]
  -endl -done -v +

_circle :
  -if {$1%2==0} -i 2,2 -else -i 1 -endif
  -+[-1] 1 -r[-1] $1,$1,1,1,0,0,0.5,0.5 -distance[-1] 1 -n[-1] 0,1 -sqrt[-1] -c[-1] 0.85,0.86 -*[-1] -1 -n[-1] 0,1

#@gmic stencil : _radius[%]>=0,_smoothness>=0,_iterations>=0
#@gmic : Apply stencil filter on selected images.
#@gmic : Default values: 'radius=3', 'smoothness=1' and 'iterations=8'.
#@gmic : $ image.jpg --stencil 1,10,3
stencil : -check "${1=3}>=0 && ${2=1}>=0 && ${3=8}>=0"
  -e[^-1] "Apply stencil filter on image$?, with radius $1, smoothness $2 and $3 iterations."
  -v - -n 0,1 -repeat $3 -b $1 -unsharp {$1+$2},1000 -c 0,255 -done -v +

#@gmic stencilbw : _edges>=0,_smoothness>=0
#@gmic : Apply B&W stencil effect on selected images.
#@gmic : Default values: 'edges=15' and 'smoothness=10'.
#@gmic : $ image.jpg --stencilbw 40,4
stencilbw : -skip ${1=15},${2=10}
  -e[^-1] "Apply B&W stencil effect on image$?, with edges $1 and smoothness $2."
  -v - -repeat @# -l[$>] -split_opacity -luminance[0] -n[0] 0,255
    --edges[0] $1 -quantize[0] 3,0,1 -b[0] $2
    -sharpen[0] 1000000 -n[0] 0,1 -*[0,-1] -n[0] 0,255
  -a c -endl -done -v +

#@gmic tetris : _scale>0
#@gmic : Apply tetris effect on selected images.
#@gmic : Default value: 'scale=10'.
#@gmic : $ image.jpg --tetris 10
tetris : -skip ${1=10}
  -e[^-1] "Apply tetris effect on image$?, with scale $1."
  -v - -repeat @# -l[$>]
    wh={w},{h},1,{s} -r $1%,$1%,$1%,100%,2 -n 0,255 -quantize 10,1,0 -r $wh -b 2 -sharpen 300,1
  -endl -done -v +

#@gmic warhol : _M>0,_N>0,_smoothness>=0,_color>=0
#@gmic : Create MxN Andy Warhol-like artwork from selected images.
#@gmic : Default values: 'M=3', 'N=M', 'smoothness=2' and 'color=20'.
#@gmic : $ image.jpg --warhol 5,3,3,40
warhol : -skip ${1=3},${2=$1},${3=2},${4=20}
  -e[^-1] "Create $1x$2 Andy Warhol-like artwork from image$?."
  -v - r0={100/max($1,$2)}
  -repeat @# -l[$>]
    -norm -b $3 -r $r0%,$r0%,1,100%,2 -quantize 6 -n 0,5 -round 1
    -repeat $1 -repeat $2
      (0,1,2,3,4,5) -n[-1] 32,224 6,1,1,2,128 -noise[-1] $4,0 -c[-1] 0,255 -a[-2,-1] c -ycbcr2rgb[-1] --map[0] [-1] -rm[-2]
    -done -done -append_tiles[^0] $1,$2 -nm[1] @{0,n},1 -rm[0]
  -endl -done -v +

#@gmic weave : _density>=0,0<=_thickness<=100,0<=_shadow<=100,_shading>=0,_fibers_amplitude>=0,_fibers_smoothness>=0,_angle,-1<=_x_curvature<=1,-1<=_y_curvature<=1
#@gmic : Apply weave effect to the selected images.
#@gmic : 'angle' can be { 0=0 deg. | 1=22.5 deg. | 2=45 deg. | 3=67.5 deg. }.
#@gmic : Default values: 'density=6', 'thickness=65', 'shadow=40', 'shading=0.5', 'fibers_amplitude=0', 'fibers_smoothness=0', 'angle=0' and 'curvature_x=curvature_y=0'
#@gmic : $ image.jpg --weave ,
weave : -check "${1=6}>=0 && ${2=65}>=0 && $2<=100 && ${3=40}>=0 && $3<=100 && ${4=0.5}>=0"
        -check "${5=0}>=0 && ${6=0}>=0 && ${7=0}>=0 && $7<=3 && ${8=0}>=-1 && $8<=1 && ${9=0}>=-1 && $9<=1"
  -e[^-1] "Apply weave effect to image$?, with $1 strips, thickness $2, shadow $3, shading $4, "\
          "fibers amplitude $5 and fibers smoothness $6, angle "{$7*22.5}" deg. and curvatures ($8,$9)."
  -v - -repeat @# -l[$>] -split_opacity -l[0]
    w={round(max(w,h)/$1,1,1)} h=$w s={(100-$3)*255%} p={max(0.01,$4)}

    # Create patterns.
    1,$h -=[-1] 1,0,50% -distance[-1] 1 -^[-1] $p -c[-1] 50%,100% -r[-1] {max(1,round($2*$w%))},100%
    $w,1 -=[-1] 1,50% -distance[-1] 1 -^[-1] $p -c[-1] 50%,100% -*[-1] -1 -r[-1] 100%,{max(1,round($2*$h%))}
    --*[-1] -1 --*[-3] -1 -n[-4,-2] 0,$s -n[-3,-1] $s,255
    {w},1 1,[-3] -rand[-2,-1] 0,1 -b[-2,-1] $6% -n[-2,-1] -$5,$5 -r[-1] [-4] -+[-5] [-1] -+[-4,-1] -+[-5] [-1] -+[-2,-1]
    --f[-3] 255 -a[-4,-1] c --f[-1] 255 -a[-2,-1] c

    amp_x={$8*($w-w)/2} amp_y={$9*($w-w)/2}
    -r[-4--1] $w,$h,1,100%,0,0,0.5,0.5
    -f[-4] 'i(x+$amp_x*sin(y/h*pi),y,0,c,1,2)' -f[-1] 'i(x-$amp_x*sin(y/h*pi),y,0,c,1,2)'
    -f[-3] 'i(x,y+$amp_y*sin(x/w*pi),0,c,1,2)' -f[-2] 'i(x,y-$amp_y*sin(x/w*pi),0,c,1,2)'
    -blend[-4,-3] alpha -blend[-2,-1] alpha -c[-2,-1] 0,255

    # Render full pattern and merge.
    -/[-2,-1] 255 [-1] [-3] -a[-4,-2] x -a[-2,-1] x -a[-2,-1] y -rotate_tileable[-1] {$7*22.5} -r[-1] [-2],[-2],1,1,0,2 -*[-2,-1]
  -endl -a c -endl -done -v +

#@gmic whirls : _texture>=0,_smoothness>=0,_darkness>=0,_lightness>=0
#@gmic : Add random whirl texture to selected images.
#@gmic : Default values: 'texture=3', 'smoothness=6', 'darkness=0.5' and 'lightness=1.8'.
#@gmic : $ image.jpg --whirls ,
whirls : -skip ${1=3},${2=6},${3=0.5},${4=1.8}
  -e[^-1] "Add random whirl texture to image$?, with texture $1, smoothness $2, darkness $3 and lightness $4."
  -v - -repeat @# -l[$>]
    100%,100% -noise[-1] 0.3,2 -repeat $1 -b[-1] $2 -gradient_norm[-1] -^[-1] 0.2 -done
    -n[-1] $3,$4 -r[-1] [-2] -* -c 0,255
  -endl -done -v +

#------------------------------------
#
#@gmic :: Warpings
#
#------------------------------------

#@gmic euclidean2polar : _center_x[%],_center_y[%],_n>0,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Apply euclidean to polar transform on selected images.
#@gmic : Default values: 'center_x=center_y=50%', 'n=1' and 'boundary=1'.
#@gmic : $ image.jpg --euclidean2polar ,
euclidean2polar : -skip ${1=50%},${2=50%} -check "${3=1}>0 && isint(${4=1}) && $4>=0 && $4<=2"
  -e[^-1] "Apply euclidean to polar transform on image$?, with center point ($1,$2), power $3 and "@{-arg\ 1+$4,dirichlet,neumann,periodic}" boundary conditions."
  -v - -repeat @# -l[$>]
    cx={if(@{-is_percent\ $1},$1*(w-1),$1)}
    cy={if(@{-is_percent\ $2},$2*(h-1),$2)}
    R={sqrt(max($cx^2,(w-1-$cx)^2)+max($cy^2,(h-1-$cy)^2))}
    -f 'r=x*$R/(w-1);a=y*2*pi/(h-1);i($cx+r*cos(a),$cy+r*sin(a),z,c,1,$4)'
  -endl -done -v +

#@gmic deform : _amplitude>=0
#@gmic : Apply random smooth deformation on selected images.
#@gmic : Default value: 'amplitude=10'.
#@gmic : $ image.jpg --deform[0] 10 --deform[0] 20
deform : -skip ${1=10}
  -e[^-1] "Apply random smooth deformation on image$?, with amplitude $1."
  -v - -repeat @# -l[$>]
    2%,2%,1,2 -noise[-1] $1 -r[-1] [-2],[-2],1,2,5 -warp[-2] [-1],1,1,1 -rm[-1]
  -endl -done -v +

#@gmic fisheye : _center_x,_center_y,0<=_radius<=100,_amplitude>=0
#@gmic : Apply fish-eye deformation on selected images.
#@gmic : Default values: 'x=y=50', 'radius=50' and 'amplitude=1.2'.
#@gmic : $ image.jpg --fisheye ,
fisheye : -skip ${1=50},${2=50},${3=50},${4=1.2}
  -e[^-1] "Apply Fish-eye effect on image$?, centered at ($1%,$2%) with radius $3% and amplitude $4."
  -if {$4==0} -return -endif
  -v - -repeat @# -l[$>]
    100%,100%,1,1 -=[-1] 1,$1%,$2% -distance[-1] 1 -c[-1] 0,$3% -*[-1] -1 -n[-1] 0,1 -^[-1] {1/$4}
    -i[-2] ({-$1/100},{1-$1/100};{-$1/100},{1-$1/100}^{-$2/100},{-$2/100};{1-$2/100},{1-$2/100}) -r[-2] [-1],[-1],1,2,3
    -n[-1] 0,{max(w,h)} -*[-2,-1]
    -warp[-2] [-1],1,1,1 -rm[-1]
  -endl -done -v +

#@gmic flower : _amplitude,_frequency,_offset_r[%],_angle,_center_x[%],_center_y[%],_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Apply flower deformation on selected images.
#@gmic : Default values: 'amplitude=30', 'frequency=6', 'offset_r=0', 'angle=0', 'center_x=center_y=50%' and 'boundary=2'.
#@gmic : $ image.jpg -flower ,
flower : -skip ${1=30},${2=6},${3=0},${4=0},${5=50%},${6=50%},${7=2}
  -e[^-1] "Apply flower deformation on image$?, with amplitude $1, frequency $2, offset $3, angle $4 deg. and center point ($1,$2)."
  -v - -if @{-is_percent\ $3}
    -transform_polar "r + (R*$3) + R*$1/100*cos(a*$2+$4*pi/180)","a",$5,$6,$7
  -else
    -transform_polar "r + $3 + R*$1/100*cos(a*$2+$4*pi/180)","a",$5,$6,$7
  -endif -v +

#@gmic kaleidoscope : _center_x[%],_center_y[%],_radius,_angle,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Create kaleidoscope effect from selected images.
#@gmic : Default values: 'center_x=center_y=50%', 'radius=100', 'angle=30' and 'boundary=1'.
#@gmic : $ image.jpg --kaleidoscope ,
kaleidoscope : -skip ${1=50%},${2=50%},${3=100},${4=30},${5=1}
  -e[^-1] "Create kaleidoscope effect from image$?, with center point ($1,$2), radius $3, angle $4 deg."
  -v - -euclidean2polar $1,$2,1,$5 -repeat @# -l[$>]
    --columns 0,$3% -rows[-1] 0,$4% -r[-1] [-2],0,2 -nm[1] @{0,n} -rm[0]
  -endl -done -polar2euclidean $1,$2,1,$5 -v +

#@gmic map_sphere : _width>0,_height>0,_radius,_dilation>0,_fading>=0,_fading_power>=0
#@gmic : Map selected images on a sphere.
#@gmic : Default values: 'width=height=512', 'radius=100', 'dilation=0.5', 'fading=0' and 'fading_power=0.5'.
#@gmic : $ image.jpg --map_sphere ,
map_sphere : -check "${1=512}>0 && ${2=512}>0 && ${5=0}>=0 && ${6=0.5}>=0" -skip ${3=100},${4=0.5}
   -e[^-1] "Map image$? on spheres in $1x$2 images, with radius $3, dilation $4 and fading $5."
   -v - r2={($3*min($1,$2)/200)^2} # Compute squared radius.
   -repeat @# -l[$>]
     -i[-2] 100%,1,1,100%,0 -nm[0] @{1,n} -a y # Add one border line to have a sphere exterior.
     ({-$1/2},{$1/2}) ({-$2/2};{$2/2}) -r[-2,-1] $1,$2,1,1,3 -atan2[-1] [-2] -rm[-2] # Compute theta angle.
     $1,$2 -=[-1] 1,50%,50% -distance[-1] 1,3 -/[-1] $r2 -sqrt[-1] -c[-1] 0,1
     -asin[-1] # Compute phi angle.
     -+[-2] {pi} -*[-2] {(@{-3,w}-1)/(2*pi)} # Normalize theta to X-coordinates
     -*[-1] {2/pi} -^[-1] $4 -*[-1] {@{-3,h}-1} -*[-1] -1 -+[-1] {@{-3,h}-1} # Normalize phi to Y-coordinates
     -if $5 -->=[-1] 1 -distance[-1] 1 -c[-1] 0,$5% -n[-1] 0,1 -^[-1] $6 -c[-2] 1,100% --[-2,-1] -endif
     -r[-1,-2] 100%,100%,@{-3,d}
     --f[-1] z -a[-3--1] c
      -warp[-2] [-1],0,1,1 -rm[-1] # Apply image warping
   -endl -done -v +

#@gmic polar2euclidean : _center_x[%],_center_y[%],_n>0,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Apply euclidean to polar transform on selected images.
#@gmic : Default values: 'center_x=center_y=50%', 'n=1' and 'boundary=1'.
#@gmic : $ image.jpg --euclidean2polar ,
polar2euclidean : -skip ${1=50%},${2=50%} -check "${3=1}>0 && isint(${4=1}) && $4>=0 && $4<=2"
  -e[^-1] "Apply polar to euclidean transform on image$?, with center point ($1,$2), power $3 and "@{-arg\ 1+$4,dirichlet,neumann,periodic}" boundary conditions."
  -v - -repeat @# -l[$>]
    cx={if(@{-is_percent\ $1},$1*(w-1),$1)}
    cy={if(@{-is_percent\ $2},$2*(h-1),$2)}
    R={sqrt(max($cx^2,(w-1-$cx)^2)+max($cy^2,(h-1-$cy)^2))}
    -f 'X=sqrt((x-$cx)^2+(y-$cy)^2);tmp=atan2((y-$cy),(x-$cx));Y=if(tmp<0,tmp+2*pi,tmp);i(X*(w-1)/$R,Y*(h-1)/(2*pi),z,c,1,$4)'
  -endl -done -v +

#@gmic raindrops : _amplitude,_density>=0,_wavelength>=0,_merging_steps>=0
#@gmic : Apply raindrops deformation on selected images.
#@gmic : Default values: 'amplitude=80','density=0.1', 'wavelength=1' and 'merging_steps=0'.
#@gmic : $ image.jpg --raindrops ,
raindrops : -check "${2=0.1}>=0 && ${3=1}>=0 && isint(${4=0}) && $4>=0" -skip ${1=80}
  -e[^-1] "Apply raindrops deformation on image$?, with amplitude $1, density $2, wavelength $3 and $4 merging steps."
  -v - -repeat @# -l[$>]
    100%,100% -noise[-1] $2,2 -distance[-1] 1 -f[-1] 'cos(i)/(1+i/(1e-8+$3))'
    -if $4
      -i[-2] (0,1,0;1,0,1;0,1,0) -/[-2] 2 [-1]
      -repeat $4 --convolve[-1] [-3],1 --[-1] [-3] -rm[-3] -done -rm[-3,-2]
    -endif
    -g[-1] -a[-2,-1] c -*[-1] {$1/(1e-5+max(abs(im),abs(iM)))}
    -warp[-2] [-1],1 -rm[-1]
  -endl -done -v +

#@gmic ripple : _amplitude,_bandwidth,_shape={ 0=bloc | 1=triangle | 2=sine | 3=sine+ | 4=random },_angle,_offset
#@gmic : Apply ripple deformation on selected images.
#@gmic : Default values: 'amplitude=10', 'bandwidth=10', 'shape=2', 'angle=0' and 'offset=0'.
#@gmic : $ image.jpg --ripple ,
ripple : -skip ${1=10},${2=20},${3=2},${4=0},${5=0}
  -e[^-1] "Apply ripple deformation on image$?, with amplitude $1, bandwidth $2, shape $3, angle $4 deg. and offset $5."
  -v -
  theta={$4*pi/180} C={cos($theta)} S={-sin($theta)}
  -repeat @# -l[$>]
    100%,100%,1,1,"x" --[-1] {w/2} 100%,100%,1,1,'y'
    --[-1] {h/2-$5} -*[-2] $S -*[-1] $C -+[-2,-1]      # Generate rotated Y.
    -_ripple$3[-1] $1,$2                               # Generate warp field.
    --*[-1] {-$S} -*[-2] $C -a[-2,-1] c                # Rotate warp field.
    -warp[-2] [-1],1 -rm[-1]
  -endl -done -v +

_ripple0 : -f {$1/2}*"(1-2*(i%"{2*$2}"<$2))"
_ripple1 : -f "I=(i%$2)/$2;$1*(2*if(I<0.5,I,1-I)-0.5)"
_ripple2 : -f {-$1/2}*"cos(i*"{2*pi/$2}")"
_ripple3 : -f {-$1/2}*"abs(cos(i*"{2*pi/$2}"))"
_ripple4 : -skip $* -n 0,{h-1} 1,{h} -rand[-1] {-$1/2},{$1/2} m={im} M={iM} -b[-1] {$2/10} -n[-1] $m,$M -map[-2] [-1] -rm[-1]

#@gmic rotoidoscope : _center_x[%],_center_y[%],_tiles>0,_smoothness[%]>=0,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Create rotational kaleidoscope effect from selected images.
#@gmic : Default values: 'cx=cy=50%', 'tiles=10', 'smoothness=1' and 'boundary=1'.
#@gmic : $ image.jpg --rotoidoscope ,
rotoidoscope : -skip ${1=50%},${2=50%},${5=1} -check "${3=10}>0 && ${4=1}>=0"
  -e[^-1] "Create rotational kaleidoscope effect from image$?, with center point ($1,$2), $3 tiles and smoothness $4."
  -v - -repeat @# -l[$>]
    -repeat $3 --rotate[0] {360/$3},1,$5,$1,$2 -blend_edges $4 -done
  -endl -done -v +

#@gmic symmetrize : _x[%],_y[%],_angle,_boundary={ 0=dirichlet | 1=neumann | 2=periodic },_is_antisymmetry={ 0 | 1 },_swap_sides={ 0 | 1 }
#@gmic : Symmetrize selected image regarding specified axis.
#@gmic : Default values: 'x=y=50%', 'angle=90', 'boundary=1', 'is_antisymmetry=0' and 'swap_sides=0'.
#@gmic : $ image.jpg --symmetrize 50%,50%,45 --symmetrize[-1] 50%,50%,-45
symmetrize : -skip ${1=50%},${2=50%},${3=90},${4=1},${5=0},${6=0}
  -e[^-1] "Symmetrize image$?, regarding axis ($1,$2,$3 deg.)."
  -v -
  theta={$3*pi/180} u={cos($theta)} v={sin($theta)}
  -if $6 symmetry_cond=A<0 -else symmetry_cond=A>0 -endif
  -repeat @# -l[$>]
    x0={if(@{-is_percent\ $1},w*$1,$1)}
    y0={if(@{-is_percent\ $2},h*$2,$2)}
    -if $5 -f 'A=($y0-y)*$u-($x0-x)*$v;X=x+2*($x0-x);Y=y+2*($y0-y);if($symmetry_cond,i(X,Y,z,c,1,$4),i)'
    -else -f 'A=($y0-y)*$u-($x0-x)*$v;X=x-2*$v*A;Y=y+2*$u*A;if($symmetry_cond,i(X,Y,z,c,1,$4),i)'
    -endif
  -endl -done
  -v +

#@gmic transform_polar : "expr_radius",_"expr_angle",_center_x[%],_center_y[%],_boundary={ 0=dirichlet | 1=neumann }
#@gmic : Apply user-defined transform on polar representation of selected images.
#@gmic : Default values: 'expr_radius=R-r', 'expr_rangle=a', 'center_x=center_y=50%' and 'boundary=1'.
#@gmic : $ image.jpg --transform_polar[0] R*(r/R)^2,a --transform_polar[0] r,2*a
transform_polar : -skip "${1=R-r}","${2=a}",${3=50%},${4=50%},${5=1}
  -e[^-1] "Apply custom polar transform with 'new_r = $1', 'new_a = $2', center point ($3%,$4%)."
  -v - -repeat @# -l[$>]
    cx={if(@{-is_percent\ $3},$3*(w-1),$3)}
    cy={if(@{-is_percent\ $4},$4*(h-1),$4)}
    R={sqrt(max($cx^2,(w-1-$cx)^2)+max($cy^2,(h-1-$cy)^2))}
    -f "R ="$R";
        r = sqrt((x-"$cx")^2 + (y-"$cy")^2);
        a = atan2(y-"$cy",x-"$cx");
        nr = $1;
        na = $2;
        i("$cx" + nr*cos(na), "$cy" + nr*sin(na), z, c,1,$5)"
  -endl -done -v +

#@gmic twirl : _amplitude,_center_x[%],_center_y[%],_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Apply twirl deformation on selected images.
#@gmic : Default values: 'amplitude=1', 'center_x=center_y=50%' and 'boundary=1'.
#@gmic : $ image.jpg --twirl 0.6
twirl : -skip ${1=1},${2=50%},${3=50%},${4=1}
  -e[^-1] "Apply twirl deformation on image$?, with amplitude $1 and center point at ($2%,$3%)."
  -v - -euclidean2polar $2,$3,1,$4 -repeat @#
    [$>],[$>],1,1,$1*x -channels[-1] -1,0 -warp[$>] [-1],1,1,2 -rm[-1]
  -done -polar2euclidean $2,$3,1,1 -v +

#@gmic warp_perspective : _x-angle,_y-angle,_zoom>0,_x-center,_y-center,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Warp selected images with perspective deformation.
#@gmic : Default values: 'x-angle=1.5', 'y-angle=0', 'zoom=1', 'x-center=y-center=50' and 'boundary=2'.
#@gmic : $ image.jpg --warp_perspective ,
warp_perspective : -skip ${1=1.5},${2=0},${3=1},${4=50},${5=50},${6=2}
  -e[^-1] "Apply perspective warp on image$?, with angles ($1 deg.,$2 deg.), zoom $3 and offsets ($4,$5)."
  -v - -repeat @# -l[$>]
    (0,100) --[-1] $4 -/[-1] 100 (0;100) --[-1] $5 -/[-1] 100 -r[-2,-1] [-3],[-3],[-3],1,3
    --*[-2] $2 --*[-2] $1 -+[-2,-1] -+[-1] $3 -/[-3] [-1] -/[-2,-1]
    -*[-2] 100 -+[-2] $4 -/[-2] 100 -*[-2] @{-3,w}
    -*[-1] 100 -+[-1] $5 -/[-1] 100 -*[-1] @{-3,h}
    -a[-2,-1] c -warp[-2] [-1],0,1,$6 -rm[-1]
  -endl -done -v +

#@gmic water : _amplitude>=0,_smoothness>=0
#@gmic : Apply water deformation on selected images.
#@gmic : Default values: 'amplitude=30' and 'smoothness=1.5'.
#@gmic : $ image.jpg --water ,
water : -skip ${1=30},${2=1.5}
  -e[^-1] "Apply water deformation on image$?, with amplitude $1 and smoothness $2."
  -v - -repeat @# -l[$>]
    25%,25%,25%,1 -noise[-1] $1 -g[-1] xyz -+[-1,-2,-3] -b[-1] $2 -*[-1] 2 -r[-1] [-2],[-2],1,2,3 -warp[-2] [-1],1 -rm[-1]
  -endl -done -v +

#@gmic wave : _amplitude>=0,_frequency>=0,_center_x,_center_y
#@gmic : Apply wave deformation on selected images.
#@gmic : Default values: 'amplitude=4', 'frequency=0.4' and 'center_x=center_y=50'.
#@gmic : $ image.jpg --wave ,
wave : -skip ${1=4},${2=0.4},${3=50},${4=50}
  -e[^-1] "Apply wave deformation on image$?, with amplitude $1, frequency $2 and center point at ($3%,$4%)."
  -v - -repeat @# -l[$>]
    100%,100% -=[-1] 1,$3%,$4% -distance[-1] 1
    -*[-1] $2 --sin[-1] -cos[-2] -a[-2,-1] c -*[-1] $1
    -warp[-2] [-1],1 -rm[-1]
  -endl -done -v +

#@gmic wind : _amplitude>=0,_angle,0<=_attenuation<=1,_threshold
#@gmic : Apply wind effect on selected images.
#@gmic : Default values: 'amplitude=20', 'angle=0', 'attenuation=0.7' and 'threshold=20'.
#@gmic : $ image.jpg --wind ,
wind : -check "isint(${1=20}) && $1>=0 && ${3=0.7}>=0 && $3<=1" -skip "${2=0},${4=20}"
  -e[^-1] "Apply wind effect on image$?, with amplitude $1, angle "{round($2/45)*45}" deg., attenuation $3 and threshold $4."
  -v -
  -if {!$1} -return -endif
  dxdy=@{-_wind{round($2/45)%8}}
  fact={(1-$3)^(1/$1)}
  -repeat @# -l[$>]
    --gradient_norm ->=[-1] $4%
    -r[-1] 100%,100%,1,[-2] -*[-1] [-2]
    -repeat $1
      -shift[-1] $dxdy,0,0,0 -max[-2] [-1] -*[-1] $fact
      -remove_pixels[-1] {100/$1}%
    -done -rm[-1]
  -endl -done -v +

_wind0 : -u 1,0
_wind1 : -u 1,1
_wind2 : -u 0,1
_wind3 : -u -1,1
_wind4 : -u -1,0
_wind5 : -u -1,-1
_wind6 : -u 0,-1
_wind7 : -u 1,-1

#@gmic zoom : _factor,_cx,_cy,_cz,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Apply zoom factor to selected images.
#@gmic : Default values: 'factor=1', 'cx=cy=cz=0.5' and 'boundary=0'.
#@gmic : $ image.jpg --zoom[0] 0.6 --zoom[0] 1.5
zoom : -skip ${1=2},${2=0.5},${3=0.5},${4=0.5},${5=0}
  -e[^-1] "Apply zoom effect on image$?, with factor $1 and center ($2,$3)."
  -v - -repeat @# -l[$>]
    -if {d==1} # 2d image.
       ({(w-1)*$2*(1-1/$1)},{(w-1)*($2+(1-$2)/$1)})
       ({(@{-2,h}-1)*$3*(1-1/$1)};{(@{-2,h}-1)*($3+(1-$3)/$1)})
       -r[-2--1] [-3],[-3],1,1,3 -a[-2--1] c -warp[-2] [-1],0,1,$5
    -else # 3d image.
       ({(w-1)*$2*(1-1/$1)},{(w-1)*($2+(1-$2)/$1)})
       ({(@{-2,h}-1)*$3*(1-1/$1)};{(@{-2,h}-1)*($3+(1-$3)/$1)})
       ({(@{-3,d}-1)*$4*(1-1/$1)}/{(@{-3,d}-1)*($4+(1-$4)/$1)})
       -r[-3--1] [-4],[-4],[-4],1,3 -a[-3--1] c -warp[-2] [-1],0,1,$5
    -endif
    -rm[-1]
  -endl -done -v +

#-----------------------------
#
#@gmic :: Degradations
#
#-----------------------------

#@gmic cracks : _density>=0,_amplitude,_relief={ 0 | 1 }
#@gmic : Add random cracks to selected images.
#@gmic : Default values: 'density=0.2', 'amplitude=40' and 'relief=0'.
#@gmic : $ image.jpg --cracks 0.2,60,1
cracks : -skip ${1=0.2},${2=40},${3=0}
  -e[^-1] "Add random cracks to image$?, with density $1."
  -v - -repeat @# -l[$>]
    ({im},{iM}) [-2],[-2],1,1 -noise[-1] $1,2 -distance[-1] 1 -sharpen[-1] 10000
    -if $3 -g[-1] xy -+[-2,-1] -n[-1] -1,1 -else -n[-1] 0,1 -endif
    -*[-1] $2 -+[-3,-1] -c[-2] @-1 -rm[-1]
  -endl -done -v +

#@gmic light_patch : _density>0,_darkness>=0,_lightness>=0
#@gmic : Add light patches to selected images.
#@gmic : Default values: 'density=10', 'darkness=0.9' and 'lightness=1.7'.
#@gmic : $ image.jpg --light_patch 20,0.9,4
light_patch : -skip ${1=10},${2=0.9},${3=1.7}
  -e[^-1] "Apply light patches to image$?, with density $1, darkness $2 and lightness $3."
  -v - -repeat @# -l[$>]
    -n 0,255 $1,$1 -noise[-1] 40 -r[-1] [-2],5 -c[-1] 0,255
    -n[-1] $2,$3 -* -c 0,255
  -endl -done -v +

#@gmic noise_hurl : _amplitude>=0
#@gmic : Add hurl noise to selected images.
#@gmic : Default value: 'amplitude=10'.
#@gmic : $ image.jpg --noise_hurl ,
noise_hurl : -skip ${1=10}
  -e[^-1] "Add hurl noise to image$?, with amplitude $1%."
  -v - -repeat @# -l[$>]
    --f 0 -noise[-1] 10 -n[-1] @{-2,m},@{-2,M} 100%,100%,1,1,-2
    -noise[-1] $1,2 ->=[-1] 0 -r[-1] [-2]
    -*[-2] [-1] -*[-1] -1 -+[-1] 1 -*[-3,-1] -+
  -endl -done -v +

#@gmic pixelize : _scale_x>0,_scale_y>0,_scale_z>0
#@gmic : Pixelize selected images with specified scales.
#@gmic : Default values: 'scale_x=20' and 'scale_y=scale_z=scale_x'.
#@gmic : $ image.jpg --pixelize ,
pixelize : -skip ${1=20},${2=$1},${3=$1}
  -e[^-1] "Pixelize image$? with scales ($1%,$2%,$3%)."
  -v - -repeat @# -l[$>] whd={w},{h},{d} -r $1%,$2%,$3%,100%,2 -r $whd -endl -done -v +

#@gmic scanlines : _amplitude,_bandwidth,_shape={ 0=bloc | 1=triangle | 2=sine | 3=sine+ | 4=random },_angle,_offset
#@gmic : Apply ripple deformation on selected images.
#@gmic : Default values: 'amplitude=60', 'bandwidth=2', 'shape=0', 'angle=0' and 'offset=0'.
#@gmic : $ image.jpg --ripple ,
scanlines : -skip ${1=60},${2=2},${3=0},${4=0},${5=0}
  -e[^-1] "Apply scanlines effect on image$?, with amplitude $1, bandwidth $2, shape $3, angle $4 deg. and offset $5."
  -v -
  theta={$4*pi/180} C={cos($theta)} S={-sin($theta)}
  -repeat @# -l[$>]
    100%,100%,1,1,"x" --[-1] {w/2} 100%,100%,1,1,'y'
    --[-1] {h/2-$5} -*[-2] $S -*[-1] $C -+[-2,-1]      # Generate rotated Y.
    -_ripple$3[-1] $1,$2                               # Generate warp field.
    -n[-1] {-$1},$1
    -+ -cut 0,255
  -endl -done -v +

#@gmic shade_stripes : _frequency>=0,_direction={ 0=horizontal | 1=vertical },_darkness>=0,_lightness>=0
#@gmic : Add shade stripes to selected images.
#@gmic : Default values: 'frequency=5', 'direction=1', 'darkness=0.8' and 'lightness=2'.
#@gmic : $ image.jpg --shade_stripes 30
shade_stripes : -skip ${1=5},${2=1},${3=0.8},${4=2}
  -e[^-1] "Add "@{-arg\ 1+!$2,vertical,horizontal}" shaded stripes to image$?, with frequency $1, darkness $3 and lightness $4."
  -v - -n 0,255 -repeat @# -l[$>]
    {max(1,w*($2!=0))},{max(1,h*($2==0))} -noise[-1] $1,2 -distance[-1] 1 -r[-1] [-2] -n[-1] $3,$4 -* -c 0,255
  -endl -done -v +

#@gmic shadow_patch : _opacity>=0
#@gmic : Add shadow patches to selected images.
#@gmic : Default value: 'opacity=0.7'.
#@gmic : $ image.jpg --shadow_patch 0.4
shadow_patch : -skip ${1=0.7}
  -e[^-1] "Apply shadow patches to image$?, with opacity $1."
  -v - -repeat @# -l[$>]
    100%,100%,1,1 -shift[-1] -2,-2 -shift[-1] 1,1
    -plasma[-1] 3,0.3,8 -abs[-1] -b[-1] 1 -c[-1] 3%,15% -r[-1] [-2]
    -n[-1] $1,1 -*
  -endl -done -v +

#@gmic spread : _dx>=0,_dy>=0,_dz>=0
#@gmic : Spread pixel values of selected images randomly along x,y and z.
#@gmic : Default values: 'dx=3', 'dy=dx' and 'dz=0'.
#@gmic : $ image.jpg --spread 3
spread : -skip ${1=3},${2=$1},${3=0}
  -e[^-1] "Spread pixel of image$? randomly, with amplitudes ($1,$2,$3)."
  -v - -repeat @# -l[$>]
    100%,100%,100%,3
    -sh[-1] 0,0 -rand[-1] {-$1},$1 -rm[-1]
    -sh[-1] 1,1 -rand[-1] {-$2},$2 -rm[-1]
    -sh[-1] 2,2 -rand[-1] {-$3},$3 -rm[-1]
    -warp[-2] [-1],1 -rm[-1]
  -endl -done -v +

#@gmic stripes_y : _frequency>=0
#@gmic : Add vertical stripes to selected images.
#@gmic : Default value: 'frequency=10'.
#@gmic : $ image.jpg --stripes_y ,
stripes_y : -skip ${1=10}
  -e[^-1] "Add vertical stripes to image$?, with frequency $1."
  -v - -repeat @# -l[$>]
    100% -noise[-1] $1,2 -*[-1] 255 -r[-1] [-2]
    -*[-1] 0.15 -+ -c 0,255
  -endl -done -v +

#@gmic texturize_canvas : _amplitude>=0,_fibrousness>=0,_emboss_level>=0
#@gmic : Add paint canvas texture to selected images.
#@gmic : Default values: 'amplitude=20', 'fibrousness=3' and 'emboss_level=0.6'.
#@gmic : $ image.jpg --texturize_canvas ,
texturize_canvas : -check "${1=20}>=0 && ${2=3}>=0 && ${3=0.6}>=0 && ${4=80}"
  -e[^-1] "Add canvas texture to image$?, with amplitude $1, fibrousness $2 and emboss level $3."
  -repeat @# -l[$>]
    {w},{h} -rand[-1] 0,255 --blur_x[-1] $2 -blur_y[-2] $2 -+[-2,-1] -g[-1] -a[-2,-1] c
    --compose_channels[-1] + -orientation[-2] -compose_channels[-2] + -n[-2] $3,1 -n[-1] 0,255
    -sharpen[-1] 80 -*[-2,-1] -n[-1] -$1,$1 -+ -c 0,255
  -endl -done -v +

#@gmic texturize_paper
#@gmic : Add paper texture to selected images.
#@gmic : $ image.jpg --texturize_paper
texturize_paper :
  -e[^-1] "Add paper texture to image$?."
  -v - -repeat @# -l[$>]
    [-1] 30%,30% -noise[-1] 1,2 -r[-1] [-2],[-2],[-2],1,0 -ifft[-1]
    -rm[-1] -shift[-1] 50%,50%,50%,0,2 -sharpen[-1] 1 -n[-1] 1,1.2 -r[-1] [-2]
    -*[-2,-1] -c[-1] [-2],[-2] -rm[-2]
  -endl -done -v +

#@gmic vignette : _strength>=0,0<=_radius_min<=100,0<=_radius_max<=100
#@gmic : Add vignette effect to selected images.
#@gmic : Default values: 'strength=100', 'radius_min=70' and 'radius_max=90'.
#@gmic : $ image.jpg --vignette ,
vignette : -check "${1=100}>=0 && ${2=70}>=0 && $2<=100 && ${3=90}>=0 && $3<=100"
  -e[^-1] "Add vignette effect to image$?, with strength $1 and size $2."
  -v - -repeat @# -l[$>]
    mM={im},{iM} d={max(w,h)}
    $d,$d -=[-1] 1,50%,50% -distance[-1] 1 -r[-1] [-2],2
    -c[-1] $2%,$3% -n[-1] 0,$1 -- -c $mM
  -endl -done -v +

#@gmic watermark_visible : _text,0<_opacity<1,_size>0,_angle,_mode={ 0=remove | 1=add },_smoothness>=0
#@gmic : Add or remove a visible watermark on selected images (value range must be [0,255]).
#@gmic : Default values: 'text=(c) G'MIC', 'opacity=0.3', 'size=53', 'angle=25', 'mode=1' and 'smoothness=0'.
#@gmic : $ image.jpg --watermark_visible ,0.7
watermark_visible : -skip "${1=\251\ G\47MIC}" -check "${2=0.3}>0 && $2<1 && ${3=53}>0 && ${6=0.5}>=0" -skip ${4=25},${5=1}
  -e[^-1] @{-arg\ 1+!$5,Add,Remove}" visible watermark '$1' on image$?, with opacity $2, size $3, angle $4 deg."
  -v - -repeat @# -l[$>]
    0 -t[-1] "$1",0,0,$3,1,255 -rotate[-1] $4,0,0 -b[-1] $6 -n[-1] 0,255
    -r[-1] [-2],0,2 -+[-1] [-2] -c[-1] 0,255  # Generate opaque watermark image
    -if $5 -*[-1] $2 -*[-2] {1-$2} -+  # Add watermark
    -else -*[-1] $2 -- -/ {1-$2}       # Remove watermark
    -endif
    -c 0,255
  -endl -done -v +

#--------------------------------------
#
#@gmic :: Blending and fading
#
#--------------------------------------

#@gmic blend : [layer],blending_mode,0<=_opacity<=1,_selection_is={ 0=base-layers | 1=top-layers } : blending_mode,0<=_opacity<=1
#@gmic : Blend selected G,GA,RGB or RGBA images by specified layer or blend all selected images together, using specified blending mode.
#@gmic : 'blending_mode' can be { add | alpha | and | average | blue | burn | darken | difference |
#@gmic : divide | dodge | edges | exclusion | freeze | grainextract | grainmerge | green | hardlight |
#@gmic : hardmix | hue | interpolation | lighten | lightness | linearburn | linearlight | luminance |
#@gmic : multiply | negation | or | overlay | pinlight | red | reflect | saturation | seamless | seamless_mixed |
#@gmic : screen | shapeaverage | shapeaverage0 | softburn | softdodge | softlight | stamp | subtract | value |
#@gmic : vividlight | xor }.
#@gmic : Default values: 'blending_mode=alpha', 'opacity=1' and 'selection_is=0'.
#@gmic : $ image.jpg --drop_shadow , -resize2dy[-1] 200 -rotate[-1] 20 --blend alpha -drgba[-2]
#@gmic : $ image.jpg -testimage2d {w},{h} -blend overlay
#@gmic : $ -m "ex : $""=arg -repeat $""# --blend[0,1] ${arg{$>+1}} -text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 -done" image.jpg -testimage2d {w},{h} -ex add,alpha,and,average,blue,burn,darken
#@gmic : $ -m "ex : $""=arg -repeat $""# --blend[0,1] ${arg{$>+1}} -text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 -done" image.jpg -testimage2d {w},{h} -ex difference,divide,dodge,exclusion,freeze,grainextract,grainmerge
#@gmic : $ -m "ex : $""=arg -repeat $""# --blend[0,1] ${arg{$>+1}} -text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 -done" image.jpg -testimage2d {w},{h} -ex green,hardlight,hardmix,hue,interpolation,lighten,lightness
#@gmic : $ -m "ex : $""=arg -repeat $""# --blend[0,1] ${arg{$>+1}} -text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 -done" image.jpg -testimage2d {w},{h} -ex linearburn,linearlight,luminance,multiply,negation,or,overlay
#@gmic : $ -m "ex : $""=arg -repeat $""# --blend[0,1] ${arg{$>+1}} -text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 -done" image.jpg -testimage2d {w},{h} -ex pinlight,red,reflect,saturation,screen,shapeaverage,softburn
#@gmic : $ -m "ex : $""=arg -repeat $""# --blend[0,1] ${arg{$>+1}} -text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 -done" image.jpg -testimage2d {w},{h} -ex softdodge,softlight,stamp,subtract,value,vividlight,xor
blend : -skip ${1=alpha},${2=1},${3=1},${4=0}
  -v -
  -if {arg(1,{'$1'})=={'['}}
    n={narg($*)} mode=@{-arg\ 1+($n>=2),alpha,$2}
    -v + -e[^-1] "Blend image$? with "@{-arg\ 1+$4,base,top}" layer $1, using '"$mode"' mode and opacity $3." -v -
    -repeat @# -pass$1 -l[$>,-1] -if $4 -rv -endif -blend $mode,$3 -endl -done -v + -return
  -endif
  -v + -e[^-1] "Blend all image$? together, using '$1' mode and opacity $2." -v -
  -repeat {@#-1} -l[0,1]
    -r[1] [0],[0],[0],100%,0,0,0.5,0.5
    s={s0=if(@{0,s}<3,1,3);s1=if(s<3,1,3);max(s0,s1)} # Target color format (G or RGB).
    -to_colormode[0] {$s+1-(@{0,s}%2)} # Target format (G,GA,RGB or RGBA).
    -to_colormode[1] {$s+1-(s%2)} # Mask format (G,GA,RGB or RGBA).
    -if {@{0,s}==2||@{0,s}==4} # Target has alpha.
      -if {s==2||s==4} # Mask has alpha.
        -sh[0,1] 0,{s-2} -_blend_$1[2,3] -rm[2,3]
        -if {$1'=='alpha} # Special blending code for alpha-mode.
          -sh[0,1] 0,{@{0,s}-2} -sh[0,1] 100%,100% -*[2,4] -*[3,4] -rm[2,3]
          --channels[1] 100% -sh[1] 100%,100% -f[3] 255 -rm[3]
          -j[0] [1],0,0,0,0,{max(0,min(1,$2))},[2],255 -rm[1,2]
          -sh[0] 0,{s-2} -sh[0] 100%,100% -+[2] 1e-10 -/[1,2] -rm[1] -c 0,255
        -else
          -sh[1] 0,{s-2} -sh[1] 100%,100% -j[0] [2],0,0,0,0,{max(0,min(1,$2))},[3],255 -rm[^0]
        -endif
      -else # Mask has no alpha.
        -sh[0] 0,{@{0,s}-2} -rv[1,2] -_blend_$1[1,2] -j[1] [2],0,0,0,0,{max(0,min(1,$2))} -rm[^0]
      -endif
    -else # Target has no alpha.
      -if {s==2||s==4} # Mask has alpha.
        -sh[1] 0,{s-2} -_blend_$1[0,2] -rm[2]
        -sh[1] 100%,100% -j[0] [1],0,0,0,0,{max(0,min(1,$2))},[2],255 -rm[^0]
      -else # Mask has no alpha.
        -_blend_$1 -j[0] [1],0,0,0,0,{max(0,min(1,$2))} -rm[1]
      -endif
    -endif
  -endl -done -v +

_blend_alpha :
_blend_and :
  -and[1] [0]
_blend_add :
  -+[1] [0] -c[1] 0,255
_blend_average :
  -+[1] [0] -/[1] 2
_blend_blue :
  -sh[0] 0,1 -j[1] [2] -rm[2]
_blend_burn :
  ---[0] 255 -+[1] 0.1 -/[2] [1] -rm[1] -+[1] 1 -*[1] 255 -c[1] 0,255
_blend_darken :
  -min[1] [0]
_blend_difference :
  --[1] [0] -abs[1]
_blend_divide :
  -+[1] 0.1 -^[1] -1 -*[1] [0] -*[1] 255 -c[1] 0,255
_blend_dodge :
  --[1] 255.1 -^[1] -1 -*[1] [0] -*[1] -255 -c[1] 0,255
_blend_edges :
  --blend_edges 0.5 -rm[1]
_blend_exclusion :
  --*[0,1] -/[2] -127.5 -+[1,2] -+[1] [0]
_blend_freeze :
  -*[1] -255 --[1] 0.1 ---[0] 255 -sqr[2] -/[2] [1] -rm[1] -+[1] 1 -*[1] 255 -c[1] 0,255
_blend_grainextract :
  --[1] [0] -*[1] -1 -+[1] 128 -c[1] 0,255
_blend_grainmerge :
  -+[1] [0] --[1] 128 -c[1] 0,255
_blend_green :
  -sh[0] 0,0 -sh[0] 2,2 -j[1] [2] -j[1] [3],0,0,0,2 -rm[2,3]
_blend_hardlight :
  --*[0,1] -/[2] 127.5 --+[0,1] -*[3] 2 --[3] 255 --[3] [2] ->[1] 128
  -j[2] [3],0,0,0,0,1,[1] -rm[1,3] -c[1] 0,255
_blend_hardmix :
  -+[1] [0] ->=[1] 255 -*[1] 255
_blend_hue :
  -to_color -sh 0,2 -rgb2hsv[2,3] -sh[2] 1,2 -j[1] [4],0,0,0,1 -rm[4] -hsv2rgb[2,3] -rm[2,3]
_blend_interpolation :
  --*[0] {pi/255} -*[1] {pi/255} -cos[1,2] -+[1,2] --[1] 2 -*[1] -63.75 -c[1] 0,255
_blend_lighten :
  -max[1] [0]
_blend_lightness :
  -to_color -sh 0,2 -rgb2lab[2,3] -sh[2] 1,2 -j[1] [4],0,0,0,1 -rm[4] -lab2rgb[2,3] -rm[2,3]
_blend_luminance :
  -to_color -sh 0,2 -rgb2ycbcr[2,3] -sh[2] 1,2 -j[1] [4],0,0,0,1 -rm[4] -ycbcr2rgb[2,3] -rm[2,3]
_blend_linearburn :
  -+[1] [0] --[1] 255 -c[-1] 0,255
_blend_linearlight :
  -*[1] 2 -+[1] [0] --[1] 255 -c[1] 0,255
_blend_multiply :
  -*[1] [0] -/[1] 255
_blend_negation :
  -+[1] [0] --[1] 255 -abs[1] -*[1] -1 -+[1] 255
_blend_or :
  -or[1] [0]
_blend_overlay :
  --*[0,1] -/[2] 127.5 -+[1] [0] -*[1] 2 --[1] 255 --[1] [2] --<[0] 128 -j[1] [2],0,0,0,0,1,[3] -rm[2,3] -c[1] 0,255
_blend_pinlight :
  -*[1] 2 --blend darken --[1] 256 --blend[0,1] lighten ->=[1] 0
  -j[2] [3],0,0,0,0,1,[1] -rm[1,3]
_blend_reflect :
  --[1] 255.1 -*[1] -1 --sqr[0] -/[2] [1] -rm[1] -c[1] 0,255
_blend_red :
  -sh[0] 1,100% -j[1] [2],0,0,0,1 -rm[2]
_blend_saturation :
  -to_color -sh 0,2 -rgb2hsv[2,3] -shift[2,3] 0,0,0,-1,2 -sh[2] 1,2 -j[1] [4],0,0,0,1 -rm[4] -shift[2,3] 0,0,0,1,2 -hsv2rgb[2,3] -rm[2,3]
_blend_screen :
  ---[0] 255 --[1] 255 -*[1,2] -/[1] 255 -*[1] -1 -+[1] 255
_blend_shapeaverage :
  -norm[1] -label[1] N={iM+1}
  -repeat @{0,s} --channels[0] $> m={im} M={iM} -n[-1] 0,{1-1/256} -+[-1] [1] -histogram[-1] {$N*256},0,{$N-1/256}
  -i[-2] 256,1,1,1,'x*($M-$m)/255+$m' -r[-2] [-1],0,2 -*[-2] [-1] -r[-2,-1] $N,1,1,1,2 -+[-1] 1e-8 -/[-2,-1] -done
  -a[2--1] c -map[1] [2] -rm[2]
_blend_shapeaverage0 : # Same as shapeaverage except that background values (i.e. 0) are kept to black.
  -norm[1] --!=[1] 0 -label[1] N=@{1,iM+1}
  -repeat @{0,s} --channels[0] $> m={im} M={iM} -n[-1] 0,{1-1/256} -+[-1] [1] -histogram[-1] {$N*256},0,{$N-1/256}
  -i[-2] 256,1,1,1,'x*($M-$m)/255+$m' -r[-2] [-1],0,2 -*[-2] [-1] -r[-2,-1] $N,1,1,1,2 -+[-1] 1e-8 -/[-2,-1] -done
  -a[3--1] c -map[1] [3] -rm[3] -*[1,2]
_blend_softburn :
  ---[0] 255.1 -^[2] -1 -*[2] [1] -*[2] -127.5 ---[0] 255 --+[1] 0.1 -/[3,4] -*[3] 127.5 -+[3] 255 -+[1] [0] ->[1] 255
  -j[2] [3],0,0,0,0,1,[1] -rm[1,3] -c[1] 0,255
_blend_softdodge :
  ---[1] 255.1 -^[2] -1 -*[2] [0] -*[2] -127.5 ---[1] 255 --+[0] 0.1 -/[3,4] -*[3] 127.5 -+[3] 255 -+[1] [0] ->[1] 255
  -j[2] [3],0,0,0,0,1,[1] -rm[1,3] -c[1] 0,255
_blend_softlight :
  --/[0] 255 -/[1] 255 --sqr[-1] -*[2] [1] -*[1] [3] -*[1] -2 -*[2] 2 -+[1-3] -*[1] 255 -c[1] 0,255
_blend_stamp :
  -*[1] 2 -+[1] [0] --[1] 255 -c[1] 0,255
_blend_subtract :
  --[1] [0] -*[1] -1 -c[1] 0,255
_blend_value :
  -to_color -sh 0,2 -rgb2hsv[2,3] -sh[2] 0,1 -j[1] [4] -rm[4] -hsv2rgb[2,3] -rm[2,3]
_blend_vividlight :
  -*[1] 2 --blend burn --[1] 256 --blend[0,1] dodge ->=[1] 0
  -j[2] [3],0,0,0,0,1,[1] -rm[1,3]
_blend_xor :
  -xor[1] [0]

#@gmic blend_edges : smoothness[%]>=0
#@gmic : Blend selected images togethers using 'edges' mode.
#@gmic : $ image.jpg -testimage2d {w},{h} --blend_edges 0.8
blend_edges : -check {$1>=0}
  -e[^-1] "Blend image$? using 'edges' mode, with smoothness $1."
  -if {@#>1} -v - -to_rgb -r[^0] [0],0,0,0.5,0.5 -repeat @# -l[$>]
    --gradient_norm -+[-1] 1 -b[-1] $1 -n[-1] 1,10 -sqr[-1] -s[-2] c -*[-4--2] [-1] -a[-4--1] c
  -endl -done -r[^0] [0],0,0,0.5,0.5 -+ -s[-1] c -/[-4--2] [-1] -rm[-1] -a[-3--1] c -v + -endif

#@gmic blend_fade : [fading_pattern]
#@gmic : Blend selected images together using specified fading pattern.
#@gmic : $ image.jpg -testimage2d {w},{h} 100%,100%,1,1,'cos(y/10)' -normalize[-1] 0,1 --blend_fade[0,1] [2]
blend_fade :
  -e[^-1] "Blend image$? together using fading pattern $1."
  -v - -r @{-max_whds},0
  -pass$1 0 -r[-1] [0],[0],[0],100%,1 -max[-1] 0 -min[-1] {@#-2}
  -repeat {@#-1} ---[-1] $> -abs[-1] --[-1] 1 -*[-1] -1 -max[-1] 0 -*[$>,-1] -done -rm[-1]
  -+ -v +

_fade :
  -r[-2] [-3],5 -r[-1] [-2],3 -c[-1] $1%,$2% -n[-1] 0,1 -j[-3] [-2],0,0,0,0,1,[-1] -rm[-2,-1]

#@gmic blend_median
#@gmic : Blend selected images together using 'median' mode.
#@gmic : $ image.jpg -testimage2d {w},{h} --mirror[0] y --blend_median
blend_median :
  -e[^-1] "Blend image$? using 'median' mode."
  -v - -to_colormode 0 -r @{-max_whd},100%,0,0,0.5,0.5,0.5 whd={w},{h},{d} -r 100%,{h*d},1,100%,-1
  -if {@#==2} -+ -/ 2
  -elif {@#%2}
    -repeat {@#/2} -repeat {@#-1-$>} -l[$>,{$>+1}] --max -min[0,1] -endl -done -done
    -k[{int(@#/2)}]
  -elif {!(@#%2)}
    -repeat {@#/2+1} -repeat {@#-1-$>} -l[$>,{$>+1}] --max -min[0,1] -endl -done -done
    -k[{int(@#/2-1)},{@#/2}]
    -+ -/ 2
  -endif
  -r $whd,100%,-1 -v +

#@gmic blend_seamless : _is_mixed_mode={ 0 | 1 },_inner_fading[%]>=0,_outer_fading[%]>=0
#@gmic : Blend selected images using a seamless blending mode (Poisson-based).
#@gmic : Default values: 'is_mixed=0', 'inner_fading=0' and 'outer_fading=100%'.
blend_seamless : -check "${2=0}>=0 && ${3=100%}>=0" -skip ${1=0}
  -v - s0="non-mixed" s1="mixed"
  -v + -e[^-1] "Blend image$? using seamless mode (Poisson-based), in "${s{$1!=0}}" mode with inner fading $2 and outer fading $3." -v -
  -to_a[^0] -r @{0,w+32},@{0,h+32},1,100%,0,0,0.5,0.5 # Avoid periodic boundaries problems.

  -if {$3'!='100%} # With outer fading.
    -repeat {@#-1} -l[0,1]
      --blend_seamless $1,$2,100% -channels[-2] 100% -!=[-2] 0 -distance[-2] 1
      iM=@{-2,iM} ic={if(@{-is_percent\ $3},2*$3*$iM,1+$3)}
      -if {$ic<=$iM} -c[-2] 0,{max(1,$ic)} -n[-2] 0,1
      -else -n[-2] 0,{max(0,2-$ic/$iM)}
      -endif
      -*[-2] -1 -+[-2] 1
      -j[0] [2],0,0,0,0,1,[1] -rm[1,2]
    -endl -done
  -else # Without outer fading.

    -repeat {@#-1} -l[0,1]

      # Get background average color.
      --r[0] 1,1,1,100%,2 avg=@-1 -rm[-1]

      # Compute mixed gradients of background and top layer.
      -split_opacity[-1] -!=[-1] 0 -*[-2] [-1] -erode[-1] 3
      -g[0,1] xy,1
      -*[-3,-2] [-1]

      # Modify mask if 'mixed' mode selected.
      -if $1
        --a[0,1] c --a[2,3] c -norm[-2,-1]
        -<[-2,-1] -*[-2,-1]
      -endif

      # Compute the desired gradient map.
      -if {$2}
        -distance[-1] 0
        iM={iM} ic={if(@{-is_percent\ $2},2*$2*$iM,1+$2)}
        -if {$ic<=$iM} -c[-1] 0,{max(1,$ic)} -n[-1] 0,1
        -else -n[-1] 0,{max(0,2-$ic/$iM)}
        -endif
      -endif

      -j[-5] [-3],0,0,0,0,1,[-1]
      -j[-4] [-2],0,0,0,0,1,[-1]
      -rm[-3--1]

      # Compute divergence (right-hand term of Poisson eq.)
      -g[0] x,-1 -g[1] y,-1 -+

      # Inverse Laplacian.
      -fft[0]
      100%,100%,1,1,'-(4-2*cos(2*x*pi/w)-2*cos(2*y*pi/h))'
      -=[-1] 1 -/[-3,-2] [-1] -rm[-1]
      -=[-2] 0 -=[-1] 0
      -ifft[-2,-1] -rm[-1]

      # Renormalize.
      --fc[-1] $avg
      -+[-2,-1]
      -c 0,255

    -endl -done
  -endif
  -z 16,16,{w-17},{h-17} -v +

#@gmic fade_diamond : 0<=_start<=100,0<=_end<=100
#@gmic : Create diamond fading from selected images.
#@gmic : Default values: 'start=80' and 'end=90'.
#@gmic : $ image.jpg -testimage2d {w},{h} --fade_diamond 80,85
fade_diamond : -skip ${1=70},${2=90}
  -e[^-1] "Create ($1%,$2%) diamond-shaped fading from image$?."
  -v - -repeat {int(@#/2)} -l[$>,{$>+1}]
    (0,1,0;1,1,1;0,1,0) -_fade $1,$2
  -endl -done -v +

#@gmic fade_linear : _angle,0<=_start<=100,0<=_end<=100
#@gmic : Create linear fading from selected images.
#@gmic : Default values: 'angle=45', 'start=30' and 'end=70'.
#@gmic : $ image.jpg -testimage2d {w},{h} --fade_linear 45,48,52
fade_linear : -skip ${1=45},${2=30},${3=70}
  -e[^-1] "Create ($2%,$3%) linear fading from image$?, with angle $1 deg."
  -v - -repeat {int(@#/2)} -l[$>,{$>+1}]
     64,64,1,1,"x*cos($1*pi/180) + y*sin($1*pi/180)" -_fade $2,$3
  -endl -done -v +

#@gmic fade_radial : 0<=_start<=100,0<=_end<=100
#@gmic : Create radial fading from selected images.
#@gmic : Default values: 'start=30' and 'end=70'.
#@gmic : $ image.jpg -testimage2d {w},{h} --fade_radial 30,70
fade_radial : -skip ${1=30},${2=70}
  -e[^-1] "Create ($1%,$2%) radial fading from image$?."
  -v - -repeat {int(@#/2)} -l[$>,{$>+1}]
    100%,100% -=[-1] 1,50%,50% -distance[-1] 1 -_fade $1,$2
  -endl -done -v +

#@gmic fade_x : 0<=_start<=100,0<=_end<=100
#@gmic : Create horizontal fading from selected images.
#@gmic : Default values: 'start=30' and 'end=70'.
#@gmic : $ image.jpg -testimage2d {w},{h} --fade_x 30,70
fade_x : -skip ${1=30},${2=70}
  -e[^-1] "Create ($1%,$2%) horizontal fading from image$?."
  -v - -repeat {int(@#/2)} -l[$>,{$>+1}] (0,1) -_fade $1,$2 -endl -done -v +

#@gmic fade_y : 0<=_start<=100,0<=_end<=100
#@gmic : Create vertical fading from selected images.
#@gmic : Default values: 'start=30' and 'end=70'.
#@gmic : $ image.jpg -testimage2d {w},{h} --fade_y 30,70
fade_y : -skip ${1=30},${2=70}
  -e[^-1] "Create ($1%,$2%) vertical fading from image$?."
  -v - -repeat {int(@#/2)} -l[$>,{$>+1}] (0;1) -_fade $1,$2 -endl -done -v +

#@gmic fade_z : 0<=_start<=100,0<=_end<=100
#@gmic : Create transversal fading from selected images.
#@gmic : Default values: 'start=30' and 'end=70'.
fade_z : -skip ${1=30},${2=70}
  -e[^-1] "Create ($1%,$2%) transversal fading from image$?."
  -v - -repeat {int(@#/2)} -l[$>,{$>+1}] (0/1) -_fade $1,$2 -endl -done -v +

#@gmic sub_alpha : [base_image],_opacity_gain>=1
#@gmic : Compute the minimal alpha-channel difference (opposite of alpha blending) between the selected images and the specified base image.
#@gmic : The alpha difference A-B is defined as the image having minimal opacity, such that alpha_blend(B,A-B) = B.
#@gmic : Default value: 'opacity_gain=1'.
#@gmic : $ image.jpg -testimage2d {w},{h} --sub_alpha[0] [1] -drgba
sub_alpha : -check "${2=1}>=1 && "@{"-is_image_arg $1"}
  -e[^-1] "Compute minimal alpha-channel difference between image$? and base image $1, with opacity gain $2."
  -v - -remove_opacity -repeat @# -pass$1 0 -l[$>,-1]
    -to_colormode 0 -r @{-max_whd},100%,0,0,0.5,0.5  # Normalize image dimensions.

    # Estimate minimal alpha-channel.
    -->[0,1] -*[2] 255
    --[0,2] [1] -replace[2] 0,1
    -i[2] [0] -/[2,3]
    -compose_channels[2] max
    -*[2] $2 -c[2] 0,1

    # Synthetize alpha-difference image.
    --replace[2] 0,1 -/[0,3] -+[0,1] -*[1] 255 -a c

  -endl -done -v +

#---------------------------------------------
#
#@gmic :: Image sequences and videos
#
#---------------------------------------------

#@gmic animate : filter_name,"param1_start,..,paramN_start","param1_end,..,paramN_end",nb_frames>=0,_output_frames={ 0 | 1 },_output_filename : delay>0
#@gmic : Animate filter from starting parameters to ending parameters or animate selected images
#@gmic : in a display window.
#@gmic : Default value: 'delay=30'.
#@gmic : $ image.jpg -animate flower,"0,3","20,8",9
animate : -skip ${1=30},${2=0},${3=""},${4=10},${5=1},"${6=}"
  -if {isval($1)}
    -if $2 -e[0--4] "Animate image$?, with a delay of $1 ms, and ping-pong mode."
    -else -e[0--4] "Animate image$?, with a delay of $1 ms."
    -endif
    -if {!@#} -return -endif
    -v -
    speed=$1    # Animation speed
    pause=-1    # Pause mode.
    direction=1 # Animation direction.
    frame=0     # Current frame.
    -do
      -w[$frame] @{-fitscreen[]\ @{$frame,w},@{$frame,h}},1,0,-1,-1,@{$frame,b}.@{$frame,x}
      frame={$frame+$direction}
      -if $2
        -if {$frame==-1} frame=0 direction=1
        -elif {$frame==@#} frame={@#-1} direction=-1
        -endif
      -else frame={$frame%@#}
      -endif
      -wait $speed
      -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,D}} -w[] {@{!,w}*1.5},{@{!,h}*1.5} -wait -1 -endif # Increase window size.
      -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,C}} -w[] {@{!,w}/1.5},{@{!,h}/1.5} -wait -1 -endif # Decrease window size.
      -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,R}} -w[] @{0,w},@{0,h} -wait -1 -endif             # Reset window size.
      -if @{!,o} speed={min(500,max(10,$speed-10*@{!,o}))} -wait -1 -endif
      -if @{!,SPACE}
        -if {$pause>=0} direction=$pause pause=-1
        -else pause=$direction direction=0 -endif
        -wait -1
      -endif

    -while {@!" && "!@{!,Q}" && "!@{!,ESC}} -w 0 -v +
  -else
    -e[0--3] "Compute animated version of filter '$1', from parameters $2 to $3 with $4 frames."
    -if {!($5||narg("$6"))} -return -endif
    -v - ($2) ($3) -y[-2,-1] x -a[-2,-1] y -r[-1] 100%,$4,1,1,3 -mv[-1] 0 -rprogress 0
    -repeat {@#-1}
      -v + -e[] " > Animate image ["$>"]" -v -
      -repeat $4 --l[0,1]
        -$1[-1] @{0,{$>*@{0,w}}-{($>+1)*@{0,w}-1}} -rm[0]
        -if {narg("$6")} -o @{-filename\ "$6",@{>,-2},$>} -endif
        -if {!$5} -rm -endif
        -rprogress {100*($>+1)/$4}
        -v + -e[] "\r > Animate image ["@{>,-2}"] : Frame "{$>+1}"/$4    " -v -
      -endl -done
    -rm[1] -done -rm[0] -v +
  -endif

#@gmic apply_camera : _command,_camera_index>=0,_skip_frames>=0,_output_filename
#@gmic : Apply specified command on live camera stream, and display it on display window [0].
#@gmic : Default values: 'command=""', 'camera_index=0' (default camera), 'skip_frames=0' and 'output_filename=""'.
apply_camera : -skip "${1=},${4=}" -check "${2=0}>=0 && ${3=0}>=0"
  -e[^-1] "Apply command '$1' on camera stream \#$2, with $3 frames skip and output filename '$4'." -v -
  -l[] i=0 -do
    -camera $2,1,$3 $1 -w[-1] -1,-1,"(Camera \#$2, "{w}x{h}")"
    -if {narg("$4")} -o[-1] @{-filename\ "$4",$i} i={$i+1} -endif
    -if @{!,S} -o[-1] gmic_camera.png -endif
    -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,D}} -w[] {@{!,w}*1.5},{@{!,h}*1.5} -wait -1 -endif # Increase window size.
    -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,C}} -w[] {@{!,w}/1.5},{@{!,h}/1.5} -wait -1 -endif # Decrease window size.
    -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,R}} -w[] @{0,w},@{0,h} -wait -1 -endif             # Reset window size.
    -rm[-1]
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}} -camera $2,0 -endl -v +

#@gmic apply_files : "command",list_of_filenames,_output_prefix,_output_extension,_view_window={ 0 | 1 }
#@gmic : Apply specified command on all specified image files, by reading them one by one,
#@gmic : and save result by appending 'output_prefix' to each original filename.
#@gmic : 'list_of_filenames' must be the list of filenames, separated by space.
#@gmic : Thus, a specified filename cannot contain a spaces.
#@gmic : If 'output_extension' is set, the output files are written using the specified extension instead of keeping
#@gmic : the original one.
#@gmic : Default value: 'output_prefix=gmic_', 'output_extension=""' and 'view_window=0'.
apply_files : -skip "${3=gmic_}","${4=}",${5=0}
  -v -
  ({'"$2"'}) -autocrop[-1] 32 -replace[-1] 32,{','} files=@{-u\ @{-1,t}}
  -if {w>128} -z[-1] 0,127 s_files=@{-1,t}... -else s_files=$files -endif
  -rm[-1]
  -m "_apply_files : $""=_file _nb_files=$""#" -_apply_files $files -uncommand _apply_files
  -m "_apply_files : $1"
  -v + -e[^-1] "Apply command '$1' on files '"$s_files"' and save result with prefix '$3'.\n" -v -
  -repeat $_nb_files -l[]
    file=${_file{$>+1}}
    _file=@{-basename\ $file}
    -if {narg("$4")} 0 -nm[-1] $_file output_file="$3"@{-1,b}."$4" -rm[-1] -else output_file="$3"$_file -endif
    -v + -e[] "\r - Image "{1+$>}/$_nb_files" ["$_file"] -> ["$output_file"]                    " -v -
    $file -_apply_files
    -o $output_file
    -if $5 -w[-1] @{-fitscreen\ {w},{h},{d}},1,0,-1,-1,$_file -endif
    -rm
  -onfail -v + -e[] "\n - Error occured on file '"$file"'.\n" -v -
  -endl -done -uncommand _apply_files -v +

#@gmic apply_video : _command,_input_filename,_output_filename,_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1
#@gmic : Apply specified command on video stream, and display it on display window [0].
#@gmic : Default values: 'command=""', 'input_filename=""', 'output_filename=""', 'first_frame=0', 'last_frame=-1' and 'frame_step=1'.
apply_video : -skip "${1=},${2=},${3=}" -check "isint(${4=0}) && $4>=0 && isint(${5=-1}) && ($5>=0 || $5==-1) && ${6=1}>=1"
  -e[^-1] "Apply command '$1' on video stream '$2', with output filename '$3', first frame $4, last frame $5 and frame step $6."
  -v - -l[]
    frame=$4 i=0 basename=@{"-basename \"$2\""}
    -do
      -i "$2",$frame
      -if @#
        $1 -w -1,-1,"(Video '"$basename"', "{w}x{h}")"
        frame={$frame+$6}
        -if {$5>=0" && "$frame>$5} frame=$4 -endif
        -if {narg("$3")" && "$i>=0} -o[-1] @{-filename\ "$3",$i} i={$i+1} -endif
        -if @{!,S} -o[-1] gmic_video.png -endif
        -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,D}} -w[] {@{!,w}*1.5},{@{!,h}*1.5} -wait -1 -endif # Increase window size.
        -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,C}} -w[] {@{!,w}/1.5},{@{!,h}/1.5} -wait -1 -endif # Decrease window size.
        -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,R}} -w[] @{0,w},@{0,h} -wait -1 -endif             # Reset window size.
      -else frame=$4 i=-1
      -endif
      -rm
    -while {@!" && "!@{!,ESC}" && "!@{!,Q}} -i "$2",0,0,0
  -endl -v +

#@gmic average_video : input_filename,_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_output_filename
#@gmic : Return the average of all frames of a video file.
#@gmic : If a display window is opened, the frames are displayed in it during processing.
average_video : -check "isint(${2=0}) && $2>=0 && isint(${3=-1}) && ($3>=0 || $3==-1) && ${4=1}>=1" -skip "${5=}"
  -e[^-1] "Average frames of video file '$1', with first frame $2, last frame $3, frame step $4 and output filename '$5'.\n"
  -v - -l[]
    frame=$2 i=0 stopflag=0 N=0
    -do
      -l[] -i "$1",$frame
        -if @#
          -v + -e[] "\r  > Frame \#"$frame -v -
          frame={$frame+$4} N={$N+1}
        -else stopflag=1
        -endif
      -onfail stopflag=1
      -endl # Read one new video frame.
      -if {@#>1} -+ -endif
      -if {narg("$5")} --/[-1] $N -c[-1] 0,255 -o[-1] @{-filename\ "$5",$i} -rm[-1] i={$i+1} -endif
      -if @!
        --n 0,255 -w[-1] -1,-1,0,"Frame \#"$frame
        -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,D}} -w[] {@{!,w}*1.5},{@{!,h}*1.5} -wait -1 -endif # Increase window size.
        -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,C}} -w[] {@{!,w}/1.5},{@{!,h}/1.5} -wait -1 -endif # Decrease window size.
        -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,R}} -w[] @{0,w},@{0,h} -wait -1 -endif             # Reset window size.
        -rm[-1]
      -endif
    -while {!$stopflag" && "($frame<$3" || "$3==-1)}
    -/ $N -c 0,255
  -endl -v +

#@gmic files2video : list_of_filenames,_output_filename,_fps>0,_codec
#@gmic : 'list_of_filenames' must be the list of input image filenames, separated by space.
#@gmic : Thus, a specified filename cannot contain a spaces.
#@gmic : Default values: 'output_filename=output.avi', 'fps=25' and 'codec=mp4v'.
files2video : -check "isint(${3=25}) && $3>0" -skip "${2=output.avi}",${4=mp4v}
  -v -
  ({'"$1"'}) -autocrop[-1] 32 -replace[-1] 32,{','} files=@{-u\ @{-1,t}}
  -if {w>128} -z[-1] 0,127 s_files=@{-1,t}... -else s_files=$files -endif
  -rm[-1]
  -m "_files2video : $""=_file _nb_files=$""#" -_files2video $files -uncommand _files2video
  -v + -e[^-1] "Convert image files '"$s_files"' into frames of output video '$2', with $3 fps and $4 codec.\n" -v -
  -repeat $_nb_files -l[]
    file=${_file{$>+1}}
    _file=@{-basename\ $file}
    -v + -e[] "\r - Image "{1+$>}/$_nb_files" ["$_file"] -> [$2]                    " -v -
    -i $file -o "$2",$3,$4,1
    -rm
  -onfail -v + -e[] "\n - Error occured on input file '"$file"'.\n" -v -
  -endl -done
  -o $output_file,0,0,0 -v +

#@gmic morph : nb_frames>0,_smoothness>=0,_precision>0
#@gmic : Create morphing sequence between selected images.
#@gmic : Default values: 'smoothness=0.1' and 'precision=5'.
#@gmic : $ image.jpg --rotate 20,1,1,50%,50% -morph 9
morph : -skip ${2=0.1},${3=5}
  -e[^-1] "Create morphing sequence between image$?, with $1 intra-frames, smoothness $2 and precision $3.\n"
  -v - -r[^0] [0],3 -i[0] (@#) --[0] 1 -repeat @0
   -v + -e[] "\r > Morph image "$>" to image "{$>+1}".    " -v -
    --equalize[-2,-1] -n[-2,-1] 0,255
    --displacement[-1] [-2],$2,$3 --warp[-5] [-1],1,1,1,$1 -a[-$1--1] z -rm[-2]
    --displacement[-3] [-2],$2,$3 --warp[-5] [-1],1,1,1,$1 -a[-$1--1] z -rm[-7--4,-2]
    (1/0) -r[-1] [-2],3 -*[-3] [-1] -*[-2,-1] -mirror[-1] z -+[-2,-1] -s[-1] z
    -mv[-$1--1] 1 -mv[1] @#
  -done -mv[-1] 1 -rm[0] -v +

#@gmic register_nonrigid : [destination],_smoothness>=0,_precision>0,_nb_scale>=0
#@gmic : Register selected source images with specified destination image, using non-rigid warp.
#@gmic : Default values: 'smoothness=0.2', 'precision=6' and 'nb_scale=0(auto)'.
#@gmic : $ image.jpg --rotate 20,1,1,50%,50% --register_nonrigid[0] [1]
register_nonrigid : -check @{-is_image_arg\ $1}" && ${2=0.2}>=0 && ${3=5}>0 && ${4=0}>=0"
  -e[^-1] "Register source image$? with destination image $1, using non-rigid warp with smoothness $1, precision $2 and $3 scale(s)."
  -v - -pass$1 0 -equalize[-1] -n[-1] 0,255
  -repeat {@#-1}
    --equalize[$>] -n[-1] 0,255 --displacement[-2] [-1],$2,$3,$4 -rm[-2]
    -warp[$>] [-1],1,1,1 -rm[-1]
  -done -rm[-1] -v +

#@gmic register_rigid : [destination],_smoothness>=0,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Register selected source images with specified destination image, using rigid warp (shift).
#@gmic : Default values: 'smoothness=1' and 'boundary=0'.
#@gmic : $ image.jpg --shift 30,20 --register_rigid[0] [1]
register_rigid : -check @{-is_image_arg\ $1}" && ${2=1}>=0 && isint(${3=0}) && $3>=0 && $3<=2"
  -e[^-1] "Register source image$? with destination image $1, using rigid warp with smoothness $2."
  -v - -pass$1 0 -equalize[-1] -b[-1] $2 -n[-1] 0,255
  -repeat {@#-1}
    --equalize[$>] -b[-1] $2 -n[-1] 0,255
    --phase_correlation[-1] [-2] -rm[-2]
    -shift[$>] @-1,0,$3 -rm[-1]
  -done -rm[-1] -v +

#@gmic transition_plasma : _nb_frames>=2,_scale>=0,_smoothness[%]>=0
#@gmic : Create plasma transition sequence between consecutive images.
#@gmic : Default values: 'nb_frames=10', 'scale=5' and 'smoothness=0.5%'.
#@gmic : $ image.jpg -testimage2d {w},{h} -transition_plasma 9
transition_plasma : -check "isint(${1=10}) && $1>=2 && isint(${2=5}) && $2>=0 && ${3=0.5%}>=0"
  -e[^-1] "Create plasma transition sequence between image$?, with $1 frames, scale $2, smoothness $3.\n"
  -v -
  -if {@#<2} -return -endif
  -slices 0 -r @{-max_whds},3
  off=0 -repeat {@#-1} -l[{$>+$off},{$>+$off+1}]
    -v + -e[] "\r > Generate transition from image "$>" to image "{$>+1}".    " -v -
    100%,100% -plasma[-1] 1,0,$2 -n[-1] 0,1
    -repeat {$1-2} --<=[2] {($>+1)/$1} -b[-1] $3 [0] -j[-1] [1],0,0,0,0,1,[-2] -rm[-2] -rprogress {$>*100/($1-2)} -done
    -rm[2] -mv[2--1] 1 off={$off+$1-2}
  -endl -done -v +

#@gmic transition3d : _nb_frames>=2,_nb_xtiles>0,_nb_ytiles>0,_axis_x,_axis_y,_axis_z,_is_antialias
#@gmic : Create 3d transition sequence between selected consecutive images.
#@gmic : 'axis_x', 'axis_y' and 'axis_z' can be set as mathematical expressions, depending on 'x' and 'y'.
#@gmic : Default values: 'nb_frames=10', 'nb_xtiles=nb_ytiles=3', 'axis_x=1', 'axis_y=1', 'axis_z=0' and 'is_antialias=1'.
#@gmic : $ image.jpg --blur 5 -transition3d 9 -drgba
transition3d : -check "isint(${1=10}) && $1>=2 && isint(${2=3}) && $2>0 && isint(${3=$2}) && $3>0" -skip ${4=1},${5=1},${6=0},${7=1}
  -e[^-1] "Create 3d transition sequence between image$?, with $1 frames, $2x$3 tiles and rotation axis ($4,$5,$6).\n"
  -v -
  -if {@#<2} -return -endif
  -slices 0 -to_rgb -r @{-max_whds},3
  off=0 -repeat {@#-1} -l[{$>+$off},{$>+$off+1}]
    -v + -e[] "\r > Generate transition from image "$>" to image "{$>+1}".    " -v -

    # Create 3d rotation vectors.
    $2,$3,1,1,'$4'
    $2,$3,1,1,'$5'
    $2,$3,1,1,'$6'
    -a[-3--1] z
    -permute[-1] zxyc -r[-1] 3,{$2*$3},1,1,-1
    -repeat {h} rot$>=@{-1,0-2} -shift[-1] 0,-1,0,0 -done
    -rm[-1]

    # Create 3d tiles.
    --split_tiles[-2,-1] $2,$3 -mv[0,1] @#
    N={$2*$3} i=0 y=0
    -repeat $3
      x=0
      -repeat $2
        lw=@{$i,w} lh=@{$i,h}
        -imageplane3d[$i] -imageplane3d[$N] -r3d[$N] ${rot$i},-180 -c3d[$i,$N] -+3d[$i,$N]
        x$i=$x y$i=$y x={$x+$lw} i={$i+1}
      -done
      y={$y+$lh}
    -done

    # Generate intermediate animation frames.
    -repeat {$1-2}
      -repeat $N -r3d[$>] ${rot$>},{180/($1-1)} --+3d[$>] ${x$>},${y$>},0 -done
      -+3d[-$N--1] -c3d[-1]

      -if $7 # Antialiased rendering.
        -i[-3] {2*@{-2,w}},{2*@{-2,h}},1,3,-1
        -*3d[-1] 2 -j3d[-3] [-1],50%,50%,0,1,2,0,0 -rm[-1]
        -to_rgba[-2] -replace_color[-2] 0,0,-1,-1,-1,255,0,0,0,0
        -r[-2] [-1],[-1],1,100%,2
      -else # Standard rendering.
        -i[-3] @{-2,w},@{-2,h},1,3,-1 -j3d[-3] [-1],50%,50%,0,1,2,0,0 -rm[-1]
        -to_rgba[-2] -replace_color[-2] 0,0,-1,-1,-1,255,0,0,0,0
      -endif

    -done
    -rm[0-{$N-1}]
    -nm[1--2] @{0,n}
    off={$off+$1-2}
  -endl -done
  -v +

#@gmic video2files : input_filename,_output_filename,_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1
#@gmic : Split specified input video file into image files, one for each frame.
#@gmic : First and last frames as well as step between frames can be specified.
#@gmic : Default values: 'output_filename=frame.png', 'first_frame=0', 'last_frame=-1' and 'frame_step=1'.
video2files : -check "isint(${3=0}) && $3>=0 && isint(${4=-1}) && ($4>=0 || $4==-1) && isint(${5=1}) && $5>=1" -skip ${2="frame.png"}
  -e[^-1] "Split input video file '$1' into image frames '$2', with first frame $3, last frame $4, and frame step $5.\n"
  -v -
  frame=$3 stopflag=0
  -do -l[]
    -i "$1",$frame
    -if @#
      -o @{"-filename \"$2\","$frame} -rm
      -v + -e[] "\r  > Frame \#"$frame -v -
      frame={$frame+$5}
    -else stopflag=1
    -endif
  -onfail stopflag=1
  -endl -while {!$stopflag" && "($frame<=$4" || "$4==-1)}
  -v +

#------------------------------------
#
#@gmic :: PINK-library operators
#
#------------------------------------

_wrbytepnk :
  -output_pink3d ${1}.pnk

_xpink :
  filename=@{-file_rand}
  prefix=pink.
  -if {!@{-is_windows}}
    -x "which "${prefix}${1}" >/dev/null 2>&1"
    -if {@{}!=0} prefix="" -x "which "$1" >/dev/null 2>&1"
	  -if {@{}!=0} -error "Executable (pink.)"$1" not found in PATH, status = "@{}"!! Returning!!\n" -return -endif
	-endif
    -output_pink3d ${filename}.pnk -x ${prefix}${1}" "${filename}".pnk $2 "${filename}"_o.pnk >/dev/null 2>&1"
  -else
    -output_pink3d ${filename}.pnk -x $1" "${filename}".pnk $2 "${filename}"_o.pnk"
  -endif
  status=@{}
  -file_rm ${filename}.pnk
  -if {$status!=0\ &&\ {$1'!='seuilauto}} -error "Exec status is "${status}"." -return
  -elif ${filename}_o.pnk -i ${filename}_o.pnk -file_rm ${filename}_o.pnk -k[-1]
  -else -error "Exec error!!" -endif

_xpinks :
  s=@{-1,s} -if {$s>1} -s[-1] c -endif
  -repeat @# -l[@{>,-1}]  -_xpink $1,"$2" -k[-1] -endl -done
  -if {$s>1} -a[-$s--1] c -endif

_xframe :
  -line 0%,0%,100%,0% -line 0%,100%,100%,100% -line 0%,0%,0%,100% -line 100%,0%,100%,100%

#@gmic output_pink3d : filename
#@gmic : Save selected images as P5-coded PPM files (PINK extension for 3d volumetric images).
output_pink3d :
  -e[^-1] "Output image$? as file '$1' (in 3d pink extension of P5-coded PPM format)."
  -v - -if {@#==1} filename0="$1"
  -else -repeat @# filename$>=@{-filename\ "\"$1\"",$>} -done
  -endif
  -repeat @# -l[$>]
    -if {d==1} -o[-1] ppm:${filename$>}  # 2d image, save as regular PPM format.
    -else                                # 3d image, save as PINK PPM extension.
      ({'P5\n{w}\ {h}\ {d}\n255\n'})
      --channels[-2] 0 -y[-1] x -a[-2,-1] x
      -o[-1] raw:${filename$>},char
      -rm[-1]
    -endif
  -endl -done -v +

#@gmic pink
#@gmic : Pink wrapper name,p1, .. ,pn (requires the PINK library to be installed).
#@gmic : (http://pinkhq.com/)
#@gmic : prepares input, calls external "name input p1 ... pn output" and reads output (/tmp)
#@gmic : $ image.jpg --pink asfr,5 -pink[0] asf,5
#@gmic : $ image.jpg --blur 2 -pink maxima,4
pink : -v -
  -if {$#>1} ({"'${2--1}'"}) -replace[-1] {','},{"' '"} p=@{-1,t} -rm[-1] -else p=" " -endif
  -v + -e[^-1] "Call pink package with cmd: \"$1$? "$p"$?\"." -v -
  -repeat @# -l[@{>,-1}] -_xpinks $1,$p -endl -done -v +

#@gmic pink_grayskel : _connectivity={ 4 | 8 | 6 | 26 }, _lambda=0
#@gmic : (http://pinkhq.com/doxygen/grayskel_8c.html)
#@gmic : Grayscale homotopic skeleton (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4' and 'lambda=0'.
#@gmic : $ image.jpg --pink_grayskel , --pink_grayskel[0] ,10 --pink_grayskel[0] ,100 -append_tiles 2
pink_grayskel : -skip ${1=4},${2=0}
  -check "${1=4}==4 || $1==8 || $1==6 || $1==26"
  -repeat @# -l[@{>,-1}] -_xpinks "grayskel","null $1 $2" -endl -done

#@gmic pink_heightmaxima : _connectivity={ 4 | 8 | 6 | 26 },_height=1
#@gmic : (http://pinkhq.com/doxygen/heightmaxima_8c.html)
#@gmic : Heightmaxima filtering (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4' and 'height=1'.
#@gmic : $ image.jpg --blur 2 --pink_heightminima ,15 --pink_heightmaxima[0,1] ,15 --[-3,-1] --[-3,-1] -keep[-1,-2]
pink_heightmaxima : -check "${1=4}==4 || $1==8 || $1==6 || $1==26" -skip ${2=1}
  -e[^-1] "Filter by heightmaxima exec with connectivity $1 height $2."
  -v - -repeat @# -l[@{>,-1}]
    s=@{-1,s} -if {$s>1} -s[-1] c -endif
    -repeat @# -l[@{>,-1}] -_xpink "heightmaxima","$1 $2" -k[-1] -endl -done
    -if {$s>1} -a[-$s--1] c -endif
  -endl -done -v +

#@gmic pink_heightminima : _connectivity={ 4 | 8 | 6 | 26 },_height=1
#@gmic : (http://pinkhq.com/doxygen/heightminima_8c.html)
#@gmic : Heightminima filtering (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4' and 'height=1'.
#@gmic : $ image.jpg --blur 2 --pink_heightminima ,15 --pink_heightmaxima[0,1] ,15 --[-3,-1] --[-3,-1] -keep[-1,-2]
pink_heightminima : -check "${1=4}==4 || $1==8 || $1==6 || $1==26" -skip ${2=1}
  -e[^-1] "Apply filter by heightminima exec with connectivity $1 height $2."
  -v - -repeat @# -l[@{>,-1}]
    s=@{-1,s} -if {$s>1} -s[-1] c -endif
    -repeat @# -l[@{>,-1}] -_xpink "heightminima","$1 $2" -k[-1] -endl -done
    -if {$s>1} -a[-$s--1] c -endif
  -endl -done -v +

#@gmic pink_htkern : _connectivity={ 4 | 8 | 6 | 26 }, _type={""|u}
#@gmic : (http://pinkhq.com/doxygen/htkern_8c.html)
#@gmic : (http://pinkhq.com/doxygen/htkernu_8c.html)
#@gmic : Grayscale ultimate homotopic thinning/thickening without condition (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4' and 'type=""'.
#@gmic : $ image.jpg --pink_htkern ,u --pink_htkern[0] , ---[-1,-2] -remove[0]
pink_htkern : -skip ${1=4},${2=""}
  -repeat @# -l[@{>,-1}] -_xpinks htkern$2,"null $1" -endl -done

#@gmic pink_lvkern : _connectivity={ 4 | 8 | 6 | 26 }, _type={""|u}
#@gmic : (http://pinkhq.com/doxygen/lvkern_8c.html)
#@gmic : (http://pinkhq.com/doxygen/lvkernu_8c.html)
#@gmic : Grayscale ultimate leveling thinning/thickening without condition (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4' and 'type=""'.
#@gmic : $ image.jpg -pink_lvkern ,u
pink_lvkern : -skip ${1=4},${2=""}
  -check "${1=4}==4 || $1==8 || $1==6 || $1==26"
  -repeat @# -l[@{>,-1}] -_xpinks lvkern${2},"null $1" -endl -done

#@gmic pink_reg_minima : _connectivity={ 4 | 8 | 6 | 26 }
#@gmic : (http://pinkhq.com/doxygen/minima_8c.html)
#@gmic : Regional minima (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4'.
#@gmic : $ image.jpg --blur 2 -pink_reg_minima ,
pink_reg_minima : -check "${1=4}==4 || $1==8 || $1==6 || $1==26"
  -e[^-1] "Compute regional minima exec with connectivity $1."
  -v - -repeat @# -l[@{>,-1}]
    s=@{-1,s} -if {$s>1} -s[-1] c -endif
    -repeat @# -l[@{>,-1}]  -_xpink "minima","$1" -k[-1] -endl -done
    -if {$s>1} -a[-$s--1] c -endif
  -endl -done -v +

#@gmic pink_skelcurv : _prio={0|1|2|3|4|8|6|26},_connectivity={ 4 | 8 | 6 | 26 },_inhibit={""}
#@gmic : (http://pinkhq.com/doxygen/skelcurv_8c.html)
#@gmic : Curvilinear binary skeleton guided by a priority function or image (requires the PINK library to be installed).
#@gmic : Default values: 'prio=0', 'connectivity=4' and 'inhibit=""'.
#@gmic : $ image.jpg -threshold 50% {w},{h} -fill[-1] 'if(x>w/2,255,0)' tp=@{-path_tmp} -output[-1] ${tp}/inhibit.pgm -remove[-1] --pink_skelcurv[0] , --pink_skelcurv[0] ,,${tp}/inhibit.pgm -exec "rm "${tp}"/inhibit.pgm"
#@gmic : $ image.jpg -threshold 50% --pink_skelcurv , --pink_skelcurv[-2] ,8
pink_skelcurv : -skip ${1=0},${2=4},${3=""}
  -e[^-1] "Curvilinear binary skeleton guided by a priority function or image from image$?, prio=$1, connectivity=$2, inhibit=$3."
  -repeat @# -l[@{>,-1}] -_xpinks "skelcurv","$1 $2 $3" -endl -done

#@gmic pink_skelend : _connectivity={ 4 | 8 | 6 | 26 },_n=0
#@gmic : (http://pinkhq.com/doxygen/skelend_8c.html)
#@gmic : Homotopic skeleton of a 2d or 3d binary image with dynamic detection of end points (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4' and 'n=0'.
#@gmic : $ image.jpg -threshold 50% --pink_skelend , --pink_skelend[-2] ,-1
pink_skelend : -skip ${1=4},${2=0}
  -repeat @# -l[@{>,-1}] -_xpinks "skelend","$1 $2" -endl -done

#@gmic pink_skeleton : _prio={0|1|2|3|4|8|6|26},_connectivity={ 4 | 8 | 6 | 26 },_inhibit={""}
#@gmic : (http://pinkhq.com/doxygen/skeleton_8c.html)
#@gmic : Ultimate binary skeleton guided by a priority image (requires the PINK library to be installed).
#@gmic : Default values: 'prio=0', 'connectivity=4' and 'inhibit=""'.
#@gmic : $ image.jpg -threshold 50% --pink_skeleton[-1] ,
 pink_skeleton : -skip ${1=0},${2=4},${3=""}
  -repeat @# -l[@{>,-1}] -_xpinks "skeleton","$1 $2 $3" -endl -done

#@gmic pink_skelpar : _algorithm={0..29},_nsteps=_1,_inhibit=""
#@gmic : (http://pinkhq.com/doxygen/skelpar_8c.html)
#@gmic : Parallel binary skeleton (requires the PINK library to be installed).
#@gmic : Default values: 'algorithm=4', 'nsteps=-1' and 'inhibit=""'.
#@gmic : $ image.jpg -threshold 50% --pink_skelpar[-1] 0 --pink_skelpar[-1] 2
pink_skelpar : -skip ${1=4},${2=-1},${3=""}
  -repeat @# -l[@{>,-1}] -_xframe -_xpinks "skelpar","$1 $2 $3" -endl -done

#@gmic pink_wshed : _connectivity={ 4 | 8 | 6 | 26 },_inverse={ 0 | 1 },_height=0
#@gmic : (http://pinkhq.com/doxygen/wshedtopo_8c.html)
#@gmic : Watershed (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4', 'inverse=0' and 'height=0'.
#@gmic : $ image.jpg --pink_wshed ,1,5 -pink_wshed[0] ,,5
pink_wshed : -check "${1=4}==4 || $1==8 || $1==6 || $1==26" -skip ${2=0},${3=0}
  -e[^-1] "Compute wshedtopo exec with connectivity $1 inversion $2 height $3."
  -v - -repeat @# -l[@{>,-1}]
    s=@{-1,s} -if {$s>1} -s[-1] c -endif
    -if {d==1}
      -check "${1=4}==4 || $1==8"
      -repeat @# -l[@{>,-1}]
        -if {$2!=0} -negative -endif
        -f max(min(i,255),0)
        -if {$3>=0} -pink heightminima,$1,$3 -endif
        -pink wshedtopo,$1
        -if {$2!=0} -negative -endif
      -endl -done
    -else
      -check "$1==6 || $1==26"
      -repeat @# -l[@{>,-1}]
        -if {$2!=0} -negative -endif
        -f max(min(i,255),0)
        -if {$3>=0}
          -pink heightminima,$1,$3
        -endif
        -pink wshedtopo,$1
        -if {$2!=0} -negative -endif
      -endl -done
    -endif
    -if {$s>1} -a[-$s--1] c -endif
  -endl -done -v +

#------------------------------
#
#@gmic :: Convenience functions
#
#------------------------------

#@gmic alert : _title,_message,_label_button1,_label_button2,...
#@gmic : Display an alert box and wait for user's choice.
#@gmic : If a single image is in the selection, it is used as an icon for the alert box.
#@gmic : Default values: 'title=[G'MIC Alert]' and 'message=This is an alert box.'.
alert : -skip "${1=[G\47MIC Alert]},${2=This is an alert box.},${3=OK}"
  -if {@#==1}
    -e[0--3] "Display alert box, with image$?, title '$1', message '$2' and buttons '${3--1}'."
  -else
    -e[0--3] "Display alert box, with title '$1', message '$2' and buttons '${3--1}'."
  -endif
  -v -

  -if {@#==1} logo= -else logo=[] -endif
  --l$logo

    # Manage alert icon.
    -if {@#==1} -to_rgb
    -else # No logo provided, generate default logo (alert).
      64,64 -polygon 3,50%,10%,10%,90%,90%,90%,1,1 -b 3 ->= 50%
      --erode[-1] 5 --[-1] [-2] -==[-1] 0
      -polygon[-1] 4,47%,43%,53%,43%,53%,66%,47%,66%,1,0 -circle[-1] 50%,76%,2,1,0
      --*[0] 255 [-1] 100%,100% -a[-3--1] c --[-1] '3*(y-h/2)'
      -*[-1] [-2] -rm[-2] -*[0] 255 -rv -a c
      -drop_shadow 3,3,1 -i[0] 100%,100%,1,3,200 -blend alpha
    -endif
    -channels -1,2

    # Create buttons graphics.
    $=arg
    -repeat {$#-2} label=${arg{$>+3}} 0 -t[-1] $label,0,0,16,1,-200 -done
    -r[^0] {min(128,max(64,@{-max_w[^0]}+12))},{min(48,max(24,@{-max_h[^0]}+12))},1,1,0,0,0.5,0.5
    -+[^0] 200 -to_rgb[^0]
    -mv[0] @#
    [0],[0],1,1,'(y-h/2)' -*[-1] -2 -c[-1] -30,30 -+[0--3] [-1] -rm[-1] -c[^-1] 0,255  # Add shading to buttons.

    -repeat {@#-1} -l[$<]

      # Create selected buttons.
      --rectangle 0,0,100%,100%,1,0xFFFFFFFF,0
      -rectangle[-1] 1,1,{w-2},{h-2},1,0xFFFFFFFF,0
      -line[-1] 2,{h-3},{w-3},{h-3},1,150 -line[-1] {w-3},{h-3},{w-3},2,1,150
      -line[-1] 1,1,{w-3},1,1,255 -line[-1] 1,1,1,{h-3},1,255
      -rectangle[-1] 4,4,{w-5},{h-5},1,0xAAAAAAAA,0

      # Create clicked buttons.
      --shift[-2] 1,1,0,0,2
      -rectangle[-1] 0,0,100%,100%,1,0xFFFFFFFF,0
      -rectangle[-1] 1,1,{w-2},{h-2},1,0xFFFFFFFF,150
      -rectangle[-1] 4,4,{w-5},{h-5},1,0xAAAAAAAA,0

      # Create default aspect.
      -rectangle[-3] 0,0,100%,100%,1,0xFFFFFFFF,0
      -line[-3] 1,{h-2},{w-2},{h-2},1,150 -line[-3] {w-2},{h-2},{w-2},1,1,150
      -line[-3] 0,0,{w-2},0,1,255 -line[-3] 0,0,0,{h-2},1,255

      # Create coordinates image.
      -i[0] 100%,100% -=[0] 1,0,0

    -a c -endl -done

    # Render alert box graphics.
    --l
      -channels 0,3 -sh 1,100% --[50%--1] 200 -rm[50%--1] -frame 8,8,0
      -if {@#<6} -a[^-1] x -else -append_tiles[^-1] , -endif
      0 -t[-1] "$2",0,0,16,1,0,-200,-200,-200 -r[-1] {w+16},{h+8},1,4,0
      -a[-2,-1] x,0.5 -rv -a y,0.5
      -sh 1,100% -+[-1] 200 -rm[-1]
      -rectangle 0,0,100%,100%,1,0xFFFFFFFF,0
      -line 0,0,{w-2},0,1,0,255,255,255 -line 0,0,0,{h-2},1,0,255,255,255
    -endl
    -rm[-2]
    --channels[-1] 0

    # Retrieve (x,y) coordinates of the buttons and fill active area.
    (0,{w-1}) (0;@{-2,h-1}) -r[-2,-1] [-3],3 -a[-2,-1] c -round[-1] -rv[-2,-1] -*[-2,-1]
    -discard[-1] 0 -r[-1] {h/2},2,1,1,-1
    -channels[-2] 1,3 -rv[-2,-1]
    100%,100% -repeat @{-3,w} x0=@{-3,($>,0)} y0=@{-3,($>,1)} -rectangle[-1] $x0,$y0,{$x0+@{0,w}-1},{$y0+@{0,h}-1},1,{1+$>} -done
    -a[-2,-1] c

    # Enter event loop.
    -repeat 9 -if {!@{!$>}} disp=$> -break -endif -done   # Find available display window.
    -if {!narg($disp)} -error[0--4] "Command '-alert': Cannot open display window for alert box." -endif

    selected={if($#==3,0,-1)} clicked=-1
    -do

      # Render current view.
      --channels[-1] 0,2
      -if {$clicked>=0}
        x0=@{-3,($clicked,0)} y0=@{-3,($clicked,1)}
        -sh[$clicked] 7,9
        -j[-2] [-1],$x0,$y0 -rm[-1]
      -elif {$selected>=0}
        x0=@{-3,($selected,0)} y0=@{-3,($selected,1)}
        -sh[$selected] 4,6
        -j[-2] [-1],$x0,$y0 -rm[-1]
      -endif
      -w$disp[-1] 100%,100%,0,"$1" -rm[-1] -wait

      # Handle user interactions.
      xm=@{!$disp,x} ym=@{!$disp,y} bm={@{!$disp,b}&1} val={i($xm,$ym,0,3)}
      -if {$bm" && "$val} clicked={$val-1}
      -elif {$bm" && "!$val" && "$clicked>=0} selected=$clicked clicked=-1
      -elif {!$bm" && "$clicked>=0" && "$clicked==$val-1} -break
      -endif
      -if @{!$disp,ARROWRIGHT} selected={($selected+1)%@{-2,w}} -wait -1
      -elif @{!$disp,ARROWLEFT} selected={($selected-1)%@{-2,w}+($selected==-1)} -wait -1
      -elif {$selected>=0" && "@{!$disp,ENTER}} clicked=$selected -break
      -endif

    -while {@{!$disp}" && "!@{!$disp,ESC}}

    # Return result (indice of clicked button or '-1').
    -w$disp 0 -rm -u $clicked
  -endl
  -v +

#@gmic arg : n,_arg1,...,_argN
#@gmic : Return the n-th argument of the specified argument list.
arg :
  -v - $=arg -u ${arg{1+($1)}} -v +

#@gmic at : _x,_y,_z
#@gmic : Return a specified vector-valued point (x,y,z) from the latest of the selected images.
at : -skip ${1=0},${2=0},${3=0}
  -v - --z[-1] ${1-3},${1-3} -u @-1 -rm[-1] -v +

#@gmic autocrop_coords : value1,value2,... | auto
#@gmic : Return coordinates (x0,y0,z0,x1,y1,z1) of the autocrop that could be performed on the latest of the selected images.
#@gmic : Default value: 'auto'
autocrop_coords : -skip ${1=auto}
  -v -
  is_auto={$1'=='auto}
  w={w} h={h} d={d}
  value={i(w-1,h-1,d-1)} --=[-1] {1+$value},100%,100%,100% -_autocrop$is_auto[-1] ${1--1} -=[-1] $value,100%,100%,100%
  x0={$w-w} y0={$h-h} z0={$d-d} -rm[-1]
  --_autocrop$is_auto[-1] ${1--1}
  x1={$x0+w-1} y1={$y0+h-1} z1={$z0+d-1} -rm[-1]
  -u $x0,$y0,$z0,$x1,$y1,$z1
  -v +

_autocrop0 : -autocrop $*
_autocrop1 : -skip $* -autocrop

#@gmic average_color
#@gmic : Return the average color of the latest of the selected images.
average_color :
  -v -
  res=""
  -repeat {s-1} -sh[-1] {1+$>},{1+$>} res=$res,{ia} -rm[-1] -done
  -sh[-1] 0,0 -u {ia}$res -rm[-1]
  -v +

#@gmic basename : file_path,_variable_name_for_folder
#@gmic : Return the basename of a file path, and opt. its folder location.
#@gmic : When specified 'variable_name_for_folder' must starts by an underscore
#@gmic : (global variable accessible from calling function).
basename : -skip ${2=unused}
  -v -
  -l[] ({"'$1'"}) -replace 92,47 -s +,47
  -if {i==47} -a y $2=@{-1,t} -u ""
  -elif {@#==1} -u @{-1,t} $2=""
  -else -a[^-1] y -u @{-1,t} $2=@{-2,t}
  -endif
  -rm -endl
  -v +

#@gmic bin : binary_int1,...
#@gmic : Print specified binary integers into their octal, decimal, hexadecimal and string representations.
bin :
  -v - dec=@{-bin2dec\ ${^0}} -v +
  -e[^-1] "Convert binary integer"@{-arg\ 1+($#>1),"",s}" '${^0}' to octal '"@{-dec2oct\ $dec}"',
           decimal '"$dec"', hexadecimal '"@{-dec2hex\ $dec}"' and string '"@{-dec2str\ $dec}"'."

#@gmic bin2dec : binary_int1,...
#@gmic : Convert specified binary integers into their decimal representations.
bin2dec :
  -v - res=@{-_$0\ $1} -repeat {$#-1} res=$res,@{-_$0\ @{-arg\ $>+2,${^0}}} -done -u $res -v +

_bin2dec :
  ({'@{-struncase\ $1}'})
  is_negative=0
  -if {@{-1,0}==45} -z[-1] 1,100% is_negative=1 -endif
  -f[-1] "if(i>=48 && i<=49,(i-48)*2^(w-1-x),nan)"
  -u {if($is_negative,-1,1)*@{-1,+}}
  -rm[-1]

# compress_gmic
# Compress .gmic custom command files for the 'gmic' command line tool,
# by removing empty lines, and useless comments (non starting with '#@gmic').
compress_gmic :
  -e[] "" -v -
  head_std={'"#@gmic"'}
  -s -,10 N=@#
  -repeat @# -l[$<]
    -if {!($>%100)} -v + -e[] "\r  Process : "{round($>/$N*100)}% -v - -endif
    -if {i=={'#'}}
      head=@{-1,0-{min(5,h-1)}}
      -if {{$head'!='$head_std}" || "(i[6]!={'" "'}" && "i[6]!={':'})} -rm[-1] -continue
      -endif
    -else
      -l[-1] -s +,32,35 -if {@#>2} -k[0] -endif -a y -endl
      -autocrop[-1] 32 -if {!w} -rm[-1] -continue -endif
    -endif
  -endl -done
  -i[1--2] (10) -a y
  -v + -e[] "\r Process : 100%"

# compress_gmic_gimp
# Compress .gmic custom command files for the GIMP plug-in,
# by removing empty lines, and useless comments (non starting with '#@gimp').
compress_gmic_gimp :
  -e[] "" -v -
  head_std={'"#@gimp"'}
  -s -,10 N=@#
  -repeat @# -l[$<]
    -if {!($>%100)} -v + -e[] "\r  Process : "{round($>/$N*100)}% -v - -endif
    -if {i=={'#'}}
      head=@{-1,0-{min(5,h-1)}}
      -if {$head'!='$head_std} -rm[-1] -continue
      -endif
    -else
      -l[-1] -s +,32,35 -if {@#>2} -k[0] -endif -a y -endl
      -autocrop[-1] 32 -if {!w} -rm[-1] -continue -endif
    -endif
  -endl -done
  -i[1--2] (10) -a y
  -v + -e[] "\r Process : 100%"

#@gmic dec : decimal_int1,...
#@gmic : Print specified decimal integers into their binary, octal, hexadecimal and string representations.
dec :
  -e[^-1] "Convert decimal integer"@{-arg\ 1+($#>1),"",s}" '${^0}' to binary '"@{-dec2bin\ ${^0}}"',
           octal '"@{-dec2oct\ ${^0}}"', hexadecimal '"@{-dec2hex\ ${^0}}"' and string '"@{-dec2str\ ${^0}}"'."

#@gmic dec2str : decimal_int1,...
#@gmic : Convert specifial decimal integers into its string representation.
dec2str :
  -v - -u {`${^0}`} -v +

#@gmic dec2bin : decimal_int1,...
#@gmic : Convert specified decimal integers into their binary representations.
dec2bin :
  -v - res=@{-_$0\ $1} -repeat {$#-1} res=$res,@{-_$0\ @{-arg\ $>+2,${^0}}} -done -u $res -v +

_dec2bin : -check isint($1)
  res="" r={abs($1)}
  -do res={$r%2}$res r={int($r/2)} -while $r
  -u @{-arg\ 1+($1>=0),-,""}$res

#@gmic dec2hex : decimal_int1,...
#@gmic : Convert specified decimal integers into their hexadecimal representations.
dec2hex :
  -v - res=@{-_$0\ $1} -repeat {$#-1} res=$res,@{-_$0\ @{-arg\ $>+2,${^0}}} -done -u $res -v +

_dec2hex : -check isint($1)
  res="" r={abs($1)}
  -do res=@{-_dec2hex_{$r%16}}$res r={int($r/16)} -while $r
  -u @{-arg\ 1+($1>=0),-,""}$res

_dec2hex_0 : -u 0
_dec2hex_1 : -u 1
_dec2hex_2 : -u 2
_dec2hex_3 : -u 3
_dec2hex_4 : -u 4
_dec2hex_5 : -u 5
_dec2hex_6 : -u 6
_dec2hex_7 : -u 7
_dec2hex_8 : -u 8
_dec2hex_9 : -u 9
_dec2hex_10 : -u a
_dec2hex_11 : -u b
_dec2hex_12 : -u c
_dec2hex_13 : -u d
_dec2hex_14 : -u e
_dec2hex_15 : -u f

#@gmic dec2oct : decimal_int1,...
#@gmic : Convert specified decimal integers into their octal representations.
dec2oct :
  -v - res=@{-_$0\ $1} -repeat {$#-1} res=$res,@{-_$0\ @{-arg\ $>+2,${^0}}} -done -u $res -v +

_dec2oct : -check isint($1)
  res="" r={abs($1)}
  -do res={$r%8}$res r={int($r/8)} -while $r
  -u @{-arg\ 1+($1>=0),-,""}$res

#@gmic fact : value
#@gmic : Return the factorial of the specified value.
fact : -check isint($1)
  -v - res=1 -repeat $1 res={$res*($>+1)} -done -u $res -v +

#@gmic file_mv : filename_src,filename_dest
#@gmic : Rename or move a file from a location $1 to another location $2.
file_mv :
  -e[^-1] "Move file '$1' to location '$2'."
  -v - -if @{-is_windows} -x "move "$1" "$2 -else -x "mv "$1" "$2 -endif -v +

#@gmic file_rand
#@gmic : Return a random filename for storing temporary data.
file_rand :
  -v -
  -do filename=@{-path_tmp}@{-file_slash}gmic@%{round(?(0,9))}{round(?(0,9))}{round(?(0,9))}{round(?(0,9))}{round(?(0,9))}{round(?(0,9))}
  -while $filename
  -u $filename
  -v +

#@gmic file_rm : filename
#@gmic : Delete a file.
file_rm :
  -e[^-1] "Remove file '$1'."
  -v -
  -if @{-is_windows}
    1 -nm[-1] "$1" dir=@{-1,f} base=@{-1,b} ext=@{-1,x} -rm[-1] com=""
    -if {narg($dir)} com="cd \""$dir"\\\" && " -endif
    -if {narg($ext)} com=${com}"del \""$base.$ext"\"" -else com=${com}"del \""$base"\"" -endif
    -x $com
  -else
    -x "rm -f \"$1\""
  -endif
  -v +

#@gmic file_slash
#@gmic : Return '/' or '\' as a path separator for filenames.
file_slash :
  -v - -if @{-is_windows} -u "\\" -else -u "/" -endif -v +

#@gmic filename : filename,_number1,_number2,...,_numberN
#@gmic : Return a filename numbered with specified indices.
filename : -skip "${1=default}"
  -v -
  -if {$#==1} -u "$1"
  -else
  (${2--1}) -name[-1] "$1" -u @{-1,f}@{-1,b}
  -repeat {w}
    -u @{}_{int(i/100000)%10}{int(i/10000)%10}{int(i/1000)%10}{int(i/100)%10}{int(i/10)%10}{i%10}
    -shift[-1] -1
  -done
  -if {narg({'@{-1,x}'})} -u @{}.@{-1,x} -endif
  -rm[-1]
  -endif
  -v +

#@gmic fitratio_wh : min_width,min_height,ratio_wh
#@gmic : Return a 2d size 'width,height' which is bigger than 'min_width,min_height' and has the specified w/h ratio.
fitratio_wh :
  -v - -if {$3*$2>$1} -u {int($3*$2)},$2 -else -u $1,{int($1/$3)} -endif -v +

#@gmic fitscreen : width,height,_depth,_minimal_size[%],_maximal_size[%]
#@gmic : Return the 'ideal' size WxH for a window intended to display an image of specified size on screen.
#gmic : Default values: 'depth=1', 'minimal_size=128' and 'maximal_size=85%'.
fitscreen : -check "$1>0 && $2>0 && ${3=1}>0 && ${4=128}>0 && ${5=85%}>0"
  -v -
  mp=@{-is_percent\ $4}
  mw={if($mp,int(@{!,u}*$4),$4)}
  mh={if($mp,int(@{!,v}*$4),$4)}
  Mp=@{-is_percent\ $5}
  Mw={if($Mp,int(@{!,u}*$5),$5)}
  Mh={if($Mp,int(@{!,v}*$5),$5)}
  w={if($3>1,$1+$3,$1)}
  h={if($3>1,$2+$3,$2)}
  -if {$w<$mw} h={max(1,int($h*$mw/$w))} w=$mw -endif
  -if {$h<$mh} w={max(1,int($w*$mh/$h))} h=$mh -endif
  -if {$w>$Mw} h={max(1,int($h*$Mw/$w))} w=$Mw -endif
  -if {$h>$Mh} w={max(1,int($w*$Mh/$h))} h=$Mh -endif
  w={max($w,$mw)}
  h={max($h,$mh)}
  -u $w,$h
  -v +

#@gmic gcd : a,b
#@gmic : Return the GCD (greatest common divisor) between a and b.
gcd : -check "isint($1) && isint($2) && $1*$2!=0"
  -v - -_gcd {max(abs($1),abs($2))},{min(abs($1),abs($2))} -v +

_gcd :
  r={$1%$2} -if $r -u @{-_gcd\ $2,$r} -else -u $2 -endif

#@gmic hex : hexadecimal_int1,...
#@gmic : Print specified hexadecimal integers into their binary, octal, decimal and string representations.
hex :
  -v - dec=@{-hex2dec\ ${^0}} -v +
  -e[^-1] "Convert hexadecimal integer"@{-arg\ 1+($#>1),s,""}" '${^0}' to binary '"@{-dec2bin\ $dec}"',
           octal '"@{-dec2oct\ $dec}"', decimal '"$dec"' and string '"@{-dec2str\ $dec}"'."

#@gmic hex2dec : hexadecimal_int1,...
#@gmic : Convert specified hexadecimal integers into their decimal representations.
hex2dec :
  -v - res=@{-_$0\ $1} -repeat {$#-1} res=$res,@{-_$0\ @{-arg\ $>+2,${^0}}} -done -u $res -v +

_hex2dec :
  ({'@{-struncase\ $1}'})
  is_negative=0
  -if {@{-1,0}==45} -z[-1] 1,100% is_negative=1 -endif
  -f[-1] "if(i>=48 && i<=57,i-48,if(i>=97 && i<=102,i-87,nan))*16^(w-1-x)"
  -u {if($is_negative,-1,1)*@{-1,+}}
  -rm[-1]

#@gmic hex2str : hexadecimal_string
#@gmic : Convert specified hexadecimal string into a string.
hex2str : -skip ${1=""}
  -v -
  -if {!narg("$1")} -return -endif
  ({'$*'})
  -if {w<2} -rm[-1] -u "" -return -endif
  -r[-1] 2,{w/2},1,1,-1 -f[-1] 'if(i>=97,i-87,i-48)' -f[-1] 'if(x==0,i*16+i(x+1),0)' -columns[-1] 0
  -u @{-1,t} -rm[-1]
  -v +

#@gmic img2str
#@gmic : Return the content of the latest of the selected image as a special G'MIC input string.
img2str :
  -v -
  -u "("
  -repeat {s} c=$>
    -repeat {d} z=$>
      -repeat {h} y=$>
        --z[-1] 0,$y,$z,$c,100%,$y,$z,$c
        -u @{}@-1
        -rm[-1]
        -if {$y!=h-1} -u @{}; -endif
        -e @{}
      -done
      -if {$z!=d-1} -u @{}/ -endif
    -done
    -if {$c!=s-1} -u @{}^ -endif
  -done
  -u @{}")"
  -v +

#@gmic img2text : _line_separator
#@gmic : Return text contained in a multi-line image.
#@gmic : Default value: 'line_separator= '.
img2text : -skip "${1= }"
  -v - --l -s y -s -,0 -y x -if {@#>1} -i[1--2] ({'"$1"'}) -endif -a x -u @{0,t} -rm -endl -v +

#@gmic img82hex
#@gmic : Convert selected 8bits-valued vectors into their hexadecimal representations (ascii-encoded).
img82hex :
  -e[^-1] "Convert 8bits-valued vector$? into hexadecimal representations (ascii-encoded)."
  -v - -mod 256 -y
  -repeat @#
    --f[$>] 'v=int(i)&15;v+if(v<10,48,87)'  # lower digit.
    -f[$>] 'v=int(i)>>4;v+if(v<10,48,87)'   # higher digit.
    -a[$>,-1] x
  -done -v +

#@gmic hex2img8
#@gmic : Convert selected hexadecimal representations (ascii-encoded) into 8bits-valued vectors.
hex2img8 :
  -e[^-1] "Convert hexadecimal representation$? (ascii-encoded) into 8bits-valued vectors."
  -v - -repeat @#
    -s[-1] x,2 -f[-2,-1] 'if(i>=97,i-87,i-48)' -*[-2] 16 -+[-2,-1]
  -mv[-1] 0 -done -v +

#@gmic is_3d
#@gmic : Return 1 if all of the selected image are 3d objects, 0 otherwise.
is_3d :
  -v - -u 1 -l -check3d 1 -onfail -u 0 -endl -v +

#@gmic is_percent : string
#@gmic : Return 1 if specified string ends with a '%', 0 otherwise.
is_percent :
  -v - -u {arg(-1,{'"$1"'})==37} -v +

#@gmic is_image_arg : string
#@gmic : Return 1 if specified string looks like '[ind]'.
is_image_arg :
  -v - asc={'"$1"'} -u {arg(1,$asc)=={'['}&&arg(-1,$asc)=={']'}&&min($asc)>=45&&max($asc)<=122} -v +

#@gmic is_windows
#@gmic : Return 1 if current computer OS is Windows, 0 otherwise.
is_windows :
  -v - -u {narg($OS)==1" && "narg($WINDIR)==1} -v +

#@gmic mad
#@gmic : Return the MAD (Maximum Absolute Deviation) of the last selected image.
#@gmic : The MAD is defined as MAD = med_i|x_i-med_j(x_j)|
mad :
  -v - ---[-1] @{-med[-1]} -abs[-1] -med[-1] -u {1.4826*@{}} -rm[-1] -v +

#@gmic max_w
#@gmic : Return the maximal width between selected images.
max_w :
  -v - -u {arg(1,@{-_max_whds\ 4})} -v +

#@gmic max_h
#@gmic : Return the maximal height between selected images.
max_h :
  -v - -u {arg(2,@{-_max_whds\ 4})} -v +

#@gmic max_d
#@gmic : Return the maximal depth between selected images.
max_d :
  -v - -u {arg(3,@{-_max_whds\ 4})} -v +

#@gmic max_s
#@gmic : Return the maximal spectrum between selected images.
max_s :
  -v - -u {arg(4,@{-_max_whds\ 4})} -v +

#@gmic max_wh
#@gmic : Return the maximal wxh size of selected images.
max_wh :
  -v - -_max_whds 2 -v +

#@gmic max_whd
#@gmic : Return the maximal wxhxd size of selected images.
max_whd :
  -v - -_max_whds 3 -v +

#@gmic max_whds
#@gmic : Return the maximal wxhxdxs size of selected images.
max_whds :
  -v - -_max_whds 4 -v +

_max_whds :
  w=0 h=0 d=0 s=0
  -repeat @#
    w={max($w,w)}
    h={max($h,h)}
    d={max($d,d)}
    s={max($s,s)}
  -mv[-1] 0 -done
  -if {$1>=4} -u $w,$h,$d,$s
  -elif {$1==3} -u $w,$h,$d
  -elif {$1==2} -u $w,$h
  -else -u $w
  -endif

#@gmic med
#@gmic : Return the median value of the last selected image.
med :
  -v - --sort[-1] -u @{-1,{w*h*d*s/2}} -rm[-1] -v +

#@gmic color_med
#@gmic : Return the median color value of the last selected image.
color_med :
  -v - -u "" s="" -repeat {s} --channels[-1] $> -u @{}$s@{-med[-1]} s=, -rm[-1] -done -v +

#@gmic min_w
#@gmic : Return the minimal width between selected images.
min_w :
  -v - -u {arg(1,@{-_min_whds\ 4})} -v +

#@gmic min_h
#@gmic : Return the minimal height between selected images.
min_h :
  -v - -u {arg(2,@{-_min_whds\ 4})} -v +

#@gmic min_d
#@gmic : Return the minimal depth between selected images.
min_d :
  -v - -u {arg(3,@{-_min_whds\ 4})} -v +

#@gmic min_s
#@gmic : Return the minimal s size of selected images.
min_s :
  -v - -_min_s @{-_min_whds\ 4} -v +

_min_s :
  -u $4

#@gmic min_wh
#@gmic : Return the minimal wxh size of selected images.
min_wh :
  -v - -_min_whds 2 -v +

#@gmic min_whd
#@gmic : Return the minimal wxhxd size of selected images.
min_whd :
  -v - -_min_whds 3 -v +

#@gmic min_whds
#@gmic : Return the minimal wxhxdxs size of selected images.
min_whds :
  -v - -_min_whds 4 -v +

_min_whds :
  w={w} h={h} d={d} s={s}
  -repeat @#
    w={min($w,w)}
    h={min($h,h)}
    d={min($d,d)}
    s={min($s,s)}
  -mv[-1] 0 -done
  -if {$1>=4} -u $w,$h,$d,$s
  -elif {$1==3} -u $w,$h,$d
  -elif {$1==2} -u $w,$h
  -else -u $w
  -endif

#@gmic normalize_filename : filename
#@gmic : Return a "normalized" version of the specified filename, without spaces and capital letters.
normalize_filename :
  -v - ({'"$1"'}) -f[-1] 'if(i>=65&&i<=90,i+32,if(i==32,95,i))' -u @{-1,t} -rm[-1] -v +

#@gmic oct : octal_int1,...
#@gmic : Print specified octal integers into their binary, decimal, hexadecimal and string representations.
oct :
  -v - dec=@{-oct2dec\ ${^0}} -v +
  -e[^-1] "Convert octal integer"@{-arg\ 1+($#>1),"",s}" '${^0}' to binary '"@{-dec2bin\ $dec}"', decimal '"$dec"',
           hexadecimal '"@{-dec2hex\ $dec}"' and string '"@{-dec2str\ $dec}"'."

#@gmic oct2dec : octal_int1,...
#@gmic : Convert specified octal integers into their decimal representations.
oct2dec :
  -v - res=@{-_$0\ $1} -repeat {$#-1} res=$res,@{-_$0\ @{-arg\ $>+2,${^0}}} -done -u $res -v +

_oct2dec :
  ({'@{-struncase\ $1}'})
  is_negative=0
  -if {@{-1,0}==45} -z[-1] 1,100% is_negative=1 -endif
  -f[-1] "if(i>=48 && i<=55,(i-48)*8^(w-1-x),nan)"
  -u {if($is_negative,-1,1)*@{-1,+}}
  -rm[-1]

#@gmic padint : number,_size>0
#@gmic : Return a integer with 'size' digits (eventually left-padded with '0').
padint : -skip ${2=4}
  -v - -u "" -repeat $2 -u @{}{int($1/10^$<)%10} -done -v +

#@gmic path_gimp
#@gmic : Return a path to store GIMP configuration files for one user (whose value is OS-dependent).
path_gimp :
  -v -
  -if {narg({'${GIMP2_DIRECTORY}'})} -u ${GIMP2_DIRECTORY} -v + -return -endif
  -if {narg({'${USERPROFILE}'})} -u ${USERPROFILE}
  -elif {narg({'${HOME}'})} -u ${HOME}
  -else -u ""
  -endif
  -if @{}/.gimp-2.8/pluginrc -u @{}/.gimp-2.8
  -elif @{}/.gimp-2.6/pluginrc -u @{}/.gimp-2.6
  -else -u @{-path_tmp}
  -endif -v +

#@gmic path_tmp
#@gmic : Return a path to store temporary files (whose value is OS-dependent).
path_tmp :
  -v - -u ""
  -if {narg({'${TMP}'})} -u ${TMP}
  -elif {narg({'${TEMP}'})} -u ${TEMP}
  -elif {narg({'${TMPDIR}'})} -u ${TMPDIR}
  -elif {narg({'${HOME}'})} -u "/tmp"
  -else -u ""
  -endif
  -v +

#@gmic path_user
#@gmic : Return a path to store persistent configuration files for one user (whose value is OS-dependent).
path_user :
  -v - -u ""
  -if {narg({'${APPDATA}'})} -u ${APPDATA}
  -elif {narg({'${HOME}'})} -u ${HOME}
  -else -u ""
  -endif
  -v +

#@gmic quote : string
#@gmic : Return a "quotified" version of the string.
quote :
  -v - -u "$*" -v +

#@gmic region_feature : region_label,feature,_default_value
#@gmic : Return feature for a specified region.
#@gmic : This function requires two images [img,region_label] in the selection.
#@gmic : Argument 'feature' is a string that corresponds to the way the feature would
#@gmic : be asked for the entire image.
#@gmic : Default value: 'default_value=0'.
#@gmic : $ image.jpg --luminance -quantize[-1] 2 -label[-1] 0,1 mean=@{"-region_feature[0,1] 10,\"{ia}\""} sum=@{"-region_feature[0,1] 10,\"@{-1,+}\""}
region_feature : -skip "${3=0}"
  -v -
  s=@{-2,s} --channels[-1] 0 -==[-1] $1 -^[-1] -1 --[-1] 1 -r[-1] [-3] -+[-1] [-3]
  -l[-1]
    -s[-1] -,inf -a y                            # Keep only pixel values inside the selected region.
    -if @# -r[-1] 1,{h/$s},1,$s,-1 -u $2 -rm[-1] # If region is not empty, compute the feature.
    -else -u $3                                  # Otherwise set a default return value.
    -endif
  -endl
  -v +

#@gmic reset
#@gmic : Reset global parameters of the interpreter environment.
reset :
  -e[^-1] "Reset global parameters of the interpreter environment."
  -v -1 -db3d -m3d -md3d -f3d -l3d -sl3d -ss3d -v +

#@gmic RGB
#@gmic : Return a random int-valued RGB color.
RGB :
  -v - -u {round(?(255))},{round(?(255))},{round(?(255))} -v +

#@gmic RGBA
#@gmic : Return a random int-valued RGBA color.
RGBA :
  -v - -u {round(?(255))},{round(?(255))},{round(?(255))},{round(?(255))} -v +

#@gmic str : string
#@gmic : Print specified string into its binary, octal, decimal and hexadecimal representations.
str : -skip $1
  -v - dec={'$*'} -v +
  -e[^-1] "Convert string '$*' to binary '"@{-dec2bin\ $dec}"', octal '"@{-dec2oct\ $dec}"', decimal '"$dec"' and
           hexadecimal '"@{-dec2hex\ $dec}"'."

#@gmic str2hex : string
#@gmic : Convert specified string into a sequence of hexadecimal values.
str2hex :
  -v - ({'"$*"'}) -rows[-1] 0,1 -f[-1] 'if(y==0,int(i/16),i(x,y-1)%16)' -f[-1] 'if(i<=9,48+i,87+i)' -transpose[-1] -u @{-1,t} -rm[-1] -v +

#@gmic stresc : val1,...,valN
#@gmic : Return escaped string from specified ascii codes.
stresc :
  -v - ($*) -c[-1] 32,255 -y[-1] [-1]
  -f[-2] 'if(i==32||i==34||i==36||i==44||i==64||i==92||i==123||i==125,92,-1)' -a[-2,-1] x
  -discard[-1] -1 -u @{-1,t} -rm[-1] -v +

#@gmic strcat : string1,string2,...
#@gmic : Return the concatenation of all strings passed as arguments.
strcat :
  -v - $=s res="$1" -repeat {$#-1} res=$res${s{$>+2}} -done
  -u $res -v +

#@gmic strcmp : string1,string2
#@gmic : Return 1 if the two strings are equal, 0 otherwise.
strcmp :
  -v - (0,{'"$1"'}) ({w},{'"$2"'}) -=[-2] {w} --[-2,-1] -abs[-1] -u {!@{-1,+}} -rm[-1] -v +

#@gmic strlen : string1
#@gmic : Return the length of specified string argument.
strlen :
  -v - ({'"$1"'}) -u {w} -rm[-1] -v +

#@gmic strreplace : string,search,replace
#@gmic : Search and replace substrings in an input string.
strreplace :
  -v -
  ls=@{-strlen\ "$2"}
  lr={@{-strlen\ "$3"}-1}
  -l[] ({'"$1"'}) -s +,{'"$2"'} -s y,-$ls
  -repeat @# -if {@{$>,t}'=='"$2"} -rows[$>] 0,$lr -f[$>] {'"$3"'} -endif -done
  -a y -u @{-1,t} -rm -endl
  -v +

#@gmic struncase : string
#@gmic : Return a lower-case version of the specified string.
struncase :
  -v - ({'"$*"'}) -+[-1] 'if(i>=65&&i<=90,32,0)' -u @{-1,t} -rm[-1] -v +

#@gmic strver
#@gmic : Return the current version number of the G'MIC interpreter, as a string.
strver :
  -v - ({'@.'}) -r[-1] 7 -f[-1] 'if(x%2,{'.'},i)' -u @{-1,t} -rm[-1] -v +

#@gmic tic
#@gmic : Initialize tic-toc timer.
#@gmic : Use it in conjunction with '-toc'.
tic :
  -e[^-1] "Initialize timer."
  -v - -if {!narg($_ticpos)} _ticpos=0 -endif _tic$_ticpos=@| _ticpos={$_ticpos+1} -v +

#@gmic toc
#@gmic : Display elapsed time of the tic-toc timer since the last call to '-tic'.
#@gmic : Use it in conjunction with '-tic'.
toc :
  -v - _ticpos={$_ticpos-1} -v +
  -e[^-1] "Elapsed time : "{_@|-${_tic$_ticpos}}" s".

#@gmic std_noise
#@gmic : Return the estimated noise standard deviation of the last selected image.
std_noise :
  -v -
  -if @# --laplacian[-1] -u {@{-mad[-1]}/sqrt(if(d==1,20,42))} -rm[-1]
  -else -u 0
  -endif
  -v +

#-------------------------------------
#
#@gmic :: Other interactive commands
#
#-------------------------------------

#@gmic demo : _run_in_parallel={ 0=no | 1=yes | 2=auto }
#@gmic : Show a menu to select and view all G'MIC interactive demos.
demo : -check "isint(${1=2}) && $1>=0 && $1<=2"
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ G\47MIC demo menu ------------------\n
----\n
---- Mouse button to select a demo.\n
---- Keys 'CTRL+D' to double window size.\n
---- Keys 'CTRL+C' to reset window size.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------"
  -v - -l[]
  parallel_mode={1-if($1!=2,$1,@*>2)}
  380,600,1,3 --plasma[-1] 1,1,5 -n[-1] 0,230 -water[-1] 100
  (0.1;0.03^0;0.1^0.2;0.1) -r[-1] [-2],3 -*[-2,-1] -c[-1] 0,255
  100%,100%,1,3
  0 -t[-1] "1- 2048 game\n"\
           "2- Blobs editor\n"\
           "3- Bouncing balls\n"\
           "4- Fire effect\n"\
           "5- Fireworks\n"\
           "6- Fish-eye effect\n"\
           "7- Fourier filtering\n"\
           "8- Histogram demo\n"\
           "9- Hough transform\n"\
           "10- Jawbreaker\n"\
           "11- The game of life\n"\
           "12- Light effect\n"\
           "13- Mandelbrot explorer\n"\
           "14- 3d metaballs\n"\
           "15- Minesweeper\n"\
           "16- Minimal path\n"\
           "17- Pacman\n"\
           "18- Paint\n"\
           "19- Plasma effect\n"\
           "20- RGB quantization\n"\
           "21- 3d reflection\n"\
           "22- 3d rubber object\n"\
           "23- Shade bobs\n"\
           "24- Spline editor\n"\
           "25- Tetris\n"\
           "26- Tic-tac-toe\n"\
           "27- Image waves\n"\
           "28- Fractal whirls\n"\
           "29- Color curves\n",0,0,18,1,255,255,255
  commands=-x_2048,-x_blobs,-x_bouncing,-x_fire,-x_fireworks,-x_fisheye,-x_fourier,-x_histogram,-x_hough,\
           -x_jawbreaker,-x_life,-x_light,-x_mandelbrot,-x_metaballs3d,-x_minesweeper,-x_minimal_path,\
           -x_pacman,-x_paint,-x_plasma,-x_quantize_rgb,-x_reflection3d,-x_rubber3d,-x_shadebobs,\
           -x_spline,-x_tetris,-x_tictactoe,-x_waves,-x_whirl,-_demo_color_curves
  y0=59
  -j[-2] [-1],20,$y0,0,0 -rm[-1]
  -rectangle[-1] 0,16,100%,44,1,120,120,32
  0 -t[-1] "G\47MIC "@{-strver}" demos",2,2,28,1,1,1,1 -b[-1] 0.5 -n[-1] 0,1
  (32;255^255;255^0;0) -r[-1] [-2],[-2],1,3,3 -*[-2,-1] -round[-1] 1,-1 --!=[-1] 0 -channels[-1] 1
  -j[-3] [-2],20,16,0,0,1,[-1] -rm[-2,-1] --channels[-1] 1 -dilate[-1] 5
  (80;255;80^0;255;0^0;0;0) (10;255;10^0;100;0^0;0;0)
  -r[-2,-1] [-3],18,1,3,3 -polygon[-2,-1] 3,1,1,1,16,10,8,1,255,255,255 --mirror[-2,-1] x
  -max[-4,-2] -max[-2,-1]

  # Pre-compute 3d objects.
  -ball[] 64,200,100,64 -n[-1] 0,230 -s[-1] c,-3 -rgb2hsv[-2] -*[-1] 0.5 -a[-2,-1] c
  -repeat 6
    -sh[-1] 0,0 -f[-1] {$>*360/6} -rm[-1] --s[-1] c,-3 -hsv2rgb[-2] -a[-2,-1] c
    ({'CImg3d'}) (5,5) 3,5 (1,0;1,4) -r[-1] 2,5,1,1,3 -round[-1] 4,5 -y[-5--1] -a[-5--1] y
    -rv[-2,-1] -sprites3d[-2,-1] -rv[-2,-1]
  -done -rm[-1] -+3d[-6--1]
  cfx={0} cfy={0} cfz={0} nfx={g} nfy={g} nfz={g} alpha=0 time0={@|-4} selected=-1 -f3d 400

  # Start main loop.
  -w[0] -1,-1,0,0,50%,50%,"[G\47MIC] Demo menu"
  -do

    # Set 3d coordinates for object.
    t={1.5*@|}
    1,30,1,1,'(1-$alpha)*cos($cfx*y+$t)+$alpha*cos($nfx*y+$t)'
    1,30,1,1,'(1-$alpha)*sin($cfy*y+$t)+$alpha*sin($nfy*y+$t)'
    1,30,1,1,'(1-$alpha)*sin($cfz*y+$t)+$alpha*sin($nfz*y+$t)'
    -a[-3--1] x -s[-1] y,5 -a[-5--1] x -y[-1]
    -j[6] [-1],0,8 -rm[-1] -*3d[6] @{0,w/2-30},@{0,h/2-30},300 -+3d[6] 0,0,200

    # Render image.
    -*[0] 0.85 -+[0] [1] -j3d[0] [6],50%,50%,0,1,0,0,0 -j[0] [2],0,0,0,0,1,[3],255

    # Manage mouse events.
    y={@{!,y}*@{0,h}/@{!,h}}
    -if {$y>=0} y={max(0,min(28,int(($y-$y0)/18)))} -j[0] [{if($selected>=0,5,4)}],0,{$y0+18*$y},0,0,0.2 -endif # Menu location.

    -w[0] -wait 20
    -if {@{!,CTRLLEFT}&&@{!,D}} -w[0] 200%,200% -elif {@{!,CTRLLEFT}&&@{!,C}} -w[0] 100%,100% -endif

    -if {(@{!,b}&1)&&$selected<0} selected=$y # Selection
    -elif {!@{!,b}}
      -if {$selected>=0&&$y==$selected}
      -m "com : -v 0 "@{-arg\ {1+$y},$commands} -parallel $parallel_mode,"-l[] -com -v -1 -rm -endl" -uncommand com
      -endif
      selected=-1
    -endif

    # Manage ball animation.
    -if {@|-$time0>5} alpha={$alpha+0.03} -endif
    -if {$alpha>1} alpha={$alpha-1} cfx=$nfx cfy=$nfy cfz=$nfz nfx={g} nfy={g} nfz={g} time0={@|-?*3} -endif
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -rm -w 0 -endl -v 0 -e[] ""

_demo_color_curves :
  -e[] "\n
------ Color curves ----------------------------------------------------------------------------\n
---- Left mouse button on a curve creates a new control point (or moves an existing one).\n
---- Right mouse button on a control point deletes it.\n
---- Left mouse button on the main image window shows the initial image until button is released.\n
---- Right mouse button on the main image window adds a keypoint to all curves from picked color.\n
---- Key 'R' on a curve resets it.\n
---- Keys 'CTRL+D' increase window size.\n
---- Keys 'CTRL+C' decrease window size.\n
---- Keys 'CTRL+R' reset window size.\n
---- Keys 'ESC', 'Q' or 'ENTER' close the current window.\n
------------------------------------------------------------------------------------------------"
  -v - -testimage2d 512 -x_color_curves rgb -v +

#@gmic x_2048
#@gmic : Launch the 2048 game.
x_2048 :
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ 2048 -----------------------------------------------\n
----\n
---- Join the numbers and get to the 2048 title!\n
----\n
---- Use your arrow keys to move the tiles. When two tiles\n
---- with the same number touch, they merge into one!\n
---- This command is a port of the '2048' game originally\n
---- designed by Gabriele Cirulli, and available at:\n
---- http://gabrielecirulli.github.io/2048/\n
----\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
--------------------------------------------------------------"
  -v - -l[]
  score=0 -f3d 50 -m3d 0
  -m "_x_2048_setrandom : --==[0] 0 -f[-1] 'if(i,4*y+x,-1)' -discard[-1] -1
      off={i[round(?(h-1))]} -rm[-1] x={$off&3} y={$off>>2} n={if(?<0.75,1,2)}
      -=[0] $n,$x,$y [{2+$n}] -c3d[-1]
      -repeat 6 -j3d[1] [-1],{78+$x*121},{190+$y*121},{10*$<},{(1+$>)/6} -w[1] -wait 20 -done
      -rm[-1]"
  -m "_x_2048_object3d : --f[0] 'if(i,i*16+4*y+x,-1)' -discard[-1] -1
      N={h} -repeat {h} v=@{-{1+$>},$>} --+3d[{2+($v>>4)}] {$v&3},{($v>>2)&3} -done
      -+3d[-$N--1] -rm[-2]"
  -i[0] 4,4

  # Pre-render game canvas and numbered titles.
  b0=204,192,179 b1=238,228,218 b2=237,224,200 b3=242,177,121
  b4=245,149,99 b5=246,124,95 b6=246,94,59 b7=237,207,114
  c0=119,110,101 c1=249,246,242 s0=" "
  520,630,1,3 -fc[-1] 250,248,239
  -t[-1] "2048",20,10,86,1,$c0
  -t[-1] "Join the numbers and get to the 2048 title!",20,90,20,1,$c0
  -rectangle[-1] 422,20,501,75,1,187,173,160 -t[-1] "SCORE",439,25,15,1,238,228,218
  -repeat 12
    107,107,1,3 -fc[-1] ${b{min($>,7)}} --fc[-1] ${c{$>>2}}
    s1={2^$>} 0 -t[-1] ${s{$>>0}},0,0,52,1,1
    -r[-1] [-2],[-2],1,1,0,0,0.5,0.5 -dilate_circ[-1] 3 -b[-1] 0.5
    -j[-3] [-2],0,0,0,0,1,[-1],1 -rm[-2,-1]
  -done
  -frame_round[2--1] 10,5,1,0.5,187,173,160 -frame[2--1] 7,7,187,173,160 -to_rgb[2--1]
  -r[2] 400%,400%,1,3,0,2 -j[1] [2],18,130
  -sprite3d[3--1]

  # Run game.
  -w[1] 100%,100%,0,"[G\47MIC] 2048" insert_new=1
  -repeat 2 -_x_2048_setrandom -done
  -do

    # Render game graphics at current iteration.
    -if $insert_new
      -_x_2048_object3d -*3d[-1] 121 -j[1] [2],18,130 -j3d[1] [-1],78,190 -rm[-1]
      80,25,1,3 -fc[-1] $c1 0 -t[-1] $score,0,0,25,1,1,1,1 -r[-1] [-2],0,0,0.5,0.8
      -rectangle[1] 422,45,501,69,1,187,173,160 -j[1] [-2],422,45,0,0,1,[-1] -rm[-2,-1]
      -w[1] insert_new=0
    -endif

    # Check for the end of the game.
    --+[0] 1 -f[-1] 'j(-1)==i||j(1)==i||j(0,-1)==i||j(1,0)==i||i==1'
    -if @{0,iM==11} # Game won.
      -alert "Game Over","\nCongratulations! You got the 2048 title!\n\n   Your score: "$score,"OK"
      -break
    -elif {!iM} # Game lost.
      -alert "Game Over","\nBad luck! You lost the game!\n\n   Your score: "$score,"OK"
      -break
    -endif
    -rm[-1]

    # Manage user events.
    -wait
    is_shift=0 -uncommand shift2048,ishift2048,vshift2048
    -if @{!,ARROWLEFT}
      -m "shift2048:" -m "ishift2048:" -m "vshift2048:"
      is_shift=1
    -elif @{!,ARROWRIGHT}
      -m "shift2048: -rotate 180" -m "ishift2048: -rotate 180"
      -m "vshift2048: -s3d -l[2] -r 3,{h/3},1,1,-1 -s x --[0,1] 3 -*[0,1] -1 -a x -y -endl -a y"
      is_shift=1
    -elif @{!,ARROWUP}
      -m "shift2048: -rotate -90" -m "ishift2048: -rotate 90"
      -m "vshift2048: -s3d -l[2] -r 3,{h/3},1,1,-1 -s x -rv[0,1] --[0] 3 -*[0] -1  -a x -y -endl -a y"
      is_shift=1
    -elif @{!,ARROWDOWN}
      -m "shift2048: -rotate 90" -m "ishift2048: -rotate -90"
      -m "vshift2048: -s3d -l[2] -r 3,{h/3},1,1,-1 -s x -rv[0,1] --[1] 3 -*[1] -1  -a x -y -endl -a y"
      is_shift=1
    -endif

    # Manage tile shifts and fusions.
    -if $is_shift
      -wait -1
      -shift2048[0]
      -repeat 2

        # Tile shifts.
        -_x_2048_object3d
        --s[0] y -discard[-4--1] 0 -y[-4--1] x -r[-4--1] 4,1,1,1,0,0 -a[-4--1] y
        --==[0,-1] insert_new={$insert_new||!im} -rm[-1]
        --f[0,-1] 'if(i,x,-1)' -discard[-2,-1] -1 -rv[-2,-1] --[-2,-1] -rv[0,-2] -rm[-2]

        -if {(im||iM)&&!@{!,k}} # Render animation for shift.
          -/[-1] 5 -z[-1] 0,2 -y[-1]
          -repeat 5
            -j[-2] [-1],0,8,0,0,-1
            -j[1] [2],18,130 --vshift2048[-2] -*3d[-1] 121 -j3d[1] [-1],78,190 -rm[-1]
            -w[1] -wait 20
          -done
        -endif
        -rm[-2,-1]

        # Tile fusions.
        -if {!$>} dscore=0
          [0] --f[0] 'if(i,i*16+4*y+x,-1)' -discard[-1] -1
          -repeat {h}
            x={i[$>]&3} y={(i[$>]>>2)&3} n={i[$>]>>4}
            -if {$x>0&&@{0,i($x-1,$y)}==$n}
              -=[0] 0,$x,$y -=[0] {$n+1},{$x-1},$y -=[-2] 0,$x,$y insert_new=1 dscore={$dscore+2^($n+1)}
            -else -=[-1] -1,0,$>
            -endif
          -done
          score={$score+$dscore}

          -if {iM<0} -rm[-2,-1]
          -else # At least one tile fusions.
            -discard[-1] -1
            -rv[0,-2] -_x_2048_object3d -rv[0,-3] -vshift2048[-1] -*3d[-1] 121 # Only tiles that do not move in this step.
            -j[1] [2],18,130 -j3d[1] [-1],78,190 -rm[-3,-1]
            N={h} -repeat {h} v=@{-{1+$>},$>} --+3d[{2+($v>>4)}] {$v&3},{($v>>2)&3} -done # Only tiles that move.
            -+3d[-$N--1] -rm[-2]
            0 -t[-1] +$dscore,0,0,33,1,1 100%,100%,1,3 -fc[-1] $c0
            -repeat 6  # Render animation for fusion.
              --vshift2048[-3] -*3d[-1] 121 --j3d[1] [-1],78,190
              -j[-1] [-3],430,{80-$>},0,0,{min(1,$</6)},[-4]
              -w[-1] -rm[-2,-1] --3d[-3] {1/6},0,0 -wait 20
            -done
            -rm[-3--1]
          -endif

        -endif
      -done
      -ishift2048[0]

      # Insert new tile.
      -if $insert_new -_x_2048_setrandom -endif
    -endif

  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -rm -w 0 -endl -uncommand _x_2048_setrandom,_x_2048_object3d -v +

#@gmic x_blobs
#@gmic : Launch the blobs editor.
x_blobs :
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ Blobs editor --------------------------\n
----\n
---- Mouse to insert/move/delete blobs.\n
---- Keys 'CTRL+D' to double window size.\n
---- Keys 'CTRL+C' to reset window size.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------------------"
  -v -

  # Create background image [0].
  -l[] (0;0^0;128^0;255) -r[-1] 350,350,1,3,3 -flower[-1] 30,8,0,0,50%,50%,1 -water[-1] 20
  -w {w},{h},0,0,"[G\47MIC] Blobs editor"

  # Start event loop.
  moving=-1
  -do
    x={@{!,x}*@{0,w}/@{!,w}}
    y={@{!,y}*@{0,h}/@{!,h}}
    b=@{!,b} nearest=-1

    # Render image of blobs and find nearest blob to mouse pointer.
    -if {@#>1}
      @{0,w},@{0,h},1,2
      -repeat @{1,h}
        r={@{1,2}*(1+@{1,3}*cos(@{1,4}+@{1,5}*@|*1000))}
        -ellipse[-1] @{1,0,1},$r,$r,0,1,@{1,6-7}
        d={sqrt(($x-@{1,0})^2+($y-@{1,1})^2)}
        -if {$d<$r} nearest=$> -endif
      -shift[1] 0,-1,0,0,2 -done
      -b[-1] 15
      --norm[-1] -->=[-1] 50 -<=[-2] 40 -*[-3,-1]
      --*[0,-1] -rm[-2] -rv[-2,-1] -*[-1] 1.6 -c[-1] 0,255 -+[-2,-1]
      -w[-1]
      -if {@{!,CTRLLEFT}&&@{!,D}} -w[] {2*w},{2*h} -elif {@{!,CTRLLEFT}&&@{!,C}} -w[] {w},{h} -endif
      -rm[-1]
    -else
      --text_outline[0] "G\47MIC Blobs Editor",65,40,23,3,1,200,128,255
      -t[-1] "* Left mouse button : Create and move blobs.\n\n\
              * Right mouse button : Remove blob.\n\n\
              * Middle mouse button : Remove all blobs.\n\n\
              * Key 'ESC' or 'Q' : Quit.\n\n\
              * Colors and sizes of appearing blobs are\n   chosen randomly",\
             60,120,13,1,255
      -w[-1]
      -if {@{!,CTRLLEFT}&&@{!,D}} -w[] {2*w},{2*h} -elif {@{!,CTRLLEFT}&&@{!,C}} -w[] {w},{h} -endif
      -rm[-1]
    -endif
    -wait 20

    # Manage blob insertion, removal or move.
    -if {$x<0||$y<0} -continue -endif
    -if {$b&1}
      -if {$nearest>=0" || "$moving>=0} # Move existing blob.
        -if {$moving<0} moving=$nearest -endif
        -=[1] $x,0,$moving -=[1] $y,1,$moving
        -else # Insert new blob.
          ($x,$y,{?(20,50)},{?(-0.3,0.3)},{?(0,pi/2)},{?(0,0.009)},{?(64,255)},{?(64,255)}) -a[^0] y
          moving={h-1}
        -endif
    -elif {$b&2} # Remove existing blob.
      -if {$nearest>=0} -l[1] -s y -rm[$nearest] -a y -endl nearest=-1 -endif
    -elif {$b&4} # Remove all blobs.
      -k[0]
    -else
      moving=-1
    -endif

  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -rm -w 0 -endl -v +

#@gmic x_bouncing
#@gmic : Launch the bouncing balls demo.
x_bouncing :
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ Bouncing balls ------------------------------\n
----\n
---- Keys 'CTRL+D' to double window size.\n
---- Keys 'CTRL+C' to reset window size.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------------------"
  -v - -l[]
  500,320,1,3 -plasma 1,1,9 -n 0,220
  N=12
  -repeat $N
    -ball[] {round(?(32,80))},@{-RGB}
    t$>={?(200)} x$>=@{0,?(10,w-10)} h$>={?(150,300)} vx$>={if(?<0.5,1,-1)*?(1,8)}
  -done
  -mv[0] @# -w[-1] -1,-1,0,"[G\47MIC] Bouncing balls"
  (0;0.7;1) -r[-1] @{-2,w},70,1,1,3

  -do
    [$N]
    -repeat $N
      bw=@{$>,w} bh=@{$>,h}
      y={${h$>}*abs(cos(${t$>}*pi/60))-$bh/2}
      dt=1
      -if {$y<0} d={-$y} y=0 bh={$bh-$d} bw={$bw+$d} dt={max(0.2,1-($d/$bh)^2)} -else dt=1 -endif
      -if {${x$>}+$bw/2>w}
        d={${x$>}+$bw/2-w} bw={$bw-$d} bh={$bh+0.5*$d}
        -if {${x$>}+$bw/4>w} vx$>={-${vx$>}} -endif
      -endif
      -if {${x$>}-$bw/2<0}
        d={$bw/2-${x$>}} bw={$bw-$d} bh={$bh+0.5*$d}
        -if {${x$>}-$bw/4<0} vx$>={-${vx$>}} -endif
      -endif
      --r[$>] $bw,$bh,1,4,3 -s[-1] c,-3
      -j[-3] [-2],{max(0,min(@{$N,w-$bw},${x$>}-$bw/2))},{@{$N,h}-@{-1,h}-$y-70},0,0,1,[-1],255 -rm[-2,-1]
      t$>={${t$>}+$dt}
      x$>={${x$>}+$dt*${vx$>}}
    -done

    --rows[-1] {h-2*70},{h-1-70} -mirror[-1] y -*[-1] [{$N+1}]
    -j[-2] [-1],0,@{-2,h-71},0,0,0.5 -rm[-1]
    -w[-1]
    -if {@{!,CTRLLEFT}&&@{!,D}} -w[] {2*w},{2*h} -elif {@{!,CTRLLEFT}&&@{!,C}} -w[] {w},{h} -endif
    -rm[-1] -wait 20
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -w 0 -rm -endl -v +

#@gmic x_color_curves : _colorspace={ rgb | cmy | cmyk | hsi | hsl | hsv | lab | lch | ycbcr | last }
#@gmic : Apply color curves on selected RGB[A] images, using an interactive window.
#@gmic : Set 'colorspace' to 'last' to apply last defined color curves without opening interactive windows.
#@gmic : Default value: 'colorspace=rgb'.
x_color_curves : -skip ${1=rgb}
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[^-1] "Apply color curves of image$?, in the '$1' colorspace."
  -if {$1'=='last} -v -
    -if {!narg($_xcc_colorbase)} -v + -return -endif
    -__x_color_curves[] $_xcc_colorbase
  -else
    -e[] "\n
------------------------------------------------------------------------------------------------\n
---- Left mouse button on a curve creates a new control point (or moves an existing one).\n
---- Right mouse button on a control point deletes it.\n
---- Left mouse button on the main image window shows the initial image until button is released.\n
---- Right mouse button on the main image window adds a keypoint to all curves from picked color.\n
---- Key 'R' on a curve resets it.\n
---- Keys 'CTRL+D' increase window size.\n
---- Keys 'CTRL+C' decrease window size.\n
---- Keys 'CTRL+R' reset window size.\n
---- Keys 'ESC', 'Q' or 'ENTER' close the current window.\n
------------------------------------------------------------------------------------------------"
    -v -
    -__x_color_curves[] $1 _xcc_colorbase=$1
  -endif

  -repeat @# -l[$>]

    -if {$1'!='last} # Open interactive windows to set color curves.
      --r[0] @{-fitscreen[]\ @{0,w},@{0,h},1,128,70%},1,100%,3
      --l[-1] -xcc_goto -s c -histogram 256,0,255 -xcc_info -endl # Compute additional info for each image channel (histogram and color axis).
      __C0= __C1= __C2= __C3= __C4=
      -if {narg($__xcc_C0)} __C0=$__xcc_C0 -endif
      -if {narg($__xcc_C1)} __C1=$__xcc_C1 -endif
      -if {narg($__xcc_C2)} __C2=$__xcc_C2 -endif
      -if {narg($__xcc_C3)} __C3=$__xcc_C3 -endif
      -if {narg($__xcc_C4)} __C4=$__xcc_C4 -endif

      x=@{1,(@{!,u}-560-w)/2} y=@{1,(@{!,v}-h)/2}
      -if {@#==5} # 3 channels.
        -parallel "-w[] 256,256,0,0,"$x","$y",\"Curve: "$_title0"\" -x_select_function1d[-3] __C0,"$_color0"",\
                  "-w[] 256,256,0,0,"{$x+280}","$y",\"Curve: "$_title1"\" -x_select_function1d[-2] __C1,"$_color1"",\
                  "-w[] 256,256,0,0,"$x","{$y+300}",\"Curve: "$_title2"\" -x_select_function1d[-1] __C2,"$_color2"",\
                  "-w[-1] 100%,100%,0,0,"{$x+560}","$y" -_x_color_curves[-4]"
      -elif {@#==6} # 4 channels.
        -parallel "-w[] 256,256,0,0,"$x","$y",\"Curve: "$_title0"\" -x_select_function1d[-4] __C0,"$_color0"",\
                  "-w[] 256,256,0,0,"{$x+280}","$y",\"Curve: "$_title1"\" -x_select_function1d[-3] __C1,"$_color1"",\
                  "-w[] 256,256,0,0,"$x","{$y+300}",\"Curve: "$_title2"\" -x_select_function1d[-2] __C2,"$_color2"",\
                  "-w[] 256,256,0,0,"{$x+280}","{$y+300}",\"Curve: "$_title3"\" -x_select_function1d[-1] __C3,"$_color3"",\
                  "-w[-1] 100%,100%,0,0,"{$x+560}","$y" -_x_color_curves[-5]"
      -elif {@#==7} # 5 channels.
        -parallel "-w[] 256,256,0,0,"$x","$y",\"Curve: "$_title0"\" -x_select_function1d[-5] __C0,"$_color0"",\
                  "-w[] 256,256,0,0,"{$x+280}","$y",\"Curve: "$_title1"\" -x_select_function1d[-4] __C1,"$_color1"",\
                  "-w[] 256,256,0,0,"$x","{$y+300}",\"Curve: "$_title2"\" -x_select_function1d[-3] __C2,"$_color2"",\
                  "-w[] 256,256,0,0,"{$x+280}","{$y+300}",\"Curve: "$_title3"\" -x_select_function1d[-2] __C3,"$_color3"",\
                  "-w[] 256,256,0,0,"{$x+280}","{$y+600}",\"Curve: "$_title4"\" -x_select_function1d[-1] __C4,"$_color4"",\
                  "-w[-1] 100%,100%,0,0,"{$x+560}","$y" -_x_color_curves[-6]"
      -endif
      -k[0]
    -endif

    # Apply color curves on fullres image.
    -xcc_goto
    -repeat {s} -function1d[] 1,${__xcc_C$>} -*[-1] {255%} -r[-1] 256,1,1,1,5 -c[-1] 0,255 -sh[0] $>,$> -map[-1] [-2] -rm[-2,-1] -done
    -xcc_backto

  -endl -done
  -uncommand xcc_goto,xcc_backto,xcc_info -v +

_x_color_curves :
  name=@{0,n} title=@{0,b} -if {narg(@{0,x})} title=$title.@{0,x} -endif ({'$title'}) -discard[-1] {'~'} title=@{-1,t} -rm[-1]
  --drgba[-1] -w[-1] 100%,100%,0,"[G\47MIC] Image: "$title -rm[-1]
  -xcc_goto[-1] [-1]

  oC0= oC1= oC2= oC3= oC4= viewmode=0
  -do
    -wait 100 need_refresh=0

    # Manage user events.
    oviewmode=$viewmode is_ctrl={@{!,CTRLLEFT}" || "@{!,CTRLRIGHT}} x=@{!,x} y=@{!,y}
    -if @{!,r} need_refresh=1 # Window resize.
    -elif {$is_ctrl" && "@{!,-D}} -w[] {@{!,w}*125%},{@{!,h}*125%} need_refresh=1 # Increase window size.
    -elif {$is_ctrl" && "@{!,-C}} -w[] {@{!,w}*80%},{@{!,h}*80%} need_refresh=1 # Decrease window size.
    -elif {$is_ctrl" && "@{!,-R}} -w[] {w},{h} need_refresh=1 # Reset window size.
    -elif {@{!,b}&1} viewmode={x=@{!,x};if(x<w/3,1,if(x<2*w/3,2,3))} # Change viewmode.
    -elif {@{!,b}&2" && "$x>=0" && "$y>=0} # Add control point from picked color.
      xc={$x*w/@{!,w}} yc={$y*h/@{!,h}} --z[0] $xc,$yc,$xc,$yc
      -repeat {s} (${__C$>},{i[$>]/255%},{i[$>]/255%}) -r[-1] 2,{w/2},1,1,-1 -sort[-1] +,y __C$>=@-1 -rm[-1] -done
      -rm[-1] -wait -1
    -else viewmode=0
    -endif
    need_refresh={$need_refresh||$oviewmode!=$viewmode}

    # Update result.
    -repeat {s} -if {${oC$>}'!='${__C$>}} # Channel must be updated.
      -function1d[] 1,${__C$>} -*[-1] {255%} -r[-1] 256,1,1,1,5 -c[-1] 0,255
      --channels[0] $> -map[-1] [-2] -j[1] [-1],0,0,0,$> -rm[-2,-1]
      need_refresh=1 oC$>=${__C$>}
    -endif -done

    # Display view.
    -if $need_refresh
      -if {$viewmode==0} # Modified view.
        --xcc_backto[1]
      -elif {$viewmode%2} # Split view.
        w2=@{0,int(w/2)} b={$viewmode==1} --z[{!$b}] 0,{$w2-1} --z[$b] $w2,100%
        -xcc_backto[-2] -xcc_backto[-1] -a[-2,-1] x -line[-1] 50%,0,50%,100%,1,0
      -else # Original view.
        --xcc_backto[0]
      -endif
      -if {s>3} -drgba[-1] -endif -w[-1] -rm[-1] refresh=0
    -endif

  -while {@!" && "!@{!,ESC}" && "!@{!,Q}" && "!@{!,SPACE}" && "!@{!,ENTER}}
  -w 0
  -repeat 4 -if {narg(${__C$>})} __xcc_C$>=${__C$>} __C$>=-1 -endif -done  # Transfer curves to output variable and request curve widgets to close;

# Define colorspace conversion functions.
__x_color_curves :
  -if {$1'=='rgb}
    _color0="255,180,180" _color1="180,255,180" _color2="180,180,255" _color3="220,220,220" _title0=Red _title1=Green _title2=Blue _title3=Alpha
    -m "xcc_goto:" -m "xcc_backto:"
    -m "xcc_info: (0,255;0,0;0,0) (0,0;0,255;0,0) (0,0;0,0;0,255) -r[-3--1] 256,3,1,1,3 "\
       "-a[0,-3] y -a[1,-2] y -a[2,-1] y"
  -elif {$1'=='cmy}
    _color0="180,255,255" _color1="255,180,255" _color2="255,255,100" _color3="220,220,220" _title0=Cyan _title1=Magenta _title2=Yellow _title3=Alpha
    -m "xcc_goto: -s c,-3 -rgb2cmy[0] -a c" -m "xcc_backto: -s c,-3 -cmy2rgb[0] -a c"
    -m "xcc_info: (255,0;255,255;255,255) (255,255;255,0;255,255) (255,255;255,255;255,0) -r[-3--1] 256,3,1,1,3 "\
       "-a[0,-3] y -a[1,-2] y -a[2,-1] y"
  -elif {$1'=='cmyk}
    _color0="180,255,255" _color1="255,180,255" _color2="255,255,100" _color3="180,180,180" _color4="220,220,220" _title0=Cyan _title1=Magenta _title2=Yellow _title3=Key _title4=Alpha
    -m "xcc_goto: -s c,-3 -rgb2cmyk[0] -a c" -m "xcc_backto: -s c,-4 -cmyk2rgb[0] -a c"
    -m "xcc_info: (255,0;255,255;255,255) (255,255;255,0;255,255) (255,255;255,255;255,0) (255,0) -r[-4--1] 256,3,1,1,3 "\
       "-a[0,-4] y -a[1,-3] y -a[2,-2] y -a[3,-1] y"
  -elif {$1'=='hsi}
    _color0="255,220,220" _color1="220,220,220" _color2="180,180,180" _color3="220,220,220" _title0=Hue _title1=Saturation _title2=Intensity _title3=Alpha
    -m "xcc_goto: -s c,-3 -rgb2hsi8[0] -a c" -m "xcc_backto: -s c,-3 -hsi82rgb[0] -a c"
    -m "xcc_info: 256,1,1,3,if(!c,x,128) 256,1,1,3,if(!c,0,if(c==1,x,128)) 256,1,1,3,if(!c,0,if(c==1,0,x)) -hsi82rgb[-3--1] -permute[-3--1] xcyz "\
       "-a[0,-3] y -a[1,-2] y -a[2,-1] y"
  -elif {$1'=='hsl}
    _color0="255,220,220" _color1="220,220,220" _color2="180,180,180" _color3="220,220,220" _title0=Hue _title1=Saturation _title2=Lightness _title3=Alpha
    -m "xcc_goto: -s c,-3 -rgb2hsl8[0] -a c" -m "xcc_backto: -s c,-3 -hsl82rgb[0] -a c"
    -m "xcc_info: 256,1,1,3,if(!c,x,128) 256,1,1,3,if(!c,0,if(c==1,x,128)) 256,1,1,3,if(!c,0,if(c==1,0,x)) -hsl82rgb[-3--1] -permute[-3--1] xcyz "\
       "-a[0,-3] y -a[1,-2] y -a[2,-1] y"
  -elif {$1'=='hsv}
    _color0="255,220,220" _color1="220,220,220" _color2="180,180,180" _color3="220,220,220" _title0=Hue _title1=Saturation _title2=Value _title3=Alpha
    -m "xcc_goto: -s c,-3 -rgb2hsv8[0] -a c" -m "xcc_backto: -s c,-3 -hsv82rgb[0] -a c"
    -m "xcc_info: 256,1,1,3,if(!c,x,255) 256,1,1,3,if(!c,0,if(c==1,x,128)) 256,1,1,3,if(!c,0,if(c==1,0,x)) -hsv82rgb[-3--1] -permute[-3--1] xcyz "\
       "-a[0,-3] y -a[1,-2] y -a[2,-1] y"
  # -elif {$1'=='lab}
  #   _color0="180,180,180" _color1="220,180,220" _color2="220,220,180" _color3="220,220,220" _title0=Lightness _title1=Chroma-A _title2=Chroma-B _title3=Alpha
  #   -m "xcc_goto: -s c,-3 -srgb2rgb[0] -apply_parallel_overlap[0] -rgb2lab8,0 -a c" -m "xcc_backto: -s c,-3 -apply_parallel_overlap[0] -lab82rgb,0 -rgb2srgb[0] -a c"
  #   -m "xcc_info: 256,1,1,3,if(!c,x,128) 256,1,1,3,if(!c,240,if(c==1,x,128)) 256,1,1,3,if(!c,240,if(c==1,128,x)) -lab82rgb[-3--1] -permute[-3--1] xcyz "\
  #      "-a[0,-3] y -a[1,-2] y -a[2,-1] y"
  # -elif {$1'=='lch}
  #   _color0="180,180,180" _color1="220,180,220" _color2="255,220,220" _color3="220,220,220" _title0=Lightness _title1=Chroma _title2=Hue _title3=Alpha
  #   -m "xcc_goto: -s c,-3 -srgb2rgb[0] -apply_parallel_overlap -rgb2lch8[0],0 -a c" -m "xcc_backto: -s c,-3 -apply_parallel_overlap -lch82rgb[0],0 -rgb2srgb[0] -a c"
  #   -m "xcc_info: 256,1,1,3,if(!c,x,0) 256,1,1,3,if(!c,255,if(c==1,x,128)) 256,1,1,3,if(!c,220,if(c==1,128,x)) -lch82rgb[-3--1] -permute[-3--1] xcyz "\
  #      "-a[0,-3] y -a[1,-2] y -a[2,-1] y"
  -elif {$1'=='lab}
    _color0="180,180,180" _color1="220,180,220" _color2="220,220,180" _color3="220,220,220" _title0=Lightness _title1=Chroma-A _title2=Chroma-B _title3=Alpha
    -m "xcc_goto: -s c,-3 -srgb2rgb[0] -rgb2lab8 -a c" -m "xcc_backto: -s c,-3 -lab82rgb -rgb2srgb[0] -a c"
    -m "xcc_info: 256,1,1,3,if(!c,x,128) 256,1,1,3,if(!c,240,if(c==1,x,128)) 256,1,1,3,if(!c,240,if(c==1,128,x)) -lab82rgb[-3--1] -permute[-3--1] xcyz "\
       "-a[0,-3] y -a[1,-2] y -a[2,-1] y"
  -elif {$1'=='lch}
    _color0="180,180,180" _color1="220,180,220" _color2="255,220,220" _color3="220,220,220" _title0=Lightness _title1=Chroma _title2=Hue _title3=Alpha
    -m "xcc_goto: -s c,-3 -srgb2rgb[0] -rgb2lch8[0] -a c" -m "xcc_backto: -s c,-3 -lch82rgb[0] -rgb2srgb[0] -a c"
    -m "xcc_info: 256,1,1,3,if(!c,x,0) 256,1,1,3,if(!c,255,if(c==1,x,128)) 256,1,1,3,if(!c,220,if(c==1,128,x)) -lch82rgb[-3--1] -permute[-3--1] xcyz "\
       "-a[0,-3] y -a[1,-2] y -a[2,-1] y"
  -elif {$1'=='ycbcr}
    _color0="180,180,180" _color1="220,220,255" _color2="255,220,220" _color3="220,220,220" _title0=Luma _title1=Blue\ chroma _title2=Red\ chroma _title3=Alpha
    -m "xcc_goto: -s c,-3 -rgb2ycbcr[0] -a c" -m "xcc_backto: -s c,-3 -ycbcr2rgb[0] -a c"
    -m "xcc_info: 256,1,1,3,if(!c,x,128) 256,1,1,3,if(!c,128,if(c==1,x,128)) 256,1,1,3,if(!c,128,if(c==1,128,x)) -ycbcr2rgb[-3--1] -permute[-3--1] xcyz "\
       "-a[0,-3] y -a[1,-2] y -a[2,-1] y"
  -else -error[0--3] "Command 'x_color_curves': Unknown specified color space '$1'."
  -endif

#@gmic x_colorize : _is_lineart={ 0 | 1 },_max_resolution={ 0 | >=128 },_multichannels_output={ 0 | 1 },_[palette1],_[palette2]
#@gmic : Colorized selected B&W images, using an interactive window.
#@gmic : When >0, argument 'max_resolution' defines the maximal image resolution used in the interactive window.
#@gmic : Default values: 'is_lineart=1', 'max_resolution=1024' and 'multichannels_output=0'.
x_colorize : -skip ${1=0},${3=0},${4=0},${5=0} -check "${2=1024}==0 || $2>=128"
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -v - s0="image" s1="lineart" s2="multichannel" s3="merged" -v +
  -e[^-1] "Colorize selected B&W "${s{!$1}}"$? interactively, with maximum resolution $2 and "${s{2+!$3}}" output."
  -e[] "\n
--------------------------------------------------------------------------------------\n
---- Left mouse button creates a new colored control point (or moves an existing one).\n
---- Right mouse button over a control point deletes it.\n
---- Right mouse button anywhere else picks a color from the image.\n
---- Mouse wheel, or keys 'CTRL+arrows UP/DOWN' zoom view in/out.\n
---- 'CTRL+mouse wheel', 'SHIFT+mouse wheel' or arrow keys move image in zoomed view.\n
---- Key 'SPACE' updates the extrapolated color field.\n
---- Key 'TAB' toggles between markers view modes.\n
---- Key 'BACKSPACE' deletes the last control point added.\n
---- Key 'PAGE UP' increases image contrast.\n
---- Key 'PAGE DOWN' decreases image contrast.\n
---- Key 'R' toggles color replace mode.\n
---- Keys 'CTRL+D' increase window size.\n
---- Keys 'CTRL+C' decrease window size.\n
---- Keys 'CTRL+R' reset window size.\n
---- Keys 'ESC', 'Q' or 'ENTER' exit the interactive window.\n
--------------------------------------------------------------------------------------"
  -v -
  is_palette1=@{"-is_image_arg[] $4"}
  -if $is_palette1 -pass$4 1 ({'@{-1,b}'}) -discard[-1] {'~'} palette_title1=@{-1,t} -rm[-1] -endif
  is_palette2=@{"-is_image_arg[] $5"}
  -if $is_palette2 -pass$5 1 ({'@{-1,b}'}) -discard[-1] {'~'} palette_title2=@{-1,t} -rm[-1] -endif
  __color=255,255,255

  -if {$is_palette1" && "$is_palette2} # With two additional palettes.
    -repeat {@#-2} -l[$>,-2,-1]
      -parallel "-_x_colorize[0] ${1--1}","-w[] 400,320,0,Palette -x_select_color[] __color,255,255,255",\
                "-w[] 400,400,0,\""$palette_title1"\" -x_select_palette[1] __color",\
                "-w[] 400,400,0,\""$palette_title2"\" -x_select_palette[2] __color"
    -endl -done
    -rm[-2,-1]
  -elif $is_palette1  # With one additional palette.
    -repeat {@#-1} -l[$>,-1]
       -parallel "-_x_colorize[0] ${1--1}","-w[] 400,320,0,Palette -x_select_color[] __color,255,255,255",\
                "-w[] 400,400,0,\""$palette_title1"\" -x_select_palette[1] __color"
    -endl -done
    -rm[-1]
  -else # Without additional palettes.
    -repeat @# -l[$>]
      -parallel "-_x_colorize[0] ${1--1}","-w[] 400,320,0,Palette -x_select_color[] __color,255,255,255"
    -endl -done
  -endif
  -v +

_x_colorize :

  # Init variables and images.
  name=@{-1,n} title=@{-1,b} -if {narg(@{-1,x})} title=$title.@{-1,x} -endif
  w={w} h={h}

  -if $1 # Line-art.
    -if {s==4} -sh[-1] 3,3 -if {abs(im-iM)>64} --*[-1] -1 -rm[-2] -+[-1] 255 -else -rm[-1] -sh[-1] 0,0 -endif
    -else -sh[-1] 0,0
    -endif
    -n 0,255
  -else # Regular image.
    -if {s==1} -sh[-1] 0,0
    -else --luminance[-1]
    -endif
  -endif

  -nm[-1] img

  fdim=@{-fitscreen[]\ $w,$h} ww={arg(1,$fdim)} wh={arg(2,$fdim)} x0=0 y0=0 x1={w-1} y1={h-1}
  selection=-1 view_markers=2 contrast=9 xpan=-1 ypan=-1 replace_color= current_replace_color=

  -if {narg($_gimp_control_points)>=6}  ($_gimp_control_points) -r[-1] {w/6},6,1,1,-1 # Import list of control points from GIMP interface.
  -else 0 # Empty list of control points.
  -endif
  -nm[-1] points

  # Compute potential map.
  -if {$2>0} -if {$w>$h} --r2dx[img] {min($2,$w)},2 -else --r2dy[img] {min($2,$h)},2 -endif -else [img] -endif
  -__x_colorize[-1] $1
  pw=@{potential,w} ph=@{potential,h}

  # Start event loop.
  -do

    # Handle user events for zoom/navigation/resizing.
    -if {narg($replace_color)" && "@{!,x}<0" && "@{!,y}<0} -wait 200 -else -wait -endif
    x=@{!,x} y=@{!,y} b=@{!,b} o=@{!,-o}
    is_ctrl={@{!,CTRLLEFT}" || "@{!,CTRLRIGHT}}
    is_shift={@{!,SHIFTLEFT}" || "@{!,SHIFTRIGHT}}
    is_mouseout={$x<0" || "$y<0}
    x={$x0+$x*($x1-$x0+1)/$ww} y={$y0+$y*($y1-$y0+1)/$wh}
    oww=$ww owh=$wh ox0=$x0 oy0=$y0 ox1=$x1 oy1=$y1

    -if @{!,r} # When window resized.
      nww=@{!,d} nwh=@{!,e} m={min($nww,$nwh)}
      cx={($x0+$x1)/2} cy={($y0+$y1)/2} dx={$nww*($x1-$x0+1)/$ww} dy={$nwh*($y1-$y0+1)/$wh}
      x0={$cx-$dx/2} x1={$cx+$dx/2}
      y0={$cy-$dy/2} y1={$cy+$dy/2}
      ww=$nww wh=$nwh
    -elif {$is_ctrl" && "@{!,-D}} # Increase window size.
      nww={min(@{!,u},$ww*1.25)} nwh={min(@{!,v},$wh*1.25)} m={min($nww,$nwh)}
      -if {$m==$nww} ww=$m wh={$h*$m/$w} -else ww={$w*$m/$h} wh=$m -endif
    -elif {$is_ctrl" && "@{!,-C}} # Decrease window size.
      nww={$ww/1.25} nwh={$wh/1.25}
      -if {min($nww,$nwh)>=64} ww=$nww wh=$nwh -endif
    -elif {$is_ctrl" && "@{!,R}} # Reset window size.
      fdim=@{-fitscreen[]\ $w,$h} ww={arg(1,$fdim)} wh={arg(2,$fdim)}
      x0=0 y0=0 x1={$w-1} y1={$h-1}
    -elif {($is_shift" && "$o<0)" || "@{!,ARROWLEFT}} # Go left.
      dx={($x1-$x0)/6} x0={$x0-$dx} x1={$x1-$dx}
    -elif {($is_shift" && "$o>0)" || "@{!,ARROWRIGHT}} # Go right.
      dx={($x1-$x0)/6} x0={$x0+$dx} x1={$x1+$dx}
    -elif {($is_ctrl" && "$o>0)" || "(@{!,ARROWUP}" && "!$is_ctrl)} # Go up.
      dy={($y1-$y0)/6} y0={$y0-$dy} y1={$y1-$dy}
    -elif {($is_ctrl" && "$o<0)" || "(@{!,ARROWDOWN}" && "!$is_ctrl)} # Go down.
      dy={($y1-$y0)/6} y0={$y0+$dy} y1={$y1+$dy}
    -elif {$o>0" || "($is_ctrl" && "@{!,ARROWUP})} # Zoom in.
      -if {$x1-$x0>16" && "$y1-$y0>16}
        cx={if($x>=0" && "!@{!,ARROWUP},$x,($x0+$x1)/2)}
        cy={if($y>=0" && "!@{!,ARROWUP},$y,($y0+$y1)/2)}
        x0={$cx+($x0-$cx)*0.75} y0={$cy+($y0-$cy)*0.75}
        x1={$cx+($x1-$cx)*0.75} y1={$cy+($y1-$cy)*0.75}
      -endif
    -elif {$o<0" || "($is_ctrl" && "@{!,ARROWDOWN})} # Zoom out.
      zfactor={max(($x1-$x0+1)/$w,($y1-$y0+1)/$h)}
      -if {$zfactor<1.3}
        cx={if($x>=0" && "!@{!,ARROWDOWN},$x,($x0+$x1)/2)}
        cy={if($y>=0" && "!@{!,ARROWDOWN},$y,($y0+$y1)/2)}
        x0={$cx+($x0-$cx)/0.75} y0={$cy+($y0-$cy)/0.75}
        x1={$cx+($x1-$cx)/0.75} y1={$cy+($y1-$cy)/0.75}
        dx={$zfactor^2*($w-$x0-$x1)/2} dy={$zfactor^2*($h-$y0-$y1)/2}
        x0={$x0+$dx} x1={$x1+$dx} y0={$y0+$dy} y1={$y1+$dy}
      -else
        dx={($w-$x0-$x1)/2} dy={($h-$y0-$y1)/2}
        x0={$x0+$dx} x1={$x1+$dx} y0={$y0+$dy} y1={$y1+$dy}
      -endif
    -elif {$b&4" && "!$is_mouseout} # Pan.
      -if {$panx<0" && "$pany<0} panx=$x pany=$y
      -else dx={round($panx-$x)} dy={round($pany-$y)} x0={$x0+$dx} y0={$y0+$dy} x1={$x1+$dx} y1={$y1+$dy}
      -endif
    -else panx=-1 pany=-1
    -endif
    -if {$ww!=$oww" || "$wh!=$owh" || "$ox0!=$x0" || "$oy0!=$y0" || "$ox1!=$x1" || "$oy1!=$y1} -rm[baseview] -endif

    # Handle events related to control points management.
    N=@{points,w}
    -if {narg($baseview)" && "$b&3" && "$x>=0" && "$y>=0" && "$x<$w" && "$y<$h}
      -if {$selection==-1" && "$N} # Check for selection of an existing point.
        ($x;$y) -r[-1] $N,2 --[-1] [points] -*[-1] {max($ww,$wh)/max($x1-$x0,$y1-$y0)} -sqr[-1] -s[-1] y -+[-2,-1]
        dmin={im} selection={if($dmin>25,-1,xm)} -rm[-1]
      -endif
      -if {narg($replace_color)} # Go back from 'Replace color' mode.
        replace_color= -wait -1
      -elif {$selection>=0}
        -if {$b&1" && "$view_markers} # Move existing point.
          --columns[points] $selection ox={i[0]} oy={i[1]} -=[-1] $x -=[-1] $y,0,1 -j[points] [-1],$selection -rm[-1]
          -rm[view]
        -elif {$b&2" && "$view_markers} # Remove existing point.
          -if {$N>1} --z[points] {$selection+1},100% -j[points] [-1],$selection -rm[-1] -r[points] {$N-1},100%,1,1,0
          -else -rm[points] -i[points] 0 -endif
          -wait -1 -rm[view]
        -endif
      -elif {$b&1} # Add new point
       ($x;$y;0) ($__color) -y[-1] y -+[-1] 1 -a[-2,-1] y -a[points,-1] x selection=$N -if {!$view_markers} view_markers=2 -endif -rm[view]
      -elif {$b&2} # Select color from image.
        __color=@{-at[colors]\ {$x*$pw/$w},{$y*$ph/$h}}
      -endif
    -else selection=-1
      -if {@{!,-SPACE}" && "narg($colors)} replace_color= -rm[colors] # Update color map.
      -elif @{!,-TAB} view_markers={($view_markers-1)%3} -rm[view] -wait -1 # Toggle markers.
      -elif {!$is_ctrl" && "@{!,-R}}  # Switch color replace mode.
        -if {narg($replace_color)} replace_color= -else replace_color=$__color -endif
        -rm[baseview] -wait -1
      -elif @{!,PAGEDOWN} contrast={max(0,$contrast-1)} -rm[view] -wait -1 # Decrease contrast.
      -elif @{!,PAGEUP} contrast={min(9,$contrast+1)} -rm[view] -wait -1 # Increase contrast.
      -elif {@{!,BACKSPACE}" && "$N} -if {$N>1} -z[points] 0,{$N-2} -else i=$points -rm[points] -i[$i] 0 -nm[$i] points -endif -rm[view] -wait -1 # Remove last point.
      -endif
    -endif

    # Manage zoomed view bounds.
    w2={round(($x1-$x0)/2)} h2={round(($y1-$y0)/2)}
    -if {$x0<-$w2} x1={$x1-$x0-$w2} x0=-$w2 -endif
    -if {$y0<-$h2} y1={$y1-$y0-$h2} y0=-$h2 -endif
    -if {$x1>=$w+$w2} x0={$w-1+$w2-$x1+$x0} x1={$w-1+$w2} -endif
    -if {$y1>=$h+$h2} y0={$h-1+$h2-$y1+$y0} y1={$h-1+$h2} -endif

    # Render color map.
    -if {!narg($colors)}
      N=@{points,w}
      -if {narg($view)} -text_outline[view] "Processing...",5,5,20,2 -w[view] -endif
      -if $N
        [points]
        -sh[-1] 0,0,0,0 -*[-1] {$pw/$w} -rm[-1]
        -sh[-1] 1,1,0,0 -*[-1] {$ph/$h} -rm[-1]
        -pointcloud[-1] -1,$pw,$ph
        --compose_channels[-1] max -!=[-1] 0 -distance[-1] 1 -*[-1] 0.02 -+[-1] 1 -pow[-1] -1 -+[-1] [potential] # Additional term that depends on marker's positions.
        -if {!$1} -dilate[-2] 3 -endif
        -watershed[-2] [-1],1 -rm[-1] --[-1] 1
      -else [potential],[potential],1,3,255
      -endif
      -nm[-1] colors
      -if {narg($baseview)} -rm[baseview] -endif
    -endif

    # Manage replace color mode.
    -if {!narg($replace_color)" && "narg($points_replaced)}
      -rm[points,colors,view] -nm[colors_replaced] colors -nm[points_replaced] points current_replace_color=
    -elif {narg($replace_color)" && "{$__color'!='$current_replace_color}}
      -if {narg($colors_replaced)} -rm[colors_replaced,points_replaced] -endif
      current_replace_color=$__color
      -if @{points,w}
        --replace_color[colors] 0,0,$replace_color,$current_replace_color
        --rows[points] 3,5 -permute[-1] xzcy --[-1] 1
        -replace_color[-1] 0,0,$replace_color,$current_replace_color
        -+[-1] 1 -permute[-1] xcyz --j[points] [-1],0,3 -rm[-2]
      -else 0 0
      -endif
      -nm[-2] colors_replaced
      -nm[-1] points_replaced
      -if {narg($baseview)} -rm[baseview] -endif
    -endif

    # Render base image.
    -if {!narg($baseview)}
      nx0={$x0*$pw/$w} ny0={$y0*$ph/$h}
      nx1={$x1*$pw/$w} ny1={$y1*$ph/$h}
      --z[img] $x0,$y0,$x1,$y1
      -r[-1] $ww,$wh,1,100%,{if($ww<w" && "$wh<h,2,1)}
      -if {narg($replace_color)" && "@{points,w}} icolors=$colors_replaced -else icolors=$colors -endif
      --z[$icolors] $nx0,$ny0,$nx1,$ny1
      -r[-1] $ww,$wh,1,100%,{if($ww<w" && "$wh<h,2,3)}
      -if $1 -*[-2] -1 -+[-2] 255 -channels[-2] -3,0 -blend[-1] [-2],alpha -rm[-2]
      -else -rgb2ycbcr[-1] -j[-1] [-2],0,0,0,0 -rm[-2] -ycbcr2rgb[-1]
      -endif
      -nm[-1] baseview
      -if {narg($view)} -rm[view] -endif
    -endif

    # Render view.
    -if {!narg($view)}
      [baseview] -r[-1] 100%,100%,1,3
      -if {$contrast<9} -/[-1] {10-$contrast} -+[-1] {128*(1-1/(10-$contrast))} -endif
      -if $view_markers
        -if {$view_markers==2} rad1=5 rad2=3 -else rad1=3 rad2=2 -endif
        -if {narg($replace_color)" && "@{points,w}} ipoints=$points_replaced -else ipoints=$points -endif
        -repeat @{$ipoints,w}
          --columns[$ipoints] $> x={(i[0]-$x0)*$ww/(1+$x1-$x0)} y={(i[1]-$y0)*$wh/(1+$y1-$y0)} col={i[3]-1},{i[4]-1},{i[5]-1} -rm[-1]
          -circle[-1] $x,$y,$rad1,1,0 -circle[-1] $x,$y,$rad2,1,$col
        -done
      -endif

      -if {narg($replace_color)}
        -text_outline[-1] "Replace      by",5,5,20,2
        -rectangle[-1] 80,8,111,25,1,0 -rectangle[-1] 82,10,109,23,1,$replace_color
        -rectangle[-1] 150,8,181,25,1,0 -rectangle[-1] 152,10,179,23,1,$current_replace_color
      -endif

      -nm[-1] view
      -w[view] $ww,$wh,0,$title
    -endif

  -while {@!" && "!@{!,ESC}" && "!@{!,Q}" && "!@{!,ENTER}}

  # Recompute colors at full resolution.
  -if {narg($view)} -text_outline[view] "Processing fullres...",5,5,20,2 -w[view] -endif
  -k[0,img,points]
  N=@{points,w} status=
  -if $N
    status=@points
    [img] -__x_colorize[-1] $1
    -pointcloud[points] -1,$w,$h
    --compose_channels[points] max -!=[-1] 0 -distance[-1] 1 -*[-1] 0.02 -+[-1] 1 -pow[-1] -1 -+[potential,-1]
    -if {!$1} zfact={@{img,max(w,h)}/@{potential,max(w,h)}} -dilate[points] {int(3*$zfact)} -endif
    -watershed[points] [potential],1 --[points] 1 -nm[points] colors
  -else [img],[img],1,3,255 -nm[-1] colors
  -endif

  -if $3 # Multichannels output.
    -k[0,colors] -a c
  -else # Merge for single layer output.
    -k[0,img,colors]
    -if $1 --*[img] -1 -+[-1] 255 -channels[-1] -3,0 -blend[colors,-1] alpha -rm[0,img]
    -else -rgb2ycbcr[colors] -j[colors] [img],0,0,0,0 -rm[0,img] -ycbcr2rgb[colors]
    -endif
  -endif
  -a c -nm $name

  __color=-1   # Force color selectors to close.
  -u $status   # Return control points.
  -w 0

# Compute potential function.
__x_colorize :
  -if $1 # Potential for lineart.
    -b[-1] 0.05% -n[-1] 0,1 --b[-1] 0.5% -pow[-2] 10 -n[-2] 0,1 -n[-1] 0.3,1 -min[-2,-1]
  -else  # Potential for generic grayscale image.
    -gradient_norm[-1] -n[-1] 0,255 -normalize_local[-1] 3,3 -*[-1] -1 -n[-1] 0,255
    -b[-1] 0.05% -n[-1] 0,1 -sqr[-1] --b[-1] 0.5% -n[-2,-1] 0,1 -min[-2,-1]
  -endif
  -nm[-1] potential

#@gmic x_fire
#@gmic : Launch the fire effect demo.
x_fire : -skip "${1=G\47MIC}"
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ Fire effect ----------------------\n
----\n
---- Keys 'CTRL+D' to double window size.\n
---- Keys 'CTRL+C' to reset window size.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------"
  -v -

  # Init image data.
  -i[0] 100,32 -w[0] 450,200,0,"[G\47MIC] Fire effect"
  -i[1] (0,255,255,255,255^0,0,255,255,255^0,0,0,128,255) -r[1] 256,1,1,3,3
  -i[2] (0,0,0;0,0,0;1,1,1;0,1,0) -*[2] 0.21
  -text3d "$1",33,3,1
  -mv[-1] 3 -c3d[3] -n3d[3] -*3d[3] 320 -col3d[3] 255,205,130 -db3d 0 -f3d 300
  100,100 -rand[-1] 0,255 -ellipse[-1] 50%,50%,5,5,0,1,300 -b[-1] 10
  -sharpen[-1] 1000 -shrink_xy[-1] 1 -n[-1] 0,255 -to_rgb[-1] -light3d [-1] -rm[-1]

  # Start animation loop.
  angle=0
  -do
    -correlate[0] [2]                                                # Apply fire effect.
    @{0,w},1 -rand[-1] 128,256 -j[0] [-1],0,{@{0,h}-1} -rm[-1]       # Add new random values at the bottom line.
    --r[0] 400,200,1,1,3 -map[-1] [1]                                # Map fire palette
    --r3d[3] 0,1,0,$angle -j3d[-2] [-1],50%,50%,0,1,5,0,0            # Draw 3d object.
    -*3d[-1] 0.25,0.16,1 -j3d[0] [-1],50%,50%,0,1,3,0,0
    -rm[-1]
    angle={$angle+3}                                                 # Update 3d angle.
    -w[-1]
    -if {@{!,CTRLLEFT}&&@{!,D}} -w[] {2*w},{2*h} -elif {@{!,CTRLLEFT}&&@{!,C}} -w[] {w},{h} -endif
    -rm[-1] -wait 40
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}

  # Exit properly.
  -rm[0-3] -w 0
  -v +

#@gmic x_fireworks
#@gmic : Launch the fireworks demo.
x_fireworks :
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ Fireworks -----------------------\n
----\n
---- Keys 'CTRL+D' to double window size.\n
---- Keys 'CTRL+C' to reset window size.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------"
  -v - -l[]
  time=0
  (0;64^0;32^128;0) -r 256,128,1,3,3            # [-2] = Background (color gradient).
  [-1]                                          # [-1] = Rendered image.
  -w[-1] {1.5*w},{1.5*h},0,"[G\47MIC] Fireworks"  # Display window.
  -do                                           # Start animation loop.
    time={$time-1}
    -if {@#==2\ ||\ $time<0} # Insert new rocket.
      -i[0] ({?(w)},\        # X-position
             {h},\           # Y-position
             {?(-3,3)},\     # X-velocity
             {?(2)-5},\      # Y-velocity
             {30+?(20)},\    # Time of explosion
             1.5,\           # Radius
             255,255,255)    # Color
      time={?(40)}           # Elapsed time until next rocket.
    -endif
    -*[-1] 0.99               # Create fading effect with previous frames.
    -j[-1] [-2],0,0,0,0,0.2   # Add background.
    i=0
    -repeat {@#-2}
      to_be_removed=0
      radius={if(@{$i,4}>0,@{$i,5}/3,@{$i,5}*(1+2*(@{$i,4}+2)/120))}
      -ellipse[-1] @{$i,0},@{$i,1},@{$i,5},{max(0.5,$radius)},{atan2(@{$i,3},@{$i,2})*180/pi},0.6,@{$i,6-8}  # Draw rocket.
      (@{$i,2},@{$i,3},0,0.09,-1,0,0,0,0) -+[$i,-1] # Compute new position of the rocket.
      -if {@{$i,0}<0\ ||\ @{$i,0}>=w\ ||\ @{$i,1}>=h\ ||\ $radius<0} to_be_removed=1 -endif # Discard if rocket disappear.
      -if {@{$i,4}<0\ &&\ @{$i,4}>=-1} # In case of explosion -> Split current rocket into several colorful rockets.
        color={min(255,80+?(200))},{min(255,80+?(200))},{min(255,80+?(200))}
        radius={?(10)}
        N={5+?(10)}
        -repeat $N
          angle={$>*2*pi/$N}
          -i[-3] (@{$i,0,1},{2*cos($angle)+@{$i,2}/1.5},{2*sin($angle)+@{$i,3}/1.5},-2,$radius,$color)
        -done
        to_be_removed=1
      -endif
      -if $to_be_removed -rm[$i] -else i={$i+1} -endif  # If processed rocket has to be removed.
    -done
    -w[-1] -wait 20  # Display rendered frame.
    -if {@{!,CTRLLEFT}&&@{!,D}} -w[] {3*w},{3*h} -elif {@{!,CTRLLEFT}&&@{!,C}} -w[] {1.5*w},{1.5*h} -endif
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -rm -w 0 -endl -v +

#@gmic x_fisheye
#@gmic : Launch the fish-eye effect demo.
x_fisheye :
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ Fish-eye effect ------------------\n
----\n
---- Mouse pointer moves fish-eye center.\n
---- Mouse buttons set fish-eye size.\n
---- Keys 'CTRL+D' to double window size.\n
---- Keys 'CTRL+C' to reset window size.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------"
  -v -
  -if {@#>0} -a x -n 0,255 -r2dy 220 -else
  120,90,1,3 -rand[-1] 0,255 -plasma[-1] 0.3,3 -n 0,255
  -t "  G\47MIC\nFISH-EYE\n EFFECT",15,13,23,1,255 -scale2x -b 5 -sharpen 1000
  -f i+150-4*abs(y-h/2) -c[-1] 0,255 -frame_fuzzy[-1] 15,10,15,1.5,0 -to_rgb[-1]
  -endif
  -torus3d 20,6 -col3d[-1] {?(30,255)},{?(30,255)},{?(30,255)} --r3d[-1] 1,0,0,90
  -col3d[-1] {?(30,255)},{?(30,255)},{?(30,255)} -+3d[-1] 15 -+3d[-2,-1] -db3d 0 -c3d[-1]
  R=30
  -w[-2] {1.5*@{-2,w}},{1.5*@{-2,h}},0,"[G\47MIC] Fish-eye effect"
  -do
    -wait 40
    -if {@{!,b}==1} R={min(80,$R+8)} -endif
    -if {@{!,b}==2} R={max(3,$R-8)} -endif
    --j3d[-2] [-1],{50+30*cos(@|*2.5)}%,{50+30*sin(@|*1.6)}%,{50+330*sin(@|*2.6)},0.7,3,0,0 -r3d[-2] 1,0.2,0.6,3
    -if {@{!,x}>=0}
    -fisheye[-1] {@{!,x}*100/@{!,w}},{@{!,y}*100/@{!,h}},$R
    -endif
    -w[-1]
    -if {@{!,CTRLLEFT}&&@{!,D}} -w[] {3*w},{3*h} -elif {@{!,CTRLLEFT}&&@{!,C}} -w[] {1.5*w},{1.5*h} -endif
    -rm[-1]
    -if {@!==0" || "@{!,ESC}" || "@{!,Q}} -rm[-2,-1] -w 0 -v + -return -endif
  -while 1

#@gmic x_fourier
#@gmic : Launch the fourier filtering demo.
x_fourier :
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ Fourier-filtering ----------------------------------------\n
----\n
---- Mouse buttons on the right image to set min/max frequencies.\n
---- Keys 'CTRL+D' to increase window size.\n
---- Keys 'CTRL+C' to decrease window size.\n
---- Keys 'CTRL+R' to reset window size.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------------------------------"
  -v -
  -if {!@#} -testimage2d 256 -endif

  -repeat @# -l[$>]

    # Init variables.
    need_update=1  # need_update (boolean)
    freqmin=0      # min freq. (in %)
    freqmax=100    # max freq. (in %)

    -if {w>3*@{!,u}/5} -r2dx[-1] {3*@{!,u}/10} -endif  # Reduce image size if necessary.
    -if {h>3*@{!,v}/5} -r2dy[-1] {3*@{!,v}/5} -endif

    # Compute fourier transform.
    --fft[-1] -nm[-2] real -nm[-1] imag

    # Generate log-magnitude image.
    --sqr[real,imag] -+[-2,-1] -sqrt[-1] -+[-1] 1 -log[-1]
    -n[-1] 0,255 -shift[-1] 50%,50%,0,0,2 -to_colormode[-1] @{-2,s}
    -nm[-1] logmag

    -w[0,-1] -1,-1,0,"[G\47MIC] Fourier filtering"

    -if {!narg($first_time)}
      -parallel 0,"--l[-1] -r2dy 128 -frame 1,1,0 \
        -alert \"[G\47MIC Fourier filtering]\",\
           \"The G\47MIC Fourier filtering demo illustrates the effect\n\
           of bandpass frequency filtering on an image. Use your mouse\n\
           buttons to select low and high bounds for the frequencies\n\
           displayed on the Fourier representation of the image\n\
           (right image).\",\
           \"OK\" \
        -rm -endl"
      first_time=0
    -endif

    # Enter user event-loop.
    -do

      -if $need_update # If image must be updated.

        # Generated filtering mask.
        -i[mask] 100%,100%
        r={sqrt(w^2+h^2)*$freqmax/200} -ellipse[mask] 50%,50%,$r,$r,0,1,1
        r={max(0,sqrt(w^2+h^2)*$freqmin/200-1)} -if $r -ellipse[mask] 50%,50%,$r,$r,0,1,0 -endif

        # Compute filtered log-magnitude.
        --*[logmag] [mask] -+[-1] [mask] -/[-1] 2 -n[-1] 0,255

        # Compute filtered fourier representation.
        -shift[mask] -50%,-50%,0,0,2
        --*[real,imag] [mask]
        -rm[-4]

        # Compute filtered image by inverse fourier.
        -ifft[-2,-1] -rm[-1] -n[-1] 0,255

        # Display filtered image.
        -rv[-2,-1]
        -if @! -r[-2,-1] {@{!,w}/2},@{!,h} -endif
        -t[-1] "Freq. Min/Max = "{int($freqmin)}"% / "{int($freqmax)}"%",5,5,13,1,255
        -w[-2,-1] -rm[-2,-1]
        need_update=0

      -endif

      -wait

      -if {@{!,b}" && "@{!,x}>=@{!,w}/2}  # If mouse button pressed on the right pane.
        r={200*sqrt((@{!,x}-3*@{!,w}/4)^2+(@{!,y}-@{!,h}/2)^2)/\ # Compute selected radius (in %).
           sqrt((@{!,w}/2)^2+@{!,h}^2)}
        -if {@{!,b}&1} freqmax=$r        # Update max freq. if left button.
        -else freqmin={max(0,$r-3)}      # Update min freq. if other button.
        -endif
        -if {$freqmin>=$freqmax} freqmin=$freqmax -endif   # Check that the min/max freq. are ordered.
        need_update=1                                      # Tell that the image must be updated.
      -endif

      -if @{!,r} need_update=1 -endif
      -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,D}} -w[] {@{!,w}*1.5},{@{!,h}*1.5} need_update=1 -endif # Increase window size.
      -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,C}} -w[] {@{!,w}/1.5},{@{!,h}/1.5} need_update=1 -endif # Decrease window size.
      -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,R}} -w[] {2*@{0,w}},@{0,h} need_update=1 -endif         # Reset window size.

    -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
    -rm[-3--1]  # Clean images.
  -endl -done -w 0 -rm -v +

#@gmic x_histogram
#@gmic : Launch the histogram demo.
x_histogram :
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ Histogram demo -------------------------------\n
----\n
---- Mouse to set parameters.\n
---- Right button or key 'SPACE' to reset.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------------------"
  -v -
  -if {!@#} -testimage2d 300,300 -else -k[0] -to_rgb -r2dy 300,2 -if {w>800} -r 800,100%,1,3,2 -endif -n 0,255 -endif

  # Prepare image layout.
  --frame[-1] 1,1,0
  300,{h},1,3,220
  -t[-1] "Gamma :",5,0,16,1,0
  -t[-1] "Contrast :",5,50,16,1,0
  -t[-1] "Brightness :",5,100,16,1,0
  -t[-1] "Smoothness :",5,150,16,1,0
  -t[-1] "Sharpness :",5,200,16,1,0
  -t[-1] "Clusters :",5,250,16,1,0
  -a[-2,-1] x
  {w},200,1,3,255
  -grid[-1] 10%,10%,0,0,0.3,0xCCCCCCCC,0
  -rectangle[-1] 0,0,100%,100%,1,0xFFFFFFFF,0
  -axes[-1] 0,255,1,0,13,1,0
  -frame[-2,-1] 5,5,220
  -a[-2,-1] y

  # Initialize variables.
  clusters=64 sharpness=0 smoothness=0 contrast=1 brightness=0 gamma=1

  # Start event loop.
  -do

    # Render corrected image and insert it in canvas.
    [0]
    ia={ia}
    -if $gamma -/[-1] 255 -^[-1] {1/$gamma} -*[-1] 255 -endif
    --[-1] $ia -*[-1] $contrast -+[-1] $brightness -+[-1] $ia
    -b[-1] $smoothness
    -sharpen[-1] $sharpness
    -c[-1] 0,255
    --j[-2] [-1],6,6

    # Render parameter sliders.
    sx={@{0,w}+12}
    -_x_histogram[-1] {$gamma*100/4} -j[-2] [-1],$sx,25 -rm[-1]
    -_x_histogram[-1] {$contrast*100/4} -j[-2] [-1],$sx,75 -rm[-1]
    -_x_histogram[-1] {($brightness+128)*100/256} -j[-2] [-1],$sx,125 -rm[-1]
    -_x_histogram[-1] {$smoothness*100/10} -j[-2] [-1],$sx,175 -rm[-1]
    -_x_histogram[-1] {$sharpness*100/2000} -j[-2] [-1],$sx,225 -rm[-1]
    -_x_histogram[-1] {$clusters*100/256} -j[-2] [-1],$sx,275 -rm[-1]

    # Render corresponding histogram.
    --s[-2] c -histogram[-3--1] $clusters,0,255 -/[-3--1] {3*@{0,wh}/$clusters} -rm[-5]
    --z[-4] 5,317,{@{-4,w}-5},{@{-4,h}-6}
    -graph[-1] [-4],3,0,1,0,0.2,255,0,0
    -graph[-1] [-3],3,0,1,0,0.2,0,255,0
    -graph[-1] [-2],3,0,1,0,0.2,0,0,255
    -rm[-4--2]
    -j[-2] [-1],5,317 -rm[-1]

    # Display rendering.
    -w[-1] {w},{h},0,"[G\47MIC] Histogram demo" -rm[-1]
    -wait

    # Manage user interactions.
    -if {@{!,b}&1\ &&\ @{!,x}>=@{0,w}-10}
      -if {@{!,y}>=25\ &&\ @{!,y}<=42}
        gamma={max(0,min(4,(@{!,x}-$sx)*4/280))}
      -elif {@{!,y}>=75\ &&\ @{!,y}<=92}
        contrast={max(0,min(4,(@{!,x}-$sx)*4/280))}
      -elif {@{!,y}>=125\ &&\ @{!,y}<=142}
        brightness={max(-128,min(128,(@{!,x}-$sx)*256/280-128))}
      -elif {@{!,y}>=175\ &&\ @{!,y}<=192}
        smoothness={max(0,min(10,(@{!,x}-$sx)*10/280))}
      -elif {@{!,y}>=225\ &&\ @{!,y}<=242}
        sharpness={max(0,min(2000,(@{!,x}-$sx)*2000/280))}
      -elif {@{!,y}>=275\ &&\ @{!,y}<=292}
        clusters={max(2,min(256,(@{!,x}-$sx)*256/280))}
      -endif
    -endif
    -if {@{!,b}&2\ ||\ @{!,SPACE}} clusters=64 sharpness=0 smoothness=0 contrast=1 brightness=0 gamma=1 -endif
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -w 0 -rm -v +

_x_histogram :
  val={max(0,min(100,$1))}
  280,2,1,3,255 -line[-1] 0,0,$val%,0,1,0,255,0 -line[-1] 0,1,$val%,1,1,240,255,62 -r[-1] 100%,16,1,3,3
  0 -t[-1] {round($val)}%,0,0,14,1,1 --*[-1] -255 -+[-1] 255 -r[-1] 100%,100%,1,3
  -j[-3] [-1],{(280-w)/2},{(16-h)/2},0,0,1,[-2] -rm[-2,-1]
  -r[-1] {w+2},{h+2},1,3,0,0,0.5,0.5

#@gmic x_hough
#@gmic : Launch the hough transform demo.
x_hough :
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ Hough-transform -----------------------------------------\n
----\n
---- Mouse buttons on the vote image to draw corresponding line.\n
---- Mouse buttons on the image to vote for all lines crossing.\n
---- the clicked point.\n
---- Key 'SPACE' to reset the hough window.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------------------------------"
  -v -
  -if {!@#} -testimage2d 400 -endif
  -n 0,255

  -repeat @# -l[$>]
    -r[-1] @{-fitscreen\ {w},{h}},1,100%,3  # Resize to fit screen if necessary.

    -if {!narg($first_time)}
      -parallel 0,"--l[0] -r2dy 128 -frame 1,1,0 \
        -alert \"[G\47MIC Hough Transform]\",\
           \"The G\47MIC Hough transform demo illustrates the application\n\
           of the Hough transform to detect lines in an image. Use your\n\
           mouse buttons to explore the transform image and see how\n\
           lines in images are represented by points in the transform.\",\
           \"OK\" \
        -rm -endl"
      first_time=0
    -endif

    rhomax={sqrt(w^2+h^2)/2}
    --b[-1] 1.5 -hough[-1] 512,400 -b[-1] 0.5 -+[-1] 1 -log[-1] -n[-1] 0,255
    -w[-2] -1,-1,0,"[G\47MIC] Image" -w1[-1] -1,-1,0,"[G\47MIC] Hough transform"

    -do
      -wait

      -if @{!,b} # When clicking on the image.
        x0={@{!,x}-@{!,w}/2}
        y0={@{!,y}-@{!,h}/2}
        rho0={sqrt(($x0)^2+($y0)^2)}
        theta0={atan2($y0,$x0)}
        (0,{2*pi}) ($theta0,{$theta0-2*pi})
        -r[-2,-1] @{-3,w},1,1,1,3
        -cos[-1] -*[-1] $rho0 --<[-1] 0 -abs[-2]
        -*[-1] {pi} -+[-3,-1] -%[-2] {2*pi}
        -*[-2] {0.5*@{-3,w}/pi} -*[-1] {@{-3,h}/$rhomax}
        -a[-2,-1] y
        -repeat {w} -point[-2] @{-1,($>,0)},@{-1,($>,1)},0,0.3,255 -done
        -rm[-1] -w1[-1]

      -elif {@{!1,x}>=0" && "@{!1,b}} # When clicking on the vote window.
        theta={@{!1,x}*2*pi/@{!1,w}}
        rho={@{!1,y}*$rhomax/@{!1,h}}
        x={@{-2,w}/2+$rho*cos($theta)}
        y={@{-2,h}/2+$rho*sin($theta)}
        x0={$x+1000*sin($theta)}
        y0={$y-1000*cos($theta)}
        x1={$x-1000*sin($theta)}
        y1={$y+1000*cos($theta)}
        [-2]
        -line[-1] $x0,$y0,$x1,$y1,1,0x0F0F0F0F,255
        -line[-1] {$x0+1},$y0,$x1,$y1,1,0x0F0F0F0F,255
        -line[-1] $x0,{$y0+1},$x1,$y1,1,0x0F0F0F0F,255
        -line[-1] $x0,$y0,$x1,$y1,1,0xF0F0F0F0,0
        -line[-1] {$x0+1},$y0,$x1,$y1,1,0xF0F0F0F0,0
        -line[-1] $x0,{$y0+1},$x1,$y1,1,0xF0F0F0F0,0
        -w[-1] -rm[-1]

      -elif {@{!,SPACE}" || "@{!1,SPACE}}
        -rm[-1] --b[-1] 1.5 -hough[-1] 512,400 -b[-1] 0.5 -+[-1] 1 -log[-1] -n[-1] 0,255
        -w1[-1] -1,-1,0,"Hough Transform"

      -elif @{!,r} -w[-2]
      -elif @{!1,r} -w1[-1]
      -endif

    -while {@!" && "@{!1}" && "!@{!,ESC}" && "!@{!,Q}" && "!@{!1,ESC}" && "!@{!1,Q}}
    -w 0 -w1 0
    -rm[-1] -endl
    -if {!@!" || "!@{!1}} -break -endif
  -done -rm -v +

#@gmic x_jawbreaker : 0<_width<20,0<_height<20,0<_balls<=8
#@gmic : Launch the Jawbreaker game.
x_jawbreaker : -check "${1=12}>0 && $1<20 && ${2=13}>0 && $2<20 && ${3=5}>0 && $3<=8"
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ Jawbreaker --------------------------------------------\n
----\n
---- The goal of the game is to remove the maximum number of\n
---- balls on the board, simply by clicking on them. But a\n
---- colored ball can disappear only if it is grouped with at\n
---- least one ball of the same color. The score is higher if\n
---- you destroy larger sets of connected colored balls.\n
----\n
---- Left mouse button to select/destroy balls on board.\n
---- Key 'BACKSPACE' or 'SPACE' to undo the last move.\n
---- Key 'S' to save snapshot of the current view.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
--------------------------------------------------------------"
  -v -

  # Init images and variables.
  -i[board] $1,$2 -rand[board] 1,$3 -round[board] 1
  -i[undo] [-1]
  -i[balls] 32,32,1,4 -_x_jawbreaker_ball[-1] -autocrop[-1] 0 -expand_xy[-1] 1,0 -*[-1] 1.5 -c[-1] 0,255 -r[-1] {@{board,w}*w},{@{board,h}*h},1,1,0,2 -/[-1] 255
  -i[back] {w},{h},1,3 -l[-1]
    -rand 0,255 -blur_xy 6,20 -equalize 100,0,255 -blur_xy 2,4
    -sh 0,0 -sh[-2] 1,1 -sh[-3] 2,2 -/[-3] 4 -/[-2] 8 -/[-1] 2 -rm[-3--1]
  -endl
  -i[visu] [back]
  score=0
  undoscore=0
  render_board=1
  shapescorey=0
  shapescore=0

  # Enter user-event loop.
  -do

    # Render board graphics.
    -if $render_board
     --abs[board] --[-1] 1 -*[-1] {360/$3} -->=[board] 0 -*[-1] 0.9 -r[-2,-1] [balls] [balls] -a[-3--1] c -hsv2rgb[-1]
      --compose_channels[-1] + ->[-1] 0 -dilate[-1] 3
      -j[visu] [back] -j[visu] [-2],0,0,0,0,1,[-1] -rm[-2,-1]
      -if {!$shapescorey} -w[visu] @{back,w},@{back,h},0,"[G\47MIC] Jawbreaker (score : "$score")" -endif
      render_board=0
    -endif

    # Add shape score sprite if necessary.
    -if $shapescorey
      --t[visu] "+"$shapescore,@{!,x},{@{!,y}-64+$shapescorey},32,{($shapescorey-1)/31},255
      shapescorey={max(0,$shapescorey-1)}
      -w[-1] @{back,w},@{back,h},0,"[G\47MIC] Jawbreaker (score : "$score")" -rm[-1] -wait 25
    -else -wait -endif

    # Check for the end of the game.
    --f[board] "if(i,j(-1)==i || j(1)==i || j(0,1)==i || j(0,-1)==i,0)"
    -if {!@{-1,+}} -rm[-1] -break -endif -rm[-1]

    # Manage user-events
    -if @{!,r} render_board=1                   # Will resize window to initial size, if resized.
    -elif @{!,S} -o[visu] gmic_jawbreaker.png   # Save snapshot if requested.
    -elif {@{!,BACKSPACE}" || "@{!,SPACE}}      # Manage undo move.
      -abs[undo] -j[board] [undo]
      score=$undoscore
      render_board=1

    -elif {@{!,x}">=0 && "@{!,b}}               # Manage button click.

      # Retrieve board coordinates.
      -wait -1
      x={"int("@{!,x}"*"@{board,w}"/"@{!,w}")"}
      y={"int("@{!,y}"*"@{board,h}"/"@{!,h}")"}

      # When selecting a ball -> display selection and init new shape score sprite.
      -if {@{board,($x,$y)}>0}
        -abs[board] -flood[board] $x,$y,0,0,0,1,-@{board,($x,$y)}
        -->=[board] 0 --[-1] 1
        shapescore={(@{-1,+}+1)^2} shapescorey={if($shapescore,32,0)} -rm[-1]

      # When confirming selection of a ball -> remove set of connected balls.
      -elif @{board,($x,$y)}

        --flood[board] $x,$y,0,0,0,1,-1 -==[-1] -1
        -if {@{-1,+}>1} # If selected ball is connected to at least one ball.

          # Save undo state.
          -j[undo] [board]
          undoscore=$score

          # Manage board shifts (vertical and horizontal).
          -flood[board] $x,$y,0,0,0,1,0
          -repeat @{board,w}
            --columns[board] $> -mirror[-1] y
            h=@{board,h} -l[-1] -s -,0 -a y -if @# -r 1,$h,1,1,0 -mirror y -else -i 1,$h -endif -endl
            -j[board] [-1],$> -rm[-1]
          -done
          -rows[board] -1,100% -f[board] "if(y==0,if(i(x,h-1),x,w),i)" -sort[board] +,x -rows[board] 1,100%

          # Update score.
          score={$score+int((@{-1,+}-1)^2)}

        -endif
        -rm[-1] # Remove selection mask.

      -else -abs[board]  # Remove previous selection if clicked outside balls.
      -endif

      render_board=1
    -endif

  -while {@!" && "!@{!,Q}" && "!@{!,ESC}}

  # Game over.
  -if {@!" && "!@{!,ESC}}
    -w[] @{visu,w},@{visu,h},0,"[G\47MIC] Jawbreaker (final score : "$score")"
    -i[gameover] 260,85 -t[-1] "Game Over!",3,0,53,1,1 -t[-1] "Score : "$score,23,53,32,1,1
    --dilate[-1] 5 -nm[-1] "mgameover" -*[-2] 255 -r[-2] 100%,100%,1,3
    -repeat 25
      --r[gameover,mgameover] {400-12*($>+1)}%,{400-12*($>+1)}%
      --j[visu] [-2],{(@{visu,w}-w)/2},{(@{visu,h}-h)/2},0,0,{$>/25},[-1]
      -w[-1] -rm[-3--1] -wait 25
    -done
    -do
      -wait -if @{!,r} -w[] @{!,w},@{!,h} -wait -1 -endif
      -while {@!" && "!@{!,Q}" && "!@{!,ESC}" && "!@{!,b}}
    -rm[gameover,mgameover]
  -endif

  # End properly.
  -rm[board,undo,balls,back,visu]
  -w 0 -v +

_x_jawbreaker_ball :
  mwh={min(w,h)}
  -sh 3,3 -f[-1] 0 -rm[-1]
  -ellipse {0.5*$mwh},{0.5*$mwh},{0.5*$mwh-4},{0.5*$mwh-4},0,1,240,240,240,1
  -sh 0,2 -*[-1] '($mwh+y-x)/(2*w)' -rm[-1]
  -ellipse {$mwh*0.7},{$mwh*0.3},{min(30,$mwh*$mwh/512)},{min(30,$mwh*$mwh/512)},0,{min($mwh/64,1)},255,255,255,1
  -sh 0,2 -b[-1] {0.02*$mwh} -rm[-1]
  -sh 3,3 -*[-2] [-1] -dilate[-1] 3 -rm[-1]
  -sh 0,2 -+[-1] 'if(i&&(!j(-1)||!j(1)||!j(0,-1)||!j(0,1)),240/6,0)' -rm[-1]

#@gmic x_life
#@gmic : Launch the game of life.
x_life :
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ The game of life --------------------------------------\n
----\n
---- The goal is to create the biggest possible biological\n
---- system. You start with a stock of cells which you can\n
---- spread over the board. For each new cells created\n
---- simultaneously and spontaneously by your system, you\n
---- gain more new cells to scatter.\n
----\n
---- Left mouse button to scatter cells in stock.\n
---- Right mouse button to reset game.\n
---- Key 'S' to save snapshot of the current view.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
--------------------------------------------------------------"
  -v -
  -i[0] 90,90,1,1,0                                             # Image[0] = game state.
  -i[1] [0] -f[1] 0                                             # Image[1] = generation counter.
  -i[2] 400,400,1,3                                             # Image[2] = visualization.
  -i[3] 1                                                       # Image[3] = colormap (to be initialized).
  iteration=0                                                   # Iteration counter.
  score=0                                                       # Current score.
  bestscore=0                                                   # Best score.
  stock=500                                                     # Remaining cells.
  -w[0] 400,400,0,"[G\47MIC] The game of life"                    # Initialize display window.
  -cursor[0] 0

  # Start user-event loop.
  -do
    (1,1,1;1,0,1;1,1,1) --correlate[0] [-1],0 -rm[-2]           # Count numbers of neighboring living cells.
    --ir[-1] 2,2 -and[-1] [0] -ir[-2] 3,3 -or[-2,-1]            # Make the game evolve (kill or create cells).
    -rv[0,-1]                                                   # Update game state.
    -if {@{!,x}>0" && "@{!,b}==1" && "$stock>0}                 # Add random cells to the game if user presses mouse button.
      nb={?*7}
      -repeat $nb
        x={@{!,x}/@{!,w}*@{0,w}+?(-4,4)}
        y={@{!,y}/@{!,h}*@{0,h}+?(-3,3)}
        -=[0] 1,$x,$y
        -=[1] $iteration,$x,$y
        -point[2] {$x*@{2,w}/@{0,w}},{$y*@{2,h}/@{0,h}},0,0.8,255
      -done
      stock={round(max(0,$stock-$nb))}
    -endif

    --[-1] [0] -*[-1] -1                                        # Compute difference between consecutive states.
    stock={$stock-2*(min(0,int(@{-1,+}/16*$score/150)))}        # Increment available cells if the evolution is fast.
    -+[1] [0]                                                   # Increment generation counter for still existing cells.
    -min[-1] 0 -+[-1] 1 -*[1,-1]                                # Reset generation counter for died cells.

    -if {@{!,b}==2}                                             # Reset game if right mouse button has been pressed.
      -f[0-2] 0 iteration=0 score=0 bestscore=0 stock=500 -rm[3] -i[3] 1
    -endif

    -if {@{3,w}==1}                                             # Create color palette if necessary.
      -rm[3] -i[3] {?(3,12)},1,1,3,?(100,255)
      -r[3] {?(100,300)}%,1,1,3,4
      -point[3] 0,0,0,1,0
      -r[3] {?(100,600)}%,1,1,3,5 -c[3] 0,255
    -endif

    --r[1] @{2,w},@{2,h} -and[-1] 7 -b[-1] {1+$score*0.05}   # Render colored image of the game and display it.
    -n[-1] 0,@{3,w} -map[-1] [3] -*[-1] 0.1 -+[2,-1] -/[2] 1.1
    [2] -if {@{!,x}>0}                                          # Add a small target icon at the mouse position.
      opac={0.7*min(1,$stock/500)} r={min(500,$stock)*cos($iteration)/100}
      -ellipse[-1] @{!,x},@{!,y},{15+$r},{15+$r},0,$opac,0,196,0
      -ellipse[-1] @{!,x},@{!,y},{10+$r},{10+$r},0,$opac,32,64,16
      -ellipse[-1] @{!,x},@{!,y},{5+$r},{5+$r},0,$opac,255,230,0
    -endif
    -t[-1] "Living cells : "$score"\n"\                      # Add score description.
           "Stock : "$stock"\n"\
           "Score : "$bestscore,5,3,22,0.7,255
    -w[-1] @{!,w},@{!,h}
    -if @{!,S} -o[-1] gmic_life.png -endif                      # Save snapshot if requested.
    -rm[-1]

    -if {!($iteration%10)} score=@{0,+} bestscore={max($score,$bestscore)} -endif  # Re-compute current and best scores, every 10th iterations.
    -wait 60
    iteration={$iteration+1}
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}

  # End game and quit properly.
  -rm[0-3] -w 0 -v +

#@gmic x_light
#@gmic : Launch the light effect demo.
x_light :
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ Light effect ----------------------\n
----\n
---- Move light position with mouse.\n
---- Mouse buttons fade light in/out.\n
---- Keys 'CTRL+D' to double window size.\n
---- Keys 'CTRL+C' to reset window size.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------"
  -v -

  # Create warping and color images.
  0 -t[-1] "    G\47MIC\nLight effect",0,0,53,1,255 -expand_xy[-1] 15,0 -b[-1] 3
  [-1] -n[-2] 0,1 -r[-2] 100%,100%,1,3
  -sh[-2] 0,0 -*[-1] 120 -rm[-1]
  -sh[-2] 1,1 -*[-1] 70 -rm[-1]
  -sh[-2] 0,50%,0,2 -*[-1] 120 -rm[-1]
  25%,25%,1,1 -rand[-1] -20,20 -smooth[-1] 10,0,1,1,4 -r[-1] [-2],3 -b[-1] 3 -n[-1] -60,60
  -+[-2,-1] -g[-1] xy -a[-2,-1] c -n[-1] -150,150
  -w[] {1.5*@{-2,w}},{1.5*@{-2,h}},0,"[G\47MIC] Light effect"  # Init display window.
  -cursor[0] 0

  # Create a large light image.
  light=70
  512,512 -gaussian[-1] $light -n[-1] 0,255
  t=0

  # Start animation.
  -do

    # Manage light position and intensity.
    -if {@{!,x}>=0}
      X={round((w-@{!,x})/2)}
      Y={round((h-@{!,y})/2)}
    -else
      X={round((w-@{-2,w}*(1+cos(2*$t)))/2)}
      Y={round((h-@{-2,h}*(1+sin(2.5*$t)))/2)}
      t={$t+0.02}
    -endif
    -if {@{!,b}&1} light={min(200,$light+10)} -gaussian[-1] $light -n[-1] 0,255 -endif
    -if {@{!,b}&2} light={max(10,$light-10)} -gaussian[-1] $light -n[-1] 0,255 -endif

    # Render lightened image.
    --z[-1] $X,$Y,{$X+@{-2,w}-1},{$Y+@{-2,h}-1}
    -warp[-1] [-3],1,0,1
    -r[-1] 100%,100%,1,3 -+[-1] [-4] -c[-1] 0,255
    -w[-1]
    -if {@{!,CTRLLEFT}&&@{!,D}} -w[] {3*w},{3*h}
    -elif {@{!,CTRLLEFT}&&@{!,C}} -w[] {1.5*w},{1.5*h} -endif
    -rm[-1] -if {@{!,x}>=0" && "!@{!,b}} -wait -else -wait 20 -endif
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -w[] 0 -rm[-3--1] -v +

#@gmic x_mandelbrot : _julia={ 0 | 1 },_c0r,_c0i
#@gmic : Launch Mandelbrot/Julia explorer.
x_mandelbrot : -skip ${1=0},${2=0.317},${3=0.03}
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ Mandelbrot/Julia explorer -----------------\n
----\n
---- Select zooming region with mouse.\n
---- Click once to reset zoom factor.\n
---- Keys 'ESC' or 'Q' to exit.\n
---- Key 'C' to print current fractal coordinates.\n
----\n
--------------------------------------------------"

  # Init variables and display.
  -v -
  -rm -w 512,512,0 -_x_mandelbrot_coords $1 -_x_mandelbrot_palette

  # Start event loop.
  -do
    siz={min(@{!,w},@{!,h})}                                                                      # Desired window dimension.
    $siz,$siz -mandelbrot[-1] @0,256,$1,{if($1,$2,0)},{if($1,$3,0)} -map[-1] [1]                  # Render fractal.
    -if $1 -w[-1] $siz,$siz,0,"[G\47MIC] Julia set c=("@{0,0}","@{0,1}")-("@{0,2}","@{0,3}"), c0=($2,$3)" # Display on window.
    -else -w[-1] $siz,$siz,0,"[G\47MIC] Mandelbrot set c=("@{0,0}","@{0,1}")-("@{0,2}","@{0,3}")" -endif
    w={w} h={h} -round[-1] -select[-1] 2                                                          # Get the user selection.

    -if {@{-1,0}>0}                                                                               # If valid selection found.
      M={max(@{-1,3}-@{-1,0},@{-1,4}-@{-1,1})}                                                    # Compute max dimension of selected rectangle.
      -if {$M<5} -_x_mandelbrot_coords $1 -rm[1] -_x_mandelbrot_palette -mv[-1] 1                 # If selection too small, reset the view,
      -else ({@{0,0}+@{-1,0}*(@{0,2}-@{0,0})/$w};\                                                # Else compute new fractal coordinates.
             {@{0,1}+@{-1,1}*(@{0,3}-@{0,1})/$h};\
             {@{0,0}+(@{-1,0}+$M)*(@{0,2}-@{0,0})/$w};\
             {@{0,1}+(@{-1,1}+$M)*(@{0,3}-@{0,1})/$h})
      -endif
      -rm[0] -mv[-1] 0                                                          # Validate new coordinates.
    -endif
    -rm[-1]                                                                     # Delete latest rendering.
    -if {@{!,C}}                                                                # If 'C' key has been pressed.
      -if $1 -v + -e[0--4] "Julia set, at c = ("@{0,0-1}")-("@{0,2-3}"), with c0 = ($2,$3)." -v -
      -else -v + -e[0--4] "Mandelbrot set, at c = ("@{0,0-1}")-("@{0,2-3}")." -v -
      -endif
    -endif
    -if {!@!" || "@{!,ESC}" || "@{!,Q}} -rm -w 0 -v + -return -endif
    -wait -1
  -while 1

_x_mandelbrot_coords :
  -if $1 (-2;-2;2;2) -else (-2.1;-1.5;1.2;1.5) -endif

_x_mandelbrot_palette :
  6,1,1,3 -rand[-1] 20,255 -r[-1] 32,1,1,3,3 -r[-1] 1024,1,1,3,0,2 -=[-1] 0,0,0,0,0 -=[-1] 0,0,0,0,1 -=[-1] 0,0,0,0,2

#@gmic x_metaballs3d
#@gmic : Launch the 3d metaballs demo.
x_metaballs3d :
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ 3d metaballs ---------------------------------------\n
----\n
---- Mouse button or 'SPACE' key to toggle rendering mode.\n
---- Keys 'CTRL+D' to double window size.\n
---- Keys 'CTRL+C' to reset window size.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------------------------"
  -v - -l[]
  100,100 -noise[-1] 100,1 -plasma[-1] 1,0,10 -r[-1] 512,320,1,3 -n[-1] 0,1 -b[-1] 4,0 -n[-1] 0,255
  -mix_channels[-1] (0.7,0,0;0,0.9,0;0,0,1.2) -c[-1] 0,255 -l3d
  0
  24,24,24,1,'X=x-w/2;Y=y-h/2;Z=z-d/2;exp(-(X*X+Y*Y+Z*Z)/100)'
  72,72,72 M=8 mode=5
  s0=Dots s1=Wireframe s2=Flat s3=Flat-shaded s4=Gouraud-shaded s5=Phong-shaded
  -repeat $M fx$>={g*1.5} fy$>={g*1.5} fz$>={g*1.5} -done
  -w[0] -1,-1,0,"[G\47MIC] 3d metaballs"
  -do
    -repeat $M
      x$>={w/2+0.5*(w-@{2,w}-4)*cos(${fx$>}*@|)}
      y$>={h/2+0.5*(h-@{2,h}-4)*sin(${fy$>}*@|)}
      z$>={d/2+0.5*(d-@{2,d}-4)*sin(${fz$>}*@|)}
    -done
    -f[3] 0 -repeat $M -j[3] [2],{${x$>}-@{2,w/2}},{${y$>}-@{2,h/2}},{${z$>}-@{2,d/2}},0,-1 -done
    --r[3] 24,24,24,1,2 -isosurface3d[-1] 0.4 --3d[-1] 12,12,12 -*3d[-1] 13 -rv3d[-1]
    -r3d[-1] 1,2,1,{100*@|}
    N={i[7]} (255,255,150;200,96,164;50,150,230) -r[-1] 3,$N,1,1,3 -y[-1] -j[-2] [-1],0,{@{-2,h}-4*$N} # Do some color tweaks.
    -if {!$mode} -circles3d[-2] 4 -endif
    -if {!@{1,w}}
      0 -t[-1] ${s$mode},5,5,23,0.5,255,255,255 -b[-1] 0.7 -n[-1] 0,255
      --dilate[-1] 3 --j[0] [-2],5,3,0,0,1,[-1],255 -mv[-1] 1 -rm[2,-2,-1]
    -endif
    --j3d[1] [-2],50%,50%,0,1,{if(!$mode,3,$mode)},0,0,300,0,0,-500,0.1,1.5
    -w[-1]
    -if {@{!,CTRLLEFT}&&@{!,D}} -w[] {2*w},{2*h} -elif {@{!,CTRLLEFT}&&@{!,C}} -w[] {w},{h} -endif
    -rm[-3--1] -wait 20
    -if {@{!,b}||@{!,SPACE}} mode={($mode+if(@{!,b}&2,-1,1))%6} -wait -1 -rm[1] -i[1] 0 -endif
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -rm -w 0 -endl -v +

#@gmic x_minesweeper : 8<=_width=<20,8<=_height<=20
#@gmic : Launch the Minesweeper game.
x_minesweeper : -check "${1=20}>=8 && $1<=30 && ${2=$1}>=8 && $2<=30"
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ Minesweeper -------------------------------------------\n
----\n
---- The goal is to clear the minefield without detonating a\n
---- mine.\n
----\n
---- Left mouse button to try clearing one square.\n
---- Right mouse button to flag or unflag a square.\n
---- Middle mouse button to reset mine field.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
--------------------------------------------------------------\n"
  -v -
  # Generate random mine field and player board.
  # Labels : 0=mine, 1=empty, 2='1-near', 3='2-near', ..., 9='8-near', 10=still unknown.
  $1,$2 -noise[-1] 30,2 nb_mines=@{-1,+} (1,1,1;1,0,1;1,1,1) --convolve[-2] [-1],0 -rm[-2] -+[-1] 1 -==[-2] 0 -*[-2,-1] -nm[-1] field
  -do x={round(?(w-1))} y={round(?(h-1))} -while {i($x,$y)!=1} # Find a good starting point.
  --f[field] 11 -=[-1] 12,$x,$y -nm[-1] board

  # Generate sprite graphics.
  24,24,1,3,200 -fc[-1] 255,180,130
  -ellipse[-1] 12,12,4,4 -line[-1] 6,12,18,12 -line[-1] 12,6,12,18 -line[-1] 13,10,14,10,1,255 -line[-1] 13,11,14,11,1,255
  -z[-1] 1,1,{w-2},{h-2} -frame[-1] 1,1,0
  --fc[-1] 230,250,255
  --t[-1] "1",10,5,13,1,0,196,0 --t[-2] "2",9,5,13,1,0,128,0 --t[-3] "3",9,5,13,1,0,0,255
  --t[-4] "4",9,5,13,1,255,0,0 --t[-5] "5",9,5,13,1,200,0,0 --t[-6] "6",9,5,13,1,150,0,0
  --t[-7] "7",9,5,13,1,128,0,0 --t[-8] "8",9,5,13,1,64,0,0
  --f[-1] 'if(x<=1||y<=1||x>=w-2||y>=h-2,if(x<y,128,255),160+2*(y+x))'
  --polygon[-1] 4,13,15,11,15,6,18,17,18,1,0 -line[-1] 12,15,12,6,1,255,0,0 -polygon[-1] 3,12,6,6,9,12,12,1,220,0,0
  -rv[-2,-1]
  [-1] 100%,100%,1,3 -line[-1] 6,14,10,18,1,0,200,0 -line[-1] 10,18,16,6,1,0,200,0 -dilate[-1] 2
  --channels[-1] 1 -n[-1] 0,0.7 -dilate[-1] 3 -j[-3] [-2],0,0,0,0,1,[-1] -rm[-2,-1]
  -a[-13--1] x -nm[-1] sprites

  # Pre-calculate offsets and canvas for faster board rendering.
  (0,23;0,23^0,0;23,23) -r[-1] 24,24,1,2,3 -r[-1] {@{board,w}*24},{@{board,h}*24},1,2,0,2 -nm[-1] offsets
  [-1],[-1],1,3,255 -frame[-1] 1,1,0 -frame[-1] 23,23,255
  0 -t[-1] "Number of mines : "$nb_mines,0,0,18,1,100,200,255 -negative[-1] -j[-2] [-1],{(@{-2,w}-w)/2},{@{-2,h}-h-2} -rm[-1]
  -nm[-1] canvas

  # Start user interaction loop.
  failed=0 succeeded=0 nb_flags=0 started=0
  -do

    # Render board.
    --*[board] 24 -r[-1] [offsets],[offsets] -channels[-1] 0,1 -+[-1] [offsets] --warp[sprites] [-1],0,0 -rm[-2]
    -j[canvas] [-1],24,24 -rm[-1]

    # Wait for user's selection.
    -wait -1
    -if $failed
      0 -t[-1] "Game\nOver!",3,3,38,1,255 -r[-1] 100%,100%,1,4 -sh[-1] 3,3 -dilate[-1] 5 -/[-1] 2 -rm[-1]
      -drop_shadow[-1] 5,5,1 -blend[canvas,-1] alpha
      0 -t[-1] "Boom! You failed!",0,0,18,1,100,255,255 -r[-1] @{canvas,w},100%,1,3,0,0,0.5,0.5 -negative[-1] -j[canvas] [-1],0,3 -rm[-1]
      -do -w[canvas] {w},{h} -wait -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
    -elif $succeeded
      0 -t[-1] "Success!",3,3,38,1,255 -r[-1] 100%,100%,1,4 -sh[-1] 3,3 -dilate[-1] 5 -/[-1] 2 -rm[-1]
      -drop_shadow[-1] 5,5,1 -blend[canvas,-1] alpha
      0 -t[-1] "Congratulations! ("{round(@|-$tic)}" s)",0,0,18,1,255,100,255 -r[-1] @{canvas,w},100%,1,3,0,0,0.5,0.5
      -negative[-1] -j[canvas] [-1],0,3 -rm[-1]
      -do -w[canvas] {w},{h} -wait -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
    -else
      --==[board] 10 nb_flags=@{-1,+} -rm[-1]
      -do
        -if {!$started} tic=@| -endif
        0 -t[-1] "Elapsed time : "{round(@|-$tic)}" s / Flags : "$nb_flags,0,0,18,1,255,200,0 -r[-1] @{canvas,w},100%,1,3,0,0,0.5,0.5
        -negative[-1] -j[canvas] [-1],0,3 -rm[-1]
        -wait 50
        x={int((@{!,x}-24)/24)} y={int((@{!,y}-24)/24)} b=@{!,b}
        -w[canvas] {w},{h},0,"[G\47MIC] Minesweeper"
      -while {@!" && "!@{!,ESC}" && "!@{!,Q}" && "!$b}
    -endif

    # Manage selected square.
    -if {$x>=0\ &&\ $y>=0\ &&\ $x<@{board,w}\ &&\ $y<@{board,h}}
      -if {$b&1}  # Try to clean square.
        started=1 val=@{field,($x,$y)}
        -if {$val==0} --==[field] 0 -j[board] [field],0,0,0,0,1,[-1] -rm[-1] failed=1  # Found a mine -> boom!
        -elif {$val==1} --flood[field] $x,$y,0,0,1,1,-1 -==[-1] -1 -dilate[-1] 3 -j[board] [field],0,0,0,0,1,[-1] -rm[-1] # Found an empty area.
        -else -=[board] $val,$x,$y # Close to one or several mines.
        -endif
      -elif {n=@{board,($x,$y)};$b&2" && "n>=10" && "n<=11}
        -=[board] {if(@{board,($x,$y)}==11,10,11)},$x,$y # Flag or unflag a square.
      -elif {$b&4} -f[board] 10  # Reset minefield.
      -endif
    -endif

    -if {$nb_mines==$nb_flags\ &&\ @{board,M}!=11} succeeded=1 -endif  # Check if board is cleared.
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -w 0 -v +

#@gmic x_minimal_path
#@gmic : Launch the minimal path demo.
x_minimal_path :
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ Minimal path ------------------------------------------\n
----\n
---- Click on two points to compute and display the minimal\n
---- path between those points. The ending point is then\n
---- chosen as the next starting point for another path.\n
---- Key 'S' to save snapshot of the current view.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
--------------------------------------------------------------"
  -v -
  -if {!@#} -testimage2d 400 -endif
  -n 0,200 -round 1
  -repeat @# -l[$>]
    -w[0] -1,-1,0,"[G\47MIC] Select starting point P0"

    -if {!narg($first_time)}
      -parallel 0,"--l[0] -r2dy 128 -frame 1,1,0 \
        -alert \"[G\47MIC Minimal path]\",\
           \"The G\47MIC minimal path demo illustrates how minimal paths\n\
           can be computed in images to detect and track edge points.\n\
           Use your mouse to select desired starting and ending points,\n\
           and see what is the minimal path computed between these points.\",\
           \"OK\" \
        -rm -endl"
      first_time=0
    -endif

    --gradient_norm -b[-1] 1 -f[-1] exp(-i/10)
    -to_rgb[0] --select[0] 0 P0=@-1
    -ellipse[0] @{-1,0,1},3,3,0,1,255,0,255
    -ellipse[0] @{-1,0,1},3,3,0,1,0xFFFFFFFF,255,255,255
    -rm[-1]
    -if {min($P0)>=0}
      p=1
      -do
        -w[0] -1,-1,0,"[G\47MIC] Select ending point P"$p
        --select[0] 0
        -if {@{!,S}}
          -rm[-1]
          --text_outline[0] "Saving snapshot...",5,5,13,1,1,255,255,255 -w[-1] -rm[-1]
          -o[0] gmic_minimal_path.png
          -wait -1
        -else
          P1=@-1
          -ellipse[0] @{-1,0,1},3,3,0,1,255,0,255
          -ellipse[0] @{-1,0,1},3,3,0,1,0xFFFFFFFF,255,255,255
          -rm[-1]
          -if {min($P1)>=0}
            --text_outline[0] "Processing...",5,5,13,1,1,255,255,255 -w[-1] -rm[-1]
            --minimal_path[1] $P0,$P1,1
            -pointcloud[-1] 0 -*[-1] 255 -r[-1] 100%,100%,1,[0],0,0,0,0,0,0.5 -r[-1] [0],0 -or[0,-1]
            P0=$P1 p={$p+1}
          -endif
        -endif
      -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
    -endif
    -rm[1]
  -endl -done -w 0 -v +

#@gmic x_pacman
#@gmic : Launch pacman game.
x_pacman :
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ Pacman -----------------------------------------------\n
----\n
---- This is a G\47MIC implementation of the pacman game.\n
----\n
---- Move the pacman to eat all pacdots on the different levels.\n
---- Eating a pacgum makes pacman invincible for 10 seconds,\n
---- which mean pacman can eat ghosts during this time.\n
---- Eating a ghost earns 100 pts.\n
---- Eating a cherry earns 10 pts.\n
---- Eating a strawberry earns 100 pts.\n
---- Eating an orange earns 1000 pts.\n
---- Eating a banana earns 5000 pts.\n
----\n
---- Arrow keys to control pacman.\n
---- Keys 'CTRL+D' to double window size.\n
---- Keys 'CTRL+C' to reset window size.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
--------------------------------------------------------------"
  -v - -l[]

  # Initialize characters gfx.
  -m "_pacman_ghost_base_gfx : 31,19 -circle[-1] 15,15,15,1,1 31,12,1,1,'y<4+8*abs(cos(x*0.3+0.25*pi*$""1))' -a[-2,-1] y"
  -repeat 4
    -_pacman_ghost_standard_gfx 255,0,0,$> -nm[-1] ghost0_$>
    -_pacman_ghost_standard_gfx 0,255,222,$> -nm[-1] ghost1_$>
    -_pacman_ghost_standard_gfx 255,184,222,$> -nm[-1] ghost2_$>
    -_pacman_ghost_standard_gfx 255,184,71,$> -nm[-1] ghost3_$>
    -_pacman_ghost_afraid_gfx $> -nm[-1] ghosta_$>
    -_pacman_ghost_base_gfx $> -r[-1] 16,16,1,1,2 -nm[-1] ghostm_$>
    -_pacman_ghost_standard_gfx 0,0,0,$> -nm[-1] ghostd_$>
    -_pacman_pacman_gfx $> -nm[-2] pacman_$> -nm[-1] pacmanm_$>
  -done
  --channels[ghostd_0] 0 -!=[-1] 0 -nm[-1] ghostdm
  -_pacman_cherry_gfx -nm[-1] fruit0 -_pacman_strawberry_gfx -nm[-1] fruit1
  -_pacman_orange_gfx -nm[-1] fruit2 -_pacman_banana_gfx -nm[-1] fruit3
  20,2,1,3,200 -nm[-1] gate
  score0="10" score1="100" score2="1000" score3="5000" score4="Argh!"
  -repeat 5
    0 -t[-1] ${score$>},0,0,13,1,255,255,255 -autocrop[-1] 0 -expand_xy[-1] 1,0 --dilate[-1] 3
    -nm[-1] scorem$> -nm[-2] score$>
  -done
  time4=255,255,255 time3=255,255,32 time2=255,128,32 time1=255,32,32
  -repeat 11 0 -t[-1] $<" s",0,0,23,1,${time{min(4,round(($<+1)/2))}} -nm[-1] time$< -done
  0 -t[-1] "Get Ready!",0,0,32,1,255 -autocrop[-1] 0 -expand_xy[-1] 4,0 --dilate[-1] 8 -r[-2] 100%,100%,1,3
  -nm[-2] get_ready -nm[-1] get_readym
  0 -t[-1] "Game\nOver!",0,0,53,1,255 -autocrop[-1] 0 -expand_xy[-1] 4,0 --dilate[-1] 8 -r[-2] 100%,100%,1,3
  -nm[-2] game_over -nm[-1] game_overm

  # Start game.
  score=0 level=-1 lives=3 is_quit=0
  -do

    # Build new level if necessary.
    -if {$level<0}
      _rlevel=33 _glevel=33 _blevel=255
      -_pacman_map_level{((-$level-1)%6)+1} mw={w} mh={h} mw2={int(w/2)} mh2={int(h/2)}
      -if {$level<-6} -replace[-1] 3,2 -endif
      -nm[-1] map0 -i[map] [-1]

      # Precompute valid directions on each map point, and shortest path to the ghost's home.
      --shift[map] -1,0 --shift[map] 0,-1 --shift[map] 1,0 --shift[map] 0,1 -a[-4--1] z -!=[-1] 1 -nm[-1] can_go
      --==[map] 1 100%,100% -=[-1] 1,$mw2,$mh2 -distance[-1] 1,[-2],3 -rm[-2]
      -f[-1] 'if(i==2,0,if(i==8,1,if(i==1,2,if(i==4,3,i))))' -nm[-1] path
      --==[map] 2 pacdots=@{-1,+} -rm[-1]
      level={-$level}
    -endif

    # Render board gfx.
    -f[map] 'if(i>=4,0,i)' --==[map] 1 -expand_xy[-1] 1,0 -r[-1] 1600%,1600% -erode[-1] 9 -b[-1] 2
    -g[-1] xy -abs[-2,-1] -+[-2,-1] ->=[-1] 80% -b[-1] 2 -n[-1] 0,1 -shrink_xy[-1] 16
    --*[-1] $_glevel --*[-2] $_blevel -*[-3] $_rlevel -a[-3--1] c
    16,16,1,1,'x' ---[map] 1 -max[-1] 0 -*[-1] 16 -r[-1] 1600%,1600%
    16,16,1,1,'y' -r[-3,-1] [-2],0,2 -+[-2,-1] -a[-2,-1] c
    16,16,1,3 -_pacman_pacdots_gfx -_pacman_pacgum_gfx -a[-3--1] y
    -warp[-1] [-2],0,0 -rm[-2] -or[-2,-1] -r[-1] 100%,{h+24},1,3,0,0,0,1
    -t[-1] "Lives :",10,0,23,1,255 -t[-1] "Score :",{w-140},0,23,1,255
    -if $lives --r[pacman_2] 12,12,1,4,2 -r[-1] {100*$lives}%,100%,1,4,0,2 -j[-2] [-1],90,7 -rm[-1] -endif
    -nm[-1] visu
    -w[visu] -1,-1,0,"[G\47MIC] Pacman" -cursor[0] 0
    0 -t[-1] "Level "$level,0,0,53,1,1 -autocrop[-1] 0 -expand_xy[-1] 4,0 (0,255^0,255^0,0) --map[-2] [-1] -rm[-2] -dilate[-2] 8
    -nm[-1] level_N -nm[-2] levelm_N

    -repeat 4 xg$>={16*$mw2} yg$>={16*$mh2+4*$>} dg$>=3 mg$>=0 -done
    xp={16*10} yp={16*21} dp=-1 pacgum_timer=-1 fruit_timer=@| dying_pacman=0 is_get_ready=1
    xscore=0 yscore=0 nscore=0 oscore=0

    # Start game interaction.
    -do

      # Display board graphics.
      t={int(6*@|)%4} left={if($pacgum_timer>=0,10-@|+$pacgum_timer,-1)}
      [visu]
      -repeat 4
        mg=${mg$>} xg=${xg$>} yg={${yg$>}+24}
        -if {$mg==0} -j[-1] [ghost$>_$t],$xg,$yg,0,0,1,[ghostm_$t]
        -elif {$mg==1} t2={if($left>7,$t,if($left>3,int(12*@|)%4,int(24*@|)%4))} -j[-1] [ghosta_$t2],$xg,$yg,0,0,1,[ghostm_$t]
        -elif {$mg==2} -j[-1] [ghostd_$t],$xg,$yg,0,0,0.8,[ghostdm]
        -else -j[-1] [ghost$>_$t],$xg,$yg,0,0,{$mg-2},[ghostm_$t] -j[-1] [ghostd_$t],$xg,$yg,0,0,1,[ghostdm]
        -endif
      -done
      -if $dying_pacman
        -_pacman_pacman_gfx {$dying_pacman/2} -rotate[-2,-1] {90*(abs($dp)-1)} -j[-3] [-2],$xp,{24+$yp},0,0,1,[-1],255 -rm[-2,-1]
        dying_pacman={$dying_pacman+1}
        -if {$dying_pacman>64}
          -if {$lives!=1} -rm[-1] -break -endif
          -j[-1] [game_over],{(w-@{game_over,w})/2},{12+(h-@{game_over,h})/2},0,0,{min(1,($dying_pacman-64)/50)},[game_overm],255
          -rectangle[-1] 90,7,101,18,1,0
        -endif
      -else
        --rotate[pacman_$t,pacmanm_$t] {90*(abs($dp)-1)} -j[-3] [-2],$xp,{24+$yp},0,0,1,[-1],255 -rm[-2,-1]
        -if {$left>=0" && "($left>=5" || "$t<=2)} -j[-1] [time{round($left)}],{(w-@{time0,w})/2-10},1 -endif
      -endif
      -t[-1] $score,{w-65},1,22,1,255
      -if {$is_get_ready}
        -j[-1] [level_N],{(w-@{level_N,w})/2},{12+(h-1.5*@{level_N,h})/2},0,0,1,[levelm_N]
        -if {int(@|*4)%2} -j[-1] [get_ready],{(w-@{get_ready,w})/2},{24+(h+@{get_ready,h})/2},0,0,1,[get_readym],255 -endif
      -endif
      -if {$oscore>0} -j[-1] [score$nscore],$xscore,$yscore,0,0,$oscore,[scorem$nscore],255 oscore={$oscore-0.04} yscore={$yscore-1} -endif
      -j[-1] [gate],158,223,0,0,0.6
      -w[-1]
      -if {@{!,CTRLLEFT}&&@{!,D}} -w[] {2*w},{2*h} -elif {@{!,CTRLLEFT}&&@{!,C}} -w[] {w},{h} -endif
      -rm[-1]

      # Manage ghosts displacements and collisions.
      -repeat 4
        xg=${xg$>} yg=${yg$>} dg=${dg$>} mg=${mg$>}

        -if {max(abs($xg-$xp),abs($yg-$yp))<=8}            # Test collision between ghost and pacman.
          -if {$mg==0" && "!$dying_pacman} dying_pacman=1  # Was in normal mode -> dying pacman.
            xscore=$xp yscore={$yp+12} oscore=1 nscore=4
          -elif {$mg==1} mg=2 mg$>=$mg score={$score+100}  # Was in invicibility mode -> dying ghost.
            xscore=$xp yscore={$yp+12} oscore=1 nscore=1
          -endif
        -endif
        -if {$mg>=2" && "($xg>>4)==$mw2" && "($yg>>4)==$mh2} # Check if dying ghost has returned to home.
          mg={$mg+0.01}
          -if {$mg>=3} mg=0 xg={$xg&-2} yg={$yg&-2} -endif
          mg$>=$mg
        -endif

        -if {!($xg&15)" && "!($yg&15)} # Check if ghost can take a new direction.
          ({?},{?},{?},{?};0,1,2,3)
          -if {$mg<2}
            -=[-1] {?(0.6,1)},{if($mg==0,dX0=$xp-$xg;dY0=$yp-$yg;if(abs(dX0)>abs(dY0),if(dX0>0,0,2),if(dY0>0,1,3)),\ # Try to chase pacman.
                                         dX1=$xp-$xg;dY1=$yp-$yg;if(abs(dX1)<abs(dY1),if(dX1>0,2,0),if(dY1>0,3,1)))} # Try to escape pacman.
            -=[-1] 0,{($dg+2)%4}
            -if $is_get_ready -=[-1] 0.8,@{path,({$xg>>4},{$yg>>4})} -endif
          -else -=[-1] 1,@{path,({$xg>>4},{$yg>>4})} # If dying ghost, follow the best path to home.
          -endif
          -sort[-1] -,x -repeat 4 d={i($>,1)} -if @{can_go,({$xg>>4},{$yg>>4},$d)} dg=$d -break -endif -done -rm[-1] # Try directions until it matches.
          dg$>=$d
        -endif
        u={D=${dg$>};(D==0)-(D==2)}
        v={D=${dg$>};(D==1)-(D==3)}
        xg$>={($xg+$u*(1+($mg==0)))%(16*$mw)}
        yg$>={($yg+$v*(1+($mg==0)))%(16*$mh)}
      -done

      -wait 22

      # Manage pacman displacement.
      -if {!$dying_pacman}
        d={if(@{!,ARROWRIGHT},1,if(@{!,ARROWDOWN},2,if(@{!,ARROWLEFT},3,if(@{!,ARROWUP},4,$dp))))}
        -if {!($xp&15)" && "!($yp&15)}
          i=@{map,({$xp>>4},{$yp>>4})}
          -if {$i==2} score={$score+10} pacdots={$pacdots-1} # Pacdot eaten.
          -elif {$i==3} pacgum_timer=@| -repeat 4 -if {!${mg$>}} mg$>=1 dg$>={(${dg$>}+2)%4} -endif -done  # Pacgum eaten.
          -elif {$i>=4} score={$score+${score{$i-4}}} xscore=$xp yscore={$yp+12} oscore=1 nscore={$i-4} # Fruit eaten.
          -endif
          -=[map] 0,{$xp>>4},{$yp>>4}
          16,16,1,3 -j[visu] [-1],$xp,{24+$yp} -rm[-1]
          d={if(@{can_go,({$xp>>4},{$yp>>4},{abs($d)-1})},$d,$dp)}
          d={if(@{can_go,({$xp>>4},{$yp>>4},{abs($d)-1})},$d,-abs($dp))}
          dp=$d
        -else dp={if(abs($d-$dp)==2,$d,$dp)}  # Allow to turn back on non-integer locations.
        -endif
        is_get_ready={if($dp>0,0,$is_get_ready)}
        u={($dp==1)-($dp==3)}
        v={($dp==2)-($dp==4)}
        xp={($xp+2*$u)%(16*$mw)}
        yp={($yp+2*$v)%(16*$mh)}

        -if {$pacgum_timer>=0" && "@|>$pacgum_timer+10} # Check if pacgum still has some effect.
          -repeat 4 xg$>={${xg$>}&-2} yg$>={${yg$>}&-2} mg$>={if(${mg$>}==1,0,${mg$>})} -done
          pacgum_timer=-1
        -endif

        -if {!$is_get_ready" && "(@|-$fruit_timer)>=10}
          x={round(?(0,@{map0,w}))}
          y={round(?(0,@{map0,h}))}
          -if {!@{map,($x,$y)}" && "@{map0,($x,$y)}==2}
            n={min(3,int(abs(g*1.7)))} -=[map] {4+$n},$x,$y -j[visu] [fruit$n],{16*$x},{16*$y+24} fruit_timer=@|
          -endif
        -endif

      -endif
      -if {!@!" || "@{!,Q}" || "@{!,ESC}} is_quit=1 -endif

    -while {!$is_quit" && "$pacdots}

    -if $is_quit -break         # Player asked to quit.
    -elif $pacdots              # Player lost a life.
      lives={$lives-1}
    -else                       # Player achieved level.
      level={-$level-1} -wait[0] -1
      -rm[map0,map,can_go,path]
    -endif
    -rm[visu,level_N,levelm_N]
  -while $lives
  -rm -w 0 -endl -v +

# The functions below create the various sprite gfx.
_pacman_ghost_standard_gfx :
  -_pacman_ghost_base_gfx $4 (0,$1^0,$2^0,$3) -map[-2] [-1] -rm[-1]
  -ellipse[-1] 10,11,3,4,0,1,255 -ellipse[-1] 20,11,3,4,0,1,255
  -r[-1] 16,16,1,3,2 -point[-1] 5,{7-($4>=2)},0,1,1 -point[-1] 10,{7-($4>=2)},0,1,1

_pacman_ghost_afraid_gfx :
  -_pacman_ghost_base_gfx $1
  -if {$1<2} col=255,255,255 (0,0^0,0^0,208) -else col=255,0,0 (0,248^0,248^0,248) -endif
  -map[-2] [-1] -rm[-1] -r[-1] 16,16,1,3,2
  -line[-1] 4,4,6,6,1,$col,255 -line[-1] 4,6,6,4,1,$col,255
  -line[-1] 9,4,11,6,1,$col,255 -line[-1] 9,6,11,4,1,$col,255
  -f[-1] 'if(y>=9&&y<=10&&x>=2&&x<=13&&((int((x+1)/2)+y)%2),arg(c+1,$col),i)'

_pacman_pacman_gfx :
  32,32,1,1,'X=x-15;Y=y-15;A=atan2(Y,X);R=sqrt(X^2+Y^2);R<15.5&&abs(A)>0.8*0.33*$1'
  (0,255^0,255^0,0^0,255) -map[-2] [-1] -rm[-1] -r[-1] 16,16,1,4,2 -s[-1] c,-3

_pacman_pacdots_gfx :
  (255^184^151) -r[-1] 4,4,1,3 -r[-1] 16,16,1,3,0,0,0.5,0.5

_pacman_pacgum_gfx :
  16,16,1,3 -circle[-1] 7,7,7,1,255,128,64

_pacman_cherry_gfx :
  (12,12,1,1,0,0,-10,-2,1,-8,-4,1,-6,-2,1,0,1,-7,0,1,-3,0,1,-3,-4,2,-3,0,1,-3,-6,2,0,1,-4,-5,2,0,-4,2,-2,\
   0,2,3,-2,2,0,-6,2,0,-2,2,3,2,0,-6,2,-2,-3,2,0,2,3,-4,2,-6,-2,2,3,-3,2,-7,-4,2,-2,0)
  -uncompress_rle[-1] (0,0,255,255^0,173,0,255^0,0,0,255) -map[-2] [-1] -rm[-1] -r2dy[-1] 14 -r[-1] 16,16,1,3,0,0,0.5,0.5

_pacman_strawberry_gfx :
  (11,12,1,1,0,0,-5,0,3,-7,-3,1,3,-3,1,-3,-2,2,-5,1,-2,2,0,-4,2,-3,1,-2,2,3,-2,2,3,-5,2,3,-6,2,3,\
   2,3,-13,2,3,-2,2,0,2,3,-2,2,3,-4,2,-2,-9,2,-3,-2,2,3,-2,2,3,-6,-5,2,-8,0,2,-5,0)
  -uncompress_rle[-1] (0,0,255,255^0,173,0,255^0,0,0,255) -map[-2] [-1] -rm[-1] -r2dy[-1] 14 -r[-1] 16,16,1,3,0,0,0.5,0.5

_pacman_orange_gfx :
  (12,13,1,1,0,0,-5,0,1,0,-2,1,-8,-6,1,-6,0,1,3,-3,1,-4,-3,2,1,-4,2,-3,-10,2,0,-60,2,0,-10,2,-2,-10,2,-4,-6,2,-3,0)
  -uncompress_rle[-1] (0,0,255,255^0,173,173,255^0,0,0,255) -map[-2] [-1] -rm[-1] -r2dy[-1] 14 -r[-1] 16,16,1,3,0,0,0.5,0.5

_pacman_banana_gfx :
  (9,12,1,1,0,0,-7,0,1,-7,-2,1,-7,-3,1,-5,0,1,0,-2,1,-5,0,1,0,-2,1,-4,0,1,0,-3,1,-4,0,1,0,-3,\
   1,-3,0,1,0,1,2,1,-3,0,1,0,1,2,-2,1,-2,0,1,0,1,2,-2,1,-2,-6,1,-3,-4,1,-5,0)
  -uncompress_rle[-1] (0,255,255^0,173,255^0,0,255) -map[-2] [-1] -rm[-1] -r2dy[-1] 14 -r[-1] 16,16,1,3,0,0,0.5,0.5

_pacman_map_level1 :
  (11,28,1,1,0,0,-12,1,-5,2,1,-4,2,1,3,-3,1,2,1,2,-4,1,2,-3,1,2,1,2,-4,1,-10,2,-3,1,2,1,2,-3,1,2,1,-2,0,1,2,1,2,-3,1,2,-4,1,\
   2,1,2,-3,1,2,1,-3,0,2,1,-5,2,-4,1,2,-3,1,0,-3,1,-2,0,1,2,-3,1,0,-3,1,-2,0,1,2,-9,0,1,2,-3,1,0,-2,1,-3,0,1,2,1,-3,0,1,-4,\
   0,1,2,1,0,1,0,1,-2,-3,1,2,1,0,1,0,-3,1,-3,0,2,-2,0,1,-4,-3,1,2,-5,1,0,1,-2,0,1,-5,2,-2,0,1,-2,0,1,2,-3,1,2,-6,1,2,-3,1,2,\
   -4,1,-9,2,0,1,2,-3,1,2,-3,1,2,-2,1,2,-3,1,2,1,-3,2,-2,1,3,-3,1,2,1,2,-4,1,2,-3,1,2,1,2,-4,1,-10,2,-11,1)
  -uncompress_rle[-1] --mirror[-1] x -z[-1] 1,100% -a[-2,-1] x
  _rlevel=33 _glevel=33 _blevel=255

_pacman_map_level2 :
  (11,28,1,1,0,0,-12,1,-10,2,1,3,1,2,-3,1,2,-4,1,2,1,2,-3,1,2,1,-2,2,1,2,1,-5,2,1,2,-2,1,2,-3,1,2,1,2,1,2,-2,1,2,-3,1,2,1,2,1,\
   2,-2,1,-5,2,1,-3,2,-4,1,2,-5,1,0,1,-2,0,1,2,-5,1,0,1,-2,0,1,2,-5,1,0,1,-2,0,1,-3,2,1,-4,-3,1,0,1,2,1,0,-2,1,-5,0,1,2,1,0,1,\
   -2,-5,1,2,-2,0,1,-2,-5,1,2,1,0,-3,1,-4,0,1,2,1,-4,-3,1,-3,2,-3,1,0,1,-2,0,1,2,1,-3,2,-2,0,1,-2,0,1,2,-3,1,2,1,0,-4,1,2,-3,1,\
   2,1,0,-2,1,-7,2,1,-2,0,1,2,-3,1,2,1,2,-4,1,2,1,-3,2,1,-4,2,1,3,1,2,-5,1,2,-2,1,2,1,2,-5,1,2,-2,1,-9,2,-12,1)
  -uncompress_rle[-1] --mirror[-1] x -z[-1] 1,100% -a[-2,-1] x
  _rlevel=200 _glevel=33 _blevel=33

_pacman_map_level3 :
  (11,28,1,1,0,0,-11,1,-6,0,1,-4,2,-5,1,0,1,2,-8,1,0,1,2,-4,1,3,-8,2,-2,1,2,-5,1,2,1,2,-2,1,2,-5,1,2,1,2,-2,1,2,1,-5,2,1,2,-2,1,2,\
   1,2,-3,1,0,1,2,-2,1,-5,2,1,0,1,-2,2,-5,1,2,1,0,-4,1,-5,2,1,-4,0,1,2,-3,1,2,1,0,-2,1,0,1,2,-3,1,2,1,0,1,-2,0,1,-3,2,1,2,-2,0,1,\
   -2,-3,1,2,1,2,1,0,-3,1,-2,0,1,2,1,2,1,-6,0,1,2,1,2,-2,1,0,-2,1,-2,0,1,2,1,2,-2,1,0,-2,1,-2,0,1,-6,2,-5,1,2,-4,1,2,-2,1,-3,-3,2,\
   1,-3,2,0,-3,1,2,1,2,1,2,-4,1,3,-2,2,1,-5,2,-2,1,2,-3,1,2,-3,1,2,-2,1,2,-3,1,2,-3,1,2,-2,1,-10,2,-11,1)
  -uncompress_rle[-1] --mirror[-1] x -z[-1] 1,100% -a[-2,-1] x
  _rlevel=33 _glevel=200 _blevel=255

_pacman_map_level4 :
  (11,28,1,1,0,0,-9,1,-2,0,1,-7,2,1,-2,0,1,2,-2,1,2,-2,1,2,1,-2,0,1,2,-2,1,2,-2,1,2,1,-2,0,1,-3,2,3,-3,2,-4,1,2,-2,1,2,-2,1,-4,2,1,2,\
   -2,1,2,-2,1,2,-2,1,2,1,-7,2,-2,1,2,1,2,-2,1,2,-2,1,-4,2,1,2,-2,1,2,-2,1,2,-2,1,2,1,-7,2,-2,1,2,-3,1,-10,0,1,-5,-2,1,0,-3,1,-5,0,1,\
   -10,0,1,-2,-3,1,-5,-6,1,-8,0,1,2,-9,0,1,2,-2,1,2,-2,1,2,-2,1,2,1,2,-2,1,2,-2,1,2,-2,1,2,1,-10,2,1,2,-2,1,2,-2,1,2,-3,0,1,2,-2,1,2,\
   -2,1,2,0,-3,1,-3,2,3,-4,2,1,0,1,2,-2,1,2,-2,1,2,-2,1,0,1,2,-2,1,2,-2,1,2,1,-2,0,1,-7,2,1,-2,-9,1,-2,0)
  -uncompress_rle[-1] --mirror[-1] x -z[-1] 1,100% -a[-2,-1] x
  _rlevel=200 _glevel=200 _blevel=33

_pacman_map_level5 :
  (11,28,1,1,0,0,-12,1,-7,2,1,-2,2,1,3,-5,1,2,1,2,-2,1,2,-5,1,2,1,2,-2,1,2,1,-7,2,-2,1,-3,2,1,2,-3,1,2,-4,1,2,1,2,1,0,1,2,-4,1,2,1,2,\
   -3,1,2,1,-4,0,1,-6,2,1,2,1,0,-3,1,0,-4,1,2,1,0,-3,1,0,-4,1,2,1,-8,0,1,2,-3,1,0,1,0,-2,1,0,1,2,-3,1,0,1,0,1,-2,0,1,2,-4,0,1,0,1,-2,\
   0,1,2,1,0,-3,1,0,-4,1,2,1,-8,0,1,2,-3,1,0,-3,1,0,-2,1,-5,2,1,-3,2,-4,1,2,1,2,1,2,-6,1,2,1,2,1,2,-4,1,3,-2,2,1,-5,2,0,1,2,-3,1,2,-3,\
   1,2,-2,1,-5,2,1,-3,2,-2,1,2,-3,1,2,1,2,-4,1,2,-3,1,2,1,2,-4,1,-5,2,1,-4,2,-11,1)
  -uncompress_rle[-1] --mirror[-1] x -z[-1] 1,100% -a[-2,-1] x
  _rlevel=200 _glevel=255 _blevel=33

_pacman_map_level6 :
  (11,28,1,1,0,0,-12,1,-10,2,1,2,-2,1,2,-7,1,3,-9,2,-5,1,2,-6,1,-10,2,1,2,-4,1,0,-5,1,2,1,-8,0,1,2,1,0,-3,1,0,-3,1,0,2,1,0,1,-6,2,1,2,\
   -2,0,1,2,-2,1,0,-3,1,2,1,-2,0,2,1,-4,0,1,2,1,0,1,2,-2,-2,1,0,1,2,1,0,1,2,1,0,1,-2,0,1,2,1,0,1,2,1,0,1,-2,0,1,2,1,0,1,2,-2,-4,1,2,\
   1,-2,0,2,1,-4,0,1,2,-2,0,1,2,-2,1,0,-2,1,0,2,1,0,1,-6,2,1,2,1,0,-3,1,0,-4,1,2,1,-8,0,1,2,-4,1,0,-3,1,0,1,-10,2,-5,1,2,-6,1,3,-9,\
   2,1,2,-2,1,2,-7,1,-10,2,-11,1)
  -uncompress_rle[-1] --mirror[-1] x -z[-1] 1,100% -a[-2,-1] x
  _rlevel=255 _glevel=130 _blevel=233

#@gmic x_paint
#@gmic : Launch the interactive painter.
x_paint :
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ Interactive painter -----------------------\n
----\n
---- Use mouse to select color and brush.\n
---- Left button draws a colored stroke.\n
---- Right button fills a colored region.\n
---- Arrow keys or SPACE and BACKSPACE to swap\n
---- between available images.\n
---- Key 'S' to save snapshot of the current view.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
--------------------------------------------------"
  -v - -to_rgb
  -if {!@#} -i[0] 512,512,1,3,255 -nm[0] "[New image]" -else -k[0] -endif
  1 # Brush image [-1]
  -parallel "-_x_paint[]","-w[] 400,320,0,Palette -x_select_color[] __color,0,0,0" -k[0]
  -v +

_x_paint :

  # Init variables.
  -pass[-2,-1] 1 ({'@{-2,n}'}) -discard[-1] {'~'} -nm[-3] @{-1,t} -rm[-1]
  color=0,0,0
  saturation=1
  brushsize=3
  brushopacity=0
  brushangle=90
  brushthickness=1
  image=0
  refresh_image=1
  refresh_brush=1
  ox1=-1
  oy1=-1

  # Start user event loop.
  -do

    # Open/refresh brush window.
    -if $refresh_brush
      -rm[-1] (32,64;64,32) -r[-1] 16,16,1,3,1 -r[-1] {8*48},{4*48},1,3,0,2
      -repeat 4 -repeat 8
        -ellipse[-1] {48*$>+24},{48*@{>,-2}+24},{2*$>+1},{(2*$>+1)*$brushthickness},$brushangle,{1-@{>,-2}/4},255
      -done -done
      -rectangle[-1] {$brushsize*48},{$brushopacity*48},\
                     {$brushsize*48+47},{$brushopacity*48+47},\
                     1,0xFFFFFFFF,255,128,128
      {w},16,1,3 -line[-1] 0,50%,100%,50%,1,0x55555555,128,64,128
      bx={$brushangle*w/180}
      -rectangle[-1] {$bx-16},20%,{$bx+16},80%,1,128
      -line[-1] {$bx-16},20%,{$bx+16},20%,1,255 -line[-1] {$bx+16},20%,{$bx+16},80%,1,255
      -line[-1] {$bx-16},80%,{$bx+16},80%,1,64 -line[-1] {$bx-16},20%,{$bx-16},80%,1,64
      -a[-2,-1] y
      16,{h-16},1,3 -line[-1] 50%,0,50%,100%,1,0x55555555,128,64,128
      by={$brushthickness*(h-16)}
      -rectangle[-1] 20%,{$by-16},80%,{$by+16},1,128
      -line[-1] 20%,{$by-16},80%,{$by-16},1,255 -line[-1] 80%,{$by-16},80%,{$by+16},1,255
      -line[-1] 20%,{$by-16},20%,{$by+16},1,64 -line[-1] 20%,{$by+16},80%,{$by+16},1,64
      -a[-2,-1] x
      -w3[-1] {w},{h},0,"Brush"
      refresh_brush=0
    -endif

    # Open/refresh image window.
    -if $refresh_image
      -w1[$image] @{$image,w},@{$image,h},0,"Image "#$image" : "@{$image,b}.@{$image,x}
      refresh_image=0
    -endif

    # Manage user events.
    x1=@{!1,x} y1=@{!1,y}
    x2=@{!2,x} y2=@{!2,y}
    x3=@{!3,x} y3=@{!3,y}

    -if {$x1>=0}                        # Event in the image window.
      -if {@{!1,b}&1}                   # Left button -> draw brush stroke.
        ox1={if($ox1<0,$x1,$ox1)}
        oy1={if($oy1<0,$y1,$oy1)}
        delta={max(abs($x1-$ox1),abs($y1-$oy1))}
        r1={2*$brushsize+1}
        r2={$r1*$brushthickness}
        dx={2*($x1-$ox1)/max(1,$delta)}
        dy={2*($y1-$oy1)/max(1,$delta)}
        o={1-($brushopacity/4)^0.04}
        -repeat {max(1,($delta+1)/2)}
          -ellipse[$image] {$ox1+$>*$dx},{$oy1+$>*$dy},$r1,$r2,$brushangle,$o,$__color
        -done
        ox1=$x1 oy1=$y1
        refresh_image=1
      -else
        ox1=-1 oy1=-1
        -if {@{!1,b}&2}               # Right button -> fill region.
          -flood[$image] $x1,$y1,0,10,0,1,$__color
          refresh_image=1
        -endif
      -endif
    -endif

    -if {@{!1,ARROWRIGHT}" || "@{!2,ARROWRIGHT}" || "@{!3,ARROWRIGHT}" || "\  # Manage image selection.
         @{!1,ARROWUP}" || "@{!2,ARROWUP}" || "@{!3,ARROWUP}" || "\
         @{!1,SPACE}" || "@{!2,SPACE}" || "@{!3,SPACE}}
      image={($image+1)%(@#-2)} refresh_image=1
    -elif {@{!1,ARROWLEFT}" || "@{!2,ARROWLEFT}" || "@{!3,ARROWLEFT}" || "\
           @{!1,ARROWDOWN}" || "@{!2,ARROWDOWN}" || "@{!3,ARROWDOWN}" || "\
           @{!1,BACKSPACE}" || "@{!2,BACKSPACE}" || "@{!3,BACKSPACE}}
      image={($image-1)%(@#-2)} refresh_image=1
    -endif

    -if @{!1,S} -o[$image] gmic_paint.png -endif  # Save snapshot if requested.

    -if {@{!3,b}" && "$x3>=0}  # Manage brush selection.
      -if {$x3<384" && "$y3>=192} brushangle={$x3*180/(w-16)}   # Bottom slider -> select brush angle.
      -elif {$x3>=384" && "$y3<192} brushthickness={$y3/(h-16)} # Right slider -> select brush thickness.
      -elif {$x3<384" && "$y3<192} brushsize={int($x3*8/(w-16))} brushopacity={int($y3*4/(h-16))}
      -endif
      refresh_brush=1
    -endif
    -wait
    -while {@{!1}" && "!@{!1,Q}" && "!@{!1,ESC}}

  # Exit properly.
  __color=-1 -w1[] 0 -w2[] 0 -w3[] 0 -rm[-2,-1]

#@gmic x_plasma
#@gmic : Launch the plasma effect demo.
x_plasma :
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ Plasma effect --------------------\n
----\n
---- Keys 'CTRL+D' to double window size.\n
---- Keys 'CTRL+C' to reset window size.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------"
  -v - -l[]

  # Init plasma backgrounds.
  N=8
  -repeat $N
    256,150,1,3 -rand[-1] 0,255 -plasma[-1] 1,0,7 -n[-1] 0,255
    amp={?(-40,40)} freq={round(?(2,6))} dir$>={if(?<0.5,-1,1)*round(?(1,2))}
    100%,100%,1,1,'$amp*cos(y*2*pi*$freq/h)'
  -done

  {w+2},100%,1,1,'x' 100%,100%,1,1,'Y=(y-60+5*cos(x/30)+10*sin(x/15));if(Y<0||Y>=32,-1,Y)' -a[-2,-1] c
  0 -t[-1] "** Welcome to G\47MIC, a powerful image processing framework **",0,0,33,1,255
  -b[-1] 0.6 -n[-1] 0,255
  M={w}

  # Start animation loop.
  -w[] {1.5*@{0,w}},{1.5*@{0,h}},0,"[G\47MIC] Plasma effect"
  t=0 tt={-1.5*@{0,w}}
  -do
    tic=@|

    # Render interpolated background between two successive plasmas.
    a={int($t)}   a2={2*$a} a21={$a2+1}
    b={($a+1)%$N} b2={2*$b} b21={$b2+1}
    --warp[$a2] [$a21],1,0,2
    --warp[$b2] [$b21],1,0,2
    -j[-2] [-1],0,0,0,0,{$t-$a} -rm[-1]

    -shift[$a21] 0,${dir$a},0,0,2  # Animate plasma background.
    -shift[$b21] 0,${dir$b},0,0,2
    -if {int($t+0.005)>int($t)} dir$a={if(?<0.5,-1,1)*round(?(1,3))} -endif
    t={($t+(@|-$tic))%$N}

    # Render text scrolling.
    --z[-2] $tt,{$tt+w-1+2}
    -warp[-1] [-4],0,0,0
    -r[-1] 100%,100%,1,3
    --*[-1] -1 -+[-1] 255
    -j[-3] [-1],0,0,0,0,1,[-2],255 -rm[-1]
    -j[-2] [-1],-2,-2,0,0,1,[-1],255 -rm[-1]

    tt={$tt+(@|-$tic)*250} # Animate scrolling.
    -if {$tt>=$M} tt={-1.5*@{0,w}} -endif

    # Display rendered frame.
    -w[-1]
    -if {@{!,CTRLLEFT}&&@{!,D}} -w[] {3*w},{3*h} -elif {@{!,CTRLLEFT}&&@{!,C}} -w[] {1.5*w},{1.5*h} -endif
    -rm[-1] -wait 20
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -rm[{-2*$N-2}--1] -w[] 0 -endl -v +

#@gmic x_quantize_rgb : _nbcolors>=2
#@gmic : Launch the RGB color quantization demo.
x_quantize_rgb : -check "isint(${1=16}) && $1>1"
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ RGB Quantization --------------------------------------\n
----\n
---- This demo shows how RGB colors can be quantified using\n
---- the k-means algorithm.\n
----\n
---- Left mouse button on 3d view rotates the color cube.\n
---- Right mouse button on 3d view toggles colors/clusters mode.\n
---- Left mouse button on image toggles dithering mode,\n
---- Left mouse button on colormap adds a random color.\n
---- Right mouse button on colormap removes a color.\n
---- Key 'R' init colormap with random values.\n
---- Key 'U' init colormap with uniform sampling.\n
---- Key 'M' init colormap with median-cut algorithm.\n
---- Key 'SPACE' does a single iteration of k-means and pauses.\n
---- Key 'ENTER' runs k-means algorithm.\n
---- Keys 'CTRL+D' to double window size.\n
---- Keys 'CTRL+C' to reset window size.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
--------------------------------------------------------------"
  -v -
  -if {!@#} -testimage2d 300 -endif                                # Create synthetic image if no input images.
  -k[0] -to_rgb -if {h>300} -r2dy 300 -round 1 -endif -nm[-1] img  # Resize input image if necessary.
  --r {w*h},1,1,3,-1 -r[-1] {min(w,8192)},1,1,3 -nm[-1] colors     # Get reduced set of image colors.
  $1,1,1,3 -rand[-1] 0,255 -round[-1] 1 -nm[-1] centroids          # Initialize random centroids.
  -_x_quantize_rgb_3d (1,0,0,0;0,1,0,0;0,0,1,0) -nm[-1] pose3d     # Init 3d object.
  -_x_quantize_rgb_text "Colors",clustering0
  -_x_quantize_rgb_text "Clusters",clustering1
  -_x_quantize_rgb_text "Dithering: off",dithering0
  -_x_quantize_rgb_text "Dithering: on",dithering1
  -if {@{img,h}<300} --r2dy[img] 300,1 -else [img] -endif          # Generate visualization canvas.
  {w+315},365,1,3,255 -rm[-2]
  -rectangle[-1] 4,4,305,305,1,0xFFFFFFFF,0
  -rectangle[-1] 309,4,{w-5},305,1,0xFFFFFFFF,0
  -rectangle[-1] 4,309,{w-5},360,1,0xFFFFFFFF,0
  [-1],[-1]
  -rectangle[-1] 310,5,{w-6},305,1,1
  -rectangle[-1] 5,310,{w-6},360,1,2
  300,300,1,1,'(y<<11)+(x<<2)+3' -j[-2] [-1],5,5 -rm[-1]
  -a[-2,-1] c  -nm[-1] visu

  # Start k-means iterations.
  dithering=0 clustering=0 pause=1 s0=off s1=on
  -repeat 1e10

    # Create and display visualization.
    -if {!narg($visu_3d)} # Update 3d vizualization.
      ---[centroids] 2 --+[centroids] 2 -a[-2,-1] x -permute[-1] cxyz -y[-1] --[-1] 128
      -j[obj3d] [-1],0,8 -rm[-1]  # Update centroids position in 3d object.
      [obj3d]
      -if $clustering
        -if {@{colors,M}<256} --index[colors] [centroids] -*[-1] 256 -+[colors,-1] -endif # Estimate nearest centroids for all colors.
        --channels[colors] 0 ->>[-1] 8 -map[-1] 2 -permute[-1] cxyz -y[-1] -j[-2] [-1],0,{@{-2,h}-$_N-h} -rm[-1]
      -endif

      -pose3d[-1] @pose3d 300,300,1,3 -j3d[-1] [-2],50%,50%,100,1,2,0,0,300 -rm[-2]
      -j[-1] [clustering$clustering],2,0,0,0,1,[mclustering$clustering],255
      -nm[-1] visu_3d -j[visu] [visu_3d],5,5
    -endif

    -if {!narg($visu_img)} # Update indexed image.
      --index[img] [centroids],{0.7*$dithering},1 -if {h<300} -r2dy[-1] 300,1 -endif
      -j[-1] [dithering$dithering],2,0,0,0,1,[mdithering$dithering],255
      -nm[-1] visu_img -j[visu] [visu_img],310,5
    -endif

    -if {!narg($visu_centroids)} # Update colormap.
      --luminance[centroids] -a[-1] [centroids],y -sort[-1] +,x -rows[-1] 1 -r[-1] {@{visu,w}-10},50,1,3
      0 -t[-1] "Colors: "@{centroids,w},2,0,16,1,255,255,255 --dilate[-1] 3 -j[-3] [-2],2,2,0,0,1,[-1],255
      -rm[-2,-1] -nm[-1] visu_centroids -j[visu] [visu_centroids],5,310
    -endif
    -l[visu]
    -w -1,-1,0,"[G\47MIC] RGB quantization"
    -if {@{!,CTRLLEFT}&&@{!,D}} -w[] {2*w},{2*h} -elif {@{!,CTRLLEFT}&&@{!,C}} -w[] {w},{h} -endif
    -endl

    # Check for user's interactions.
    x={int(@{!,x}*@{visu,w}/@{!,w})}
    y={int(@{!,y}*@{visu,h}/@{!,h})}
    b=@{!,b}
    i=@{visu,($x,$y,0,3)}
    -if {$b&1" && "$i==1} # Toggle dithering.
      dithering={!$dithering} -rm[visu_img] -wait -1
    -elif {$b&1" && "$i==2} # Add new color.
      (@{-RGB}) -y[-1] c -a[centroids,-1] x  -_x_quantize_rgb_3d -rm[visu_3d,visu_img,visu_centroids] -and[colors] 255 pause=1 -wait 100
    -elif {$b&2" && "$i==2" && "@{centroids,w}>2} # Remove color.
      -r[centroids] {@{centroids,w}-1} -_x_quantize_rgb_3d -rm[visu_3d,visu_img,visu_centroids] -and[colors] 255 pause=1 -wait 100
    -elif {$b&2" && "$i>=3} # Toggle clusters/colors mode.
      clustering={!$clustering} -rm[visu_3d] -wait -1
    -elif @{!,M} # Init colormap with median-cut.
      --and[colors] 255 -colormap[-1] @{centroids,w},0,0 -rm[centroids] -nm[-1] centroids
      -_x_quantize_rgb_3d -rm[visu_3d,visu_img,visu_centroids] -and[colors] 255 pause=1 -wait -1
    -elif @{!,R} # Init colormap with random values.
      -rand[centroids] 0,255 -round[centroids] 1
      -_x_quantize_rgb_3d -rm[visu_3d,visu_img,visu_centroids] -and[colors] 255 pause=1 -wait -1
    -elif @{!,U} # Init colormap with uniform sampling.
      -uniform_distribution @{centroids,w},3 -*[-1] 255 -rm[centroids] -nm[-1] centroids
      -_x_quantize_rgb_3d -rm[visu_3d,visu_img,visu_centroids] -and[colors] 255 pause=1 -wait -1
    -elif @{!,ENTER} # Start k-means iterations.
      pause=0
    -elif {$b&1" && "$i>=3} # Manage 3d view rotation.
      coords={@{visu,($x,$y,0,3)}-3} u1={(($coords>>2)&511)-150} v1={($coords>>11)-150}
      -if {!narg($u0)} u0=$u1 v0=$v1 -endif
      -if {$u0!=$u1" && "$v0!=$v1}
        n0={sqrt(($u0)^2+($v0)^2)}
        nu0={if($n0>135,$u0*135/$n0,$u0)} nv0={if($n0>135,$v0*135/$n0,$v0)} nw0={sqrt(max(0,18225-($nu0)^2-($nv0)^2))}
        n1={sqrt(($u1)^2+($v1)^2)}
        nu1={if($n1>135,$u1*135/$n1,$u1)} nv1={if($n1>135,$v1*135/$n1,$v1)} nw1={sqrt(max(0,18225-($nu1)^2-($nv1)^2))}
        u={$nv0*$nw1-$nw0*$nv1} v={$nw0*$nu1-$nu0*$nw1} w={$nv0*$nu1-$nu0*$nv1} n={sqrt(($u)^2+($v)^2+($w)^2)}
        -rotation3d[] $u,$v,$w,{asin($n/18225)*180/pi} -mv[pose3d] @# -**[-2,-1] -nm[-1] pose3d
        u0=$u1 v0=$v1 -rm[visu_3d]
      -endif
    -elif {!($b&1)} u0=
    -endif

    -if {!$pause" || "@{!,SPACE}}  # Do one iteration of k-means.
      pause=@{!,SPACE}

      # Estimate new centroids positions.
      -and[colors] 255 --index[colors] [centroids] -*[-1] 256 -+[colors,-1]      # Estimate nearest centroids for all colors.
      -repeat @{colors,s}                                                        # Recompute centroid positions.
        -sh[colors] $>,$> --histogram[-1] {@{centroids,w}*256},0,{@{centroids,w}*256-1} -rm[-2]
        -i[-2] 256,1,1,1,'x' -r[-2] {w},1,1,1,0,2 -*[-2] [-1] -r[-2,-1] @{centroids,w},1,1,1,2 -max[-1] 0.01 -/[-2,-1]
      -done -a[-@{colors,s}--1] c
      -rm[centroids] -nm[-1] centroids

      # Re-assign ununsed centroids.
      -->>[colors] 8 -channels[-1] 0 -histogram[-1] @{centroids,w},0,{@{centroids,w}-1}
      cmax=@{-1,xM}
      -repeat {w} -if {!i($>)} -point[centroids] $>,0,0,1,@{-at[centroids]\ $cmax} -point[centroids] $>,0,0,-0.001,@{-RGB} -endif -done
      -rm[-1] -c[centroids] 0,255

      -if $visu_3d -rm[visu_3d] -endif
      -if $visu_img -rm[visu_img] -endif
      -if $visu_centroids -rm[visu_centroids] -endif
      -wait 20

    -else -if $visu_img -wait -endif
    -endif

  -if {!@!" || "@{!,Q}" || "@{!,ESC}} -break -endif
  -done
  -rm -w 0 -v +

 _x_quantize_rgb_3d :
  -if $obj3d -rm[obj3d] -endif
  --distribution3d[centroids] -circles3d[-1] 5 -col3d[-1] 255      # Pre-compute 3d object.
  -colorcube3d -p3d[-1] 1
  --and[colors] 255 -distribution3d[-1] -o3d[-1] 0.8 -+3d[-3--1]
  --3d[-1] 128,128,128 -nm[-1] obj3d _N={i[7]}

_x_quantize_rgb_text :
  0 -t[-1] "$1",0,0,16,1,255 -r[-1] {w+2},15,1,1,0,0,0.5,0.5 --dilate[-1] 3 -to_rgb[-2]
  -nm[-2] $2 -nm[-1] m$2

#@gmic x_reflection3d
#@gmic : Launch the 3d reflection demo.
x_reflection3d :
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ 3d reflection --------------------\n
----\n
---- Keys 'CTRL+D' to double window size.\n
---- Keys 'CTRL+C' to reset window size.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------"
  -v -

  # Render background.
  128,256,1,3 -rand[-1] 0,255 -plasma[-1] 1,100 -blur_xy[-1] 30,2
  -sh[-1] 0,0 -n[-1] 0,90 -rm[-1] -sh[-1] 1,1 -n[-1] 0,60 -rm[-1] -sh[-1] 2,2 -n[-1] 0,180 -rm[-1]
  --mirror[-1] x [-2,-1] -a[-4--1] x
  --luminance[-1] -mirror[-1] x -b[-1] 2 -n[-1] 0,255

  # Create 3d objects.
  -torus3d 30,10 -col3d[-1] 255,200,0
  -spherical3d 47,34,"80+20*abs(cos(2*theta))" -s3d[-1] -rm[-2] -i[-2] 3,{h},1,1,150,220,255,200,255,255 -y[-2] -a[-6--1] y
  -spherical3d 47,34,"100*abs(1+0.6*cos(3*phi)*sin(4*theta))"
  -r3d[-2,-1] 0,1,0,90 -db3d 0

  # Start animation loop.
  xb=0 xl=0 anim=0
  -w[] 256,256,0,"[G\47MIC] 3d reflection"
  -do

    tic=@|
    # Recreate 3d interpolated background object.
    --rows[-1] 8,{8+3*i[6]-1} --j[-3] [-1],0,8,0,0,{if($anim<250,0,0.5-0.5*cos(($anim-250)/100))} -rm[-2]

    # Render 3d background object (with flat colors).
    --z[-6] $xb,0,{$xb+255},255 -j3d[-1] [-2],75%,50%,0,1,3,0,0

    # Render light reflection map.
    --z[-6] $xl,0,{$xl+255},255
    xf={min(30,$anim-70)+20*cos(1.8*@|)}
    yf={50+20*sin(2.7*@|)}
    -j3d[-1] [-6],{20+$xf}%,$yf%,0,1,4,0,0

    # Add light reflection to 3d background object.
    -l3d [-1] -rm[-1] --j3d[-1] [-2],75%,50%,0,1,5,0,0 -j[-2] [-1],0,0,0,0,0.6 -rm[-3,-1]

    # Add 3d foreground object.
    -j3d[-1] [-4],$xf%,$yf%,0,1,4,0,0

    # Display frame and update animation variables.
    -w[-1]
    -if {@{!,CTRLLEFT}&&@{!,D}} -w[] {2*w},{2*h} -elif {@{!,CTRLLEFT}&&@{!,C}} -w[] {w},{h} -endif
    -rm[-1]
    xb={($xb+6)&255}
    xl={($xl-6)&255}
    anim={$anim+1}
    -r3d[-2,-1] {sin(0.5*@|)},{cos(@|)},1,{(@|-$tic)*33}
    -r3d[-3] -1,0.3,0.8,{(@|-$tic)*100}
    -wait 20
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -rm[-5--1] -w[] 0 -v +

#@gmic x_rubber3d
#@gmic : Launch the 3d rubber object demo.
x_rubber3d :
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ 3d rubber object -----------------\n
----\n
---- Keys 'CTRL+D' to double window size.\n
---- Keys 'CTRL+C' to reset window size.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------"
  -v - -rm
  -sphere3d 150,0 -torus3d 70,15 -cylinder3d 20,40
  -col3d[-3] 200,200,200,0.3 -col3d[-2] 128,200,76 -col3d[-1] 200,128,76
  -c3d[-3--1] -r3d[-1] 1,0,0,70 -+3d[-3--1] -+3d[-1] 10,-8,20
  256,256,64,3
  {w},{h},1,3,'if(c==0,x,if(c==1,y,y*@{1,d}/h))'
  {w},{h},1,3
  -w[] {w},{h},0,"[G\47MIC] 3d rubber object"
  frame=0
  -do
    {w},{h},1,3 -fc[-1] 16,32,32 -j3d[-1] [0],50%,50%,0,1,3,0,0 -j[1] [-1],0,0,$frame -rm[-1]
    -r3d[0] 0.1,1,0.6,{3*cos(@|*1.25)} -r3d[0] 1,0.2,0.6,-1
    --warp[1] [2],0,0 -*[3] 0.8 -*[-1] 0.2 -+[3,-1]
    -w[-1]
    -if {@{!,CTRLLEFT}&&@{!,D}} -w[] {2*w},{2*h} -elif {@{!,CTRLLEFT}&&@{!,C}} -w[] {w},{h} -endif
    -wait 20
    -sh[2] 2,2 --[-1] 1 -and[-1] {@{1,d}-1} -rm[-1]
    frame={($frame-1)%@{1,d}}
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -rm -w 0 -v +

#@gmic x_segment : _max_resolution={ 0 | >=128 }
#@gmic : Segment foreground from background in selected opaque RGB images, interactively.
#@gmic : Return RGBA images with binary alpha-channels.
#@gmic : Default value: 'max_resolution=1024'.
x_segment : -check "${1=1024}==0 || $1>=128"
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[^-1] "Extract foreground from background in image$? interactively, with maximum resolution $1."
  -e[] "\n
----------------------------------------------------------------------------------------------------\n
---- Left mouse button or key 'F' create a new foreground control point (or move an existing one).\n
---- Right mouse button or key 'B' create a new background control point (or move an existing one).\n
---- Mouse wheel, or keys 'CTRL+arrows UP/DOWN' zoom view in/out.\n
---- 'CTRL+mouse wheel', 'SHIFT+mouse wheel' or arrow keys move image in zoomed view.\n
---- Key 'SPACE' updates the extraction mask.\n
---- Key 'TAB' toggles background view modes.\n
---- Key 'M' toggles marker view modes.\n
---- Key 'BACKSPACE' deletes the last control point added.\n
---- Key 'PAGE UP' increases background opacity.\n
---- Key 'PAGE DOWN' decreases background opacity.\n
---- Keys 'CTRL+D' increase window size.\n
---- Keys 'CTRL+C' decrease window size.\n
---- Keys 'CTRL+R' reset window size.\n
---- Keys 'ESC', 'Q' or 'ENTER' exit the interactive window.\n
----------------------------------------------------------------------------------------------------"
  -v - -repeat @# -l[$>]

    # Init variables and images.
    name=@{0,n} title=@{0,b} -if {narg(@{0,x})} title=$title.@{0,x} -endif
    w={w} h={h} fdim=@{-fitscreen[]\ $w,$h} ww={arg(1,$fdim)} wh={arg(2,$fdim)} x0=0 y0=0 x1={w-1} y1={h-1}
    selection=-1 marker_mode=2 xpan=-1 ypan=-1 bg_mode=0 opacity=64
    -to_rgb -nm img

    -if {narg($_gimp_control_points)>=4}  ($_gimp_control_points) -r[-1] {w/4},4,1,1,-1 # Import list of control points from GIMP interface.
    -else 0 # Empty list of control points.
    -endif
    -nm[-1] points

    # Compute potential map.
    -if {$1>0} -if {$w>$h} --r2dx[img] {min($1,$w)},2 -else --r2dy[img] {min($1,$h)},2 -endif -else [img] -endif
    -_x_segment[-1]
    pw=@{potential,w} ph=@{potential,h}

    # Start event loop.
    -do

      # Handle user events for zoom/navigation/resizing.
      -wait
      x=@{!,x} y=@{!,y} b=@{!,b} o=@{!,-o}
      is_ctrl={@{!,CTRLLEFT}" || "@{!,CTRLRIGHT}}
      is_shift={@{!,SHIFTLEFT}" || "@{!,SHIFTRIGHT}}
      is_mouseout={$x<0" || "$y<0}
      x={$x0+$x*($x1-$x0+1)/$ww} y={$y0+$y*($y1-$y0+1)/$wh}
      oww=$ww owh=$wh ox0=$x0 oy0=$y0 ox1=$x1 oy1=$y1

      -if @{!,r} # When window resized.
        nww=@{!,d} nwh=@{!,e} m={min($nww,$nwh)}
        cx={($x0+$x1)/2} cy={($y0+$y1)/2} dx={$nww*($x1-$x0+1)/$ww} dy={$nwh*($y1-$y0+1)/$wh}
        x0={$cx-$dx/2} x1={$cx+$dx/2}
        y0={$cy-$dy/2} y1={$cy+$dy/2}
        ww=$nww wh=$nwh
      -elif {$is_ctrl" && "@{!,-D}} # Increase window size.
        nww={min(@{!,u},$ww*1.25)} nwh={min(@{!,v},$wh*1.25)} m={min($nww,$nwh)}
        -if {$m==$nww} ww=$m wh={$h*$m/$w} -else ww={$w*$m/$h} wh=$m -endif
      -elif {$is_ctrl" && "@{!,-C}} # Decrease window size.
        nww={$ww/1.25} nwh={$wh/1.25}
        -if {min($nww,$nwh)>=64} ww=$nww wh=$nwh -endif
      -elif {$is_ctrl" && "@{!,-R}} # Reset window size.
        fdim=@{-fitscreen[]\ $w,$h} ww={arg(1,$fdim)} wh={arg(2,$fdim)}
        x0=0 y0=0 x1={$w-1} y1={$h-1}
      -elif {($is_shift" && "$o<0)" || "@{!,ARROWLEFT}} # Go left.
        dx={($x1-$x0)/6} x0={$x0-$dx} x1={$x1-$dx}
      -elif {($is_shift" && "$o>0)" || "@{!,ARROWRIGHT}} # Go right.
        dx={($x1-$x0)/6} x0={$x0+$dx} x1={$x1+$dx}
      -elif {($is_ctrl" && "$o>0)" || "(@{!,ARROWUP}" && "!$is_ctrl)} # Go up.
        dy={($y1-$y0)/6} y0={$y0-$dy} y1={$y1-$dy}
      -elif {($is_ctrl" && "$o<0)" || "(@{!,ARROWDOWN}" && "!$is_ctrl)} # Go down.
        dy={($y1-$y0)/6} y0={$y0+$dy} y1={$y1+$dy}
      -elif {$o>0" || "($is_ctrl" && "@{!,ARROWUP})} # Zoom in.
        -if {$x1-$x0>16" && "$y1-$y0>16}
          cx={if($x>=0" && "!@{!,ARROWUP},$x,($x0+$x1)/2)}
          cy={if($y>=0" && "!@{!,ARROWUP},$y,($y0+$y1)/2)}
          x0={$cx+($x0-$cx)*0.75} y0={$cy+($y0-$cy)*0.75}
          x1={$cx+($x1-$cx)*0.75} y1={$cy+($y1-$cy)*0.75}
        -endif
      -elif {$o<0" || "($is_ctrl" && "@{!,ARROWDOWN})} # Zoom out.
        zfactor={max(($x1-$x0+1)/$w,($y1-$y0+1)/$h)}
        -if {$zfactor<1.3}
          cx={if($x>=0" && "!@{!,ARROWDOWN},$x,($x0+$x1)/2)}
          cy={if($y>=0" && "!@{!,ARROWDOWN},$y,($y0+$y1)/2)}
          x0={$cx+($x0-$cx)/0.75} y0={$cy+($y0-$cy)/0.75}
          x1={$cx+($x1-$cx)/0.75} y1={$cy+($y1-$cy)/0.75}
          dx={$zfactor^2*($w-$x0-$x1)/2} dy={$zfactor^2*($h-$y0-$y1)/2}
          x0={$x0+$dx} x1={$x1+$dx} y0={$y0+$dy} y1={$y1+$dy}
        -else
          dx={($w-$x0-$x1)/2} dy={($h-$y0-$y1)/2}
          x0={$x0+$dx} x1={$x1+$dx} y0={$y0+$dy} y1={$y1+$dy}
        -endif
      -elif {$b&4" && "!$is_mouseout} # Pan.
        -if {$panx<0" && "$pany<0} panx=$x pany=$y
        -else dx={round($panx-$x)} dy={round($pany-$y)} x0={$x0+$dx} y0={$y0+$dy} x1={$x1+$dx} y1={$y1+$dy}
        -endif
      -else panx=-1 pany=-1
      -endif
      -if {$ww!=$oww" || "$wh!=$owh" || "$ox0!=$x0" || "$oy0!=$y0" || "$ox1!=$x1" || "$oy1!=$y1} -rm[baseview] -endif

      # Handle events related to control points management.
      N=@{points,w}
      is_left_button={$b&1" || "@{!,F}} is_right_button={$b&2" || "@{!,B}} is_button={$is_left_button" || "$is_right_button}
      -if {narg($baseview)" && "$is_button" && "$x>=0" && "$y>=0" && "$x<$w" && "$y<$h}
        -if {$selection==-1" && "$N} # Check for selection of an existing point.
          ($x;$y) -r[-1] $N,2 --[-1] [points] -*[-1] {max($ww,$wh)/max($x1-$x0,$y1-$y0)} -sqr[-1] -s[-1] y -+[-2,-1]
          dmin={im} selection={if($dmin>25,-1,xm)} -rm[-1]
        -endif
        -if {$selection>=0}
          -if $marker_mode # Move existing point.
            --columns[points] $selection ox={i[0]} oy={i[1]}
            -=[-1] $x -=[-1] $y,0,1 -=[-1] {1+$is_left_button},0,3
            -j[points] [-1],$selection -rm[-1] -rm[view]
          -endif
        -else # Add new foreground or background point.
          ($x;$y;0;{1+$is_left_button}) -a[points,-1] x selection=$N -if {!$marker_mode} marker_mode=2 -endif -rm[view]
        -endif
      -else selection=-1
        -if {@{!,SPACE}" && "narg($labels)} -rm[labels] # Update labels.
        -elif @{!,TAB} bg_mode={($bg_mode+1)%6} -rm[baseview] -wait -1 # Toggle background view modes.
        -elif @{!,M} marker_mode={($marker_mode-1)%3} -rm[view] -wait -1 # Toggle markers view modes.
        -elif @{!,PAGEDOWN} opacity={max(0,$opacity-32)} -rm[baseview] -wait -1 # Decrease background opacity.
        -elif @{!,PAGEUP} opacity={min(255,$opacity+32)} -rm[baseview] -wait -1 # Increase background opacity.
        -elif {@{!,BACKSPACE}" && "$N} -if {$N>1} -z[points] 0,{$N-2} -else i=$points -rm[points] -i[$i] 0 -nm[$i] points -endif -rm[view] -wait -1 # Remove last point.
        -endif
      -endif

      # Manage zoomed view bounds.
      w2={round(($x1-$x0)/2)} h2={round(($y1-$y0)/2)}
      -if {$x0<-$w2} x1={$x1-$x0-$w2} x0=-$w2 -endif
      -if {$y0<-$h2} y1={$y1-$y0-$h2} y0=-$h2 -endif
      -if {$x1>=$w+$w2} x0={$w-1+$w2-$x1+$x0} x1={$w-1+$w2} -endif
      -if {$y1>=$h+$h2} y0={$h-1+$h2-$y1+$y0} y1={$h-1+$h2} -endif

      # Render labels.
      -if {!narg($labels)}
        N=@{points,w}
        -if {narg($view)} -text_outline[view] "Processing...",5,5,20,2 -w[view] -endif
        -if $N
          [points]
          -sh[-1] 0,0,0,0 -*[-1] {$pw/$w} -rm[-1]
          -sh[-1] 1,1,0,0 -*[-1] {$ph/$h} -rm[-1]
          -pointcloud[-1] -1,$pw,$ph -dilate[-1] 3
          -watershed[-1] [potential] --[-1] 1
        -else [potential],[potential],1,1,1
        -endif
        -nm[-1] labels
        -if {narg($baseview)} -rm[baseview] -endif
      -endif

      # Render base image.
      -if {!narg($baseview)}
        nx0={$x0*$pw/$w} ny0={$y0*$ph/$h}
        nx1={$x1*$pw/$w} ny1={$y1*$ph/$h}
        --z[img] $x0,$y0,$x1,$y1
        -r[-1] $ww,$wh,1,100%,{if($ww<w" && "$wh<h,2,1)}
        --z[labels] $nx0,$ny0,$nx1,$ny1
        -r[-1] $ww,$wh,1,100%,{if($ww<w" && "$wh<h,2,3)}
        -if {$bg_mode>=3} -*[-1] -1 -+[-1] 1 -endif
        -*[-1] {255-$opacity} -+[-1] $opacity -a[-2,-1] c
        -if {$bg_mode%3>=1} -i[-2] 100%,100%,1,3,{(($bg_mode-1)%3)*255} -blend[-2,-1] alpha
        -else -drgba[-1]
        -endif
        -nm[-1] baseview
        -if {narg($view)} -rm[view] -endif
      -endif

      # Render view.
      -if {!narg($view)}
        [baseview] -r[-1] 100%,100%,1,3
        -if $marker_mode
          -if {$marker_mode==2} rad1=5 rad2=3 opa=1 -else rad1=3 rad2=2 opa=0.8 -endif
          col0=255,0,0 col1=0,255,0
          -repeat @{points,w}
            --columns[points] $> x={(i[0]-$x0)*$ww/(1+$x1-$x0)} y={(i[1]-$y0)*$wh/(1+$y1-$y0)} l={i[3]-1} -rm[-1]
            -circle[-1] $x,$y,$rad1,1,0 -circle[-1] $x,$y,$rad2,$opa,${col$l}
          -done
        -endif

        -nm[-1] view
        -w[view] $ww,$wh,0,$title
      -endif

    -while {@!" && "!@{!,ESC}" && "!@{!,Q}" && "!@{!,ENTER}}

    # Recompute labels at full resolution.
    -if {narg($view)} -text_outline[view] "Processing fullres...",5,5,20,2 -w[view] -endif
    -k[img,points]
    N=@{points,w} status=
    -if $N
      status=@points
      [img] -_x_segment[-1] -pointcloud[points] -1,$w,$h
      zfact={@{img,max(w,h)}/@{potential,max(w,h)}} -dilate[points] {int(3*$zfact)}
      -watershed[points] [potential],1 --[points] 1 -k[img,points]
      -*[-1] 255
    -else -k[img] [img],[img],1,1,255
    -endif
    -a c -nm $name

  -endl -done
  -u $status   # Return control points of last image.
  -w 0 -v +

# Compute potential function.
_x_segment :
  -b[-1] 0.2% -gradient_norm[-1] -f[-1] '1/(1+i^2)'
  -nm[-1] potential

#@gmic x_select_color : _variable_name
#@gmic : Display a RGB or RGBA color selector.
#@gmic : Argument 'variable_name' specifies the variable that contains the selected color values (as R,G,B,[A]) at any time.
#@gmic : Its value specifies the initial selected color. Assigning '-1' to it forces the interactive window to close.
#@gmic : Default value: 'variable_name=xsc_variable'.
x_select_color : -skip ${1=xsc_variable}
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -v - -rm
  n={narg($$1)} -if {!$n} $1=0,0,0 -endif
  rgba_mode={$n>=4} R={arg(1,$$1)} G={arg(2,$$1)} B={arg(3,$$1)} A={if($rgba_mode,arg(4,$$1),255)}
  -v + -e[^-1] "Open "@{-arg\ 1+$rgba_mode,RGB,RGBA}" color selector widget, with variable '$1' and starting color "($$1)"." -v -
  -if {!@!} -w[] {400+24*$rgba_mode},400,0,"Select a color" -endif
  update_view=1 is_sv=0 is_h=0 is_a=0 colordb=0 is_thread_variable={arg(1,{'$1'})=={'_'}" && "arg(2,{'$1'})=={'_'}}

  # Manage color presets.
  -m "add_preset : -if {!narg($_xsc_preset$""1)} _xsc_preset$""1=$""2,$""3,$""4 -endif"
  -add_preset 0,0,0,0,0 -add_preset 1,255,255,255 -add_preset 2,255,0,0 -add_preset 3,0,255,0 -add_preset 4,0,0,255 -add_preset 5,255,255,0
  -add_preset 6,255,0,255 -add_preset 7,0,255,255 -add_preset 8,50,50,50 -add_preset 9,100,100,100 -add_preset 10,150,150,150 -add_preset 11,200,200,200
  -uncommand add_preset
  -if {!narg($_xsc_preset)} _xsc_preset=11 -endif
  ($R^$G^$B) -c[-1] 0,255 -rgb2hsv[-1] H={i[0]} S={i[1]} V={i[2]} -rm[-1]

  # Start event loop.
  -do
    w=@{!,d} h=@{!,e} x=@{!,x} y=@{!,y} b=@{!,b}

    # Update base image.
    -if {!@#}
      $w,$h,1,3,200
      -if $rgba_mode x1={w-89} y1={h-57} x2={w-80} -else x1={w-49} y1={h-57} x2={w-40} -endif
      x0=8 y0=8 x3={$x2+31} x4={w-40} x5={$x4+31} x6={max($x0+232+32*$rgba_mode,w-152)} y6={$y1+7}
      -rectangle {$x0-1},{$y0-1},{$x1+1},{$y1+1},1,0xFFFFFFFF,232 -line {$x0-1},{$y0-1},{$x1+1},{$y0-1},1,128 -line {$x0-1},{$y0-1},{$x0-1},{$y1+1},1,128
      (1;0) (0,1) -r[-2,-1] {$x1-$x0+1},{$y1-$y0+1},1,1,3 -i[-3] 100%,100%,1,1,$H -a[-3--1] c -hsv2rgb[-1] -j[-2] [-1],$x0,$y0 -rm[-1]
      -rectangle {$x2-1},{$y0-1},{$x3+1},{$y1+1},1,0xFFFFFFFF,232 -line {$x2-1},{$y0-1},{$x3+1},{$y0-1},1,128 -line {$x2-1},{$y0-1},{$x2-1},{$y1+1},1,128
      (359;0^1;1^1;1) -r[-1] {$x3-$x2+1},{$y1-$y0+1},1,3,3 -hsv2rgb[-1] -j[-2] [-1],$x2,$y0 -rm[-1]
      -if $rgba_mode
        -rectangle {$x4-1},{$y0-1},{$x5+1},{$y1+1},1,0xFFFFFFFF,232 -line {$x4-1},{$y0-1},{$x5+1},{$y0-1},1,128 -line {$x4-1},{$y0-1},{$x4-1},{$y1+1},1,128
        (1;0) -r[-1] {$x5-$x4+1},{$y1-$y0+1},1,4,3 -*[-1] 255 -drgba[-1] -j[-2] [-1],$x4,$y0 -rm[-1]
      -endif
      -t[-1] "Current",$x0,{$y1+12},14,1,0
      -if {narg($_xsc_old)}
        -t[-1] "Old",$x0,{$y1+34},14,1,0
        ($_xsc_old) -y[-1] c -r[-1] 48,16 -drgba[-1] -r[-1] {w+2},{h+2},1,3,0,0,0.5,0.5 -j[-2] [-1],{$x0+55},{$y1+32} -rm[-1]
      -endif
      -repeat 12
        (${_xsc_preset$>}) --[-1] 255 -r[-1] 4,1,1,1,0 -+[-1] 255
        -y[-1] c -r[-1] 18,18 -drgba[-1] -frame[-1] 1,1,{255*($>==$_xsc_preset)}
        -j[-2] [-1],{$x6+($>%6)*25},{$y6+($>>=6)*25} -rm[-1]
      -done
      update_view=1
    -endif

    # Update view.
    -if $update_view
      [-1]
      cx={$x0+$V*($x1-$x0)} cy={$y0+(1-$S)*($y1-$y0)}
      -if {$cx>$x0} -line[-1] {$cx-1},$y0,{$cx-1},$y1,1,200 -endif
      -if {$cx<$x1} -line[-1] {$cx+1},$y0,{$cx+1},$y1,1,200 -endif
      -if {$cy>$y0} -line[-1] $x0,{$cy-1},$x1,{$cy-1},1,200 -endif
      -if {$cy<$y1} -line[-1] $x0,{$cy+1},$x1,{$cy+1},1,200 -endif
      -line[-1] $x0,$cy,$x1,$cy,1,0 -line[-1] $cx,$y0,$cx,$y1,1,0
      cy={$y0+(359-$H)*($y1-$y0)/359}
      -if {$cy>$y0} -line[-1] $x2,{$cy-1},$x3,{$cy-1},1,200 -endif
      -if {$cy<$y1} -line[-1] $x2,{$cy+1},$x3,{$cy+1},1,200 -endif
      -line[-1] $x2,$cy,$x3,$cy,1,0
      -if $rgba_mode
        cy={$y0+(255-$A)*($y1-$y0)/255}
        -if {$cy>$y0} -line[-1] $x4,{$cy-1},$x5,{$cy-1},1,200 -endif
        -if {$cy<$y1} -line[-1] $x4,{$cy+1},$x5,{$cy+1},1,200 -endif
        -line[-1] $x4,$cy,$x5,$cy,1,0
      -endif
      ($H^$S^$V^$A) -sh[-1] 0,2 -hsv2rgb[-1] -rm[-1] -round[-1] R={i[0]} G={i[1]} B={i[2]}
      -r[-1] 48,16 -drgba[-1] -r[-1] {w+2},{h+2},1,3,0,0,0.5,0.5 -j[-2] [-1],{$x0+55},{$y1+10} -rm[-1]
      -t[-1] "HSV ("{round($H)}","{round($S*255)}","{round($V*255)}")",{$x0+115},{$y1+24},14,1,0
      -if $rgba_mode -t[-1] "RGBA ("$R","$G","$B","{round($A)}")",{$x0+115},{$y1+8},14,1,0
      -else -t[-1] "RGB ("$R","$G","$B")",{$x0+115},{$y1+8},14,1,0
      -endif
      ({'@{-dec2hex\ {$R*65536+$G*256+$B}}'}) --[-1] {'0'} -r[-1] 6,1,1,1,0,0,1,0 -+[-1] {'0'}
      -f[-1] if(i>={'a'}&&i<={'z'},i+{'A'}-{'a'},i)
      -t[-2] "HTML \#"@{-1,t},{$x0+115},{$y1+40},14,1,0 -rm[-1]
      -w[-1] 100%,100%,0 -rm[-1]
      -if $rgba_mode $1=$R,$G,$B,$A -else $1=$R,$G,$B -endif
      update_view=0
    -endif
    -if $is_thread_variable -wait 50 -else -wait -endif

    # Manage window size.
    ww=@{!,w} wh=@{!,h}
    is_ctrl={@{!,CTRLLEFT}||@{!,CTRLRIGHT}}
    -if @{!,r} ww=@{!,d} wh=@{!,e}
    -elif {$is_ctrl" && "@{!,-D}} ww={1.25*$ww} wh={1.25*$wh}
    -elif {$is_ctrl" && "@{!,-C}} ww={0.8*$ww} wh={0.8*$wh}
    -elif {$is_ctrl" && "@{!,R}} ww={400+24*$rgba_mode} wh=400
    -endif
    ww={max(200,$ww)} wh={max(200,$wh)}
    -if {$ww!=@{!,w}" || "$wh!=@{!,h}} -w[] $ww,$wh -rm -endif

    # Manage user events.
    -if {$b&1" && "$x>=0" && "$y>=0}
      -if {!$is_h" && "!$is_a" && "($is_sv" || "($x>=$x0" && "$x<=$x1" && "$y>=$y0" && "$y<=$y1))} # SV selection.
        S={max(0,min(1,1-($y-$y0)/($y1-$y0)))} V={max(0,min(1,($x-$x0)/($x1-$x0)))}
        update_view=1 colordb=0 is_sv=1 -k[0]
      -elif {!$is_sv" && "!$is_a" && "($is_h" || "($x>=$x2" && "$x<=$x3" && "$y>=$y0" && "$y<=$y1))} # H selection.
        H={max(0,min(359,359-($y-$y0)*359/($y1-$y0)))}
        colordb=0 is_h=1 -rm
      -elif {!$is_sv" && "!$is_h" && "($is_a" || "($x>=$x4" && "$x<=$x5" && "$y>=$y0" && "$y<=$y1))} # A selection.
        A={round(max(0,min(255,255-($y-$y0)*255/($y1-$y0))))}
        colordb=0 is_a=1 update_view=1 -k[0]
      -elif {!$is_sv" && "!$is_h" && "!$is_a" && "{narg($_xsc_old)}" && "$x>=$x0+55" && "$x<=$x0+102" && "$y>=$y1+32" && "$y<=$y1+47} # Old color.
        ($_xsc_old) -y[-1] c -sh[-1] 0,2 -rgb2hsv[-1] -rm[-1] H={i[0]} S={i[1]} V={i[2]} A={i[3]}
        colordb=0 -rm
      -elif {!$is_sv" && "!$is_h" && "!$is_a" && "$x>=$x6" && "$x<=$x5" && "$y>=$y6" && "$y<=$y6+50" && "($x-$x6)%25<=20" && "($y-$y6)%25<=20} # Preset.
        p={int(($x-$x6)/25)+6*int(($y-$y6)/25)} (${_xsc_preset$p}) --[-1] 255 -r[-1] 4,1,1,1,0 -+[-1] 255 -y[-1] c -sh[-1] 0,2 -rgb2hsv[-1] -rm[-1]
        H={i[0]} S={i[1]} V={i[2]} A={i[3]}
        colordb=0 -rm
      -elif {!$is_sv" && "!$is_h" && "!$is_a" && "$x>=$x0+55" && "$x<=$x0+102" && "$y>=$y1+10" && "$y<=$y1+27} # Add current as old and/or preset.
        _xsc_old=$R,$G,$B,$A colordb={($colordb+1)%2}
        -if {!$colordb} _xsc_preset$_xsc_preset=$R,$G,$B,$A _xsc_preset={($_xsc_preset-1)%12} -endif # Double-click to add to preset.
        -rm -wait -1
      -else colordb=0
      -endif
    -elif {!$b} is_sv=0 is_h=0 is_a=0
    -endif
    -if @{!,ARROWUP} colordb=0 S={min(1,$S+1/256)} update_view=1 -k[0] -wait -1
    -elif @{!,ARROWDOWN} colordb=0 S={max(0,$S-1/256)} update_view=1 -k[0] -wait -1
    -elif @{!,ARROWRIGHT} colordb=0 V={min(1,$V+1/256)} update_view=1 -k[0] -wait -1
    -elif @{!,ARROWLEFT} colordb=0 V={max(0,$V-1/256)} update_view=1 -k[0] -wait -1
    -elif @{!,PAGEUP} colordb=0 H={min(359,$H+1)} -rm -wait -1
    -elif @{!,PAGEDOWN} colordb=0 H={max(0,$H-1)} -rm -wait -1
    -endif

    # Check RGB variable modification from another thread.
    -if {$$1'=='-1} -break -endif  # Close request.
    -if {(($rgba_mode" && "{$$1'!='$R,$G,$B,$A})" || "(!$rgba_mode" && "{$$1'!='$R,$G,$B}))" && "$x<0" && "$y<0" && "!$is_sv" && "!$is_h" && "!$is_a}
      ($$1) -y[-1] c --[-1] 255 -r[-1] 1,1,1,4,0 -+[-1] 255 -sh[-1] 0,2 -rgb2hsv[-1] -rm[-1]
      H={i[0]} S={i[1]} V={i[2]} A={i[3]} -rm
    -endif

  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -rm -w 0
  -if $rgba_mode -u $R,$G,$B,$A -else -u $R,$G,$B -endif
  _xsc_old=@{}
  -v +

#@gmic x_select_function1d : _variable_name,_background_curve_R,_background_curve_G,_background_curve_B
#@gmic : Open an interactive window, where the user can defined its own 1d function.
#@gmic : If an image is selected, it is used to display additional informations :
#@gmic :   - The first row defines the values of a background curve displayed on the window (e.g. an histogram).
#@gmic :   - The 2nd, 3rd and 4th rows define the R,G,B color components displayed beside the X and Y axes.
#@gmic : Argument 'variable_name' specifies the variable that contains the selected function keypoints at any time.
#@gmic : Assigning '-1' to it forces the interactive window to close.
#@gmic : Default values: 'variable_name=xsf_variable', 'background_curve_R=220', 'background_curve_G=background_curve_B=background_curve_T'.
x_select_function1d : -skip ${1=xsf_variable},${2=220},${3=$2},${4=$2}
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[^-1] "Open 1d function widget, with variable name '$1'."
  -v -
  -if @# -k[0] -endif
  is_additional_data=@#
  -if {!@!} -w[] 400,400,0,"Create a 1d function" -endif
  reset_w=@{!,w} reset_h=@{!,h}
  -if {!narg($$1)} $1=0,0,100,100 -endif
  -i[points] ($$1) -y[-1] x -r[-1] 2,{w/2},1,1,-1
  is_thread_variable={arg(1,{'$1'})=={'_'}" && "arg(2,{'$1'})=={'_'}} selected=-1 X=-1 Y=-1
  -do

    # Update base view.
    -if {!narg($baseview)}
      {@{!,d}-48},{@{!,e}-48},1,3,255
      -if $is_additional_data  # Render background graph.
        100%,100% --rows[0] 0 -graph[-2] [-1],3,0,0,0,1,1 -rm[-1] -c[-1] 0,1
        --fc[-2] ${2-4} -j[-3] [-1],0,0,0,0,1,[-2] -rm[-2,-1]
      -endif
      -grid[-1] {(w-1)/8},{(h-1)/8},0,0,0.2,0xCCCCCCCC,0
      -line[-1] 0,100%,100%,0,0.2,0
       -frame[-1] 24,24,200
      -rectangle[-1] 23,23,{w-24},{h-24},1,0xFFFFFFFF,232 -line[-1] 23,23,23,{h-24},1,128 -line[-1] 23,23,{w-24},23,1,128
      -if {$is_additional_data" && "@{0,h}>1} # Render colored X-axis guide.
        -if {@{0,h}>2} --rows[0] 1,3 -else --rows[0] 1 -r[-1] 100%,3 -endif
        -r[-1] @{-2,w-48},3,1,1,3 -permute[-1] xzcy -r[-1] 100%,8 -frame[-1] 1,1,0
        -j[-2] [-1],23,@{-2,h-19} -rotate[-1] -90 -j[-2] [-1],@{-2,w-19},23 -rm[-1]
      -endif
      -nm[-1] baseview
      -l -rm[view] -onfail -endl
    -endif

    # Update view.
    -if {!narg($view)}
      --z[baseview] 24,24,@{baseview,w-25},@{baseview,h-25} -r[-1] 200%,200%

      # Draw curve.
      -function1d[] 1,@points
      -l[-1] -c 0,100 -transpose
        -i[0] ({'CImg3d'},{h},{h-1})
        -i[-2] 1,100%,1,1,y 1,100% -a[-3--1] x
        1,{h-1},1,1,2 --f[-1] y --+[-1] 1 -a[-3--1] x
        4,100%,1,1,1 -y -a y -col3d 0
      -endl
      -*3d[-1] @{-2,(w-1)/100},@{-2,(1-h)/100}
      -j3d[-2] [-1],0,100%,0,1,1,0,0 -rm[-1]

      # Draw control points.
      -repeat @{points,h}
        x=@{points,(0,$>)} y={100-@{points,(1,$>)}}
        -circle[-1] $x%,$y%,6,1,0xFFFFFFFF,0
      -done
      -if {$selected>=0}
        x=@{points,(0,$selected)} y={100-@{points,(1,$selected)}}
        -circle[-1] $x%,$y%,3,1,0
      -endif

      -r[-1] 50%,50%,1,3,2
      --j[baseview] [-1],24,24 -rm[-2]

      # Draw current coordinates.
      -if {$X>=0" && "$Y>=0} -t[-1] "X: "{min(255,round(255*$X/100))}" Y: "{min(round(255*$Y/100))},24,6,12,1 -endif
      -nm[-1] view
      -w[view]
    -endif

    -if $is_thread_variable -wait 50 -else -wait -endif

    # Manage user events.
    x=@{!,x} y=@{!,y} b=@{!,b} is_ctrl={@{!,CTRLLEFT}" || "@{!,CTRLRIGHT}}
    X={($x-24)*100/(@{!,w}-49)} Y={100-($y-24)*100/(@{!,h}-49)}
    oww=@{!,w} owh=@{!,h} ww=$oww wh=$owh
    -if @{!,r} ww=@{!,d} wh=@{!,e} # Resize window.
    -elif {$is_ctrl" && "@{!,-D}} ww=@{view,w*125%} wh=@{view,h*125%} # Increase window size.
    -elif {$is_ctrl" && "@{!,-C}} ww=@{view,w*75%} wh=@{view,h*75%} # Decrease window size.
    -elif {$is_ctrl" && "@{!,R}} ww=$reset_w wh=$reset_h # Reset window size.
    -elif {!$is_ctrl" && "@{!,R}} -rm[points] -i[points] (0,0;100,100) $1=@points -rm[view] # Reset keypoints.
    -elif {$b&3} # Add/move/delete point.
      is_inside={$X>=0" && "$Y>=0" && "$X<=100" && "$Y<=100}

      # Check for a point selection.
      -if {$selected<0} --f[points] 'sqrt((i-$X)^2+(j(1)-$Y)^2)*@{!,w}%' -z[-1] 0,0 selected={if(im>8,-1,ym)} -rm[-1] -endif

      -if {$x>=0" && "$b&1" && "$selected>=0} # Move an existing point.
        -if @{points,$selected>0" && "$selected<h-1}
          -=[points] @{points,max(min($X,i(0,$selected+1)-0.5),i(0,$selected-1)+0.5)},0,$selected
        -endif
        -=[points] {min(100,max(0,$Y))},1,$selected $1=@points -rm[view]
      -elif {$b&1" && "$is_inside} # Create new point.
        ($X,$Y) -a[points,-1] y -sort[points] +,y
        --f[points] 'sqrt((i-$X)^2+(j(1)-$Y)^2)*@{!,w}%' -z[-1] 0,0 selected={if(im>8,-1,ym)} $1=@points -rm[view,-1]
      -elif {$b&2" && "$selected>0" && "$selected<@{points,h-1}" && "$is_inside} # Delete an existing point.
        -l[points] -s y -rm[$selected] -a y -endl -wait -1 selected=-1 $1=@points -rm[view]
      -endif
    -elif {!($b&1)} selected=-1
    -endif

    # Manage window size.
    ww={min(90%*@{!,u},max(200,$ww))}
    wh={min(90%*@{!,v},max(200,$wh))}
    -if {$oww!=$ww" || "$owh!=$wh} -w[] $ww,$wh -rm[baseview,view] -endif

    # Check points variable modification from another thread.
    -if {$$1'=='-1} -break -endif # Close request.
    -if {$$1'!='@points} -rm[points] -i[points] ($$1) -y[-1] x -r[-1] 2,{w/2},1,1,-1 -l -rm[view] -onfail -endl -endif # Keypoints changed.

  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -w[] 0 -u @points
  -if $is_additional_data -rm[^0] -else -rm -endif
  -v +

#@gmic x_select_palette : _variable_name,_number_of_columns= { 0=auto | >0 }
#@gmic : Open a RGB or RGBA color selector widget from a palette.
#@gmic : The palette is given as a selected image.
#@gmic : Argument 'variable_name' specifies the variable that contains the selected color values (ad R,G,B,[A]) at any time.
#@gmic : Assigning '-1' to it forces the interactive window to close.
#@gmic : Default values: 'variable_name=xsp_variable' and 'number_of_columns=2'.
x_select_palette : -skip ${1=xsp_variable},${2=0}
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -if {!@#} -error[0--3] "Command '-x_select_palette': Missing specified palette image." -endif
  -v - -k[0] --r {w*h*d},1,1,{s},-1 -to_color[-1] rgba_mode={s==4} -to_rgba[-1] -nm[-1] palette -v +
  -e[^-1] "Open "@{-arg\ 1+$rgba_mode,RGB,RGBA}" color selector widget for palette$?, with variable name '$1'."
  -v -
  -if {w>1024} -v + -error[0--3] "Command 'x_select_color': Too much colors ("{w}") in selected palette." -endif
  -if {!@!} -w[] 400,400,0,0,-1,-1,"Palette: "@{0,b} -endif

  selected=-1 oselected=-1
  -do
    ww=@{!,w} wh=@{!,h}
    R=@{palette,round(i($selected,0,0,0))} G=@{palette,round(i($selected,0,0,1))}
    B=@{palette,round(i($selected,0,0,2))} A=@{palette,round(i($selected,0,0,3))}

    # Update color in specified variable.
    -if {$selected>=0" && "$oselected!=$selected}
      -if $rgba_mode $1=$R,$G,$B,$A -else $1=$R,$G,$B -endif
    -endif

    # Check close request from external thread.
    -if {$$1'=='-1} -break -endif

    # Create base view.
    -if {!narg($baseview)} -l[palette]
      {w},1,1,1,x -+[-1] 1
      -s[-1] x -append_tiles[^0] $2
      M={w} N={h} 100%,100%,1,1,1
      --r[-1] {$ww-17},100%,1,1,4
      -r[-2] 100%,{$wh-57},1,1,4
      -r[-2,-1] [-1],[-2] -or[-2,-1]
      -line[-1] 100%,0,100%,100%,1,1
      -line[-1] 0,100%,100%,100%,1,1
      --[-1] 1 -*[-1] -1
      -r[-2] [-1],[-1],1,1,1 --[-2] 1
      --map[-2] [0],0 -drgba[-1]
      -rv[-2,-1] -*[-2,-1]
      --!=[-2] -1 -dilate[-1] 3
      -mv[-3] @# -+[-1] 1 -a[-3--1] c
      -nm[-1] baseview
    -endl
    -if {narg($view)} -rm[view] -endif
    -endif

    # Create and display view.
    -if {!narg($view)}
      $ww,$wh,1,3,200
      -if {$selected<0} -sh[baseview] 0,2
      -else
        --channels[baseview] 0,2 --channels[baseview] 4,4
        -!=[-1] {$selected+1} -rectangle[-1] 0,0,100%,100%,1,0xFFFFFFFF,1
        --dilate[-1] 5 --[-2,-1] -*[-1] -1 --dilate[-1] 5 -*[-2] 255
        -r[-2] 100%,100%,1,3 -j[-3] [-2],0,0,0,0,1,[-1] -rm[-2,-1]
        -if $rgba_mode -t[-2] "RGBA ("$R","$G","$B","$A")",8,{$wh-45},14,1,0
        -else -t[-2] "RGB ("$R","$G","$B")",8,{$wh-45},14,1,0
        -endif
        ($R^$G^$B) -rgb2hsv[-1] H={round(i[0])} S={round(i[1]*255)} V={round(i[2]*255)} -rm[-1]
        -t[-2] "HSV ("$H","$S","$V")",8,{$wh-31},14,1,0
        ({'@{-dec2hex\ {$R*65536+$G*256+$B}}'}) --[-1] {'0'} -r[-1] 6,1,1,1,0,0,1,0 -+[-1] {'0'}
        -f[-1] if(i>={'a'}&&i<={'z'},i+{'A'}-{'a'},i)
        -t[-3] "HTML \#"@{-1,t},8,{$wh-17},14,1,0 -rm[-1]
      -endif
      -sh[baseview] 3,3 -j[-3] [-2],8,8,0,0,1,[-1] -rm[-2,-1]
      -nm[-1] view -w[view]
    -endif

    -if {arg(1,{'$1'})=={'_'}" && "arg(2,{'$1'})=={'_'}} -wait 50 -else -wait -endif

    # Manage window size.
    is_ctrl={@{!,CTRLLEFT}||@{!,CTRLRIGHT}}
    -if @{!,r} ww=@{!,d} wh=@{!,e}
    -elif {$is_ctrl" && "@{!,-D}} ww={1.25*$ww} wh={1.25*$wh}
    -elif {$is_ctrl" && "@{!,-C}} ww={0.8*$ww} wh={0.8*$wh}
    -elif {$is_ctrl" && "@{!,R}} ww=400 wh=400
    -endif
    ww={max(200,$ww)} wh={max(200,$wh)}
    -if {($ww!=@{!,w}" || "$wh!=@{!,h})" && "narg($baseview)} -w[] $ww,$wh -rm[baseview] -endif

    # Handle user events.
    oselected=$selected
    -if {narg($baseview)}
      x=@{!,x} y=@{!,y} b=@{!,b}
      -if {$b&1" && "$x>=0" && "$y>=0}  # Select color.
        -if @{baseview,i($x-8,$y-8,0,4)} selected=@{baseview,i($x-8,$y-8,0,4)-1} -else selected=-1 -endif
        -rm[view] -wait -1
      -elif {@{!,ARROWUP}" && "$selected>=$M} selected={$selected-$M} -rm[view] -wait -1
      -elif {@{!,ARROWDOWN}" && "$selected<@{0,w-$M}} selected={$selected+$M} -rm[view] -wait -1
      -elif {@{!,ARROWRIGHT}" && "$selected<@{0,w-1}} selected={$selected+1} -rm[view] -wait -1
      -elif {@{!,ARROWLEFT}" && "$selected>0} selected={$selected-1} -rm[view] -wait -1
      -endif
    -endif

  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -w 0 -k[0]
  -if {$selected>=0} -if $rgba_mode -u $R,$G,$B,$A -else -u $R,$G,$B -endif -else -u -1 -endif
  -v +

#@gmic x_shadebobs
#@gmic : Launch the shade bobs demo.
x_shadebobs :
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ Shade bobs -------------------------------\n
----\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-------------------------------------------------"
  -v - -rm t=100 -w 512,512,0,"[G\47MIC] Shade bobs"

  # Start animation loop.
  -do
    t={$t+0.015}
    -if {$t>4*pi" || "@{!,b}} # Reset motions variables if necessary.
      rx={?(-1,1)} ry={?(-1,1)} rz={?(-1,1)} rt={?(-1,1)} rcx={?(-0.6*0.6)} t=0
      N={20+round(?(80))} R={(2+round(?(40)))*min(@{!,w},@{!,h})/300}
      -if $obj3d -rm[colormap,img,obj3d] -endif
      {4+round(?(12))},1,1,3 -noise[0] 255,2 -r[0] 256,1,1,3,3 -*[0] 255 -shift[0] 1 -nm[-1] colormap
      (67.5;73.5;109.5;103.5;51.5;100.5;{2*$N};$N) 3,{2*$N},1,1,0
      1,$N,1,1,5 2,$N,1,1,'y+x*$N' -a[-2--1] x -z[-1] 0,5
      4,$N,1,1,1 -y[-3--1] -a[-4--1] y -nm[-1] obj3d
      @{!,w},@{!,h} -nm[-1] img
      -wait -1
    -endif

    # Compute bobs coordinates.
    r={$ry+$rx*cos(6*$rz*$t)+(1-$rx)*sin(6*$rt*$t)}
    (0;{30*$ry*($N-1)}) ($t;{2*pi*($N-1)/$N+$t}) -r[-2,-1] 1,$N,1,1,3
    -+[-2] {360*sin($rz*$t)} -*[-2] {pi/180}
    --sin[-2,-1] -cos[-4,-3] -*[-4,-2] $r -*[-3,-1] $rcx -+[-4,-3] -+[-2,-1]
    -*[-2] {@{!,w}/2} -*[-1] {@{!,h}/2} -a[-2,-1] x
    --+[-1] $R --[-2] $R -a[-2,-1] y -z[-1] 0,2 -y[-1] -j[obj3d] [-1],0,8 -rm[-1]

    # Draw bobs, map colors and display.
    -j3d[img] [obj3d],50%,50%,0,-1,2,0,0
    -and[img] 255 --map[img] [colormap] -w[-1] -rm[-1] -wait 20
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -rm -w 0 -v +

#@gmic x_spline
#@gmic : Launch spline curve editor.
x_spline :
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ Spline curve editor --------------------------\n
----\n
---- Mouse to insert/move/delete points.\n
---- Key 'R' to reset the curve.\n
---- Key 'SPACE' to shows/hide spline curve.\n
---- Key 'P' to shows/hide control points.\n
---- Key 'ENTER' to shows/hide control polygon.\n
---- Key 'T' to shows/hide point tangents.\n
---- Key 'I' to shows/hide point indices.\n
---- Key 'C' to shows/hide point coordinates.\n
---- Keys '+' and '-' to increase/decrease roundness.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------------------"

  # Init display and variables.
  -v -
  -if @# -a x -n 0,255 -to_rgb -else (0;0^0;128^0;0) -r[-1] 512,512,1,3,3 -name[-1] "[G\47MIC] Spline Editor" -endif
  -w[0] @{0,w},@{0,h},0,0,-1,-1,@{-1,n} -r[0] @{!,w},@{!,h},1,3,1
  -i[1] 1        # Point coordinates
  roundness=0.5  # Curve roundness
  visuflags=23   # Visualisation flags
  nearest=-1     # Nearest point
  active=-1      # Active point

  # Start event loop.
  -do

    # Init coordinates [1] if necessary.
    -if {@{1,#}==1}
      -rm[1] roundness=0.5 nearest=-1 active=-1
      -i[1] ({0.2*w},{0.2*h};\
             {0.2*w},{0.8*h};\
             {0.8*w},{0.8*h};\
             {0.8*w},{0.2*h})
    -endif

    # Estimate screen-normalized coordinates [2], curve tangents [3] and tangent orientations [4].
    [1] ({@{!,w}/@{0,w}},{@{!,h}/@{0,h}}) -*[-2,-1]                        # Normalized coordinates.
    --shift[2] 0,-1,0,0,2 --shift[2] 0,1,0,0,2 --[-2,-1] -*[-1] $roundness # Curve tangents.
    --s[-1] x -sqr[-2,-1] -+[-2,-1] -sqrt[-1] -r[-1] 2 --/[-2,-1] -rm[-2]  # Tangent orientations.

    # Display curve, control points, polygon and tangents.
    --r[0] @{!,w},@{!,h},1,3
    -if {$visuflags&4} -polygon[-1] @{2,h},@2,0.3,128,200,255 -endif
    -repeat @{1,h}
      -line[-1] @{2,0-3},0.3,255,255,0
      -if {$visuflags&1} -spline[-1] @{2,0-1},@{3,0-1},@{2,2-3},@{3,2-3},32,1,255 -endif
      -if {$visuflags&8} -line[-1] {@{2,0}-@{4,0}*20},{@{2,1}-@{4,1}*20},{@{2,0}+@{4,0}*20},{@{2,1}+@{4,1}*20},1,0,255,0 -endif
      -if {$visuflags&16} -t[-1] $>,{@{2,0}-3},{@{2,1}-18},13,1,255,255,0 -endif
      -if {$visuflags&32} -t[-1] "("{round(@{1,0})}","{round(@{1,1})}")",{@{2,0}-16},{@{2,1}+10},13,1,100,200,255 -endif
      -shift[1-4] 0,-1,0,0,2
    -done
    -if {$visuflags"&2"} -repeat @{1,h}
      -ellipse[-1] @{2,0-1},4,4,0,1,0,0,0 -ellipse[-1] @{2,0-1},2,2,0,1,255,100,155 -shift[2] 0,1,0,0,2
    -done -endif
    -w[-1] -rm[3,4,-1] -wait

    # Handle key events.
    -if @{!,SPACE} visuflags={$visuflags+if($visuflags&1,-1,1)} -wait -1 -endif  # Show/hide spline.
    -if @{!,P} visuflags={$visuflags+if($visuflags&2,-2,2)} -wait -1 -endif      # Show/hide points.
    -if @{!,ENTER} visuflags={$visuflags+if($visuflags&4,-4,4)} -wait -1 -endif  # Show/hide polygon.
    -if @{!,T} visuflags={$visuflags+if($visuflags&8,-8,8)} -wait -1 -endif      # Show/hide tangents.
    -if @{!,I} visuflags={$visuflags+if($visuflags&16,-16,16)} -wait -1 -endif   # Show/hide indices.
    -if {@{!,C}" && "!@{!,CTRLLEFT}" && "!@{!,CTRLRIGHT}} visuflags={$visuflags+if($visuflags&32,-32,32)} -wait -1 -endif # Show/hide coordinates.
    -if {@{!,PADADD}" && "$roundness<1} roundness={$roundness*1.1} -wait -1 -endif    # Increase roundness.
    -if {@{!,PADSUB}" && "$roundness>0.1} roundness={$roundness*0.9} -wait -1 -endif  # Decrease roundness.
    -if {@{!,R}" && "!@{!,CTRLLEFT}" && "!@{!,CTRLRIGHT}} -rm[-1] -i[1] 1 -wait -1 -endif # Reset curve.
    -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,D}} -w[] {@{!,w}*1.5},{@{!,h}*1.5} -endif # Increase window size.
    -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,C}} -w[] {@{!,w}/1.5},{@{!,h}/1.5} -endif # Decrease window size.
    -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,R}} -w[] @{0,w},@{0,h} -endif             # Reset window size.
    -if @{!,r} -w[] -endif # Resize window if necessary.

    # Set/unset active point.
    -if {@{!,b}==0} active=-1                                   # Unset active point if mouse button is released.
    -elif {@{!,x}>=0" && "@{!,b}" && "$active==-1}              # Find new active point.
      [2] (@{!,x},@{!,y}) --[-2,-1] -sqr[-1] -s[-1] x -+[-2,-1] # Compute distance vector to points.
      (@{-1,c}) nearest=@{-1,1} -rm[-1]                         # Set nearest point.
      -if {@{-1,m}<64} active=$nearest -endif                   # Set it as active point, if near enough.
      -rm[-1]
    -endif
    -rm[2]

    # Move active point.
    -if {@{!,b}&1" && "@{!,x}>=0" && "$active!=-1}
      -=[1] {@{!,x}*@{0,w}/@{!,w}},0,$active
      -=[1] {@{!,y}*@{0,h}/@{!,h}},1,$active

    # Delete nearest point.
    -elif {@{!,b}&2" && "@{!,x}>=0" && "@{1,h}>3}
      -l[1] -s y -rm[$nearest] -a y -endl -wait -1

    # Insert new active point.
    -elif {@{!,b}&1" && "@{!,x}>=0}
      xy=({@{!,x}*@{0,w}/@{!,w}},{@{!,y}*@{0,h}/@{!,h}})              # Point coordinates in the image basis.
      --shift[1] 0,-1,0,0,2 -+[-1] [1] -/[-1] 2                       # Compute center of segments.
      $xy --[-2,-1] -sqr[-1] -s[-1] x -+[-2,-1]                       # Compute distance vector to segments.
      (@{-1,c}) ns=@{-1,1} -rm[-2,-1]                                 # Get nearest segment.
      -l[1] -s y -i[{$ns+1}] $xy -a y -endl                           # Insert new point at right position.
      active={$ns+1}                                                  # Set new active point as newly inserted.
    -endif

  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}

  # Render spline as a tertiary mask for output.
  --shift[1] 0,-1,0,0,2 --shift[1] 0,1,0,0,2 --[-2,-1] -*[-1] $roundness
  [0],[0],1,1,2 -rm[0]
  -repeat @{1,h} -spline[-1] @{0,0-1},@{1,0-1},@{0,2-3},@{1,2-3},128,1,1 -shift[0] 0,-1,0,0,2 -shift[1] 0,-1,0,0,2 -done
  -flood[-1] 0,0,0,0,0,1,0

  # Exit properly.
  -rm[0,1] -w 0 -v +

#@gmic x_tetris
#@gmic : Launch tetris game.
x_tetris :
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ Tetris --------------------------------------------\n
----\n
---- This is a G\47MIC implementation of the Tetris game.\n
----\n
---- Arrow keys to move/rotate the triominos.\n
---- Key 'SPACE' to make the current triomino falling.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
----------------------------------------------------------"
  -v - -rm

  # Init board and triominos shapes.
  -i[m0] 4,1,1,1,1,1,1,1
  -i[m4] 3,2,1,1,1,0,0,1,1,1
  -i[m8] 3,2,1,1,0,0,1,1,1,1
  -i[m12] 2,2,1,1,1,1,1,1
  -i[m16] 3,2,1,1,0,1,1,1,1,0
  -i[m20] 3,2,1,1,0,1,0,1,1,1
  -i[m24] 3,2,1,1,1,1,0,0,1,1
  -if {?<0.25}  # Enable extended set.
    -i[m28] 2,1,1,1,1,1
    -i[m32] 2,2,1,1,1,1,0,1
    -i[m36] 3,1,1,1,1,1,1
    -i[m40] 1,1,1,1,1
    -i[m44] 3,2,1,1,1,1,1,1,0,1
    -i[m48] 3,3,1,1,1,1,1,1,0,1,1,1,1
  -endif
  -repeat @# i={4*$>} -l[m$i] -repeat 3 --rotate[0] {90*($>+1)} -nm[-1] m{$i+$>+1} -done -endl -done
  N=@#

  # Render triomino colored sprites.
  -i[colors] 3,$N,1,1,'?(16,224)' -r[-1] 3,400% -i[mask] (0,-1,0;1,0,-1;0,1,0) -*[-1] 120
  -repeat $N
    --r[m$>] 500%,500%,1,3 --correlate[-1] [mask],0 -r[-1] 200%,200%,1,1,3 -r[-2] [-1] -*[-2,-1] -c[-1] 30%,100%
    --r[m$>] [-1],[-1],1,3 --replace_color[-1] 0,0,1,1,1,@{colors,{3*$>}-{3*$>+2}} -rv[-3,-1] -+[-3,-1] -c[-2] 0,255
    -channels[-1] 0 -*[-1] 255 -a[-2,-1] c -nm[-1] s$>
  -done
  -rm[colors,mask]
  fact={@{s0,w}/@{m0,w}}

  # Generate board and background.
  W=12 H=20
  -i[board] $W,$H -i[curr_board] [board]
  -i[render] {$fact*$W},{$fact*$H},1,3 -i[curr_render] [render] --channels[-1] 0 -nm[-1] curr_render_mask
  --rows[render] 0,50% -plasma[-1] 1,2 -noise[-1] 20 -blur_y[-1] 40%,1 --mirror[-1] y -a[-2,-1] y -r[-1] [render]
  -n[-1] 0,64 -blur_x[-1] 1 100%,100% -noise[-1] 0.5,2 -b[-1] 1 -*[-1] 300 -+[-2,-1] -c[-1] 0,255 -nm[-1] background

  # Start game.
  time=@| score=0 fall_mode=0 gameover=0 n=-1 nn={round(?(0,$N-1))}
  -do
    -wait {if($fall_mode,-1,-20)}

    # In case of game over.
    -if $gameover
      --j[background] [curr_render],0,0,0,0,0.7,[curr_render_mask],255
      -text_outline[-1] "Game\nOver!",30,30%,32,2,1,255 -w[-1] -rm[-1]
      -continue
    -endif

    # Check for completed lines and select new random triomino.
    -if {$n<0}
      -l[board] -s y i=-1 -repeat @# -if @{$<,m} i=$<,$i -endif -done
      0 -rm[$i] -a y score={$score+2^(narg($i)-1)-1} -r $W,$H,1,1,0,0,0,1 -nm board -endl
      -if {narg($i)>1} -l[render] -s y,$H 0 -rm[$i] -a y -r {$fact*$W},{$fact*$H},1,3,0,0,0,1 -nm render -endl -endif
      n=$nn nn={round(?(0,$N-1))} x={$W/2} y=0 do_render=1 fall_mode=0
    -endif

    # Render board at current time.
    -if $do_render
      -rm[curr_board,curr_render,curr_render_mask]
      -i[curr_board] [board] -j[curr_board] [m$n],{$x-int(@{m$n,w}/2)},$y,0,0,1,[m$n]
      -i[curr_render] [render] -sh[s$n] 3,3 -j[curr_render] [s$n],{$fact*($x-int(@{m$n,w}/2))},{$fact*$y},0,0,1,[-1],255 -rm[-1]
      --*[curr_board] 255 -r[-1] [curr_render],[curr_render] -nm[-1] curr_render_mask
      0 -t[-1] "Score : "$score"    Next :",4,0,32,1,164 -r[-1] 40%,40%,1,3,2 --!=[-1] 0 -*[-1] 255
      -j[curr_render] [-2],0,0,0,0,1,[-1],255 -j[curr_render_mask] [-1],0,0,0,0,1,[-1],255 -rm[-2,-1]
      --*[m$nn] 196 -r[-1] 300%,300%,1,3 -j[curr_render,curr_render_mask] [-1],{@{curr_render,w}-w-4},3,0,0,1,[-1],196 -rm[-1]
      do_render=0
    -endif

    --shift[background] 0,{-13*@|*1.04^$score},0,0,2
    -j[-1] [curr_render],0,0,0,0,1,[curr_render_mask],255
    -w[-1] {2*w},{2*h},0,"[G\47MIC] Tetris" -rm[-1] -cursor[0] 0

    # Manage user interactions.
    -if @{!,SPACE} fall_mode=1 -endif
    -if {@{!,ARROWUP}" || "@{!,ARROWLEFT}" || "@{!,ARROWRIGHT}}
      an={if(@{!,ARROWUP},n=$n+1;if(n%4,n,n-4),$n)}
      nx={w2=int(@{m$an,w}/2);max(w2,min($x-@{!,ARROWLEFT}+@{!,ARROWRIGHT},$W-(@{m$an,w}%2)-w2))}
      --j[board] [m$an],{$nx-int(@{m$an,w}/2)},$y,0,0,-1,[m$an]
      -if {@{-1,M}==1} x=$nx n=$an -endif
      -rm[-1]
      do_render=1
    -endif

    -if {@{!,ARROWDOWN}" || "@|-$time>0.9^int($score/2)" || "$fall_mode}   # Piece goes down.
      y={$y+1}
      --j[board] [m$n],{$x-int(@{m$n,w}/2)},$y,0,0,-1,[m$n]
      -if {@{-1,M}>1" || "$y+@{m$n,h}>$H}
        -if {$y<=1} gameover=1 -endif  # Game over!
        -j[board] [curr_board] -j[render] [curr_render] n=-1
      -endif
      -rm[-1]
      time=@| do_render=1
    -endif

  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -rm -w 0 -v +

#@gmic x_tictactoe
#@gmic : Launch tic-tac-toe game.
x_tictactoe :
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ Tic-Tac-Toe game -----------------\n
----\n
---- Use mouse to select positions of the\n
---- symbols. Close window to exit game.\n
----\n
-----------------------------------------"
  -v -                            # Become quiet.

  # Allocate variables.
  message=0                       # [-7] : State message.
  counter=0                       # [-6] : Turn counter (0 to 8).
  player=0                        # [-5] : Current player (0 or 1).
  state=0                         # [-4] : Board state.
  tmp3=0                          # [-3] : Temporary variable 3.
  tmp2=0                          # [-2] : Temporary variable 2.
  tmp1=0                          # [-1] : Temporary variable 1.
  -_x_tictactoe2                  # Generate board.
  -w[-1] -1,-1,0," "              # Init display window.

  # Start main loop.
  -do

    # Set state message depending on the current player.
    -if $player message="Tic-Tac-Toe (O to play)"
    -else message="Tic-Tac-Toe (X to play)"
    -endif

    # Select position by the user.
    -do                                                                       # Enter event loop.
      -w[] {w},{h},0,"[G\47MIC] "$message -wait                                 # Wait for events and force window size if necessary.
      -if {!@!" || "@{!,ESC}" || "@{!,Q}} -w[] 0 -rm -v + -return -endif        # Quit properly if window has been closed.
      -if {@{!,b}&1" && "@{!,x}>20" && "@{!,y}>20" && "@{!,x}<400" && "@{!,y}<400} # If mouse button has been pressed on the board area.
        tmp3={int((@{!,x}-15)/130)}                                                # Get x-coord of the selected position (0,1 or 2).
        tmp2={int((@{!,y}-15)/130)}                                                # Get y-coord of the selected position (0,1 or 2).
        tmp1={4^($tmp2*3+$tmp3)}                                                   # Get state code of the selected position.
        -if {int($state/$tmp1)%4} tmp1=-1 -endif                                   # Check availability of the selected position.
      -else tmp1=-1 -endif                                                    # If no mouse button, do nothing but loop.
    -while {$tmp1<0}                                                          # Go on until a valid position has been selected.

    # Draw symbol on selected position and update board state.
    -_x_tictactoe{$player%2}                                                  # Generate the symbol sprite and his mask.
    -j[-3] [-2],{"130*"$tmp3" + 15+?(-5,5)"},\                                # Draw symbol at its position (with some fuzzyness).
                {"130*"$tmp2" + 15+?(-5,5)"},0,0,1,[-1]
    -rm[-2--1]                                                                # Delete the sprite and the mask (not needed anymore).
    -w[-1]                                                                    # Update display window.
    state={$state+(1+$player)*$tmp1}                                          # Update the board state.

    # Check for a winning configuration.
    (21,1344,86016,4161,16644,66576,65793,4368;\                              # The list of winning configurations.
     0,0,0,0,1,2,0,0;\                                                        # Corresponding X coords for the stroke.
     0,1,2,0,0,0,0,0;\                                                        # Corresponding Y coords for the stroke.
     3,3,3,4,4,4,5,6)                                                         # Corresponding indice of the stroke sprite.
    -repeat {w}                                                               # Start to check configurations.
      tmp1=@{-1,$>}                                                           # Save the current configuration code (used several times).
      -if {($state&$tmp1)==$tmp1||($state&(2*$tmp1))==2*$tmp1}                # If a winner has been found.
        -_x_tictactoe@{-1,($>,3)}                                               # Generate the stroke symbol and his mask.
        -j[-4] [-2],{130*@{-3,($>,1)}+?(-5,5)},\                              # And display it on the board at its position.
                        {130*@{-3,($>,2)}+?(-5,5)},0,0,1,[-1] -rm[-2--1]
        -if {($state&$tmp1)==$tmp1} -w[-2] -1,-1,0,"Tic-Tac-Toe (X won!)"
        -else -w[-2] -1,-1,0,"Tic-Tac-Toe (O won!)"                           # Update display window.
        -endif
        -do -wait -w[] @{!,w},@{!,h} -while {@!" && "!@{!,ESC}" && "!@{!,Q}}    # Wait for the window to be closed.
        -rm -w[] 0 -v + -return                                                 # And return properly.
      -endif
    -done                                                                     # Go on until all configurations have been checked.
    -rm[-1]                                                                   # Delete winning configuration data.

    player={($player+1)%2}                                                  # Select next player.
    counter={$counter+1}                                                    # Increment turn counter.
  -while {$counter<9}                                                       # Loop to next move until all positions have been filled.

  # Here, the game has been ended without winners.
  -w[] -1,-1,0,0,"Tic-Tac-Toe (Tied game!)"                                 # Change window title.
  -do -wait -w[] @{!,w},@{!,h} -while {@!" && "!@{!,ESC}" && "!@{!,Q}}      # Wait for the window to be closed.
  -w[] 0 -rm -v +                                                           # Return properly.

# Generate Tic-Tac-Toe graphics.
_x_tictactoe : # Apply a hand-drawing effect.
  -spread[-1] 4 -b[-1] 6 -sharpen[-1] 0.8 -n[-1] 0,1

__x_tictactoe : # Apply color to last image and generate corresponding opacity mask.
  --f[-1] 1-i --n[-2] $2,255 --n[-3] $3,255 -n[-4] $1,255 -a[-4,-2,-1] c

_x_tictactoe0 : # Generate a 'X' and his mask.
  128,128,1,1,1 -line[-1] 15%,15%,85%,85%,1,0 -line[-1] 15%,85%,85%,15%,1,0 -erode[-1] 12 -_x_tictactoe -deform[-1] 4 -__x_tictactoe 40,40,160

_x_tictactoe1 : # Generate a 'O' and his mask.
  128,128,1,1,1 -ellipse[-1] 50%,50%,22%,22%,0,1,0 -ellipse[-1] 50%,50%,15%,15%,0,1,1 -_x_tictactoe -deform[-1] 4 -__x_tictactoe 160,40,160

_x_tictactoe2 : # Generate the board.
  391,391,1,1,"!(x%130) || !(y%130)" -r[-1] 421,421,1,1,0,0,0.5,0.5 -dilate[-1] 3 -_x_tictactoe -f[-1] 1-i
  100%,100% -noise[-1] 10 -b[-1] 8,0 -sharpen[-1] 1.5 -n[-1] 220,255 -*[-2,-1] -to_rgb[-1]

_x_tictactoe3 : # Generate an horizontal stroke and his mask.
  421,130,1,1,1 -line[-1] 10%,60%,90%,60%,1,0 -erode[-1] 6 -_x_tictactoe -rotate[-1] {?(-6,6)},1,1,50%,50% -__x_tictactoe 180,10,10

_x_tictactoe4 : # Generate a vertical stroke and his mask.
  -_x_tictactoe3 -transpose[-2--1]

_x_tictactoe5 : # Generate a ++ diagonal stroke and his mask.
  421,421,1,1,1 -line[-1] 10%,10%,90%,90%,1,0 -erode[-1] 6 -_x_tictactoe -__x_tictactoe 180,10,10

_x_tictactoe6 : # Generate a +- diagonal stroke and his mask.
  421,421,1,1,1 -line[-1] 10%,90%,90%,10%,1,0 -erode[-1] 6 -_x_tictactoe -__x_tictactoe 180,10,10

#@gmic x_waves
#@gmic : Launch the image waves demo.
x_waves :
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ Image waves --------------------------\n
----\n
---- Left mouse button to drop balls.\n
---- Right mouse button to rotate view.\n
---- Keys 'CTRL+D' to double window size.\n
---- Keys 'CTRL+C' to reset window size.\n
---- Keys 'CTRL+F' to switch fullscreen mode.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
---------------------------------------------"
  -v -
  -if {!@#} -l[] # Generate fractal image
    200,200 x={-1.06-?*0.1} y={-0.26-?*0.1}
    -mandelbrot $x,$y,{$x+0.1},{$y+0.1},256
    16,1,1,3,? -r[-1] 256,1,1,3,3 -shift[-1] 1
    -map[0] [-1] -rm[-1] -r2dx 100
    --mirror y --mirror x -+ -n 0,255
  -endl -else -k[0] -r[0] 100,100,1,3,2 -endif
  -i[0] (20;80;0^20;80;0^20;80;0) -r[0] 400,300,1,3,3 -water[0] 100,2
  -w[0] @{0,w},@{0,h},0,"[G\47MIC] Image waves"
  w={w} -elevation3d[-1] 0 -rv3d[-1]
  -sh[-1] 8,{7+3*i[6]},0,0 -r[-1] 3,{h/3},1,1,-1
  (0,1,0;1,0,1;0,1,0) -/[-1] 2
  -ball[] 20,200,255,128,1,0.7,3.5
  0 $w,$w [-1]
  -l3d {$w/2},-200,-1000 -sl3d 0.4 -ss3d 0.8 -f3d 500 time0=@|
  -do
    --convolve[-1] [3],1 --[-1] [-3] -rm[-3] -b[-1] 0.8 --[-1] {ia} # Update height map.
    -r[-1] 1,{$w*$w},1,1,-1 -j[2] [-1],2,0 -r[-1] $w,$w,1,1,-1      # Set 3d object coordinates.
    [1]
    -if @{5,h} --l[5] -rows 0,2
      nb={w}
      -i[0] ({'CImg3d'}) -i[1] ($nb,$nb) -transpose[2]
      (1,0;1,{$nb-1}) -r[-1] 2,$nb,1,1,3 -round[-1]
      1,{4*$nb},1,1,1 -y -a y
    -endl [4] -sprites3d[-2,-1] -+3d[-2,-1] -endif
    --3d[-1] {$w/2},{$w/2} -*3d[-1] @{0,0.9*max(w,h)/$w} # Center and scale 3d object.
    -r3d[-1] 0,0,1,{if(@{!,b}&2,-@{!,x}*360/@{!,w},@|*30)} -r3d[-1] 1,0,0,-120 # Get rotated 3d object.
    --j3d[0] [-1],50%,65%,30,1,3,0,0 -w[-1]
    -if {@{!,CTRLLEFT}&&@{!,D}} -w[] {2*w},{2*h} -elif {@{!,CTRLLEFT}&&@{!,C}} -w[] {w},{h}
    -elif {@{!,CTRLLEFT}&&@{!,F}}
      -if {!narg($is_fs)} is_fs=@{!,w},@{!,h} fw={min(@{!,u}*h/w,@{!,v}*w/h)} -w[] $fw,{$fw*h/w},0,1
      -else -w[] $is_fs,0,0 is_fs=""
      -endif
    -endif

    -rm[-2,-1] -wait 20
    -if {@{!,b}&1||(@|-$time0)>1} ({?*$w};{?*$w};70;0) -a[5,-1] x time0={@|-?} -endif # Insert new ball.
    -if @{5,h} -l[5,-1] # Manage ball motion and collision.
      -sh[0] 2,2,0,0 -sh[0] 3,3,0,0 --[-2] [-1] -+[-1] 0.2 -rm[-2,-1]
      -s[0] x -repeat {@#-1} coords=@{$<,0-1} -if {@{$<,2}<i($coords)} -=[-1] {80+@{-1,($coords)}},$coords -rm[$<] -endif -done
      -if {@#==1} -i[0] 0 -else -a[0--2] x -endif
      -endl
    -endif
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -rm -w 0 -v +

#@gmic x_whirl : _opacity>=0
#@gmic : Launch the fractal whirls demo.
#@gmic : Default values: 'opacity=0.2'.
x_whirl : -check ${1=0.2}>=0
  -if {!@{!,u}} -error[0--3] "Command '-$0': No display available." -return -endif
  -e[] "\n
------ Fractal whirls ----------------------------\n
----\n
---- Keys 'CTRL+D' to double window size.\n
---- Keys 'CTRL+C' to reset window size.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
--------------------------------------------------"
  -v -
  5,5,1,3 256,256,1,3 [-1] -w[-1] 384,384,0,"[G\47MIC] Fractal whirls"
  tangle=0 tzoom=0 xc={(w-@{-3,w})/2} yc={(h-@{-3,h})/2}
  -do
    -rand[-3] 0,255 -j[-2] [-3],$xc,$yc,0,0
    -rotate[-2] {8*sin($tangle)},0,0,{w/2+?(-2,2)},{h/2},{1.03+0.02*sin($tzoom)}
    tangle={$tangle+0.001} tzoom={$tzoom+0.02}
    -j[-1] [-2],0,0,0,0,$1 -w[-1]
    -if {@{!,CTRLLEFT}&&@{!,D}} -w[] {3*w},{3*h} -elif {@{!,CTRLLEFT}&&@{!,C}} -w[] {1.5*w},{1.5*h} -endif
    -wait 20
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -rm[-3,-2] -w[] 0 -v +

#-------------------------------------
#
# Define menu entries for
# the G'MIC plug-in for GIMP
#
#-------------------------------------
__help_end : #  <-- don't remove me, used as a marker for help !

# Function that returns the list of external sources to be included in the GIMP plug-in.
# This command can be superseded on the user '.gmic' file to add sources for the plug-in.
gimp_filter_sources :
  ({'gmic'})
  ({'http://gmic.eu/update@..gmic'},1) # Override default filters.

# Function used for filters based on parallelization with spatial splitting.
gimp_parallel_overlap :
  -apply_parallel_overlap "$1",$3,{if($2,2^($2-1),0)}

# Flatten list of input layers according to their blending modes, opacities and positions,
# set in each layer name by the GIMP plug-in.
gimp_merge_layers :
  mode0=@{"-_gimp_merge_layers[-1] mode,alpha"}
  opacity0=@{"-_gimp_merge_layers[-1] opacity,100"}
  pos0=@{"-_gimp_merge_layers[-1] pos,0,0"}
  -if {$opacity0<100" || "{$pos0'!='0,0}} 100%,100%,1,4 -endif

  wh0={w},{h}
  wh=@{-max_wh} -r[-1] $wh,1,100%,0

  -repeat {@#-1} -l[-2,-1] -rv
    mode=@{"-_gimp_merge_layers[1] mode,alpha"}
    opacity=@{"-_gimp_merge_layers[1] opacity,100"}
    pos=@{"-_gimp_merge_layers[1] pos,0,0"}
    -to_a[1] -r[1] $wh,1,100%,0
    -shift[1] @{-u\ $pos},0,0
    -to_colormode[0,1] 0
    -blend $mode,{max(0,min(1,$opacity/100))}
  -endl -done
  -r $wh0,1,100%,0

_gimp_merge_layers :
  res=""
  ({'@{0,n}'})
  -l[-1]
    ({'"$1("'}) l={w} str=@-1 -rm[-1]
    -s +,$str
    -if {@#>1}
      -repeat @#
        -if {$>!=@#-1" && "{@{$>,0-@{$>,min($l,h)-1}}'=='$str}}
          -l[{$>+1}] -s +,{')'} -if {@#>1} res=@{0,t} -endif -a y -endl
        -endif
        -if {narg($res)} -break -endif
      -done
    -endif
    -rm
  -endl
  -if {narg($res)} -u $res -else -u "${2--1}" -endif

# Generate a splitted preview, with arguments "command",_split_type.
# 'split_type' can be { 0=no split | 1=forw. horiz. | 2=forw. vert. | 3=back. horiz. | 4=back. vert. | 5=dupl. horiz. | 6=dupl. vert. }
_before :
  0 -t[-1] "Before",1,-1,13,1,1 -r[-1] {w+4},{h+4},1,1,0,0,0.5,0.5
_after :
  0 -t[-1] "After",1,-1,13,1,1 -r[-1] {w+4},{h+4},1,1,0,0,0.5,0.5

gimp_split_preview :
  -m "gsp : w={w} h={h} s={s} $1 -if {!@#} $w,$h,1,4 -drgba -to_colormode $s -endif -k[0] -if {s>4} -channels 0,3 -endif"
  -repeat @# -l[$>]
    -if {$2==0} -gsp[-1] -mv[-1] 0 -continue -endif  # No split.
    -if {!($2%2)} # Vertical split.
      -s[-1] x,2
      -if {$2==2} -gsp[-1] -to_colormode[-2,-1] 0 -_before -_after    # Forward vertical.
      -elif {$2==4} -gsp[-2] -to_colormode[-2,-1] 0 -_after -_before  # Backward vertical.
      -else -rm[-1] --gsp[-1] -to_colormode[-2,-1] 0 -_before -_after # Duplicate vertical.
      -endif
      -line[-3] 0,0,0,@{-3,h},1,0,0,0,255 -a[-4,-3] x
    -else # Horizontal split.
      -s[-1] y,2
      -if {$2==1} -gsp[-1] -to_colormode[-2,-1] {max(@{-2,s},s)} -_before -_after   # Forward horizontal.
      -elif {$2==3} -gsp[-2] -to_colormode[-2,-1] {max(@{-2,s},s)} -_after -_before # Backward horizontal.
      -else -rm[-1] --gsp[-1] -to_colormode[-2,-1] 0 -_before -_after               # Duplicate horizontal.
      -endif
      -line[-3] 0,0,@{-3,w},0,1,0,0,0,255 -a[-4,-3] y
    -endif
    --dilate[-2,-1] 5 -*[-4,-3] 255 -to_colormode[-4,-3] @{-5,s} # If splited, display "before/after" text.
    -j[-5] [-4],1,1,0,0,0.8,[-2] -j[-5] [-3],{@{-5,w}-w-1},{@{-5,h}-h-1},0,0,0.8,[-1]
    -rm[-4--1]
  -endl -done
  -uncommand gsp

# Command to display text on a the G'MIC plug-in preview.
# $1 : header message
# $2 : header font size.
# $3 : main message
# $4 : main font size.
# $5 : Split size for main message.
gimp_print_preview : -skip "${1=},${3=}" -check "${2=32}>=0 && ${4=20}>=0 && ${5=20}>=0"
  -if {!@#" || "w<128" || "h<128} -rm 420,300,1,4,0 -endif
  -k[0] -drgba
  (1;1^1;0.5^0;0.5) (1.5,0,1.5;0,0,0;1.5,0,1.5) -r[-2,-1] [-3],3 -* -c 0,255

  -l[] # Render title.
    0 -t[-1] "$1",0,0,$2,1,255 -r[-1] 100%,140%,1,1,0
    -i[0] 100%,100%,1,3 -fc[0] 255,200,128 -a c
  -onfail -rm
  -endl

  -l[] # Render message.
    ({'"$3"'}) --f[-1] '>if(i>32||j(-1)<$5,j(-1)+1,0)' -==[-1] 0 -*[-1] 256 -max[-2,-1] -s -,256
    -s y,-{round(1.3*$5)}
    -repeat @# -l[$>] 0 -t[-1] @{0,t},0,0,$4,1,255 -rm[0] -endl -done
    -a y -i[0] 100%,100%,1,3,255 -a c
  -onfail -rm
  -endl

  -a[^0] y,0.5
  -if {@#>1}
    -if {w>@{0,w}} -r2dx[-1] @{0,w-8} -endif
    -if {h>@{0,h}} -r2dy[-1] @{0,h-8} -endif
    -r[1] [0],[0],1,4,0,0,0.5,0.5 -blend alpha
  -endif

gimp_no_preview : -skip "$*"
  -gimp_print_preview "",0,"No preview\n  available",32

gimp_warning_preview :
  -gimp_print_preview "Preview warning:",32,"$*",22,30

gimp_error_preview :
  -gimp_print_preview "Preview error:",32,"$*",15,40

# Function to auto-crop layers and set their position for GIMP.
gimp_autocrop_layers :
  -repeat @# -l[$>]
    coords=@{-autocrop_coords}
    -z $coords
    -nm pos({arg(1,$coords)},{arg(2,$coords)})
  -endl -done

# Do not forget to ucomment this entry for a deprecated version of the G'MIC plug-in!
# #@gimp <span foreground="red"><b>  UPDATE INFORMATION</b></span> : _none_, gimp_logo_en
# #@gimp : note = note{"A <b>new version</b> of the G'MIC plug-in for GIMP is available!
# #@gimp : You are strongly encouraged to download and install this updated version, by clicking on one of the following urls :"}
# #@gimp : note = note{"\n<span foreground="purple"><u>Windows version :</u></span>"}
# #@gimp : url = link{"Download G'MIC plug-in for Windows (32 bits)","http://downloads.sourceforge.net/gmic/windows/gmic_gimp_win32.exe"}
# #@gimp : url = link{"Download G'MIC plug-in for Windows (64 bits)","http://downloads.sourceforge.net/gmic/windows/gmic_gimp_win64.zip"}
# #@gimp : note = note{"<b>Installation </b>: unzip the archive files and copy them into folder\n
# #@gimp :              <i>C:\\Program Files\\GIMP\\lib\\gimp\\2.0\\plug-ins\</i>"}
# #@gimp : note = note{"\n<span foreground="purple"><u>Linux version :</u></span>"}
# #@gimp : url = link{"Download plug-in for Linux (32 bits)","http://downloads.sourceforge.net/gmic/linux/gmic_gimp_linux32.zip"}
# #@gimp : url = link{"Download plug-in for Linux (64 bits)","http://downloads.sourceforge.net/gmic/linux/gmic_gimp_linux64.zip"}
# #@gimp : note = note{"<b>Installation </b>: unzip the archive files and copy them in folder\n
# #@gimp :              <i>/usr/lib/gimp/2.0/plug-ins/</i>"}
# #@gimp : note = note{"\nNote that there will be no updated filters anymore for your current plug-in version.
# #@gimp : Installing the G'MIC plug-in for GIMP is easy and fast, so there are no reasons not for doing it :).\n\n
# #@gimp : Best regards,\n\n <i>The G'MIC team.</i>"}


#----------------------
# English translations
#----------------------

#@gimp _<b>About</b>
#-------------------

#@gimp_en About G'MIC : _none_, gimp_logo_en
#@gimp_en : note = note{"
#@gimp_en : <span foreground="purple">( <b>G</b>REYC's <b>M</b>agic for <b>I</b>mage <b>C</b>omputing )</span>\n\nis proposed to you by"}
#@gimp_en : note = link("David Tschumperl\303\251","http://tschumperle.users.greyc.fr/")
#@gimp_en : note = link{"( IMAGE Team / GREYC Laboratory - CNRS UMR 6072 )","http://www.greyc.fr/node/36"}
#@gimp_en : note = note{"
#@gimp_en : This plug-in is based on our open-source libraries <b>G'MIC</b> and <b>CImg</b> (C++ Template Image Processing Library),
#@gimp_en : available at:"}
#@gimp_en : note = link("http://gmic.eu/")
#@gimp_en : note = note{"and"}
#@gimp_en : note = link("http://cimg.sourceforge.net/")
#@gimp_en : note = note{"\n
#@gimp_en : If you appreciate <b>G'MIC</b>, you are welcome to send us a nice postcard from your place, at:\n\n
#@gimp_en : <small><tt>David Tschumperl&#233;,\n Laboratoire GREYC (CNRS UMR 6072), Equipe Image,\n
#@gimp_en :  6 Bd du Mar&#233;chal Juin,\n 14050 Caen Cedex / France.</tt></small>\n\n
#@gimp_en : Postcards senders automatically enter the <i>Friends Hall of Fame</i> :) !
#@gimp_en : "}
gimp_logo_version3 : -skip "${1=Plug-in for GIMP}"
  -rm s="G\47MIC"
  -repeat {narg({'$s'})}
    0 -t[-1] {`{arg(1+$>,{'$s'})}`},0,0,53,1,1 -frame[-1] 3,0,0
    -r[-1] 500%,500%,1,1,3 -b[-1] 3% ->=[-1] 50%
    -distance[-1] 1 -<=[-1] 10
    [-1]x3 -whirls[-4--2] ,
    r$>={?(0.4,1)} g$>={?(0.2,1)} b$>={?(0.6,1)}
    -*[-4] ${r$>} -*[-3] ${g$>} -*[-2] ${b$>}
    -a[-4--2] c -n[-2] 0,255 -*[-1] 255 -a[-2,-1] c
  -done
  -a[-5--1] x
  -r[-1] 100%,120%,1,4,0,0,0.5,1
  -ball 64,{255*$r3},{255*$g3},{255*$b3} -j[-2] [-1],450,5 -rm[-1]
  -sh[-1] 100%,100% -dilate[-1] 7 -rm[-1] -autocrop[-1]
  -drop_shadow[-1] 10,10,1%,0.5
  0 -t[-1] "$1",0,0,53,1,255 -frame[-1] 4,4,0 [-1]x3 -dilate[-1] 7 -a[-4--1] c
  -a[-2,-1] y,0.5
  -r2dy[-1] 50%
  -i[-2] 120%,120%,1,3,255 -plasma[-2] 1,1 -s[-2] c
  -n[-4] 150,255 -n[-3] 180,255 -n[-2] 200,255 -a[-4--2] c
  -blend alpha
  -frame 0,1,0,0,0 -frame 0,5,255,255,255

gimp_logo_version2 : -skip "${1=Plug-in for GIMP}"
  -if @# -k[0] -endif
  -to_rgb 0 -t[-1] "G\47MIC",0,0,53,1,1 -label[-1]
  6,1,1,3 -rand[-1] 150,255 -point[-1] 0 -map[-2] [-1] -rm[-1]
  -expand_xy[-1] 10,0 -b[-1] 2 -r[-1] 200%,200%,1,3,6 -sqr[-1] -c[-1] 0,60% -n[-1] 0,255
  -warp_perspective[-1] 0.5,0,1,50,50,0 -shift[-1] 0,-10
  100%,100% -noise[-1] 0.8,2 -*[-1] 180 --blur_linear[-1] 20,0,45,0 -*[-1] 20 -max[-3--1]
  -sh[-1] 2,2 (0;128) -r[-1] [-2],3 -+[-2,-1] -min[-1] 255 -rm[-1]
  -text_outline[-1] "$1",32%,75%,13,3,1,255 -frame[-1] 1,1,128 -mv[-1] 0
  -if {@#>1} -*[^0] 0.45 -repeat {@#-1} -j[-1] [0],{(w-@{0,w})/2},{(h-@{0,h})/2} -mv[-1] 1 -done -rm[0] -endif

gimp_logo_version1 : -skip "${1=Plug-in for GIMP}"
  -if @# ratio={w/h} -else ratio=1 -endif
  -rm 118,44,1,1 -t "G\47MIC",3,-6,53,1,255 -r 100%,100%,10,1 -r 100%,100%,20,1,0,0,0.5,0.5,0.5 -b 1.5
  -isosurface3d 50%
  -col3d {?(150,255)},{?(150,255)},{?(150,255)}
  -sphere3d 8 -col3d[-1] {?(150,255)},{?(150,255)},{?(150,255)} -+3d[-1] 72,-6 -+3d -c3d[-1] -rv3d
  -db3d 0 -sl3d 0.2 -ss3d 1.3 -r3d[-1] 1,0,0,30 -f3d 120 -*3d[-1] 1.5
  230,120,1,3 -j3d[-1] [-2],50%,30%,0,1,4 -rm[-2] -t "$1",36%,75%,13,1,255
  -to_rgba -replace_color 0,0,0,0,0,255,0,0,0,0 -drop_shadow 6,6,2
  -i[-2] @{-fitratio_wh\ 230,120,$ratio},1,3
  -rand[-2] 0,255 -sh[-2] 0,0 -/[-1] 2 -rm[-1]
  -blur_radial[-2] 20 -sharpen[-2] 300
  -r[-1] [-2],[-2],1,4,0,0,0.5,0.5 -blend alpha

gimp_logo : -skip "${1=Plug-in for GIMP\n    [ "@{-strver}" ]}"
    -gimp_logo_version{round(?(0.5,3.49))} "$1"

gimp_logo_en :
  -if {narg($_gmic_is_beta)}
    -gimp_logo_version{round(?(0.5,3.49))} "Plug-in for GIMP\n "[" "@{-strver}" beta "]
  -else
    -gimp_logo_version{round(?(0.5,3.49))} "Plug-in for GIMP\n    "[" "@{-strver}" "]
  -endif

#---------------------
# French translations
#---------------------

#@gimp_fr A propos de G'MIC : _none_, gimp_logo_fr
#@gimp_fr : note = note{"
#@gimp_fr : <span foreground="purple">( <b>G</b>REYC's <b>M</b>agic for <b>I</b>mage <b>C</b>omputing )</span>\n\nvous est propos&#233; par"}
#@gimp_fr : note = link("David Tschumperl\303\251","http://tschumperle.users.greyc.fr/")
#@gimp_fr : note = link{"( Equipe IMAGE / Laboratoire GREYC - CNRS UMR 6072 )","http://www.greyc.fr/node/36"}
#@gimp_fr : note = note{"
#@gimp_fr : Ce greffon est bas&#233; sur nos biblioth&#232;ques libres <b>G'MIC</b> et <b>CImg</b> (C++ Template Image Processing Library),
#@gimp_fr : disponibles aux adresses :"}
#@gimp_fr : note = link("http://gmic.eu/")
#@gimp_fr : note = note{"et"}
#@gimp_fr : note = link("http://cimg.sourceforge.net/")
#@gimp_fr : note = note{"\n
#@gimp_fr : Si vous appr&#233;ciez <b>G'MIC</b>, vous pouvez nous le faire savoir en nous envoyant une jolie carte
#@gimp_fr : postale de votre ville ou r&#233;gion, &#224; l'adresse :\n\n
#@gimp_fr : <small><tt>David Tschumperl&#233;,\n Laboratoire GREYC (CNRS UMR 6072), Equipe Image,\n
#@gimp_fr :  6 Bd du Mar&#233;chal Juin,\n 14050 Caen Cedex / France.</tt></small>\n\n
#@gimp_fr : Envoyer une carte postale vous fera rentrer <i>de facto</i> dans le <i>Friends Hall of Fame</i> :) !
#@gimp_fr : "}
gimp_logo_fr :
  -if {narg($_gmic_is_beta)}
    -gimp_logo_version{round(?(0.5,3.49))} "Greffon pour GIMP\n  "[" "@{-strver}" beta "]
  -else
    -gimp_logo_version{round(?(0.5,3.49))} "Greffon pour GIMP\n    "[" "@{-strver}" "]
  -endif

#----------------------
# Catalan translations
#----------------------

#@gimp_ca G'MIC per al GIMP : _none_, gimp_logo_ca
#@gimp_ca : note = note{"
#@gimp_ca : <span foreground="purple">( <b>G</b>REYC's <b>M</b>agic for <b>I</b>mage <b>C</b>omputing )</span>\n\n &#233;s una gentilesa de"}
#@gimp_ca : note = link("David Tschumperl\303\251","http://tschumperle.users.greyc.fr/")
#@gimp_ca : note = link{"( IMAGE Team / GREYC Laboratory - CNRS UMR 6072 )","http://www.greyc.fr/node/36"}
#@gimp_ca : note = note{"
#@gimp_ca : Aquest connector est&#224; basat en les biblioteques de codi obert <b>G'MIC</b> i <b>CImg</b> (C++ Template Image Processing Library),
#@gimp_ca : disponibles a :"}
#@gimp_ca : note = link("http://gmic.eu/")
#@gimp_ca : note = note{"i"}
#@gimp_ca : note = link("http://cimg.sourceforge.net/")
#@gimp_ca : note = note{"\n
#@gimp_ca : Si t'agrada el <b>G'MIC</b>, pots enviar-nos una postal del lloc on vius, a :\n\n
#@gimp_ca : <small><tt>David Tschumperl&#233;,\n Laboratoire GREYC (CNRS UMR 6072), Equipe Image,\n
#@gimp_ca :  6 Bd du Mar&#233;chal Juin,\n 14050 Caen Cedex / France.</tt></small>\n\n
#@gimp_ca : Tot aquell que envi&#239; una postal apareixer&#224; al <i>Friends Hall of Fame</i> :) !
#@gimp_ca : "}
gimp_logo_ca :
  -if {narg($_gmic_is_beta)}
    -gimp_logo_version{round(?(0.5,3.49))} "  per al GIMP\n  "[" "@{-strver}" beta "]
  -else
    -gimp_logo_version{round(?(0.5,3.49))} "  per al GIMP\n    "[" "@{-strver}" "]
  -endif

#----------------------
# Untranslated filters
#----------------------

#@gimp Contributors : _none_, _none_
#@gimp : note = note{"
#@gimp : We would like to thank all these people who contributed to <b>G'MIC</b> in one way or another.
#@gimp : A big hug to : \n\n
#@gimp : <b> -</b> <i>Sylvie Alexandre</i> <small>(packaging, testing &amp; filters)</small>
#@gimp : <b> -</b> <i>Partha Bagchi</i> <small>(packaging)</small>
#@gimp : <b> -</b> <i>S&#233;bastien Bougleux</i> <small>(debugging)</small>
#@gimp : <b> -</b> <i>J&#233;rome Boulanger</i> <small>(testing &amp; code)</small>
#@gimp : <b> -</b> <i>Claude Bulin</i> <small>(packaging)</small>
#@gimp : <b> -</b> <i>Aur&#233;lien Ceyden</i> <small>(packaging)</small>
#@gimp : <b> -</b> <i>Fran&#231;ois Collard</i> <small>(testing)</small>
#@gimp : <b> -</b> <i>Patrick David</i> <small>(testing &amp; filters)</small>
#@gimp : <b> -</b> <i>Maxime Daisy</i> <small>(code &amp; testing)</small>
#@gimp : <b> -</b> <i>Fr&#233;d&#233;ric Devernay</i> <small>(code)</small>
#@gimp : <b> -</b> <i>Iain Fergusson</i> <small>(filters)</small>
#@gimp : <b> -</b> <i>Roberto Ferramosca</i> <small>(packaging)</small>
#@gimp : <b> -</b> <i>J&#233;rome Ferrari</i> <small>(testing, code &amp; tutorials)</small>
#@gimp : <b> -</b> <i>Chris Fiedler</i> <small>(gfx)</small>
#@gimp : <b> -</b> <i>S&#233;bastien Fourey</i> <small>(ZArt code &amp; G'MIC online)</small>
#@gimp : <b> -</b> <i>Gentlemanbeggar</i> <small>(filters)</small>
#@gimp : <b> -</b> <i>Claes Holmerson</i> <small>(tutorials)</small>
#@gimp : <b> -</b> <i>Arto Huotari</i> <small>(filters)</small>
#@gimp : <b> -</b> <i>Dan Leinir Turthra Jensen</i> <small>(debugging)</small>
#@gimp : <b> -</b> <i>Tom Keil</i> <small>(testing, filters &amp; tutorials)</small>
#@gimp : <b> -</b> <i>Andy Kelday</i> <small>(testing &amp; filters)</small>
#@gimp : <b> -</b> <i>Angelo Lama</i> <small>(testing &amp; EKD integration)</small>
#@gimp : <b> -</b> <i>John Lakkas</i> <small>(filters)</small>
#@gimp : <b> -</b> <i>St&#233;phane de la Linuxerie</i> <small>(design)</small>
#@gimp : <b> -</b> <i>Mark</i> <small>(translation)</small>
#@gimp : <b> -</b> <i>Mahvin</i> <small>(testing &amp; design)</small>
#@gimp : <b> -</b> <i>MareroQ</i> <small>(translation)</small>
#@gimp : <b> -</b> <i>Ramon Miranda</i> <small>(translation)</small>
#@gimp : <b> -</b> <i>Mauro Quercia</i> <small>(translation)</small>
#@gimp : <b> -</b> <i>PhotoComiX</i> <small>(testing, translation &amp; filters)</small>
#@gimp : <b> -</b> <i>Garry Osgood</i> <small>(documentation &amp; filters)</small>
#@gimp : <b> -</b> <i>James Prichard</i> <small>(testing &amp; filters)</small>
#@gimp : <b> -</b> <i>Guilherme Razgriz</i> <small>(translation)</small>
#@gimp : <b> -</b> <i>Karsten Rodenacker</i> <small>(packaging &amp; code)</small>
#@gimp : <b> -</b> <i>Dani Sard&#224;</i> <small>(translation)</small>
#@gimp : <b> -</b> <i>Yuri Shemanin</i> <small>(debugging)</small>
#@gimp : <b> -</b> <i>Stepanekos</i> <small>(translation)</small>
#@gimp : <b> -</b> <i>Thorsten "otto" Stettin</i> <small>(packaging)</small>
#@gimp : <b> -</b> <i>Lukas Tvrdy</i> <small>(Krita integration)</small>
#@gimp : <b> -</b> <i>Bernd Zeimetz</i> <small>(packaging)</small>
#@gimp : <b> -</b> <i>Matthias Zepper</i> <small>(testing)</small>
#@gimp : <b> -</b>"}

#@gimp Filter design : _none_, _none_
#@gimp : note = note{"
#@gimp : <b>G'MIC</b> is an <b>open</b> image processing framework. Thus, including
#@gimp : <b>user-defined filters</b> into this plug-in is possible.\n\n
#@gimp : To do so, you need to create a <span foreground="purple" style="italic">.gmic</span>
#@gimp : file in your <i>$HOME/</i> folder (or <i>%APPDATA%/gmic</i> on Windows, without the first dot).
#@gimp : It will be read each time the plug-in is launched, or when the <i>Refresh</i>
#@gimp : button (under the central pane) is pressed. It must be a regular ASCII file, containing the declarations and
#@gimp : implementations of the filters (written in the <b>G'MIC</b> language) that will be added
#@gimp : to the list of available ones."}
#@gimp : note = note{"
#@gimp : Existing filters are already defined this way.
#@gimp : Writing a filter from scratch in <b>G'MIC</b> requires some skills, but
#@gimp : can be generally done in very few lines.\n\n
#@gimp : <span foreground="purple" underline="single">Example of a valid <i>.gmic</i> entry :</span>"}
#@gimp : note = note{"<tt>#@gimp My effect : my_effect, my_effect</tt>"}
#@gimp : note = note{"<tt>#@gimp : Sigma = float(2,0,10)</tt>"}
#@gimp : note = note{"<tt>my_effect :\n     --blur $1 -n 0,255 -xor</tt>"}
#@gimp : note = note{"
#@gimp : Look at the reference documentation and the tutorial whose links are given below, to learn more.
#@gimp : By the way, you are encouraged to share your nice custom filters with us on our forums,
#@gimp : for inclusion into next releases of <b>G'MIC</b>.
#@gimp : "}
#@gimp : sep = separator()
#@gimp : note = link(0,"[1] G'MIC reference documentation","http://gmic.eu/reference.shtml")
#@gimp : note = link(0,"[2] G'MIC scripting tutorial","http://gmic.eu/tutorial/index.shtml")

#@gimp Filter sources : _none_, gimp_display_filter_sources
#@gimp : note = note{"Here is displayed the filter sources currently enabled in your plug-in.
#@gimp : For most users, there should be only one URL listed there, that links to the official <b>G'MIC</b> server."}
gimp_display_filter_sources :
  -l[]
    -if @{-is_windows} path=@{-path_user}/ -else path=@{-path_user}/. -endif
    -gimp_filter_sources
    msg= i=1 -replace 1,32
    -repeat @#
      -if {@{$>,0-3}'=='{'http'}} msg=$msg"\n["$i"] "@{$>,t} i={$i+1}
      -else
        -if $path@{$>,t} msg=$msg"\n["$i"] "@{$>,t}" (local file)" i={$i+1} -endif
      -endif
    -done
  -rm -endl
  -gimp_print_preview "Enabled external sources:",32,$msg,15,140

#@gimp Friends Hall of Fame : _none_, gimp_friends
#@gimp : note = note{"\n<span foreground="purple" underline="single">Donators :</span>"}
#@gimp : note = note{" <b>-</b> We've already received <b>31</b> donations from <b>G'MIC</b> mega-enthusiasts so far.
#@gimp :               You could be the <b>32nd</b> donator :)"}
#@gimp : note = note{"<b><small>Note:</small></b> Donations are mainly used to help us making <b>G'MIC</b> more visible
#@gimp :              (cover expenses for open-source events, for instance). Also, it will motivate
#@gimp :              us to design more new image filters and effects. Feel free to donate
#@gimp :              if you appreciate <b>G'MIC</b>, by clicking on:"}
#@gimp : link = link{"Make a donation via Paypal","http://sourceforge.net/donate/index.php?group_id=234931"}
#@gimp : link = link{"Make a donation via Flattr","http://flattr.com/thing/41097/GMIC-GREYCs-Magic-for-Image-Computing"}
#@gimp : link = link{"Make a donation via Bitcoin","bitcoin:1N5BsWvLRGHq42KLdCEtXuGvu9pat93kHD?label=G'MIC%20Donation"}
#@gimp : note = note("<small><b>Bitcoin address:</b> 1N5BsWvLRGHq42KLdCEtXuGvu9pat93kHD</small>")
#@gimp : sep = separator()
#@gimp : note = note{" <b>-</b> A big hug goes to these donators (recently received first) :"}
#@gimp : link = link(0,"[1] Phillip R Ziesemer","")
#@gimp : link = link(0,"[2] Jean Francois","")
#@gimp : link = link(0,"[3] Franz Ziereis","")
#@gimp : link = link(0,"[4] Alessandro Renzi","")
#@gimp : link = link(0,"[5] Tsuda Koshi","")
#@gimp : link = link(0,"[6] Boxrec Ltd","http://www.boxrec.com")
#@gimp : link = link(0,"[7] Wolfgang Schweizer","http://www.wolfgangschweizer.com/")
#@gimp : link = link(0,"[8] Ramon Miranda","http://www.ramonmiranda.com/")
#@gimp : link = link(0,"[9] Volker Bradley","")
#@gimp : link = link(0,"[10] Marco Zara","http://plus.google.com/+MarcoZara")
#@gimp : link = link(0,"[11] Marco Tedaldi","http://plus.google.com/+MarcoTedaldi")
#@gimp : link = link(0,"[12] Rodney Lee","http://cybertographer.com")
#@gimp : link = link(0,"[13] Konstantinos Blatzonis","")
#@gimp : link = link(0,"[14] Simon Chanson","")
#@gimp : link = link(0,"[15] Herbert Malle","")
#@gimp : link = link(0,"[16] Matthias Zepper","http://www.matthias-zepper.de/")
#@gimp : link = link(0,"[17] Christian Mariucci","")
#@gimp : link = link(0,"[18] M. R.","")
#@gimp : link = link(0,"[19] Mark Link","")
#@gimp : link = link(0,"[20] Rolf Steinort","http://blog.meetthegimp.org/")
#@gimp : link = link(0,"[21] Pat David","http://blog.patdavid.net/")
#@gimp : link = link(0,"[22] Daniel Tauro","https://plus.google.com/112357088505488756823/posts")
#@gimp : link = link(0,"[23] Ben Langhinrichs","http://geniisoft.com/")
#@gimp : link = link(0,"[24] Paolo Pedaletti","http://www.openlabs.it/")
#@gimp : link = link(0,"[25] Ricardo Corin","http://blog.photomontager.com")
#@gimp : link = link(0,"[26] James Prichard","https://plus.google.com/115953666279509959258")
#@gimp : link = link(0,"[27] Matt Jones","https://plus.google.com/116658221461047313647")
#@gimp : link = link(0,"[28] Eddy Vervest","http://www.flickr.com/people/twekkel/")
#@gimp : link = link(0,"[29] Steven Shupe","http://www.flickr.com/photos/ssshupe/")
#@gimp : link = link(0,"[30] Flavio Casadei Della Chiesa","http://www.flaviocdc.net/wiki/")
#@gimp : link = link(0,"[31] Lyle Kroll","http://www.artwanted.com/artist.cfm?artid=10918")
#@gimp : sep = separator()
#@gimp : note = note{"\n<span foreground="purple" underline="single">Postcard senders :</span>"}
#@gimp : note = note{" <b>-</b> We've received <b>25</b> postcards from <b>G'MIC</b> enthusiasts so far.
#@gimp :               You could be the <b>26th</b> sender :)"}
#@gimp : note = note{" <b>-</b> A big hug goes to these postcard senders (recently received first) :"}
#@gimp : link = link(0,"[1] ZondeR - France","http://cimg.sourceforge.net/img/postcard51.jpg")
#@gimp : link = link(0,"[2] Bill C. - USA","http://cimg.sourceforge.net/img/postcard50.jpg")
#@gimp : link = link(0,"[3] Michael T. - France","http://cimg.sourceforge.net/img/postcard49.jpg")
#@gimp : link = link(0,"[4] Patrick Wauters - Lisboa","http://cimg.sourceforge.net/img/postcard48.jpg")
#@gimp : link = link(0,"[5] Akky [Gimpchat] - Australia","http://cimg.sourceforge.net/img/postcard47.jpg")
#@gimp : link = link(0,"[6] Michel Thomas - Germany","http://cimg.sourceforge.net/img/postcard45.jpg")
#@gimp : link = link(0,"[7] Pierre-Yves - Ile de Batz/France","http://cimg.sourceforge.net/img/postcard44.jpg")
#@gimp : link = link(0,"[8] Family Hamacher - Trier/Germany","http://cimg.sourceforge.net/img/postcard43.jpg")
#@gimp : link = link(0,"[9] Benoit Gauzere and Francois Lozes - Hokusai/Japan","http://cimg.sourceforge.net/img/postcard41.jpg")
#@gimp : link = link(0,"[10] Dr. Rainer Teubner - Seligenstadt/Germany","http://cimg.sourceforge.net/img/postcard40.jpg")
#@gimp : link = link(0,"[11] Mauro Mitrino - Mantova/Italy","http://cimg.sourceforge.net/img/postcard39.jpg")
#@gimp : link = link(0,"[12] Werner Meier - Mettlach/Germany","http://cimg.sourceforge.net/img/postcard37.jpg")
#@gimp : link = link(0,"[13] Arto Huotari - Helsinki/Finland","http://cimg.sourceforge.net/img/postcard36.jpg")
#@gimp : link = link(0,"[14] Benoit Gauzere - California/USA","http://cimg.sourceforge.net/img/postcard33.jpg")
#@gimp : link = link(0,"[15] Arkadi Gelfond - Foster City - California/USA","http://cimg.sourceforge.net/img/postcard30.jpg")
#@gimp : link = link(0,"[16] Corinne Masimann - Neuchatel/Switzerland","http://cimg.sourceforge.net/img/postcard29.jpg")
#@gimp : link = link(0,"[17] Mahvin - Portland/USA","http://cimg.sourceforge.net/img/postcard27.jpg")
#@gimp : link = link(0,"[18] Vincent Roullier - Caen/France","http://cimg.sourceforge.net/img/postcard26.jpg")
#@gimp : link = link(0,"[19] M???? - Munich/Germany","http://cimg.sourceforge.net/img/postcard24.jpg")
#@gimp : link = link(0,"[20] F. Albior - Jaca/Spain","http://cimg.sourceforge.net/img/postcard23.jpg")
#@gimp : link = link(0,"[21] PhotoComIX - Frascati/Italy","http://cimg.sourceforge.net/img/postcard22.jpg")
#@gimp : link = link(0,"[22] Guy Poizat - Cabestany/France","http://cimg.sourceforge.net/img/postcard21.jpg")
#@gimp : link = link(0,"[23] Institut for Biomathematik und Biometrie - Neuherberg/Germany","http://cimg.sourceforge.net/img/postcard20.jpg")
#@gimp : link = link(0,"[24] Jaime - Barcelona/Spain","http://cimg.sourceforge.net/img/postcard14.jpg")
#@gimp : link = link(0,"[25] Jean-Michel Webbe - Guadeloupe/France","http://cimg.sourceforge.net/img/postcard15.jpg")
#@gimp : sep = separator()
#@gimp : note = note{"\nMay the force be with you!"}
gimp_friends :
  -if @# ratio={w/h} -else ratio=1 -endif
  -rm -_heart80x73 -scale3x -r 150%,150%,1,1,0,0,0.5,0.5
  --*[-1] 70 --*[-2] 110 --*[-3] 255 -*[-4] 255 -a c
  -blur_radial 4 -sharpen 300
  -i[-2] @{-fitratio_wh\ {w},{h},$ratio},1,3
  -rand[-2] 0,255 -sh[-2] 1,2 -/[-1] 2 -rm[-1]
  -blur_radial[-2] 20 -sharpen[-2] 50
  -r[-1] [-2],[-2],1,4,0,0,0.5,0.5 -blend alpha
  113,67,1,1,0 -t[-1] "Greetings to\n  all G\47MIC\n  friends!",2,-2,23,1,1
  --dilate[-1] 3 -*[-2] 255 -to_rgb[-2] -j[-3] [-2],{(@{-3,w}-@{-2,w})/2},{(@{-3,h}-@{-2,h})/2.2},0,0,1,[-1]
  -rm[-2,-1]

_heart80x73 :
  40,73,1,1,0 -ellipse 22,22,20,20,0,1,1 -polygon 3,7,37,42,72,42,27,1,1 --mirror x -a x

#@gimp Gmicky / Roddy : gimp_gmicky, gimp_gmicky_preview
#@gimp : Mascot image = choice("Gmicky","Gmicky & Wilber","Roddy")
#@gimp : sep = separator()
#@gimp : note = note{"<b><i>Gmicky</i></b> is the name of the <b>G'MIC</b> mascot. He is a small and cute tiger who knows how to do magic.
#@gimp : <b><i>Gmicky</i></b> is a tiger, i.e. fast, agile and elegant, just as the <b>G'MIC</b> code is :).
#@gimp : As many magicians, <b><i>Gmicky</i></b> knows lot of <b>gimmicks</b>, and he is a direct and friendly competitor of
#@gimp : the ImageMagick's wizard, or the GraphicMagick's frog."}
#@gimp : note = note{"<b><i>Roddy</i></b> is another mascot designed specifically for the <i>Artistic / Rodilius</i> filter of <b>G'MIC</b>."}
#@gimp : note = note{"<b><i>Gmicky</i></b> and <b><i>Roddy</i></b> have been both created and drawn by "}
#@gimp : link = link("Mahvelous Mahvin","http://www.mahvin.com/")
gimp_gmicky :
  -rm
  -if {$1==0} -gmicky
  -elif {$1==1} -gmicky_wilber
  -else -roddy
  -endif

gimp_gmicky_preview :
  w={w} h={h} -rm
  -if {$1==0}
    filename=@{-path_tmp}/gmicky_small.cimgz
    url=http://gmic.eu/img/gmicky_small.cimgz
  -elif {$1==1}
    filename=@{-path_tmp}/gmicky_wilber_small.cimgz
    url=http://gmic.eu/img/gmicky_wilber_small.cimgz
  -else
    filename=@{-path_tmp}/roddy_small.cimgz
    url=http://gmic.eu/img/roddy_small.cimgz
  -endif
  -if $filename $filename -else -i $url -o $filename -endif
  -r2dy $h

#@gimp Links : _none_, _none_
#@gimp : note = note{"
#@gimp : Here is a list of links that might help you in finding additional information about the <b>G'MIC</b> open-source project.
#@gimp : "}
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Documentation:</b></small>")
#@gimp : note = link{0,"Official G'MIC wiki.","https://sourceforge.net/p/gmic/wiki/Home/"}
#@gimp : note = link{0,"Screenshots of some of the plug-in filters.","http://gmic.eu/gimp.shtml"}
#@gimp : note = link{0,"List of available plug-in filters.","http://gmic.eu/gimp_filters.txt"}
#@gimp : note = link{0,"Tutorial for learning the G'MIC language.","http://gmic.eu/tutorial/index.shtml"}
#@gimp : note = link{0,"Reference documentation of the G'MIC language (html).","http://gmic.eu/reference.shtml"}
#@gimp : note = link{0,"Reference documentation of the G'MIC language (pdf).","http://gmic.eu/gmic_reference.pdf"}
#@gimp : note = link{0,"Tutorial videos","http://www.youtube.com/channel/UC05Y8hpbFOSQ4ivh01R_1AQ"}
#@gimp : sep = separator()
#@gimp : note = note("<small><b>News / Communities:</b></small>")
#@gimp : note = link{0,"G'MIC news on Google+.","https://plus.google.com/117441237982283011318/posts"}
#@gimp : note = link{0,"G'MIC community on Google+.","https://plus.google.com/u/0/b/117441237982283011318/communities/100367598461382347439"}
#@gimp : note = link{0,"G'MIC community on GimpChat.","http://www.gimpchat.com/viewforum.php?f=28"}
#@gimp : note = link{0,"G'MIC community on Flickr.","http://www.flickr.com/groups/gmic/discuss/"}

#@gimp Release notes : _none_, _none_
#@gimp : note = note{"
#@gimp : - <b>01/13/2009</b> : version <i>1.3</i> (initial plug-in release).\n
#@gimp : - <b>09/03/2010</b> : version <i>1.4</i>.\n
#@gimp : - <b>07/07/2011</b> : version <i>1.5.0.0</i>.\n
#@gimp : - <b>03/01/2012</b> : version <i>1.5.1.0</i>.\n
#@gimp : - <b>10/15/2012</b> : version <i>1.5.2.0</i>.\n
#@gimp : - <b>01/07/2013</b> : version <i>1.5.3.0</i>.\n
#@gimp : - <b>01/28/2013</b> : version <i>1.5.4.0</i>.\n
#@gimp : - <b>03/08/2013</b> : version <i>1.5.5.0</i>.\n
#@gimp : - <b>06/03/2013</b> : version <i>1.5.6.0</i>.\n
#@gimp : - <b>09/09/2013</b> : version <i>1.5.7.0</i>.\n
#@gimp : - <b>12/07/2013</b> : version <i>1.5.8.0</i>.\n
#@gimp : - <b>05/14/2014</b> : version <i>1.5.9.0</i>.\n
#@gimp : - <b>08/20/2014</b> : version <i>1.6.0.0</i>.\n
#@gimp : - <span foreground="purple"><b>02/04/2015</b> : version <i>1.6.0.4</i> (Current stable).</span>\n
#@gimp : - <b>02/16/2015</b> : version <i>1.6.1.0</i> (Current beta).\n
#@gimp : "}
#@gimp : sep = separator()
#@gimp : link = link("View latest changelog","https://www.flickr.com/groups/gmic/discuss/72157649713920459/")

#@gimp _<b>Arrays &amp; tiles</b>
#--------------------------------

#@gimp Array [faded] : gimp_array_fade, gimp_array_fade_preview(1)
#@gimp : X-tiles = int(2,1,10)
#@gimp : Y-tiles = int(2,1,10)
#@gimp : X-offset (%) = float(0,0,100)
#@gimp : Y-offset (%) = float(0,0,100)
#@gimp : Fade start (%) = float(80,1,100)
#@gimp : Fade end (%) = float(90,1,100)
#@gimp : Mirror = choice("None","x-axis","y-axis","xy-axes")
#@gimp : Size = _choice("Shrink", "Expand", "Repeat [Memory consuming!]")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_array_fade :
  -if {$7&1} -mirror x -endif -if {$7>1} -mirror y -endif
  -array_fade $1,$2,$5,$6,$8
  -shift -$3%,-$4%,0,0,2

gimp_array_fade_preview :
  -gimp_array_fade $1,$2,$3,$4,$5,$6,$7,0

#@gimp Array [mirrored] : gimp_array_mirror, gimp_array_mirror_preview(1)
#@gimp : Iterations = int(1,1,10)
#@gimp : X-offset (%) = float(0,0,100)
#@gimp : Y-offset (%) = float(0,0,100)
#@gimp : Array mode = choice(2,"x-axis","y-axis","xy-axes","2xy-axes")
#@gimp : Initialization = choice("Original","Mirror X","Mirror Y","Rotate 90 deg.","Rotate 180 deg.","Rotate 270 deg.")
#@gimp : Expand size = _bool(false)
#@gimp : Crop (%) = int(0,0,100)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_array_mirror : -skip ${7=0}
  -if {$5==1} -mirror x
  -elif {$5==2} -mirror y
  -elif {$5==3} -rotate 90
  -elif {$5==4} -rotate 180
  -elif {$5==5} -rotate 270
  -endif
  -if $7
    -if {$4==0} -columns 0,{100-$7}%
    -elif {$4==1} -rows 0,{100-$7}%
    -elif {$4==2} -z 0,0,{100-$7}%,{100-$7}%
    -elif {$4==3} -z {$7/2}%,{$7/2}%,{100-$7/2}%,{100-$7/2}%
    -endif
  -endif
  -shift -$2%,-$3%,0,0,2
  -array_mirror $1,$4,$6

gimp_array_mirror_preview :
  -gimp_array_mirror $1,$2,$3,$4,$5,0,$7

#@gimp Array [random] : array_random, array_random(1)
#@gimp : Source X-tiles = int(5,1,20)
#@gimp : Source Y-tiles = int(5,1,20)
#@gimp : Destination X-tiles = int(7,1,20)
#@gimp : Destination Y-tiles = int(7,1,20)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")

#@gimp Array [random colors] : gimp_array_color, gimp_array_color(1)
#@gimp : X-tiles = int(5,1,20)
#@gimp : Y-tiles = int(5,1,20)
#@gimp : Opacity = float(0.5,0,1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_array_color :
  -repeat @# -l[-1]
    $1,$2,1,3 -rand[-1] 0,255 -to_colormode[-1] @{-2,s} -r[-1] [-2] -*[-1] $3 -*[-2] {1-$3} -+[-2,-1]
  -endl -mv[-1] 0 -done

#@gimp Array [regular] : gimp_array, gimp_array_preview(1)
#@gimp : X-tiles = int(2,1,10)
#@gimp : Y-tiles = int(2,1,10)
#@gimp : X-offset (%) = float(0,0,100)
#@gimp : Y-offset (%) = float(0,0,100)
#@gimp : Mirror = choice("None","x-axis","y-axis","xy-axes")
#@gimp : Size = _choice("Shrink", "Expand", "Repeat [Memory consuming!]")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_array :
  -shift -$3%,-$4%,0,0,2
  -if {$5&1} -mirror x -endif -if {$5>1} -mirror y -endif
  -array $1,$2,$6

gimp_array_preview :
  -gimp_array $1,$2,$3,$4,$5,0

#@gimp Ascii art : gimp_asciiart, gimp_asciiart_preview(0)
#@gimp : Charset = choice(5,"Custom","Binary digits","Digits","Lowercase letters","Uppercase letters","Ascii","Card suits","Math symbols")
#@gimp : Custom dictionnary = text{" .oO0"}
#@gimp : Analysis scale = int(16,8,103)
#@gimp : Analysis smoothness = float(15,0,100)
#@gimp : Synthesis scale = int(16,8,103)
#@gimp : Result type = choice(2,"White on black","Black on white","Colored on black","Colored on transparent")
#@gimp : sep = separator()
#@gimp : Gamma = float(0,-3,3)
#@gimp : Smoothness = float(0.2,0,5)
#@gimp : Colors = choice("Full colors","2 colors","3 colors","4 colors","8 colors","12 colors","16 colors",
#@gimp :                 "Grayscale","2 grays","3 grays","4 grays","8 grays","12 grays","16 grays")
#@gimp : sep = separator()
#@gimp : Output ascii file = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : Output filename = _text("gmic_asciiart.txt")
#@gimp : sep = separator(), link = link("Click here for a detailed description of this filter.","http://www.gimpchat.com/viewtopic.php?f=28&t=10047")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>03/27/2014</i>.</small>")
gimp_asciiart :
  -repeat @# -l[$>] -to_rgb
    -apply_gamma {10^$7} -b $8% -n 0,255
    -if {$1==0} dict="$2"
    -elif {$1==1} dict=" 01"
    -elif {$1==2} dict=" 0123456789"
    -elif {$1==3} dict=" abcdefghijklmnopqrstuvwxyz"
    -elif {$1==4} dict=" ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    -elif {$1==5} dict=" !\042\#$%&\047()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\133\\\135^_\140abcdefghijklmnopqrstuvwxyz\173|\174~"
    -elif {$1==6} dict=" \16\17\20\21"
    -elif {$1==7} dict=" \200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217\220\221\222\223\224\225\226\227\230\231"
    -endif
    -if {$6==1} -negative -endif
    -if $-3 --img2ascii $dict,$3,$4%,$5,"$-2"/"$-1"
    -else --img2ascii $dict,$3,$4%,$5
    -endif
    wh=@{}
    -if {$6==0} -k[-1] -n 0,255
    -elif {$6==1} -k[-1] -negative -n 0,255
    -elif {$6==2||$6==3}
      -r[0] $wh,1,100%,1
      -if {$9>=7} -luminance[0] -endif
      -if {$9%7} -quantize[0] {arg($9%7,2,3,4,8,12,16)-1},1,0 -endif
      -r[0] [1],[1],1,100% -*[0] [1]
      -if {$6==2} -rm[1]
      -else -*[1] 255 -a c
      -endif
    -endif
  -endl -done

gimp_asciiart_preview :
  -repeat @# -l[$>]
    w={w} h={h}
    -gimp_asciiart $1,"$2",${3--4},0,foo,foo
    -r $w,$h,1,100%,0,0,0.5,0.5
  -endl -done

#@gimp Chessboard : gimp_chessboard, gimp_chessboard_preview(0)
#@gimp : First size = int(64,1,512)
#@gimp : Second size = int(64,1,512)
#@gimp : First offset = int(0,0,512)
#@gimp : Second offset = int(0,0,512)
#@gimp : Angle = float(0,0,180)
#@gimp : Opacity = float(0.5,0,1)
#@gimp : First color = color(0,0,0,255)
#@gimp : Second color = color(255,255,255,255)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_chessboard :
  -to_rgba -chessboard ${1-14}

gimp_chessboard_preview :
  -gimp_split_preview "-gimp_chessboard $*",$-1

#@gimp Dices : gimp_dices, gimp_dices(0)
#@gimp : Resolution = float(2,1,10)
#@gimp : Size = int(24,8,64)
#@gimp : Color model = choice(1,"Black dices","White dices","Dices with colored numbers","Dices with colored sides")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>06/27/2013</i>.</small>")
gimp_dices :

    # Create dice patterns.
    -repeat 6 {2*$2},{2*$2} -_dice$> -done
    -if {$3%2} -negative[-6--1] -endif
    -frame_round[-6--1] 10,10,0,0,128,128,128,0
    -r2dy[-6--1] $2 -a[-6--1] x

    -repeat {@#-1} -l[$>,-1]

      # Prepare input images.
      --luminance[0] -rv[1,2] -r[0,1] {100*$1/$2}%,{100*$1/$2}%,1,100%,2 -quantize[1] 6,0

      # Convert input image to dices pattern.
      -*[-2] $2 -channels[-2] 0,1 -r[-2] {$2*100}%,{$2*100}%
      $2,$2,1,2,'if(c,y,x)' -r[-1] [-3],[-3],1,2,0,2 -+[-3,-1] --warp[-1] [-2],0,0 -rm[-3]

      -if {$3<2} -rm[0] -mv[-1] 0
      -else -r[0] [2],[2],1,100% -rv[0,-1] -blend[0,-1] multiply
      -endif

    -endl -done -rm[-1]

_dice0 : -ellipse[-1] 50%,50%,5.2%,5.2%,0,1,255
_dice1 : -ellipse[-1] 25%,25%,5.2%,5.2%,0,1,255 -ellipse[-1] 75%,75%,5.2%,5.2%,0,1,255
_dice2 : -_dice1 -_dice0
_dice3 : -_dice1 -ellipse[-1] 25%,75%,5.2%,5.2%,0,1,255 -ellipse[-1] 75%,25%,5.2%,5.2%,0,1,255
_dice4 : -_dice3 -_dice0
_dice5 : -_dice3 -ellipse[-1] 25%,50%,5.2%,5.2%,0,1,255 -ellipse[-1] 75%,50%,5.2%,5.2%,0,1,255

#@gimp Extract objects : gimp_extract_objects, gimp_extract_objects_preview(1)
#@gimp : X-background (%) = float(0,0,100)
#@gimp : Y-background (%) = float(0,0,100)
#@gimp : Color tolerance = int(20,0,256)
#@gimp : Opacity threshold (%) = int(50,0,100)
#@gimp : Minimal area = float(0.3,0,5)
#@gimp : Connectivity = choice("Low","High")
#@gimp : Output as = _choice(0,"Crop","Segmentation")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>01/26/2015</i>.</small>")
#@gimp : note = link("Filter explained here","http://gimpchat.com/viewtopic.php?f=28&t=7905")
gimp_extract_objects :
  -if $5 min_area=$5% -else min_area=5 -endif
  -repeat @# -l[$<] -to_rgba
    w={w} h={h}
    x={$1%*(w-1)}
    y={$2%*(h-1)}
    color=@{-at\ $x,$y}
    -if {$7==0} # Output: Crop.
      --replace_color $3,0,$color,0,0,0,0 -autocrop_components[-1] $4%,$min_area,$6,2
      -repeat {w}
        --z[0] @{1,i($>,0)},@{1,i($>,1)},@{1,i($>,3)},@{1,i($>,4)}
        -nm[-1] pos(@{1,i($>,0)},@{1,i($>,1)})
      -done -rm[0,1]
    -elif {$7==1} # Output: Segmentation.
      -replace_color $3,0,$color,0,0,0,0 --autocrop_components $4%,$min_area,$6,2
      -repeat {w}
        --z[0] @{1,i($>,0)},@{1,i($>,1)},@{1,i($>,3)},@{1,i($>,4)}
        -nm[-1] pos(@{1,i($>,0)},@{1,i($>,1)})
      -done -rm[0,1]
    -endif
    $w,$h,1,4 -fc[-1] $color
  -endl -done

gimp_extract_objects_preview :
  -if $5 min_area=$5% -else min_area=5 -endif
  -repeat @# -l[$>] -to_rgba
    x={$1%*(w-1)}
    y={$2%*(h-1)}
    color=@{-at\ $x,$y}
    --replace_color $3,0,$color,0,0,0,0
    -autocrop_components[-1] $4%,$min_area,$6,2
    -repeat {w}
      xycoords=@{1,i($>,0)},@{1,i($>,1)},@{1,i($>,3)},@{1,i($>,4)}
      -rectangle[0] $xycoords,0.3,0,0,255,255
      -rectangle[0] $xycoords,1,0xFFFFFFFF,0,0,0,255
    -done
    -drgba[0]
    -text_outline[0] {w}" objects",2,2,13,2,0.3,255,255,255,255
    -k[0]
    -circle $x,$y,3,1,0,255,0
    -circle $x,$y,3,1,0xFFFFFFFF,0
  -endl -done

#@gimp Grid [cartesian] : gimp_imagegrid, gimp_imagegrid(0)
#@gimp : X-size = int(10,2,100)
#@gimp : Y-size = int(10,2,100)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_imagegrid :
  -imagegrid $1,$2

#@gimp Grid [hexagonal] : imagegrid_hexagonal, imagegrid_hexagonal(1)
#@gimp : Resolution = int(32,1,128)
#@gimp : Outline = float(0.1,0,0.5)
#@gimp : Anti-aliasing = bool(1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>01/12/2015</i>.</small>")

#@gimp Make seamless : gimp_make_seamless, gimp_make_seamless_preview(1)
#@gimp : Equalize light = float(0,0,100)
#@gimp : sep = separator(),
#@gimp : Preview original = bool(0)
#@gimp : Tiled preview = choice(1,"None","2x2","3x3","4x4")
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note{"<small><b>Note:</b> This filter helps in converting your input pattern as a <b>seamless</b> (a.k.a periodic) texture.</small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>04/16/2014</i>.</small>")
gimp_make_seamless :
  -repeat @# -l[$>]
    -if $1 --b {20.5-$1/50}% --[0] [1] -fc[-1] @{-average_color[-1]} -+ -endif
  -endl -done
  -periodize_poisson -c 0,255

gimp_make_seamless_preview :
  -gimp_split_preview "-if {!$2} -gimp_make_seamless $* -endif -if $3 -array {$3+1},{$3+1} -endif",$-1

#@gimp Ministeck : gimp_ministeck, gimp_ministeck_preview(1)
#@gimp : Number of colors = int(8,2,24)
#@gimp : Resolution (px) = int(64,16,256)
#@gimp : Piece size (px) = int(8,1,64)
#@gimp : Piece complexity = int(2,1,10)
#@gimp : Relief amplitude = float(100,0,256)
#@gimp : Relief size = float(0.3,0,1)
#@gimp : Add 1px outline = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>01/14/2015</i>.</small>")
gimp_ministeck :
  -repeat @# -l[$>]
    -if {w>h} -r2dx {min($2,w)} -else -r2dy {min($2,h)} -endif
    -split_opacity -l[0]
      --colormap[-1] $1 -index[-2] [-1]
      [0],[0],1,1 -rand[2] 0,1 -dilate[2] $4 -+[0,2]
      -r[0] $3""00%,$3""00%
      --g[0] xy,1 -!=[-2,-1] 0 --f[0] 'i(x+1,y+1)-i(x,y)' -!=[-3--1] 0 -or[-3--1]
      -z[0,-1] 0,0,{w-2},{h-2}
      -if $7 [-1] -endif
      --shift[-1] 1,1 -*[-2] -1 -+[-2,-1] -b[-1] {$6*$3/5} -n[-1] -$5,$5
      -map[0] [1] -rm[1] -+[0,-1]
      -if $7 -==[1] 0 -* -endif
    -endl -r[-1] [0],[0],1,100% -a c
  -endl -done
  -c 0,255

gimp_ministeck_preview :
  -repeat @# -l[$>]
    w={w} h={h}
    -gimp_ministeck $*
    -r $w,$h,1,100%,0,0,0.5,0.5
  -endl -done

#@gimp Montage : gimp_montage, gimp_montage_preview(1)
#@gimp : Montage type = choice("Auto","Custom layout","Horizontal","Vertical","Horizontal array","Vertical array")
#@gimp : Custom layout = text{"V(H(0,1),H(2,V(3,4)))"}
#@gimp : Merging mode = choice(1,"Aligned","Scaled")
#@gimp : Centering / scale = float(0.5,0,1)
#@gimp : Padding (px) = int(0,0,128)
#@gimp : sep = separator()
#@gimp : Frame (px) = int(0,0,128)
#@gimp : Frame color = color(0,0,0,255)
#@gimp : sep = separator()
#@gimp : Angle = float(0,0,360)
#@gimp : Angle variations = float(0,0,180)
#@gimp : sep = separator()
#@gimp : Cycle layers = int(0,-255,255)
#@gimp : Output as = _choice("Single layer","Multiple layers")
#@gimp : sep = separator()
#@gimp : note = note{"<small><b>Instructions:</b>\n
#@gimp : - Don't forget to set the <i>Input layers...</i> option on the left if you have multiple input layers for your montage.\n
#@gimp : - The size ratio of the layers displayed in the preview window may not reflect what you get in the final rendering.\n
#@gimp : - The <i>Custom layout</i> parameter is only active when <i>Montage type</i> is set to <i>Custom layout</i>.
#@gimp : This is basically a string containing expressions such as:\n
#@gimp : \n     . <i>H(a,b)</i> or <i>V(a,b)</i> stand respectively for an horizontal and vertical merge of two blocks <i>a</i> and <i>b</i>.
#@gimp : \n     . <i>R(a)</i>, stands for a 90-deg. rotated version of a block <i>a</i>. Use <i>RR(a)</i> and <i>RRR(a)</i> for resp. 180-deg and 270-deg. rotations.
#@gimp : \n     . <i>M(a)</i>, stands for a X-mirrored version of a block <i>a</i>. Use <i>MRR(a)</i> for a Y-mirrored version of <i>a</i>.\n\n
#@gimp : - A block <i>a</i> can be a layer indice or a nested montage expression itself.\n
#@gimp : - Layer indices start from <i>0 (top layer)</i> and are treated periodically.
#@gimp : </small>"}
#@gimp : link = link("Click here for a tutorial","http://blog.patdavid.net/2014/05/gmic-montage.html")
#@gimp : link = link("+ video tutorial","http://www.youtube.com/watch?v=iM42vx22gwg")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/22/2014</i>.</small>")
gimp_montage : -skip "${2=A}"
  -if {!@#} -return -endif
  code0=X code1="$2" code2=H code3=V code4=A code5=B
  -if {$3==1&&$4<0.5} -r {max(10,$4*200)}%,{max(10,$4*200)}%,1,100%,2 -endif
  -to_rgba -if {$13%@#} -mv[{$13%@#}--1] 0 -endif
  -if {$11||$12} -repeat @# -rotate[$>] {$11+?(-$12,$12)},1,0 -done -endif
  -montage ${code$1},{if($3==0,$4,2+max(0,$4-0.5))},$14,\
    "-if {$""7%2} -mirror x -endif -if {$""8%2} -mirror y -endif "\
    "-rotate {90*$""6} "\
    "-if {$5||$6} "\
    "-r {max(1,$""4-2*($5+$6))},{max(1,$""5-2*($5+$6))},1,100%,2 "\
    "-frame $6,$6,${7-10} "\
    "-r {w+2*$5},{h+2*$5},1,100%,0,0,0.5,0.5 "\
    "-else -r $""4,$""5,1,100%,2 -endif "
  -if $14 -gimp_autocrop_layers -endif

gimp_montage_preview : -skip "${2=A}"
  -if {!@#} -return -endif
  w={w} h={h}
  -if {$3==1&&$4<0.5} -r {max(10,$4*200)}%,{max(10,$4*200)}%,1,100%,2 -endif
  -drgba
  code0=X code1="$2" code2=H code3=V code4=A code5=B
  -to_rgba -if {$13%@#} -mv[{$13%@#}--1] 0 -endif
  -if {$11||$12} -repeat @# -rotate[$>] {$11+?(-$12,$12)},1,0 -done -endif
  -montage ${code$1},{if($3==0,$4,2+max(0,$4-0.5))},0,\
    "-if {$""7%2} -mirror x -endif -if {$""8%2} -mirror y -endif "\
    "-rotate {90*$""6} "\
    "-if {$5||$6} "\
    "  -r {max(1,$""4-2*($5+$6))},{max(1,$""5-2*($5+$6))},1,100%,2 fs={min(53,max(w,h)/3)} "\
    "  -frame $6,$6,${7-10} "\
    "  -r {w+2*$5},{h+2*$5},1,100%,0,0,0.5,0.5 "\
    "  0 -t[-1] $""1,0,0,$fs,1,255 -expand_xy[-1] 3,0 [-1]x3 -a[-4--2] c -dilate[-1] {3+2*$fs/20} -a[-2] [-1],c -j[0] [1],{5+$5+$6},{$5+$6},0,0,1,[2],255 -k[0] "\
    "-else "\
    "  -r $""4,$""5,1,100%,2 fs={min(53,max(w,h)/3)} "\
    "  0 -t[-1] $""1,0,0,$fs,1,255 -expand_xy[-1] 3,0 [-1]x3 -a[-4--2] c -dilate[-1] {3+2*$fs/20} -a[-2] [-1],c -j[0] [1],5,0,0,0,1,[2],255 -k[0] "\
    "-endif "
  nw={w} nh={h}
  -resize_ratio2d $w,{$h-16},2,2
  -drgba
  -i[0] 100%,15,1,3,240 -t[0] "Estimated size : "{round(100*$nw/$w)}%" x "{round(100*$nh/$h)}%,2,0,16 -r[0] 100%,16,1,3,0
  -a y

#@gimp Puzzle : gimp_puzzle, gimp_puzzle_preview(1)
#@gimp : note = note("<small><b>Pattern parameters:</b></small>")
#@gimp : X-tiles = int(5,2,32)
#@gimp : Y-tiles = int(5,2,32)
#@gimp : Curvature = float(0.5,0,1.5)
#@gimp : Connectors centering = float(0,0,1)
#@gimp : Connectors variability = float(0,0,2)
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Blending parameters:</b></small>")
#@gimp : Relief smoothness = float(0.3,0,3)
#@gimp : Relief contrast = float(100,0,255)
#@gimp : Outline smoothness = float(0.2,0,3)
#@gimp : Outline contrast = float(255,0,255)
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Recomposition parameters:</b></small>")
#@gimp : Scale = float(100,0,150)
#@gimp : Scale variations = float(0,0,100)
#@gimp : Angle = float(0,-180,180)
#@gimp : Angle variations = float(0,0,180)
#@gimp : Shuffle pieces = bool(0)
#@gimp : Additional outline = bool(0)
#@gimp : Output each piece on a different layer = _bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>01/06/2014</i>.</small>")
gimp_puzzle :
  -repeat @# -l[$<]
    w={w} h={h} -to_rgb
    -puzzle $w,$h,$1,$2,$3,$4,$5
    --b[-1] $6%,0 -g[-1] xy -+[-2,-1] -n[-1] -$7,$7 -+[0,-1]  # Relief.
    --b[-1] $8%,0 -n[-1] 0,1 -*[-1] -1 -+[-1] 1 -n[-1] {(255-$9)/255},1 -*[0,-1] -c 0,255  # Outline.

    -if {$10!=100||$11||$12||$13||$14||$15||$16}

      # Decompose puzzle into set of pieces.
      ---[-1] 1 -label_fg[-1] 0
      --area_fg[-1] 0,0 -<[-1] 50% -or[-3] [-1] -==[-1] 0 -*[-2,-1]
      -distance[-2] 0 -*[-2] -1 -watershed[-1] [-2] -rm[-2] -label[-1] 0,0

      -repeat {iM+1}
        --==[1] $>
        coords=@{-autocrop_coords[-1]\ 0}
        --z[0] $coords -z[-2] $coords -rv[-2,-1] -*[-2] [-1] -*[-1] 255 -a[-2,-1] c
        x$>={arg(1,$coords)+round(w/2)} y$>={arg(2,$coords)+round(h/2)}
      -done
      -rm[0,1]

      # Recompose puzzle.
      -if $14 -sort_list +,? -endif

      -if $16 # One piece by layer.
        -repeat @# -l[$<]
          -r2dy {max(0.1,$10+$11*?(-1,1))}% -rotate {$12+$13*?(-1,1)}
          -if $15 -expand_xy 1,0 -endif
          cx={round(w/2)} cy={round(h/2)}
          -sh 100%,100% -if $15 -dilate[-1] 3 -endif
          -i[0] $w,$h,1,4
          -j[0] [-2],{${x$<}-$cx},{${y$<}-$cy},0,0,1,[-1],255 -rm[-2,-1]
        -endl -done

      -else # All pieces on the same layer.
        -i[0] $w,$h,1,{s}
        -repeat {@#-1}
          -r2dy[-1] {max(0.1,$10+$11*?(-1,1))}% -rotate[-1] {$12+$13*?(-1,1)}
          -if $15 -expand_xy[-1] 1,0 -endif
          cx={round(w/2)} cy={round(h/2)}
          -sh[-1] 100%,100% -if $15 -dilate[-1] 3 -endif
          -j[0] [-2],{${x$<}-$cx},{${y$<}-$cy},0,0,1,[-1],255 -rm[-2,-1]
        -done
      -endif

    -else -rm[-1]
    -endif
  -endl -done

gimp_puzzle_preview :
  -gimp_puzzle ${1-15},0

#@gimp Taquin : gimp_taquin, gimp_taquin(1)
#@gimp : X-tiles = int(7,1,20)
#@gimp : Y-tiles = int(7,1,20)
#@gimp : Remove tile = choice("None","First","Last","Random")
#@gimp : sep = separator()
#@gimp : Relief = float(50,0,255)
#@gimp : Border thickness (%) = float(5,0,100)
#@gimp : Border outline = int(0,0,16)
#@gimp : Ouline color = color(0,0,0,255)
#@gimp : sep = separator()
#@gimp : Random seed = int(0,0,65535)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>01/13/2014</i>.</small>")
gimp_taquin :
  -to_a -repeat @# -l[$>] -srand $11 -taquin $1,$2,$3,$4,$5%,$6,${7-10} -endl -done

#@gimp Tileable rotation : gimp_rotate_tileable, gimp_rotate_tileable_preview(1)
#@gimp : Angle = float(45,0,360)
#@gimp : Maximum size factor = int(8,0,20)
#@gimp : Array mode = choice(0,"None","x-axis","y-axis","xy-axes","2xy-axes")
#@gimp : sep = separator(), note = note("<small><b>Note:</b> This filter implements the tileable rotation technique described by <b>Peter Yu</b>, at:</small>")
#@gimp : link = link("[Peter Yu] Create rotated tileable patterns","http://www.peteryu.ca/tutorials/gimp/rotate_tileable_patterns")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>05/26/2011</i>.</small>")
gimp_rotate_tileable :
  -if $3 -array_mirror 1,{$3-1},1 -endif
  -rotate_tileable $1,{if($3==0,$2,$2/2)}

gimp_rotate_tileable_preview :
  -l -gimp_rotate_tileable $*
  -onfail -gimp_warning_preview "Invalid image size" -endl

#@gimp Tiled rotation : gimp_rotate_tiles, gimp_rotate_tiles(1)
#@gimp : X-tiles = int(5,1,80)
#@gimp : Y-tiles = int(5,1,80)
#@gimp : Angle = float(15,0,360)
#@gimp : X-shadow = float(3,-20,20)
#@gimp : Y-shadow = float(3,-20,20)
#@gimp : Smoothness = float(1.8,0,5)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_rotate_tiles :
  -to_rgba -rotate_tiles $3,$1,$2 -drop_shadow $4%,$5%,$6%

#@gimp Tiled normalization : gimp_normalize_tiles, gimp_normalize_tiles(1)
#@gimp : X-tiles = int(25,1,80)
#@gimp : Y-tiles = int(25,1,80)
#@gimp : Minimal value = float(0,0,255)
#@gimp : Maximal value = float(255,0,255)
#@gimp : Channel(s) = choice(3,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
_gimp_normalize_tiles :
  -repeat @# -l[-1] -split_tiles $1,$2 -n $3,$4 -append_tiles $1,$2 -endl -mv[-1] 0 -done

gimp_normalize_tiles :
  -apply_channels "-_gimp_normalize_tiles ${1-4}",$-1

#@gimp Tiled random shifts : gimp_shift_tiles, gimp_shift_tiles(1)
#@gimp : X-tiles = int(10,1,30)
#@gimp : Y-tiles = int(10,1,30)
#@gimp : Amplitude = float(10,0,100)
#@gimp : Opacity = float(1,0,1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_shift_tiles :
  -to_rgba -shift_tiles $1,$2,$3
  -if {$4<1} -repeat @# -s[-1] c -*[-1] $4 -a[-4--1] c -mv[-1] 0 -done -endif

#@gimp Tiled parameterization : gimp_parameterize_tiles, gimp_parameterize_tiles(1)
#@gimp : X-tiles = int(10,1,30)
#@gimp : Y-tiles = int(10,1,30)
#@gimp : Fitting function = choice("Linear","Quadratic")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_parameterize_tiles :
  -if $3
    -quadratize_tiles $1,$2
  -else
    -linearize_tiles $1,$2
  -endif
  -c 0,255

#@gimp Tiled isolation : gimp_isolate_tiles, gimp_isolate_tiles(0)
#@gimp : X-size = float(10,0,100)
#@gimp : Y-size = float(10,0,100)
#@gimp : X-border = float(5,0,100)
#@gimp : Y-border = float(5,0,100)
#@gimp : Keep tiles square = bool(1)
#@gimp : Keep borders square = bool(1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>04/13/2011</i>.</small>")
gimp_isolate_tiles :
  -repeat @# -l[$>] -to_rgba
    -if $5 sx={round(min(w,h)*max($1,$2)/100)} sy=$sx -else sx={round(w*$1/100)} sy={round(h*$2/100)} -endif
    -if $6 bx={max($3,$4)} by=$bx -else bx=$3 by=$4 -endif
    -s x,-$sx
    -repeat @# -l[$>] -s y,-$sy -r 100%,{100+$by}%,1,100%,0,0,0.5,0.5 -a y -endl -done
    -r {100+$bx}%,100%,1,100%,0,0,0.5,0.5 -a x
  -endl -done


#@gimp _<b>Artistic</b>
#----------------------

#@gimp Bokeh : bokeh, gimp_bokeh_preview(0)
#@gimp : note = note("<b><small>Global parameters:</small></b>")
#@gimp : Amplitude = float(250,0,600)
#@gimp : Smoothness = float(2,0,20)
#@gimp : Density = float(0.5,0,5)
#@gimp : sep = separator(), note = note("<b><small>Bokeh shape:</small></b>")
#@gimp : Size = int(24,1,64)
#@gimp : Outline size = float(10,0,100)
#@gimp : Outline amplitude = float(2,0,10)
#@gimp : Smoothness = float(0.7,0,5)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>04/24/2013</i>.</small>")
gimp_bokeh_preview :
  -gimp_split_preview "-bokeh $*",$-1

#@gimp Cartoon : cartoon, gimp_cartoon_preview(0)
#@gimp : Smoothness = float(3,0,10)
#@gimp : Sharpening = float(200,0,400)
#@gimp : Edge threshold = float(20,1,30)
#@gimp : Edge thickness = float(0.25,0,1)
#@gimp : Color strength = float(1.5,0,3)
#@gimp : Color quantization = int(8,2,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_cartoon_preview :
  -gimp_split_preview "-cartoon $*",$-1

#@gimp Circle abstraction : gimp_circle_abstraction, gimp_circle_abstraction_preview(1)
#@gimp : Number of colors = int(8,2,16)
#@gimp : Density = int(5,1,100)
#@gimp : Opacity = float(0.8,0,1)
#@gimp : Smoothness = float(0,0,4)
#@gimp : Filled circles = bool(1)
#@gimp : Fill transparent holes = bool(1)
#@gimp : Normalize colors = bool(1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>06/16/2014</i>.</small>")
gimp_circle_abstraction :
  -repeat @# -l[$>]
    -b $4%
    --colormap $1 -index[0] [1],0,0
    [0],[0],1,4,0

    -repeat $1
      -rprogress {$>*100/$1}
      --==[0] $>
      -skeleton3d[-1] 2,2,0,1,0
      -if @{-1,7} # Process only non empty objects.
        -s3d[-1] -l[-6--1]
          -r[2] 3,@{2,h/3},1,1,-1
          1,@{2,h/2*$2%},1,1,1 -r[-1] 1,@{2,h/2},1,1,4 -r[-1] 3,200% -*[2,-1] -y
        -endl
        -a[-6--1] y -col3d[-1] @{-at[1]\ $>}

        [0],[0],1,4,0
        -j3d[-1] [-2],0,0,0,1,{1+$5},0,0
        -sh[-1] 3,3 -col3d[-3] 255 -j3d[-1] [-3],0,0,0,$3,{1+$5},0,0 -rm[-1]
        -rm[-2]
        -blend[2,-1] alpha
      -endif
    -done
    -k[2]
    -if $6 --channels 3 -<[-1] 1 -inpaint[0] [1],0,1 -rm[-1] -channels[-1] 0,2 -endif
    -if $7 -n 0,255 -endif
    -rprogress 100
  -endl -done

gimp_circle_abstraction_preview :
  -gimp_split_preview "-gimp_circle_abstraction $*",$-1

#@gimp Cubism : gimp_cubism, gimp_cubism_preview(1)
#@gimp : Iterations = int(2,0,10)
#@gimp : Density = float(50,0,200)
#@gimp : Thickness = float(10,0,50)
#@gimp : Angle = float(90,0,360)
#@gimp : Opacity = float(0.7,0.01,1)
#@gimp : Smoothness = float(0,0,5)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>06/05/2013</i>.</small>")
gimp_cubism :
  -repeat $1 -cubism ${2--1} -done

gimp_cubism_preview :
  -gimp_split_preview "-gimp_cubism $*",$-1

#@gimp Cutout : gimp_cutout, gimp_cutout_preview(1)
#@gimp : Number of levels = int(4,2,32)
#@gimp : Edge simplicity = float(0.5,0,3)
#@gimp : Edge fidelity = int(4,0,10)
#@gimp : Normalize = bool(1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i> and <i>Garagecoder</i>.      Latest update: <i>06/03/2014</i>.</small>")
gimp_cutout :
  -repeat @# -l[$>] -split_opacity -l[0]
    -median {10-$3}
    -quantize $1
    --area[-1] 0,1 med=@{-med} -rm[-1]
    -inpaint_holes {$med*$2%},0,1
    -if $4 -n 0,255 -endif
  -endl -a c -endl -done

gimp_cutout_preview :
  -gimp_split_preview "-gimp_cutout $*",$-1

#@gimp Ellipsionism : gimp_ellipsionism, gimp_ellipsionism_preview(0)
#@gimp : Primary radius = float(20,1,100)
#@gimp : Secondary radius = float(10,1,100)
#@gimp : Smoothness = float(0.5,0,10)
#@gimp : Opacity = float(0.7,0,1)
#@gimp : Outline = float(8,1,3)
#@gimp : Density = float(0.5,0.1,2)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_ellipsionism :
  -ellipsionism ${^0}

gimp_ellipsionism_preview :
  -gimp_split_preview "-gimp_ellipsionism $*",$-1

#@gimp Felt pen : gimp_feltpen, gimp_feltpen_preview(0)
#@gimp : Amplitude = float(300,0,4000)
#@gimp : Density = float(50,0,100)
#@gimp : Smoothness = float(1,0,10)
#@gimp : Opacity = float(0.1,0,1)
#@gimp : Edge = float(20,0,100)
#@gimp : Thickness = int(5,2,32)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/25/2012</i>.</small>")
gimp_feltpen :
  -repeat @# -l[$>] --gimp_hardsketchbw ${1-5},0,0 -blend hardlight -erode_oct $6 -endl -done

gimp_feltpen_preview :
  -gimp_split_preview "-gimp_feltpen $*",$-1

#@gimp Fractalize : fractalize, fractalize(1)
#@gimp : Detail level = float(0.8,0,1)
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Note:</b> This filter uses lot of random values to generate its result, so running it twice will give you different results !</small>")
#@gimp : sep = separator(), link = link("Click here for a detailed description of this filter.","http://www.gimpchat.com/viewtopic.php?f=28&t=10036")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>04/25/2014</i>.</small>")

#@gimp Hope poster : gimp_poster_hope, gimp_poster_hope_preview(0)
#@gimp : Gamma = float(0,-3,3)
#@gimp : Smoothness = float(3,0,20)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>11/07/2013</i>.</small>")
gimp_poster_hope :
  -repeat @# -l[$>] -split_opacity -l[0]
    -apply_gamma {10^$1} -poster_hope $2
  -endl -a c -endl -done

gimp_poster_hope_preview :
  -gimp_split_preview "-gimp_poster_hope $*",$-1

#@gimp Kuwahara : gimp_kuwahara, gimp_kuwahara_preview(0)
#@gimp : Iterations = int(2,1,20)
#@gimp : Radius = int(5,1,30)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>05/31/2011</i>.</small>")
gimp_kuwahara :
  -apply_channels "-repeat $1 -kuwahara $2 -done",$3,0

gimp_kuwahara_preview :
  -gimp_split_preview "-gimp_kuwahara $*",$-1

#@gimp Lylejk's painting : gimp_lylejk_painting, gimp_lylejk_painting_preview(0)
#@gimp : Iterations = int(2,1,20)
#@gimp : Radius = int(4,1,30)
#@gimp : Canvas = float(10,0,100)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>Lyle Kroll</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>09/21/2011</i>.</small>")
#@gimp : note = link("Filter Explained here","http://www.gimpchat.com/viewtopic.php?f=10&t=2624")
gimp_lylejk_painting :
  -repeat @#
    --_gimp_lylejk_painting[-1] 10,10.49,0.75,0
    -smooth[-1] 300,0.26,1,0,7 -sharpen[-1] $3
    [-1] -rv[-3--1]
    -blend[-2,-1] lighten,0.5
    -blend[-2,-1] grainmerge,1
    -gimp_kuwahara[-1] $1,$2,0
    -texturize_canvas[-1] $3,4
  -mv[-1] 0 -done

gimp_lylejk_painting_preview :
  -gimp_split_preview "-gimp_lylejk_painting $*",$-1

_gimp_lylejk_painting :
  -apply_channels "-repeat $1 -b $3 -unsharp $3,$2 -c 0,255 -mv[-1] 0 -done",$4,0

#@gimp Painting : gimp_painting, gimp_painting_preview(0)
#@gimp : Abstraction = int(5,1,10)
#@gimp : Details scale = float(2.5,0,5)
#@gimp : Color = float(1.5,0,4)
#@gimp : Smoothness = float(50,0,1000)
#@gimp : Sharpen shades = bool(1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>Lyle Kroll</i>, <i>Angelo Lama</i> and <i>David Tschumperl&#233;</i>.\nLatest update: <i>02/28/2011</i>.</small>")
gimp_painting : -skip ${4=0},${5=0}
  -repeat @# -l[$>]
    -to_colormode {max(3,s)} -split_opacity -rv
    -repeat $1 -gimp_normalize_local[-1] 10,6,5,20,1,3 -done
    -gimp_anisotropic_smoothing[-1] {100*$2},0.2,1,$2,{2*$2},0.8,90,2,0,1,1,2,1,16
    -gimp_mix_lab[-1] 1,0,0,$3,0,0.5,$3,0,0.5,0,2,0
    -if $5 -gimp_segment_watershed[-1] 10,1,0 -endif
    -smooth[-1] $4,0,1,1,1
    -rv -a c
  -endl -done

gimp_painting_preview :
  -gimp_split_preview "-gimp_painting $*",$-1

#@gimp Pen drawing : gimp_pen_drawing, gimp_pen_drawing_preview(0)
#@gimp : Amplitude = float(10,0,30)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_pen_drawing :
  -drawing $1

gimp_pen_drawing_preview :
  -gimp_split_preview "-gimp_pen_drawing $*",$-1

#@gimp Polygonize [delaunay] : gimp_delaunay,gimp_delaunay_preview(0)
#@gimp : Density = float(5,0,100)
#@gimp : Edges = float(75,0,100)
#@gimp : Smoothness = float(1,0,8)
#@gimp : Background = choice(3,"Black","White","Flat random colors","Flat image colors","Original image")
#@gimp : Outline color = color(0,0,0,128)
#@gimp : Border constraints = bool(1)
#@gimp : Anti-aliasing = bool(1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>01/19/2015</i>.</small>")
gimp_delaunay :
  -repeat @# -l[$>] -split_opacity -l[0] -to_rgb
    --b $3
    -gradient_norm[-1] ->=[-1] {(100-$2)/5}
    -if $9 -rectangle[-1] 0,0,100%,100%,1,0xFFFFFFFF,1 -endif
    -remove_pixels[-1] {100-max(0.1,$1/4)}%
    -delaunay3d[-1]
    -l[-1] -s3d -rm[4] -i[4] 1,100%,1,1,y -r[4] 3,100% -y -a y -endl  # Assign a different color to each triangle.
    -if $10 -r[0] 200%,200% -*3d[1] 2 -endif

    -if {$4==0} -f[0] 0
    -elif {$4==1} -f[0] 255
    -elif {$4==2} -f[0] 0 -l[1] -s3d -rand[-2] 0,255 -a y -endl -j3d[0] [1],0,0,0,1,2,1,0,0
    -elif {$4==3} [0],[0],1,1,-1 -j3d[-1] [-2],0,0,0,1,2,1,0,0 -blend[0,-1] shapeaverage
    -endif
    -col3d[1] $5,$6,$7 -j3d[0] [1],0,0,0,{$8/255},1,1,0,0 -rm[1]

    -if $10 -r 50%,50%,1,100%,2 -endif
  -endl -a c -endl -done

gimp_delaunay_preview :
  -gimp_split_preview "-gimp_delaunay $*",$-1

#@gimp Polygonize [energy] : gimp_polygonize, gimp_polygonize_preview(0)
#@gimp : Amplitude = int(300,0,2000)
#@gimp : Smoothness = float(10,0,100)
#@gimp : Minimal area = float(10,0,100)
#@gimp : X-resolution = float(10,1,256)
#@gimp : Y-resolution = float(10,1,256)
#@gimp : Outline color = color(0,0,0,255)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), link = link("Click here for a detailed description of this filter.","http://www.gimpchat.com/viewtopic.php?f=28&t=9174")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/02/2013</i>.</small>")
gimp_polygonize :
  -polygonize $1,$2,{$3^2},$4,$5
  -if $9 -repeat @# -l[$>]  # has outline.
    --norm -g[-1] xy,1 -!=[-2,-1] 0 -or[-2,-1] -r[-1] 100%,100%,1,4
    -replace_color[-1] 0,0,1,1,1,1,$6,$7,$8,$9
    -blend alpha
  -endl -done -endif

gimp_polygonize_preview :
  -gimp_split_preview "-gimp_polygonize $*",$-1

#@gimp Poster edges : gimp_poster_edges, gimp_poster_edges_preview(0)
#@gimp : Image smoothness = float(20,0,100)
#@gimp : Edge threshold = float(60,0,100)
#@gimp : Edge shade = float(5,0,30)
#@gimp : Edge thickness = float(0,0,5)
#@gimp : Edge antialiasing = float(10,0,100)
#@gimp : Posterization level = int(0,0,15)
#@gimp : Posterization antialiasing = float(0,0,100)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), link = link("Click here for a detailed description of this filter.","http://www.davidrevoy.com/article147/gmic-new-filter-poster-edges")
#@gimp : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i> and <i>David Revoy</i>.      Latest update: <i>11/30/2012</i>.</small>")
gimp_poster_edges :
  -if $1 -bilateral 10,$1 -endif
  -poster_edges ${2-7}

gimp_poster_edges_preview :
  -gimp_split_preview "-gimp_poster_edges $*",$-1

#@gimp Rodilius : gimp_rodilius, gimp_rodilius_preview(1)
#@gimp : Amplitude = float(10,0,30)
#@gimp : Thickness = float(10,0,100)
#@gimp : Sharpness = float(300,0,1000)
#@gimp : Orientations = int(5,2,36)
#@gimp : Offset = float(30,0,180)
#@gimp : Smoothness = int(0,0,5)
#@gimp : Color mode = choice(1,"Darker","Lighter")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : link = link("Click here for a video tutorial","http://www.youtube.com/watch?v=RC07VUpzwGc")
#@gimp : sep = separator(), note = note("<small>Authors: <i>Rod/GimpChat</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>03/05/2013</i>.</small>")
gimp_rodilius :
  -apply_channels "-rodilius ${1-5,7} -repeat $6 -smooth 10,0,1,1,1,0.8,45 -sharpen 30 -done -c 0,255",$8,0

gimp_rodilius_preview :
  -gimp_split_preview "-gimp_rodilius $*",$-1

#@gimp Shapeism : gimp_shapeism, gimp_shapeism_preview(0)
#@gimp : Shape = choice(2,"Squares","Triangles","Circles","Diamond","Hexagon","Octagon","Stars","Custom")
#@gimp : Branches = int(7,3,16)
#@gimp : Thickness = float(0.38,0,1)
#@gimp : Angle = float(0,0,360)
#@gimp : note = note("<small><b>Note:</b> Parameters <i>Branches</i>, <i>Thickness</i> and <i>Angle</i> are used only for <i>Custom</i> shapes.</small>")
#@gimp : Antialiasing = bool(1)
#@gimp : sep = separator()
#@gimp : Scales = int(5,1,16)
#@gimp : Maximal size = int(32,1,256)
#@gimp : Minimal size = int(8,1,256)
#@gimp : Allow angle = choice(3,"0 deg.","180 deg.","90 deg.","Any")
#@gimp : Spacing = int(1,-5,5)
#@gimp : Precision = int(5,1,10)
#@gimp : Edges = float(0.5,0,2)
#@gimp : Smoothness = float(1,0,10)
#@gimp : Background = color(0,0,0,255)
#@gimp : sep = separator(), link = link("Click here for a detailed description of this filter.","http://gimpchat.com/viewtopic.php?f=28&t=7500&sid=5b483979826903b8f8fc8fdaf1767dae")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>06/11/2013</i>.</small>")
gimp_shapeism :
  -repeat @# -l[$>]
    -to_rgb
    --gradient_norm -b[-1] $13% -^[-1] $12 -quantize[-1] $6,0,0
    100%,100%,1,2
    -repeat $6

      # Create map of possible locations.
      --channels[2] 100% -->[1] $> -!=[-2] 0 -or[-2,-1] -a[2,-1] c

      # Create shape at given scale.
      size={if($6<=1,$7,$7+($8-$7)*$>/($6-1))}
      -if {$size<1} -break -endif
      -if $5 {2*$size},{2*$size} -_gimp_shapeism$1[-1] ${2-4} -r2dy[-1] $size
      -else $size,$size -_gimp_shapeism$1[-1] ${2-4}
      -endif
      --!=[-1] 0 -expand_xy[-2,-1] 1,0 -n[-2,-1] 0,1
      -if {$10<1} -dilate[-1] 3 -endif
      [-1] -a[-3--1] c

      # Pack sprites for given scale
      -rprogress "-pack_sprites[-2,-1] 1,100,$9,$10,$11",{$>*100/$6},{($>+1)*100/$6}
      -channels[-1] 0,1

    -done

    -rprogress 97
    -rm[1]
    -channels[-1] 0 --!=[-1] 0 -blend[0,-1] shapeaverage0 -*[1] 255 -a c
    -i[0] 100%,100%,1,4 -fc[0] $14,$15,$16,$17
    -blend alpha
    -rprogress 100
  -endl -done

gimp_shapeism_preview :
  -gimp_print_preview ""
  50%,50% -_gimp_shapeism$1[-1] ${2-4} -frame[-1] 1,1,0 ->=[-1] 50% -n[-1] 0,255 -r[-1] 100%,100%,1,4
  -r[-1] [0],0,0,0.5,0.5 -or

_gimp_shapeism0 : # Square
  -f 255 -skip $*

_gimp_shapeism1 : # Triangle
  -polygon 3,50%,0,0,100%,100%,100%,1,1 -skip $*

_gimp_shapeism2 : # Circle
  -_dt_circle {w} -rm[-2] -skip $*

_gimp_shapeism3 : # Diamond
  -_dt_diamond {w} -rm[-2] -skip $*

_gimp_shapeism4 : # Hexagon
  -star3d 3,1 -*3d[-1] @{0,min(w,h)/2} -j3d[0] [-1],50%,50%,0,1,2,0 -k[0] -skip $*

_gimp_shapeism5 : # Octogon
  -star3d 4,1 -*3d[-1] @{0,min(w,h)/2} -j3d[0] [-1],50%,50%,0,1,2,0 -k[0] -skip $*

_gimp_shapeism6 : # Star
  -star3d 5 -*3d[-1] @{0,min(w,h)/2} -j3d[0] [-1],50%,50%,0,1,2,0 -k[0] -skip $*

_gimp_shapeism7 : # Custom
  -star3d $1,$2 -*3d[-1] @{0,min(w,h)/2} -r3d[-1] 0,0,1,$3 -j3d[0] [-1],50%,50%,0,1,2,0 -k[0]

#@gimp Warhol : warhol, warhol(1)
#@gimp : X-tiles = int(3,1,10)
#@gimp : Y-tiles = int(3,1,10)
#@gimp : Smoothness = float(2,0,10)
#@gimp : Color = float(40,0,60)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")

#@gimp Whirl drawing : draw_whirl, gimp_draw_whirl_preview(0)
#@gimp : Amplitude = float(20,0,100)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_draw_whirl_preview :
  -gimp_split_preview "-draw_whirl $*",$-1


#@gimp _<b>Black &amp; white</b>
#-------------------------------

#@gimp Black &amp; white : gimp_blackandwhite, gimp_blackandwhite_preview(1)
#@gimp : Red level = float(0.299,0,1)
#@gimp : Red smoothness = float(0,0,10)
#@gimp : Green level = float(0.587,0,1)
#@gimp : Green smoothness = float(0,0,10)
#@gimp : Blue level = float(0.114,0,1)
#@gimp : Blue smoothness = float(0,0,10)
#@gimp : sep = separator()
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Hue = float(0,0,360)
#@gimp : Saturation = float(0,0,1)
#@gimp : sep = separator()
#@gimp : Grain (shadows) = float(0,0,200)
#@gimp : Grain (midtones) = float(0,0,200)
#@gimp : Grain (highlights) = float(0,0,200)
#@gimp : Grain tone fading = float(2,0,10)
#@gimp : Grain scale = float(0,0,3)
#@gimp : Grain type = choice("Gaussian","Uniform","Salt and pepper","Poisson")
#@gimp : sep = separator()
#@gimp : Local contrast = float(0,0,60)
#@gimp : Radius = int(16,1,512)
#@gimp : Contrast smoothness = float(4,0,10)
#@gimp : sep = separator()
#@gimp : Pseudo-gray dithering = int(0,0,5)
#@gimp : Use maximum tones = bool(false)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>02/20/2013</i>.</small>")
gimp_blackandwhite :
  -repeat @#
    -l[-1] -split_opacity -rv -to_rgb[-1] -s[-1] c          # Isolate opacity
    -*[-3] $1 -b[-3] $2%                                    # Red contrast + smoothness
    -*[-2] $3 -b[-2] $4%                                    # Green contrast + smoothness
    -*[-1] $5 -b[-1] $6%                                    # Blue contrast + smoothness
    -+[-3--1] -/[-1] {$1+$3+$5} -c[-1] 0,255                # (R,G,B) -> B&W

    -apply_gamma[-1] {10^$7}                                # Gamma correction
    --[-1] 128 -*[-1] $8 -+[-1] 128 -+[-1] $9 -c[-1] 0,255  # B&W contrast and brightness.

    -if {$12||$13||$14}
      100%,100% [-1]x2                                        # Create noise for shadows, midtones and highlights.
      -noise[-3] 100,$17 -b[-3] $16% -n[-3] -$12,$12          # Scaled grain on shadows.
      -noise[-2] 100,$17 -b[-2] $16% -n[-2] -$13,$13          # Scaled grain on midtones.
      -noise[-1] 100,$17 -b[-1] $16% -n[-1] -$14,$14          # Scaled grain on highlights.
      --tones[-4] 3 -b[-3--1] $15%                            # Get smoothed tones.
      -*[-6,-3] -*[-4,-2] -*[-2,-1]                           # Get noisy tones.
      -+[-4--1] -c[-1] 0,255                                  # Compose them with the B&W image.
    -endif

    -if {$10||$11}
      -/[-1] 255
      -i[-2] 100%,100%,1,1,$11
      -i[-3] 100%,100%,1,1,$10
      -a[-3--1] c -hsv2rgb[-1]
    -endif

    -rv -a c -endl -mv[-1] 0 -done                          # Re-compose opacity and loop to next image.
  -if $18 -normalize_local $18,$19,$20,2%,1,0,255 -endif
  -if $22 -n 0,255 -endif
  -if $21 -to_pseudogray $21,1 -endif

gimp_blackandwhite_preview :
  -gimp_split_preview "-gimp_blackandwhite $*",$-1

#@gimp B&amp;W stencil : gimp_stencilbw, gimp_stencilbw_preview(0)
#@gimp : Threshold = float(10,0,30)
#@gimp : Smoothness = float(10,0,30)
#@gimp : Hue = float(0,0,360)
#@gimp : Saturation = float(0,0,1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_stencilbw :
  -stencilbw $1,$2
  -if {$3||$4} -repeat @# -l[$>] -split_opacity
    -/[0] 255 -i[0] 100%,100%,1,1,$4 -i[0] 100%,100%,1,1,$3 -a[0-2] c -hsv2rgb[0]
  -a c -endl -done -endif

gimp_stencilbw_preview :
  -gimp_split_preview "-gimp_stencilbw $*",$-1

#@gimp Charcoal : gimp_charcoal, gimp_charcoal_preview(0)
#@gimp : Granularity = int(65,0,800)
#@gimp : Lowlights crossover point = int(70,0,255)
#@gimp : Highlights crossover point = int(170,0,255)
#@gimp : Boost contrast = bool(0)
#@gimp : Resize image for optimum effect = bool(1)
#@gimp : Add chalk highlights = bool(0)
#@gimp : Minimal highlights = int(50,0,255)
#@gimp : Maximal highlights = int(70,0,255)
#@gimp : Background color = color(255,255,255)
#@gimp : Foreground color = color(0,0,0)
#@gimp : Invert background/foreground = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>03/17/2011</i>.</small>")
#@gimp : note = note("<small>Inspired from the Charcoal script by <i>micomicon</i> :</small>")
#@gimp : link = link("http://registry.gimp.org/node/25078")
gimp_charcoal :
  -repeat @# -l[$>] -split_opacity -l[0]
    -compose_channels max
    w={w} h={h}
    -if $5 -r[-1] 150%,150%,1,1,6 -endif
    -if $4 -equalize[-1] -n[-1] 0,255 -endif
    -sharpen {$1*3} -cut 0,255
    -if $6 --ir $7,$8 -endif  # Add highlights layer if required.
    -ir[0] $2,$3
    -if {!$15} -==[0] 0 -endif
    -or
    --*[0] $10 --*[0] $11 -*[0] $9
    -a[-3--1] c -replace_color 0,0,0,0,0,$12,$13,$14
    -r $w,$h,1,100%,2
  -endl -a c -endl -done

gimp_charcoal_preview :
  -gimp_split_preview "-gimp_charcoal $*",$-1

#@gimp Colorize [comics] : gimp_colorize_comics, gimp_colorize_comics_preview(1)
#@gimp : note = note("<b>Layers ordering:</b>")
#@gimp : Input layers = choice{0,"Color spots + lineart","Lineart + color spots","Color spots + extrapolated colors + lineart","Lineart + color spots + extrapolated colors"}
#@gimp : Output layers = _choice{1,"Single (merged)","Extrapolated colors + lineart","Lineart + extrapolated colors","Color spots + extrapolated colors + lineart","Lineart + color spots + extrapolated colors"}
#@gimp : Extrapolate colors as = choice("One layer","Two layers","Three layers","Four layers","Five layers","Six layers","Seven layers","Eight layers","Nine layers","Ten layers","One layer per single color","One layer per single region")
#@gimp : sep = separator()
#@gimp : Smoothness = float(0.05,0,1)
#@gimp : sep = separator(), note = note{"<small><b>Note:</b> You probably need to select <i>All</i> for the <i>Input layers</i> option on the left.\n
#@gimp : <i>Color spots</i> = your layer with color indications.\n
#@gimp : <i>Lineart</i> = your layer with line-art (b&amp;w or transparent).\n
#@gimp : <i>Extrapolated colors</i> = the G'MIC generated layer with flat colors.\n\n
#@gimp : <b>Warnings:</b>
#@gimp : \n  - Do not rely too much on the preview, it is probably not accurate !
#@gimp : \n  - Activate option <i>Extrapolate color as one layer per single color/region</i> only if you have <i>a lot</i> of available memory !
#@gimp : </small>"}
#@gimp : sep = separator(), link = link("Click here for a detailed description of this filter.","http://www.gimpchat.com/viewtopic.php?f=28&t=7567")
#@gimp : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i>, <i>Timoth&#233;e Giet</i> and <i>David Revoy</i>.      Latest update: <i>06/19/2013</i>.</small>")
gimp_colorize_comics :
  -if {@#<2} -return -endif
  -if {$1<2} selection=0,1 -else selection=0,1,2 -endif
  -l[$selection]

    # Format input layers.
    -if {$1==0}              # Color strokes + drawing
    -elif {$1==1} -rv        # Drawing + color strokes
    -elif {$1==2} -rm[1]     # Color strokes + extrapolated colors + drawing
    -elif {$1==3} -rm[2] -rv # Drawing + color strokes + extrapolated colors.
    -endif

    # Here we have only 'color strokes + drawing' -> process.
    --to_rgba[0] -split_opacity[-1] -+[-2] 1 -!=[-1] 0 -*[-2,-1]  # Map of color labels to spread.
    --norm[1] -n[-1] 0,1 --histogram[-1] 2,0,1
    -if {i(0)>i(1)} -*[-2] -1 -+[-2] 1 -endif -rm[-1]              # Determine color model of the drawing.
    -b[-1] $4% -watershed[-2] [-1] -rm[-1]                         # Priority map.
    --[-1] 1
    # Here we have 'color strokes + drawing + extrapolated colors'.

    # Format output layers.
    -if {$2==0} -rm[0] -rv -blend[0,1] multiply ind=-1
    -elif {$2==1} -rm[0] -rv ind=0
    -elif {$2==2} -rm[0] ind=1
    -elif {$2==3} -rv[1,2] ind=1
    -elif {$2==4} -rv[0,1] ind=2
    -endif

    # Separate extrapolated colors as multiple layers.
    -if {$3&&$ind>=0} -l[$ind]
      --mix_channels (65536,256,1)
      -if {$3==10} -do  # Split by colors.
        iM=@{1,iM}
        -if {$iM>=0}
          --==[1] $iM area=@{-1,+} -replace[1] $iM,-1
          --r[-1] 100%,100%,1,3 -*[-1] [0]
          -rv[-2,-1] -*[-1] 255 -a[-2,-1] c -nm[-1] $area
        -endif
      -while {$iM>=0} -else  # Split by disconnected regions.
        -label[-1]
        -if {$3<10} -%[-1] {$3+1} -endif
        -repeat {iM+1} --==[1] $< area=@{-1,+} --r[-1] 100%,100%,1,[0] -*[-1] [0] -rv[-2,-1] -*[-1] 255 -a[-2,-1] c -nm[-1] $area -done
      -endif
      -rm[0,1]
      -sort_list +,n
    -endl -endif

  -endl

gimp_colorize_comics_preview :
  -gimp_colorize_comics $1,0,$3,$4

#@gimp Colorize [interactive] : gimp_colorize_interactive, gimp_colorize_interactive_preview
#@gimp : Input type = _choice("B&W photograph","Lineart")
#@gimp : Output type = _choice{"Colorized image (1 layer)","Colors only (1 layer)","Image + Colors (2 layers)","Image + Colors (multi-layers)"}
#@gimp : View resolution = _choice{1,"Small (faster)","Medium","High (slower)","Very high (even slower)"}
#@gimp : 1st additional palette (.gpl file) = _file("")
#@gimp : 2nd additional palette (.gpl file) = _file("")
#@gimp : sep = separator()
#@gimp : note = note{"<small><b>Description:</b>\n
#@gimp : This filter allows to quickly colorize a B&amp;W image or lineart.
#@gimp : Click on the <i>Apply</i> or <i>OK</i> buttons below to open the G'MIC interactive window and start adding color control points.
#@gimp : When you're done, exit the interactive window: your colored result will be transfered back to GIMP.\n\n
#@gimp : If you are not satisfied with the result, <i>Undo it (CTRL+Z)</i>, and click on <i>Apply</i> once again to modify your control points defined previously.
#@gimp : To clear all control points, click on the <i>Reset</i> button below.
#@gimp : </small>"}
#@gimp : Clear control points = button(0.5)
#@gimp : Last image size = const(0,0)
#@gimp : Control points = const(-1)
#@gimp : sep = separator()
#@gimp : note = note{"<small><b>Interactions:</b>\n
#@gimp : Use the following actions in the interactive window to manage your colorization :\n\n
#@gimp : - <b>Left mouse button</b> creates a new color control point (or move an existing one).\n
#@gimp : - <b>Right mouse button</b> over a control point deletes it.\n
#@gimp : - <b>Right mouse button</b> anywhere else picks a color from the image.\n
#@gimp : - <b>Mouse wheel</b>, or keys <b>CTRL+arrows up/down</b> zoom view in/out.\n
#@gimp : - <b>CTRL+mouse wheel</b>, <b>SHIFT+wheel</b> or arrow keys move image in zoomed view.\n
#@gimp : - Key <b>SPACE</b> updates the extrapolated color field.\n
#@gimp : - Key <b>TAB</b> toggles markers view modes.\n
#@gimp : - Key <b>BACKSPACE</b> deletes the last control point added.\n
#@gimp : - Key <b>PAGE UP</b> increases image contrast.\n
#@gimp : - Key <b>PAGE DOWN</b> decreases image contrast.\n
#@gimp : - Key <b>R</b> enters/exits color replace mode.\n
#@gimp : - Keys <b>CTRL+D</b> increase window size.\n
#@gimp : - Keys <b>CTRL+C</b> decrease window size.\n
#@gimp : - Keys <b>CTRL+R</b> resets window size.\n
#@gimp : - Keys <b>ESC</b>, <b>Q</b> or <b>ENTER</b> exit the interactive window.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>You can find more informations on how to use this filter here :</small>")
#@gimp : link = link("David Revoy's G'MIC Colorization Page","http://www.davidrevoy.com/article240/gmic-line-art-colorization")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/09/2014</i>.</small>")
gimp_colorize_interactive :
  N=@#
  resolution={arg(1+$3,512,1024,2048,0)}
  -nm "[G\47MIC] Colorize"
  -if {$8==-1" || "$7!=w" || "$8!=h} _gimp_control_points= -else _gimp_control_points=${9--1} -endif
  -l[] 0 -nm[-1] "$4" ext=@{-1,x} -rm -if {$ext'=='gpl} -input_gpl "$4" -endif -onfail -rm -endl
  -l[] 0 -nm[-1] "$5" ext=@{-1,x} -rm -if {$ext'=='gpl} -input_gpl "$5" -endif -onfail -rm -endl
  -if {@#==$N+2} # Two additional palettes.
    -repeat {@#-2} status=@{-x_colorize[$>]\ $1,$resolution,$2,[-2],[-1]} -done
    -rm[-2,-1]
  -elif {@#==$N+1} # One additional palette.
    -repeat {@#-1} status=@{-x_colorize[$>]\ $1,$resolution,$2,[-1]} -done
    -rm[-1]
  -else # No additional palette.
    -repeat @# status=@{-x_colorize[$>]\ $1,$resolution,$2} -done
  -endif
  -if {$2==1} -repeat @# -l[$<] # Output : colors only (1 layer).
      -channels {s-3},{s-1}
    -endl -done
  -elif {$2>=2} -repeat @# -l[$<] # Output : Lineart + Colors (2 layers).
      --channels {s-3},{s-1} -channels[-2] 0,@{0,s-4}
    -endl -done
    -if {$2>=3} -gimp_colors2layers[-1] 0 -endif # Split colors into layers.
  -endif
  -u \{$1\}\{$2\}\{$3\}\{"$4"\}\{"$5"\}\{0\}\{{w},{h}\}\{$status\}

gimp_colorize_interactive_preview :
  -if $6  # Clear control points.
    -gimp_print_preview "No preview\n  available",,"(Control points cleared)"
    -u \{$1\}\{$2\}\{$3\}\{"$4"\}\{"$5"\}\{0\}\{{w},{h}\}\{-1\}
  -else -gimp_no_preview ,
  -endif

#@gimp Colorize [photographs] : gimp_recolorize, gimp_recolorize_preview(1)
#@gimp : Smoothness = int(2,0,6)
#@gimp : Anisotropy = float(0.2,0,1)
#@gimp : Output mode = choice("Merge brightness/colors","Split brightness/colors")
#@gimp : sep = separator()
#@gimp : note = note{"<small><b>Note:</b> This filter needs two layers to work properly. The bottom layer must be a B&amp;W image, while the
#@gimp : top layer contains color patches that will be extrapolated in a smart way (edge-directed) to fill the entire image. At the end,
#@gimp : you get a completely recolored image.</small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>01/16/2013</i>.</small>")
gimp_recolorize :
  -repeat {int(@#/2)}
    -if $3 s=$>,{$>+1} -else s={2*$>},{2*$>+1} -endif
    -l[$s] -rv[0,1]
      -channels[0] 0 -to_rgb[-2] # Convert to pure gray.
      -to_rgba[-1] -split_opacity[-1] -!=[-1] 0  # Retrieve mask of color patchs.
      -srgb2rgb[-3,-2] -rgb2lab8[-3,-2] -channels[-3] 0 -channels[-2] 1,2 # Now, list is [0]=lightness / [1]=chroma / [2]=mask.
      -+[-2] 1 -*[-2] [-1] --gradient_norm[-3] -*[-1] -1 -watershed[-3] [-1] -rm[-1] --[-2] 1 # Get first estimate for the color interpolation.
      --diffusiontensors[-3] $2,1,0.5,0.5 -==[-2] 0 -*[-1] [-2] -rm[-2]
      -smooth[-2] [-1],{$1*80},0.8,60 -rm[-1]
      -a[-2,-1] c -lab82rgb[-1] -rgb2srgb[-1]
      -if $3 -rgb2hsv[-1] -s[-1] c -i[2] 100%,100%,1,1,1 -i[3] 100%,100%,1,2,0 -a[0-2] c -a[^0] c -hsv2rgb -rv -endif
    -endl
  -done

gimp_recolorize_preview :
  -gimp_recolorize $* -a x

#@gimp Colorize [with colormap] : gimp_bwrecolorize, gimp_bwrecolorize_preview
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Normalize = bool(0)
#@gimp : sep = separator()
#@gimp : Gradient preset = choice("User-defined","Black to white","White to black","Sepia","Solarize")
#@gimp : Interpolation type = choice(1,"Nearest","Linear","Cubic","Lanczos")
#@gimp : Preserve initial brightness = bool(0)
#@gimp : sep = separator(), note = note("<small><u>User-defined gradient :</u></small>")
#@gimp : Number of tones = int(5,2,8)
#@gimp : 1st tone = color(0,0,0,255)
#@gimp : 2nd tone = color(43,25,55,255)
#@gimp : 3rd tone = color(158,137,189,255)
#@gimp : 4th tone = color(224,191,228,255)
#@gimp : 5th tone = color(255,255,255,255)
#@gimp : 6th tone = color(255,255,255,255)
#@gimp : 7th tone = color(255,255,255,255)
#@gimp : 8th tone = color(255,255,255,255)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_bwrecolorize :
  -remove_opacity
  -if $4 -n 0,255 -endif
  -if {$5==0}  # User-defined gradient
    (${9--2}) -r[-1] 4,$8,1,1,-1 -permute[-1] yzcx
  -elif {$5==1} # Black to white
    (0,255^0,255^0,255^255,255)
  -elif {$5==2} # White to black
    (255,0^255,0^255,0^255,255)
  -elif {$5==3} # Sepia
    (0,44,115,143,196,244^0,20,84,119,184,235^0,5,44,73,144,200^255,255,255,255,255,255)
  -else         # Solarize
    (0,359^1,1^1,1^255,255) -r[-1] 256,1,1,4,3 -sh[-1] 0,2 -hsv2rgb[-1] -rm[-1]
  -endif
  -if {$6==0} -r[-1] 256,1,1,4,1
  -elif {$6==1} -r[-1] 256,1,1,4,3
  -elif {$6==2} -r[-1] 256,1,1,4,5 -c[-1] 0,255
  -else -r[-1] 256,1,1,4,6
  -endif
  -if {$7==1} -sh[-1] 0,2 -rgb2hsv[-1] -sh[-1] 2,2 -f[-1] x/w -hsv2rgb[-2] -rm[-2,-1] -endif
  -l[^-1] -luminance -apply_gamma {10^$1} -- 128 -* $2 -+ {$3+128} -c 0,255 -endl -map[^-1] [-1] -rm[-1]

gimp_bwrecolorize_preview :
  -gimp_split_preview "-gimp_bwrecolorize ${^0}",$-1

#@gimp Dithering : gimp_ditheredbw, gimp_ditheredbw_preview(0)
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Hue = float(0,0,360)
#@gimp : Saturation = float(0,0,1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_ditheredbw :
  -repeat @# -l[$>] -split_opacity -l[0]
    -luminance -n 0,255 -apply_gamma {10^$1} -- 128 -* $2 -+ 128 -+ $3 -b $4 -c 0,255 -ditheredbw
    -if {$5||$6} -/ 255 -i[0] 100%,100%,1,2 -fc[0] $5,$6 -a c -hsv2rgb -endif
  -endl -a c -endl -done

gimp_ditheredbw_preview :
  -gimp_split_preview "-gimp_ditheredbw $*",$-1

#@gimp Hard sketch : gimp_hardsketchbw, gimp_hardsketchbw_preview(0)
#@gimp : Amplitude = float(300,0,4000)
#@gimp : Density = float(50,0,100)
#@gimp : Smoothness = float(1,0,10)
#@gimp : Opacity = float(0.1,0,1)
#@gimp : Edge = float(20,0,100)
#@gimp : Fast approximation = bool(0)
#@gimp : Color model = choice("Black on white","White on black","Black on transparent white","White on transparent black","Color on white")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_hardsketchbw :
  -b $3
  -if {$7==4} -repeat @# -l[$>] --hardsketchbw $1,$2,$4,$5,$6 -blend hardlight -endl -done -return -endif
  -hardsketchbw $1,$2,$4,$5,$6
  -if {$7&1} -negative -endif
  -if {$7==2} -r 100%,100%,1,4 -repeat @# -sh[$>] 3,3 -*[-1] -2 -+[-1] {2*255} -c[-1] 0,255 -rm[-1] -done
  -elif {$7==3} -r 100%,100%,1,4 -repeat @# -sh[$>] 3,3 -*[-1] 2 -c[-1] 0,255 -rm[-1] -done
  -endif

gimp_hardsketchbw_preview :
  -gimp_split_preview "-gimp_hardsketchbw $*",$-1

#@gimp Hough sketch : gimp_houghsketchbw, gimp_houghsketchbw_preview(0)
#@gimp : Smoothness = float(1.25,0,10)
#@gimp : Density = float(10,0,70)
#@gimp : Radius = int(5,0,30)
#@gimp : Threshold = float(80,0,100)
#@gimp : Opacity = float(0.1,0,1)
#@gimp : Color model = choice("Black on white","White on black","Black on transparent white","White on transparent black","Color on white")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>05/18/2011</i>.</small>")
gimp_houghsketchbw :
  -b $1 -n 0,255
  -if {$6==4} -repeat @# -l[$>] --houghsketchbw ${2-5} -blend hardlight -endl -done -return -endif
  -houghsketchbw ${2-5}
  -if {$6&1} -negative -endif
  -if {$6==2} -r 100%,100%,1,4 -repeat @# -sh[$>] 3,3 -*[-1] -2 -+[-1] {2*255} -c[-1] 0,255 -rm[-1] -done
  -elif {$6==3} -r 100%,100%,1,4 -repeat @# -sh[$>] 3,3 -*[-1] 2 -c[-1] 0,255 -rm[-1] -done
  -endif

gimp_houghsketchbw_preview :
  -gimp_split_preview "-gimp_houghsketchbw $*",$-1

#@gimp Ink wash : gimp_ink_wash, gimp_ink_wash(0)
#@gimp : note = note("Ink wash controls")
#@gimp : Size = float(0.14,0,4)
#@gimp : Amplitude = float(23,0,200)
#@gimp : sep = separator()
#@gimp : note = note("Check if you wish visual control on this step")
#@gimp : SKIP all other steps = bool(false)
#@gimp : note = note ("UNcheck to reactivate the other controls")
#@gimp : sep = separator()
#@gimp : Smoother Sharpness = float(0.5,0,2)
#@gimp : Smoother Edge Protection = float(0.54,0,1)
#@gimp : Smoother Softness = float(2.25,0,10)
#@gimp : sep = separator()
#@gimp : Stretch Contrast = choice("None","Automatic","Automatic & Contrast Mask","Manual Controls")
#@gimp : note = note ("To activate the sliders below chose 'Manual Controls'")
#@gimp :sep = separator()
#@gimp : LN Amplititude = float(2,0,60)
#@gimp : LN Size = float(6,0,64)
#@gimp : LN Neightborhood-Smoothness = float(5,0,40)
#@gimp : LN Average-Smoothness = float(20,0,40)
#@gimp : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update: <i>04/05/2011</i>.</small>")
#@gimp : note = link(0,"Forum thread about the filter discussion","http://gimpchat.com/viewtopic.php?f=10&t=914")
gimp_ink_wash :
  -repeat @# -l[$>] -split_opacity -l[0]
    -gimp_pencilbw[-1] $1,$2,0,0,0
    -if {$3==1} -continue
    -elif {$3==0} -gimp_anisotropic_smoothing[-1] 60,$4,$5,$6,1.1,0.8,30,2,0,1,1,0,1,16
    -endif
    -if {$7==1} -normalize_local[-1] 2,6,5,24,1,0,255
	-elif {$7==2}  -normalize_local[-1] 2,6,5,24,1,0,255 -gimp_contrast_swm 2,0,0.512
    -elif {$7==3} -gimp_normalize_local[-1] $8,$9,$10,$11,1,3,0
    -endif
  -endl -a c -endl -done

#@gimp Pencil : gimp_pencilbw, gimp_pencilbw_preview(0)
#@gimp : Size = float(0.3,0,5)
#@gimp : Amplitude = float(60,0,200)
#@gimp : Hue = float(0,0,360)
#@gimp : Saturation = float(0,0,1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>03/05/2013</i>.</small>")
gimp_pencilbw :
  -pencilbw $1,$2
  -if {$3||$4} -repeat @# -l[$>] -split_opacity
    -/[0] 255 -i[0] 100%,100%,1,1,$4 -i[0] 100%,100%,1,1,$3 -a[0-2] c -hsv2rgb[0]
  -a c -endl -done -endif

gimp_pencilbw_preview :
  -gimp_split_preview "-gimp_pencilbw $*",$-1

#@gimp Pencil portrait : gimp_pencil_portraitbw, gimp_pencil_portraitbw_preview(0)
#@gimp : Stroke length = float(30,0,500)
#@gimp : Stroke angle = float(120,0,180)
#@gimp : Contour threshold = float(1,0,3)
#@gimp : Opacity = float(0.5,0,1)
#@gimp : Color = color(144,79,21)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>Ramon Miranda</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>12/11/2012</i>.</small>")
gimp_pencil_portraitbw :
  -repeat @# -l[$>] -split_opacity -l[0]
    --b 2%
    --blend divide -rm[-2] -luminance[-1]
    -gimp_ink_wash[-2] 0,167,0,0.5,0.54,2.25,0,2,6,5,20
    --gimp_hardsketchbw[-1] 80,32,1.89,0.21,31.46,0,0
    --gimp_sketchbw[-2] 1,$2,180,$1,$3,0.03,0,0.6,0.1,0.6,0.25,1,0,1,0
    -blend[0,1] darken
    -blend[0,1] multiply,0.5
    -blend[0,1] lighten,$4
    -normalize_local ,
    -to_rgb --fc ${5-7} -blend softlight
  -endl -a c -endl -done

gimp_pencil_portraitbw_preview :
  -gimp_split_preview "-gimp_pencil_portraitbw $*",$-1

#@gimp Sketch : gimp_sketchbw, gimp_sketchbw_preview(0)
#@gimp : Number of orientations = int(2,1,16)
#@gimp : Starting angle = float(45,0,180)
#@gimp : Angle range = float(180,0,180)
#@gimp : Stroke length = float(30,0,1000)
#@gimp : Contour threshold = float(1,0,3)
#@gimp : Opacity = float(0.03,0,0.3)
#@gimp : Background intensity = float(0,0,2)
#@gimp : Density = float(0.6,0,5)
#@gimp : Sharpness = float(0.1,0,1.5)
#@gimp : Anisotropy = float(0.6,0,1)
#@gimp : Smoothness = float(0.25,0,10)
#@gimp : Coherence = float(1,0,10)
#@gimp : Boost stroke = bool(0)
#@gimp : Curved stroke = bool(1)
#@gimp : Color model = choice("Black on white","White on black","Black on transparent white","White on transparent black","Color on white")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_sketchbw :
  -if {$15==4} -repeat @# -l[$>] --sketchbw ${1-14} -blend hardlight -endl -done -return -endif
  -sketchbw ${1-14}
  -if {$15&1} -negative -endif
  -if {$15==2} -r 100%,100%,1,4 -repeat @# -sh[$>] 3,3 -*[-1] -2 -+[-1] {2*255} -c[-1] 0,255 -rm[-1] -done
  -elif {$15==3} -r 100%,100%,1,4 -repeat @# -sh[$>] 3,3 -*[-1] 2 -c[-1] 0,255 -rm[-1] -done
  -endif

gimp_sketchbw_preview :
  -gimp_split_preview "-gimp_sketchbw $*",$-1

#@gimp Stamp : gimp_stamp, gimp_stamp_preview(0)
#@gimp : Auto-threshold = bool(1)
#@gimp : Threshold = int(50,0,100)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Sharpening = float(0,0,30)
#@gimp : Grain = float(0,0,100)
#@gimp : Invert colors = bool(false)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>Antaron</i>, <i>Mahvin</i> and <i>David Tschumperl&#233;</i>.             Latest update: <i>10/08/2012</i>.</small>")
gimp_stamp :
  -repeat @# -l[$>] -split_opacity
    -norm -noise $5
    -if $1 -otsu 256 -else ->= $2% -endif
    -b $3,0 -sharpen $4 -n 0,255
    -apply_curve 1,0,0,101,33,170,229,255,255
    -if $6 -negative -endif
  -a c -endl -done

gimp_stamp_preview :
  -gimp_split_preview "-gimp_stamp $*",$-1


#@gimp _<b>Colors</b>
#--------------------

#@gimp Abstraction : gimp_color_abstraction, gimp_color_abstraction_preview(0)
#@gimp : Smoothness = float(1,0,10)
#@gimp : Levels = int(10,2,255)
#@gimp : Contrast = float(0.2,0.01,1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/19/2011</i>.</small>")
gimp_color_abstraction :
  -repeat @# -l[$>] -split_opacity -l[0] -to_rgb
    -b $1 -s c -quantize $2,1,0 -area 0 -^ $3 -n 0,255
  -endl -a c -endl -done

gimp_color_abstraction_preview :
  -gimp_split_preview "-gimp_color_abstraction $*",$-1

#@gimp Boost-fade : gimp_boost_fade, gimp_boost_fade_preview
#@gimp : Amplitude = float(5,0,10)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/12/2011</i>.</small>")
gimp_boost_fade :
  -i[0] 640,480,1,3 -rand[0] 0,1 -b[0] {10-$1} -n[0] 0,255 -transfer_colors[^0] [0] -rm[0]

gimp_boost_fade_preview :
  -gimp_split_preview "-gimp_boost_fade $*",$-1

#@gimp Boost chromaticity : gimp_boost_chroma, gimp_boost_chroma_preview(1)
#@gimp : Amplitude = float(0.5,0,1)
#@gimp : Color space = choice("YCbCr","Lab")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>08/19/2014</i>.</small>")
gimp_boost_chroma :
  -repeat @# -l[$>] -split_opacity -l[0]
    --to_rgb
    -if $2
      -srgb2rgb -rgb2lab[-1]
      -sh[-1] 1,2 -equalize[-1] -rm[-1]
      -lab2rgb[-1] -rgb2srgb
    -else
      -rgb2ycbcr[-1]
      -sh[-1] 1,2 -equalize[-1] -rm[-1]
      -ycbcr2rgb[-1]
    -endif
    -blend alpha,$1
  -endl -a c -endl -done

gimp_boost_chroma_preview :
  -gimp_split_preview "-gimp_boost_chroma $*",$-1

#@gimp Channel processing : gimp_channel_processing, gimp_channel_processing_preview(1)
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Value action = choice("None","Cut","Cut & Normalize","Normalize","Threshold")
#@gimp : Low value = float(0,0,100)
#@gimp : High value = float(100,0,100)
#@gimp : Quantization = int(256,1,256)
#@gimp : Equalization = bool(0)
#@gimp : Negation = bool(0)
#@gimp : sep = separator()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
#@gimp : sep = separator()
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
_gimp_channel_processing :
  -apply_gamma[-1] {10^$1}
  -if {$2!=1} --[-1] 128 -*[-1] $2 -+[-1] 128 -endif
  -+[-1] $3
  -b[-1] $4% -c[-1] 0,255
  -if {$5==1} -c[-1] $6%,$7%
  -elif {$5==2} -c[-1] $6%,$7% -n[-1] 0,255
  -elif {$5==3} -n[-1] $6%,$7%
  -elif {$5==4} -ir[-1] $6%,$7% -*[-1] 255
  -endif
  -if {$8!=256} -quantize[-1] $8,1,0 -endif
  -if $9 -equalize[-1] -endif
  -if $10 -negative[-1] -endif

gimp_channel_processing :
  -repeat @# -l[-1] -split_opacity -rv -to_rgb[-1]
    -gimp_start_mix $11,$12
    -apply_channels[-1] "-_gimp_channel_processing $1,$2,$3,$4,$5,$6,$7,$8,$9,$10",$13,0
    -gimp_end_mix $11
  -if {@#!=3} -rv -a c -endif -endl -mv[-1] 0 -done

gimp_channel_processing_preview :
  -gimp_split_preview "-gimp_channel_processing $*",$-1

#@gimp Color balance : gimp_balance_gamma, gimp_balance_gamma_preview
#@gimp : Neutral color = color(128,128,128)
#@gimp : Stretch colors = bool(1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>07/01/2011</i>.</small>")
gimp_balance_gamma :
  -balance_gamma ${1-3}
  -if $4 -repeat @# -l[$>] -split_opacity -l[0] -s c -n 0,255 -a c -endl -a c -endl -done -endif

gimp_balance_gamma_preview :
  -gimp_split_preview "-gimp_balance_gamma $*",$-1

#@gimp Colormap : gimp_colormap,gimp_colormap_preview
#@gimp : Colormap = choice[1,"Adaptive","Custom","Standard (256)","HSV (256)","Lines (256)","Hot (256)","Cool (256)","Jet (256)","Flag (256)","Cube (256)"]
#@gimp : Dithering = float(1,0,1)
#@gimp : sep = separator(), note = note("<small><i>For adaptive and custom colormaps only :</i></small>")
#@gimp : Number of tones = int(32,2,256)
#@gimp : sep = separator(), note = note("<small><i>For custom colormaps only :</i></small>")
#@gimp : Number of colors = int(8,2,8)
#@gimp : 1st color = color(0,0,0)
#@gimp : 2nd color = color(255,255,255)
#@gimp : 3rd color = color(255,0,0)
#@gimp : 4th color = color(0,255,0)
#@gimp : 5th color = color(0,0,255)
#@gimp : 6th color = color(255,255,0)
#@gimp : 7th color = color(255,0,255)
#@gimp : 8th color = color(0,255,255)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/27/2011</i>.</small>")
gimp_colormap :
  -repeat @# -l[$>] -split_opacity -to_rgb[0]
    -if {$1>=2}                # Pre-defined colormap.
      -index[0] {$1-2},$2,1
    -elif {$1==1}              # Custom colormap.
      (${5-28}) -z[-1] 0,{3*$4-1}
      -r[-1] 3,{w/3},1,1,-1 -permute[-1] yzcx -r[-1] $3,1,1,3,3
      -index[0] [-1],$2,1 -rm[-1]
    -else                      # Adaptive colormap.
      -autoindex[0] $3,$2,{if($3<=32,1,0)}
    -endif
    -a c
  -endl -done

gimp_colormap_preview :
  -gimp_split_preview "-gimp_colormap $*",$-1

#@gimp Curves : gimp_apply_curve, gimp_apply_curve_preview
#@gimp : Starting Y = int(0,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(1) = int(-1,-1,255)
#@gimp : Y-coord(1) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(2) = int(-1,-1,255)
#@gimp : Y-coord(2) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(3) = int(-1,-1,255)
#@gimp : Y-coord(3) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(4) = int(-1,-1,255)
#@gimp : Y-coord(4) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(5) = int(-1,-1,255)
#@gimp : Y-coord(5) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : Ending Y = int(255,0,255)
#@gimp : sep = separator()
#@gimp : Curve smoothness = float(1,0,1)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : Value range = choice("Cut","Normalize")
#@gimp : Display histogram = float(0,0,1)
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_apply_curve :
  -apply_channels "-_gimp_apply_curve ${1-13}",$14,$15

_gimp_apply_curve :
  -apply_curve $13,0,$1,\
                   @{"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
                   @{"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
                   @{"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
                   @{"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
                   @{"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
                   255,$12

gimp_apply_curve_preview :
  -function1d $13,0,$1,\
                  @{"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
                  @{"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
                  @{"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
                  @{"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
                  @{"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
                  255,$12
  -mv[-1] 0
  -repeat {@#-1}
    --gimp_split_preview[-1] "-gimp_apply_curve $*",$-1
    100%,100% -axes[-1] 0,255,255,0,13,1,255 --dilate[-1] 3 -r[-2] [-3] -j[-3] [-2],0,0,0,0,1,[-1],255 -rm[-2,-1]
    -grid[-1] 10%,10%,0,0,0.3,0xCCCCCCCC,255
    -line[-1] 0,100%,100%,0,0.3,0xCCCCCCCC,255
    -if $-2
      [-1],[-1] -to_gray[-3] -histogram[-3] 256,0,255 -graph[-1] [-3],3,0,0,0,1,1 -!=[-1] 0 -*[-1] 255 -rm[-3]
      --xor[-2,-1] -j[-3] [-1],0,0,0,0,$16,[-2],255 -rm[-2,-1]
     -else -rm[-2] -endif
     100%,100% -graph[-1] [0],1,0,255,0,1,255 --dilate[-1] 3 -r[-2] [-3] -j[-3] [-2],0,0,0,0,1,[-1],255 -rm[-2,-1]
     -_gimp_apply_curve_preview 0,$1,0 -_gimp_apply_curve_preview $2,$3,1
     -_gimp_apply_curve_preview $4,$5,2 -_gimp_apply_curve_preview $6,$7,3
     -_gimp_apply_curve_preview $8,$9,4 -_gimp_apply_curve_preview $10,$11,5
     -_gimp_apply_curve_preview 255,$12,6
  -mv[-1] 1 -done -rm[0]

_gimp_apply_curve_preview :
  -if {$1>=0}
    x={$1*100/255}% y={100-$2*100/255}%
    -ellipse[-1] $x,$y,3,3,0,1,0xFFFFFFFF,0,0,0 -ellipse[-1] $x,$y,2,2,0,1,0,255,0
    -t[-1] $3,$x,{$y*h-20},13,1,255
  -endif

#@gimp Curves [interactive] : gimp_curves_interactive, gimp_curves_interactive_preview
#@gimp : Colorspace = choice{"RGB","CMY","CMYK","HSI","HSL","HSV","Lab","Lch","YCbCr"}
#@gimp : Output preset as a CLUT layer = _choice("Disable","Low-res CLUT","High-res CLUT")
#@gimp : Apply transformation from = _choice("New curves [interactive]","Curves defined previously")
#@gimp : Colorspace = const(0)
#@gimp : Keypoints = const(0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100)
#@gimp : sep = separator()
#@gimp : note = note{"<small><b>Description:</b>\n
#@gimp : This filter allows to apply color curves on your images, in many different colorspaces.
#@gimp : Click on the <i>Apply</i> or <i>OK</i> buttons below to open the G'MIC interactive windows and start building your color curves.
#@gimp : When you're done, exit the main image window: your modified result will be transfered back to GIMP.\n\n
#@gimp : Once you've set curves, you can save them by pressing the <b>Add to faves</b> button below the filter tree.
#@gimp : To clear control points for your curves, click on the <i>Reset</i> button at the bottom.
#@gimp : </small>"}
#@gimp : sep = separator()
#@gimp : Note = note{"<small><b>Interactions:</b>\n
#@gimp : Use the following actions in the interactive windows to manage your colorization :\n\n
#@gimp : - <b>Left mouse button</b> on a curve creates a new color control point (or move an existing one).\n
#@gimp : - <b>Right mouse button</b> on a control point deletes it.\n
#@gimp : - <b>Left mouse button</b> on the main image window shows the initial image until button is released.\n
#@gimp : - <b>Right mouse button</b> on the main image window adds a keypoint to all curves from picked color.\n
#@gimp : - Key <b>R</b> on a curve resets it.\n
#@gimp : - Keys <b>CTRL+D</b> increase window size.\n
#@gimp : - Keys <b>CTRL+C</b> decrease window size.\n
#@gimp : - Keys <b>CTRL+R</b> resets window size.\n
#@gimp : - Keys <b>ESC</b>, <b>Q</b> or <b>ENTER</b> close the current window.
#@gimp : </small>"}
#@gimp : Sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>09/28/2014</i>.</small>")
gimp_curves_interactive :
  -nm "Color curves"
  -repeat 4 __xcc_C$>=0,0,100,100 -done
  -if {$4==$1} -l[] (${5--1}) -s -,-1 -repeat @# __xcc_C$>=@{$>} -done -rm -endl -endif
  -if $3 _xcc_colorbase=@{-arg\ {$4+1},rgb,cmy,cmyk,hsi,hsl,hsv,lab,lch,ycbcr} -x_color_curves last # Apply transformation from previously defined curves.
  -else # Run interactive curve builder.
    -x_color_curves @{-arg\ {$1+1},rgb,cmy,cmyk,hsi,hsl,hsv,lab,lch,ycbcr}
    -u "{$1}{$2}{$3}{$1}{"$__xcc_C0,-1,$__xcc_C1,-1,$__xcc_C2,-1,$__xcc_C3,-1,$__xcc_C4"}"
  -endif
  -if $2 # Add CLUT layer.
    (0,255) (0;255) (0/255) -r[-3--1] 2,2,2 -a[-3--1] c
    -if {$2==2} -r[-1] 256,256,256,3,3 -r[-1] 4096,4096,1,3,-1 # High-res CLUT.
    -else -r[-1] 64,64,64,3,3 -r[-1] 512,512,1,3,-1 # Low-res CLUT.
    -endif
    -x_color_curves[-1] last
  -endif

gimp_curves_interactive_preview :
  -gimp_curves_interactive $1,0,1,${4--1}

#@gimp Curves [RGB]
#@gimp Red : gimp_apply_RGBcurve, gimp_apply_Rcurve_preview
#@gimp : Starting Y = int(0,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(1) = int(-1,-1,255)
#@gimp : Y-coord(1) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(2) = int(-1,-1,255)
#@gimp : Y-coord(2) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(3) = int(-1,-1,255)
#@gimp : Y-coord(3) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(4) = int(-1,-1,255)
#@gimp : Y-coord(4) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(5) = int(-1,-1,255)
#@gimp : Y-coord(5) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : Ending Y = int(255,0,255)
#@gimp : sep = separator()
#@gimp : Curve smoothness = float(1,0,1)
#@gimp : Display histogram = float(0,0,100)
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")

#@gimp Green : gimp_apply_RGBcurve, gimp_apply_Gcurve_preview
#@gimp : Starting Y = int(0,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(1) = int(-1,-1,255)
#@gimp : Y-coord(1) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(2) = int(-1,-1,255)
#@gimp : Y-coord(2) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(3) = int(-1,-1,255)
#@gimp : Y-coord(3) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(4) = int(-1,-1,255)
#@gimp : Y-coord(4) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(5) = int(-1,-1,255)
#@gimp : Y-coord(5) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : Ending Y = int(255,0,255)
#@gimp : sep = separator()
#@gimp : Curve smoothness = float(1,0,1)
#@gimp : Display histogram = float(0,0,100)
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")

#@gimp Blue : gimp_apply_RGBcurve, gimp_apply_Bcurve_preview
#@gimp : Starting Y = int(0,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(1) = int(-1,-1,255)
#@gimp : Y-coord(1) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(2) = int(-1,-1,255)
#@gimp : Y-coord(2) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(3) = int(-1,-1,255)
#@gimp : Y-coord(3) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(4) = int(-1,-1,255)
#@gimp : Y-coord(4) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(5) = int(-1,-1,255)
#@gimp : Y-coord(5) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : Ending Y = int(255,0,255)
#@gimp : sep = separator()
#@gimp : Curve smoothness = float(1,0,1)
#@gimp : Display histogram = float(0,0,100)
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
#@gimp _
gimp_apply_RGBcurve : -skip $1
  -gimp_apply_RGBcurve_configfile
  -repeat {@#-1} -l[$>,-1]
    -to_colormode[0] {max(3,s)}
    -sh[0] 0,0 -_gimp_apply_RGBcurve[-1] @{-2,0-12} -rm[-1]
    -sh[0] 1,1 -_gimp_apply_RGBcurve[-1] @{-2,13-25} -rm[-1]
    -sh[0] 2,2 -_gimp_apply_RGBcurve[-1] @{-2,26-38} -rm[-1]
  -endl -done
  -rm[-1]

_gimp_apply_RGBcurve :
  -apply_curve $13,0,$1,\
                   @{"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
                   @{"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
                   @{"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
                   @{"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
                   @{"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
                   255,$12
  -c 0,255

gimp_apply_Rcurve_preview :
  -gimp_apply_RGBcurve_configfile
  -sh[-1] 0,0,0,0 -f[-1] ${1--3} -rm[-1]
  -gimp_apply_RGBcurve_preview[^-1] @-1,0,${-2,-1} -rm[-1]

gimp_apply_Gcurve_preview :
  -gimp_apply_RGBcurve_configfile
  -sh[-1] 1,1,0,0 -f[-1] ${1--3} -rm[-1]
  -gimp_apply_RGBcurve_preview[^-1] @-1,1,${-2,-1} -rm[-1]

gimp_apply_Bcurve_preview :
  -gimp_apply_RGBcurve_configfile
  -sh[-1] 2,2,0,0 -f[-1] ${1--3} -rm[-1]
  -gimp_apply_RGBcurve_preview[^-1] @-1,2,${-2,-1} -rm[-1]

gimp_apply_RGBcurve_configfile :
  filename=@{-path_tmp}/.gmic_RGBcurve.dlm
  -if $filename $filename -else (0,-1,128,-1,128,-1,128,-1,128,-1,128,255,1) -r[-1] 100%,3 -endif

gimp_apply_RGBcurve_preview :
  (${1--3}) -r[-1] 13,3,1,1,-1 -o[-1] @{-path_tmp}/.gmic_RGBcurve.dlm -rm[-1]
  -function1d $13,0,$1,\
                  @{"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
                  @{"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
                  @{"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
                  @{"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
                  @{"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
                  255,$12
  -function1d $26,0,$14,\
                  @{"-if {$15>=0} -u $15,$16, -else -u \"\" -endif"}\
                  @{"-if {$17>=0} -u $17,$18, -else -u \"\" -endif"}\
                  @{"-if {$19>=0} -u $19,$20, -else -u \"\" -endif"}\
                  @{"-if {$21>=0} -u $21,$22, -else -u \"\" -endif"}\
                  @{"-if {$23>=0} -u $23,$24, -else -u \"\" -endif"}\
                  255,$25
  -function1d $39,0,$27,\
                  @{"-if {$28>=0} -u $28,$29, -else -u \"\" -endif"}\
                  @{"-if {$30>=0} -u $30,$31, -else -u \"\" -endif"}\
                  @{"-if {$32>=0} -u $32,$33, -else -u \"\" -endif"}\
                  @{"-if {$34>=0} -u $34,$35, -else -u \"\" -endif"}\
                  @{"-if {$36>=0} -u $36,$37, -else -u \"\" -endif"}\
                  255,$38
  -a[-3--1] y -mv[-1] 0
  -repeat {@#-1}
    --gimp_split_preview[-1] "-gimp_apply_RGBcurve 0",$-1
    100%,100% -axes[-1] 0,255,255,0,13,1,255 --dilate[-1] 3 -r[-2] [-3] -j[-3] [-2],0,0,0,0,1,[-1],255 -rm[-2,-1]
    -grid[-1] 10%,10%,0,0,0.3,0xCCCCCCCC,255
    -line[-1] 0,100%,100%,0,0.3,0xCCCCCCCC,255
     -if $-2
        [-1],[-1],1,1,-{$-2*255/100} -to_gray[-3] -histogram[-3] 256,0,255 -graph[-1] [-3],3,0,0,0,1,0
        -rm[-3] -+[-1] {$-2*255/100} -+[-2,-1] -c[-1] 0,255
     -else -rm[-2] -endif
     -line[-1] 0,100%,100%,0,0.3,0xCCCCCCCC,255
     -sh[0] 0,0,0,0
     -graph[-2] [-1],1,0,255,0,1,255,128,128 --[-1] 1
     -graph[-2] [-1],1,0,255,0,0.5,200,0,0 -rm[-1]
     -sh[0] 1,1,0,0
     -graph[-2] [-1],1,0,255,0,1,128,255,128 --[-1] 1
     -graph[-2] [-1],1,0,255,0,0.5,0,200,0 -rm[-1]
     -sh[0] 2,2,0,0
     -graph[-2] [-1],1,0,255,0,1,128,128,255 --[-1] 1
     -graph[-2] [-1],1,0,255,0,0.5,0,0,200 -rm[-1]
     -if {$40==0}
       -_gimp_apply_curve_preview 0,$1,0 -_gimp_apply_curve_preview $2,$3,1
       -_gimp_apply_curve_preview $4,$5,2 -_gimp_apply_curve_preview $6,$7,3
       -_gimp_apply_curve_preview $8,$9,4 -_gimp_apply_curve_preview $10,$11,5
       -_gimp_apply_curve_preview 255,$12,6
     -elif {$40==1}
       -_gimp_apply_curve_preview 0,$14,0 -_gimp_apply_curve_preview $15,$16,1
       -_gimp_apply_curve_preview $17,$18,2 -_gimp_apply_curve_preview $19,$20,3
       -_gimp_apply_curve_preview $21,$22,4 -_gimp_apply_curve_preview $23,$24,5
       -_gimp_apply_curve_preview 255,$25,6
     -else
       -_gimp_apply_curve_preview 0,$27,0 -_gimp_apply_curve_preview $28,$29,1
       -_gimp_apply_curve_preview $30,$31,2 -_gimp_apply_curve_preview $32,$33,3
       -_gimp_apply_curve_preview $34,$35,4 -_gimp_apply_curve_preview $36,$37,5
       -_gimp_apply_curve_preview 255,$38,6
     -endif
  -mv[-1] 1 -done -rm[0]

#@gimp Curves [YCbCr]
#@gimp Luminance : gimp_apply_YCbCrcurve, gimp_apply_Ycurve_preview
#@gimp : Starting Y = int(0,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(1) = int(-1,-1,255)
#@gimp : Y-coord(1) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(2) = int(-1,-1,255)
#@gimp : Y-coord(2) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(3) = int(-1,-1,255)
#@gimp : Y-coord(3) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(4) = int(-1,-1,255)
#@gimp : Y-coord(4) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(5) = int(-1,-1,255)
#@gimp : Y-coord(5) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : Ending Y = int(255,0,255)
#@gimp : sep = separator()
#@gimp : Curve smoothness = float(1,0,1)
#@gimp : Display histogram = float(0,0,100)
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")

#@gimp Blue chrominance : gimp_apply_YCbCrcurve, gimp_apply_Cbcurve_preview
#@gimp : Starting Y = int(0,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(1) = int(-1,-1,255)
#@gimp : Y-coord(1) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(2) = int(-1,-1,255)
#@gimp : Y-coord(2) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(3) = int(-1,-1,255)
#@gimp : Y-coord(3) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(4) = int(-1,-1,255)
#@gimp : Y-coord(4) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(5) = int(-1,-1,255)
#@gimp : Y-coord(5) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : Ending Y = int(255,0,255)
#@gimp : sep = separator()
#@gimp : Curve smoothness = float(1,0,1)
#@gimp : Display histogram = float(0,0,100)
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")

#@gimp Red chrominance : gimp_apply_YCbCrcurve, gimp_apply_Crcurve_preview
#@gimp : Starting Y = int(0,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(1) = int(-1,-1,255)
#@gimp : Y-coord(1) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(2) = int(-1,-1,255)
#@gimp : Y-coord(2) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(3) = int(-1,-1,255)
#@gimp : Y-coord(3) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(4) = int(-1,-1,255)
#@gimp : Y-coord(4) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(5) = int(-1,-1,255)
#@gimp : Y-coord(5) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : Ending Y = int(255,0,255)
#@gimp : sep = separator()
#@gimp : Curve smoothness = float(1,0,1)
#@gimp : Display histogram = float(0,0,100)
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
#@gimp _
gimp_apply_YCbCrcurve : -skip $1
  -gimp_apply_YCbCrcurve_configfile
  -repeat {@#-1} -l[$>,-1]
    -to_colormode[0] {max(3,s)} -sh[0] 0,2 -rgb2ycbcr[-1] -rm[-1]
    -sh[0] 0,0 -_gimp_apply_YCbCrcurve[-1] @{-2,0-12} -rm[-1]
    -sh[0] 1,1 -_gimp_apply_YCbCrcurve[-1] @{-2,13-25} -rm[-1]
    -sh[0] 2,2 -_gimp_apply_YCbCrcurve[-1] @{-2,26-38} -rm[-1]
    -sh[0] 0,2 -ycbcr2rgb[-1] -rm[-1]
  -endl -done
  -rm[-1]

_gimp_apply_YCbCrcurve :
  -apply_curve $13,0,$1,\
                   @{"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
                   @{"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
                   @{"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
                   @{"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
                   @{"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
                   255,$12
  -c 0,255

gimp_apply_Ycurve_preview :
  -gimp_apply_YCbCrcurve_configfile
  -sh[-1] 0,0,0,0 -f[-1] ${1--3} -rm[-1]
  -gimp_apply_YCbCrcurve_preview[^-1] @-1,0,${-2,-1} -rm[-1]

gimp_apply_Cbcurve_preview :
  -gimp_apply_YCbCrcurve_configfile
  -sh[-1] 1,1,0,0 -f[-1] ${1--3} -rm[-1]
  -gimp_apply_YCbCrcurve_preview[^-1] @-1,1,${-2,-1} -rm[-1]

gimp_apply_Crcurve_preview :
  -gimp_apply_YCbCrcurve_configfile
  -sh[-1] 2,2,0,0 -f[-1] ${1--3} -rm[-1]
  -gimp_apply_YCbCrcurve_preview[^-1] @-1,2,${-2,-1} -rm[-1]

gimp_apply_YCbCrcurve_configfile :
  filename=@{-path_tmp}/.gmic_YCbCrcurve.dlm
  -if $filename $filename -else (0,-1,128,-1,128,-1,128,-1,128,-1,128,255,1) -r[-1] 100%,3 -endif

gimp_apply_YCbCrcurve_preview :
  (${1--3}) -r[-1] 13,3,1,1,-1 -o[-1] @{-path_tmp}/.gmic_YCbCrcurve.dlm -rm[-1]
  -function1d $13,0,$1,\
                  @{"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
                  @{"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
                  @{"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
                  @{"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
                  @{"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
                  255,$12
  -function1d $26,0,$14,\
                  @{"-if {$15>=0} -u $15,$16, -else -u \"\" -endif"}\
                  @{"-if {$17>=0} -u $17,$18, -else -u \"\" -endif"}\
                  @{"-if {$19>=0} -u $19,$20, -else -u \"\" -endif"}\
                  @{"-if {$21>=0} -u $21,$22, -else -u \"\" -endif"}\
                  @{"-if {$23>=0} -u $23,$24, -else -u \"\" -endif"}\
                  255,$25
  -function1d $39,0,$27,\
                  @{"-if {$28>=0} -u $28,$29, -else -u \"\" -endif"}\
                  @{"-if {$30>=0} -u $30,$31, -else -u \"\" -endif"}\
                  @{"-if {$32>=0} -u $32,$33, -else -u \"\" -endif"}\
                  @{"-if {$34>=0} -u $34,$35, -else -u \"\" -endif"}\
                  @{"-if {$36>=0} -u $36,$37, -else -u \"\" -endif"}\
                  255,$38
  -a[-3--1] y -mv[-1] 0
  -repeat {@#-1}
    --gimp_split_preview[-1] "-gimp_apply_YCbCrcurve 0",$-1
    -axes[-1] 0,255,255,0,13,1,255
    100%,100% -axes[-1] 0,255,255,0,13,1,255 --dilate[-1] 3 -r[-2] [-3] -j[-3] [-2],0,0,0,0,1,[-1],255 -rm[-2,-1]
    -grid[-1] 10%,10%,0,0,0.3,0xCCCCCCCC,255
    -line[-1] 0,100%,100%,0,0.3,0xCCCCCCCC,255
     -if $-2
        [-1],[-1],1,1,-{$-2*255/100} -to_gray[-3] -histogram[-3] 256,0,255 -graph[-1] [-3],3,0,0,0,1,0
        -rm[-3] -+[-1] {$-2*255/100} -+[-2,-1] -c[-1] 0,255
     -else -rm[-2] -endif
     -line[-1] 0,100%,100%,0,0.3,0xCCCCCCCC,255
     -sh[0] 0,0,0,0
     -graph[-2] [-1],1,0,255,0,1,255,255,255 --[-1] 1
     -graph[-2] [-1],1,0,255,0,0.5,200,200,200 -rm[-1]
     -sh[0] 1,1,0,0
     -graph[-2] [-1],1,0,255,0,1,128,128,255 --[-1] 1
     -graph[-2] [-1],1,0,255,0,0.5,0,0,200 -rm[-1]
     -sh[0] 2,2,0,0
     -graph[-2] [-1],1,0,255,0,1,255,128,128 --[-1] 1
     -graph[-2] [-1],1,0,255,0,0.5,200,0,0 -rm[-1]
     -if {$40==0}
       -_gimp_apply_curve_preview 0,$1,0 -_gimp_apply_curve_preview $2,$3,1
       -_gimp_apply_curve_preview $4,$5,2 -_gimp_apply_curve_preview $6,$7,3
       -_gimp_apply_curve_preview $8,$9,4 -_gimp_apply_curve_preview $10,$11,5
       -_gimp_apply_curve_preview 255,$12,6
     -elif {$40==1}
       -_gimp_apply_curve_preview 0,$14,0 -_gimp_apply_curve_preview $15,$16,1
       -_gimp_apply_curve_preview $17,$18,2 -_gimp_apply_curve_preview $19,$20,3
       -_gimp_apply_curve_preview $21,$22,4 -_gimp_apply_curve_preview $23,$24,5
       -_gimp_apply_curve_preview 255,$25,6
     -else
       -_gimp_apply_curve_preview 0,$27,0 -_gimp_apply_curve_preview $28,$29,1
       -_gimp_apply_curve_preview $30,$31,2 -_gimp_apply_curve_preview $32,$33,3
       -_gimp_apply_curve_preview $34,$35,4 -_gimp_apply_curve_preview $36,$37,5
       -_gimp_apply_curve_preview 255,$38,6
     -endif
  -mv[-1] 1 -done -rm[0]

#@gimp Curves [Lab]
#@gimp Lightness : gimp_apply_Labcurve, gimp_apply_Lcurve_preview
#@gimp : Starting Y = int(0,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(1) = int(-1,-1,255)
#@gimp : Y-coord(1) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(2) = int(-1,-1,255)
#@gimp : Y-coord(2) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(3) = int(-1,-1,255)
#@gimp : Y-coord(3) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(4) = int(-1,-1,255)
#@gimp : Y-coord(4) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(5) = int(-1,-1,255)
#@gimp : Y-coord(5) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : Ending Y = int(255,0,255)
#@gimp : sep = separator()
#@gimp : Curve smoothness = float(1,0,1)
#@gimp : Display histogram = float(0,0,100)
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")

#@gimp A-color : gimp_apply_Labcurve, gimp_apply_acurve_preview
#@gimp : Starting Y = int(0,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(1) = int(-1,-1,255)
#@gimp : Y-coord(1) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(2) = int(-1,-1,255)
#@gimp : Y-coord(2) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(3) = int(-1,-1,255)
#@gimp : Y-coord(3) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(4) = int(-1,-1,255)
#@gimp : Y-coord(4) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(5) = int(-1,-1,255)
#@gimp : Y-coord(5) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : Ending Y = int(255,0,255)
#@gimp : sep = separator()
#@gimp : Curve smoothness = float(1,0,1)
#@gimp : Display histogram = float(0,0,100)
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")

#@gimp B-color : gimp_apply_Labcurve, gimp_apply_bcurve_preview
#@gimp : Starting Y = int(0,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(1) = int(-1,-1,255)
#@gimp : Y-coord(1) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(2) = int(-1,-1,255)
#@gimp : Y-coord(2) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(3) = int(-1,-1,255)
#@gimp : Y-coord(3) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(4) = int(-1,-1,255)
#@gimp : Y-coord(4) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(5) = int(-1,-1,255)
#@gimp : Y-coord(5) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : Ending Y = int(255,0,255)
#@gimp : sep = separator()
#@gimp : Curve smoothness = float(1,0,1)
#@gimp : Display histogram = float(0,0,100)
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
#@gimp _
gimp_apply_Labcurve : -skip $1
  -gimp_apply_Labcurve_configfile
  -repeat {@#-1} -l[$>,-1]
    -to_colormode[0] {max(3,s)} -sh[0] 0,2 -rgb2lab[-1] -rm[-1]
    -sh[0] 0,0 -*[-1] 2.55 -_gimp_apply_Labcurve[-1] @{-2,0-12} -/[-1] 2.55 -rm[-1]
    -sh[0] 1,1 -+[-1] 86 -*[-1] 1.38587 -_gimp_apply_Labcurve[-1] @{-2,13-25} -/[-1] 1.38587 --[-1] 86 -rm[-1]
    -sh[0] 2,2 -+[-1] 108 -*[-1] 1.25616 -_gimp_apply_Labcurve[-1] @{-2,26-38} -/[-1] 1.25616 --[-1] 108 -rm[-1]
    -sh[0] 0,2 -lab2rgb[-1] -rm[-1]
  -endl -done
  -rm[-1]

_gimp_apply_Labcurve :
  -apply_curve $13,0,$1,\
                   @{"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
                   @{"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
                   @{"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
                   @{"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
                   @{"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
                   255,$12
  -c 0,255

gimp_apply_Lcurve_preview :
  -gimp_apply_Labcurve_configfile
  -sh[-1] 0,0,0,0 -f[-1] ${1--3} -rm[-1]
  -gimp_apply_Labcurve_preview[^-1] @-1,0,${-2,-1} -rm[-1]

gimp_apply_acurve_preview :
  -gimp_apply_Labcurve_configfile
  -sh[-1] 1,1,0,0 -f[-1] ${1--3} -rm[-1]
  -gimp_apply_Labcurve_preview[^-1] @-1,1,${-2,-1} -rm[-1]

gimp_apply_bcurve_preview :
  -gimp_apply_Labcurve_configfile
  -sh[-1] 2,2,0,0 -f[-1] ${1--3} -rm[-1]
  -gimp_apply_Labcurve_preview[^-1] @-1,2,${-2,-1} -rm[-1]

gimp_apply_Labcurve_configfile :
  filename=@{-path_tmp}/.gmic_Labcurve.dlm
  -if $filename $filename -else (0,-1,128,-1,128,-1,128,-1,128,-1,128,255,1) -r[-1] 100%,3 -endif

gimp_apply_Labcurve_preview :
  (${1--3}) -r[-1] 13,3,1,1,-1 -o[-1] @{-path_tmp}/.gmic_Labcurve.dlm -rm[-1]
  -function1d $13,0,$1,\
                  @{"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
                  @{"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
                  @{"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
                  @{"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
                  @{"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
                  255,$12
  -function1d $26,0,$14,\
                  @{"-if {$15>=0} -u $15,$16, -else -u \"\" -endif"}\
                  @{"-if {$17>=0} -u $17,$18, -else -u \"\" -endif"}\
                  @{"-if {$19>=0} -u $19,$20, -else -u \"\" -endif"}\
                  @{"-if {$21>=0} -u $21,$22, -else -u \"\" -endif"}\
                  @{"-if {$23>=0} -u $23,$24, -else -u \"\" -endif"}\
                  255,$25
  -function1d $39,0,$27,\
                  @{"-if {$28>=0} -u $28,$29, -else -u \"\" -endif"}\
                  @{"-if {$30>=0} -u $30,$31, -else -u \"\" -endif"}\
                  @{"-if {$32>=0} -u $32,$33, -else -u \"\" -endif"}\
                  @{"-if {$34>=0} -u $34,$35, -else -u \"\" -endif"}\
                  @{"-if {$36>=0} -u $36,$37, -else -u \"\" -endif"}\
                  255,$38
  -a[-3--1] y -mv[-1] 0
  -repeat {@#-1}
    --gimp_split_preview[-1] "-gimp_apply_Labcurve 0",$-1
    -axes[-1] 0,255,255,0,13,1,255
    100%,100% -axes[-1] 0,255,255,0,13,1,255 --dilate[-1] 3 -r[-2] [-3] -j[-3] [-2],0,0,0,0,1,[-1],255 -rm[-2,-1]
    -grid[-1] 10%,10%,0,0,0.3,0xCCCCCCCC,255
    -line[-1] 0,100%,100%,0,0.3,0xCCCCCCCC,255
     -if $-2
        [-1],[-1],1,1,-{$-2*255/100} -to_gray[-3] -histogram[-3] 256,0,255 -graph[-1] [-3],3,0,0,0,1,0
        -rm[-3] -+[-1] {$-2*255/100} -+[-2,-1] -c[-1] 0,255
     -else -rm[-2] -endif
     -line[-1] 0,100%,100%,0,0.3,0xCCCCCCCC,255
     -sh[0] 0,0,0,0
     -graph[-2] [-1],1,0,255,0,1,255,255,255 --[-1] 1
     -graph[-2] [-1],1,0,255,0,0.5,200,200,200 -rm[-1]
     -sh[0] 1,1,0,0
     -graph[-2] [-1],1,0,255,0,1,255,128,128 --[-1] 1
     -graph[-2] [-1],1,0,255,0,0.5,200,0,0 -rm[-1]
     -sh[0] 2,2,0,0
     -graph[-2] [-1],1,0,255,0,1,128,128,255 --[-1] 1
     -graph[-2] [-1],1,0,255,0,0.5,0,0,200 -rm[-1]
     -if {$40==0}
       -_gimp_apply_curve_preview 0,$1,0 -_gimp_apply_curve_preview $2,$3,1
       -_gimp_apply_curve_preview $4,$5,2 -_gimp_apply_curve_preview $6,$7,3
       -_gimp_apply_curve_preview $8,$9,4 -_gimp_apply_curve_preview $10,$11,5
       -_gimp_apply_curve_preview 255,$12,6
     -elif {$40==1}
       -_gimp_apply_curve_preview 0,$14,0 -_gimp_apply_curve_preview $15,$16,1
       -_gimp_apply_curve_preview $17,$18,2 -_gimp_apply_curve_preview $19,$20,3
       -_gimp_apply_curve_preview $21,$22,4 -_gimp_apply_curve_preview $23,$24,5
       -_gimp_apply_curve_preview 255,$25,6
     -else
       -_gimp_apply_curve_preview 0,$27,0 -_gimp_apply_curve_preview $28,$29,1
       -_gimp_apply_curve_preview $30,$31,2 -_gimp_apply_curve_preview $32,$33,3
       -_gimp_apply_curve_preview $34,$35,4 -_gimp_apply_curve_preview $36,$37,5
       -_gimp_apply_curve_preview 255,$38,6
     -endif
  -mv[-1] 1 -done -rm[0]

#@gimp Decompose channels : gimp_decompose_channels, gimp_decompose_channels_preview
#@gimp : Color basis = choice(7,"RGB","HSV","HSL","HSI","YUV","YCbCr","XYZ","Lab","Lch","CMY","CMYK")
#@gimp : Action = choice("Decompose","Recompose")
#@gimp : Use multiple layers = bool(0)
#@gimp : Include opacity layer = bool(1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_decompose_channels :
  -if {!$2} # Decompose
    -if $4 -to_rgba -else -to_rgb -endif
    -repeat @# -l[-1]
      -split_opacity -_gimp_decompose_channels$1[0]
      -s[0] c -if {!$3} -a x -endif
      nb=@#
    -endl -mv[-$nb--1] 0 -done
  -else # Recompose
    -channels 0 nbc={3+($1==10)} nb={$nbc+$4}
    -if $3 -repeat {int(@#/$nb)} -l[0-{$nb-1}]
      -a[0-{$nbc-1}] c -_gimp_recompose_channels$1[0] -a c
    -endl -mv[-1] 0 -done
    -else -repeat @# -l[$>]
      -s x,$nb -a[0-{$nbc-1}] c -_gimp_recompose_channels$1[0] -a c
    -endl -mv[-1] 0 -done -endif
  -endif

gimp_decompose_channels_preview :
  -gimp_decompose_channels ${^0} -append_tiles ,

_gimp_decompose_channels0 :
_gimp_decompose_channels1 : -rgb2hsv8
_gimp_decompose_channels2 : -rgb2hsl8
_gimp_decompose_channels3 : -rgb2hsi8
_gimp_decompose_channels4 : -rgb2yuv8
_gimp_decompose_channels5 : -rgb2ycbcr
_gimp_decompose_channels6 : -rgb2xyz8
_gimp_decompose_channels7 : -rgb2lab8
_gimp_decompose_channels8 : -rgb2lch8
_gimp_decompose_channels9 : -rgb2cmy
_gimp_decompose_channels10 : -rgb2cmyk

_gimp_recompose_channels0 :
_gimp_recompose_channels1 : -hsv82rgb
_gimp_recompose_channels2 : -hsl82rgb
_gimp_recompose_channels3 : -hsi82rgb
_gimp_recompose_channels4 : -yuv82rgb
_gimp_recompose_channels5 : -ycbcr2rgb
_gimp_recompose_channels6 : -xyz82rgb
_gimp_recompose_channels7 : -lab82rgb
_gimp_recompose_channels8 : -lch82rgb
_gimp_recompose_channels9 : -cmy2rgb
_gimp_recompose_channels10 : -cmyk2rgb

#@gimp Detect skin : gimp_detect_skin, gimp_detect_skin_preview(1)
#@gimp : Skin estimation = choice(1,"Manual","Automatic")
#@gimp : sep = separator()
#@gimp : Tolerance = float(0.5,0,1)
#@gimp : Smoothness = float(0.5,0,5)
#@gimp : Threshold = float(1,0,10)
#@gimp : Pre-normalize image = bool(1)
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Manual estimation:</b>\n
#@gimp : Use the sliders below to target as much skin pixels as you can.</small>")
#@gimp : X-coordinate = float(50,0,100)
#@gimp : Y-coordinate = float(50,0,100)
#@gimp : Radius = float(5,0,25)
#@gimp : sep = separator()
#@gimp : Output mode = choice(1,"Probability map","Opaque skin","Transparent skin")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>01/03/2014</i>.</small>")
gimp_detect_skin :
  -to_rgb
  -m "_gimp_detect_skin :
        -if $5 -balance_gamma 128,128,128 -endif
        -if $1 -detect_skin $2 -else -detect_skin $2,$6%,$7%,$8% -endif
        M={iM} -b $3% -* {255*$M/iM} -* $4 -c 0,255"
  -repeat @# -l[$>]
    -if $9  # Opaque/transparent skin.
      --_gimp_detect_skin -a c
      -if {$9>1} -sh 100%,100% -*[-1] -1 -+[-1] 255 -rm[-1] -endif
    -else -_gimp_detect_skin # Probability mask.
    -endif
  -endl -done
  -uncommand _gimp_detect_skin

gimp_detect_skin_preview :
  -gimp_split_preview "-gimp_detect_skin $*",$-1
  -to_rgba
  -if {!$1}
    -circle $6%,$7%,$8%,0.3,0,255,0,255
    -circle $6%,$7%,$8%,1,0xFFFFFFFF,0,255,0,255
    -line {$6-0.25*$8}%,{$7-0.25*$8}%,{$6+0.25*$8}%,{$7+0.25*$8}%,1,255,255,0,255
    -line {$6+0.25*$8}%,{$7-0.25*$8}%,{$6-0.25*$8}%,{$7+0.25*$8}%,1,255,255,0,255
  -endif

#@gimp Equalize HSV : gimp_hsv_equalizer, gimp_hsv_equalizer_preview
#@gimp : Preview bands = bool(false)
#@gimp : sep = separator()
#@gimp : Hue band = float(180,0,360)
#@gimp : Band width = float(40,1,360)
#@gimp : Hue shift = float(0,-180,180)
#@gimp : Saturation correction = float(0,-0.99,0.99)
#@gimp : Value correction = float(0,-0.99,0.99)
#@gimp : sep = separator()
#@gimp : Hue band = float(180,0,360)
#@gimp : Band width = float(40,1,360)
#@gimp : Hue shift = float(0,-180,180)
#@gimp : Saturation correction = float(0,-0.99,0.99)
#@gimp : Value correction = float(0,-0.99,0.99)
#@gimp : sep = separator()
#@gimp : Hue band = float(180,0,360)
#@gimp : Band width = float(40,1,360)
#@gimp : Hue shift = float(0,-180,180)
#@gimp : Saturation correction = float(0,-0.99,0.99)
#@gimp : Value correction = float(0,-0.99,0.99)
#@gimp : sep = separator()
#@gimp : note = note("<small>Author: <i>J&#233;rome Ferrari</i>.      Latest update: <i>01/14/2011</i>.</small>")
#@gimp : note = link("Filter explained here","http://www.flickr.com/groups/gmic/discuss/72157625798533482")
gimp_hsv_equalizer :
  -repeat @# -l[@{>,-1}]
  -to_rgb -rgb2hsv -s c
# From now on 0,1,2 are H,S,V
#3 masks:
  --f[0] if(abs(i-$2)<$3/2|abs(i-$2-360)<$3/2|abs(i-$2+360)<$3/2,1,0)
  --f[0] if(abs(i-$7)<$8/2|abs(i-$7-360)<$8/2|abs(i-$7+360)<$8/2,1,0)
  --f[0] if(abs(i-$12)<$13/2|abs(i-$12-360)<$13/2|abs(i-$12+360)<$13/2,1,0)
# From now on 3,4,5 are Masks
  --threshold[1,2] 0.01 -*[-1,-2] [-1]x2 -*[-1,3] -*[-1,4] -*[-1,5]	#0 saturation and value not in mask
# Hue shift:
  --*[3] $4 --*[4] $9 --*[5] $14 -+[-1,-2,-3]
  -+[-1,0] -%[0] 360
# Saturation :
  -if {$5>=0} --*[3] -$5 -else --*[3] {1/(1+$5)-1} -endif -+[-1] 1
  -if {$10>=0} --*[4] -$10 -else --*[4] {1/(1+$10)-1} -endif -+[-1] 1
  -if {$15>=0} --*[5] -$15 -else --*[5] {1/(1+$15)-1} -endif -+[-1] 1
  -*[-1,-2,-3] -^[1,-1]
# Value :
  -if {$6>=0} --*[3] -$6 -else --*[3] {1/(1+$6)-1} -endif -+[-1] 1
  -if {$11>=0} --*[4] -$11 -else --*[4] {1/(1+$11)-1} -endif -+[-1] 1
  -if {$16>=0} --*[5] -$16 -else --*[5] {1/(1+$16)-1} -endif -+[-1] 1
  -*[-1,-2,-3] -^[2,-1]
#reconstruction
  -rm[3,4,5] -a[0,1,2] c -hsv2rgb
  -endl -done

gimp_hsv_equalizer_preview :
  -l[-1]
  -if {$1==0} -gimp_hsv_equalizer $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16
  -else
    -to_rgb -rgb2hsv -s c
    (0,359) -r[-1] [-2],{@{0,h}/10},1,1,3 [-1] -f[-1] 1	#create lower band
    -j[0] [3],0,91% -j[1] [4],0,91% -j[2] [4],0,91% -rm[-1,-2] #paste lower band
    --f[0] if(abs(i-$2)<$3/2|abs(i-$2-360)<$3/2|abs(i-$2+360)<$3/2,1,0)
    --f[0] if(abs(i-$7)<$8/2|abs(i-$7-360)<$8/2|abs(i-$7+360)<$8/2,1,0)
    --f[0] if(abs(i-$12)<$13/2|abs(i-$12-360)<$13/2|abs(i-$12+360)<$13/2,1,0) #masks
    -or[-3--1] -+[-1] 0.33 -/[-1] 1.33	#1 and 0.25
    -*[2,-1] -a c -hsv2rgb
  -endif -endl

#@gimp Mixer [RGB] : gimp_mix_rgb, gimp_mix_rgb_preview(1)
#@gimp : Red contrast = float(1,0,4)
#@gimp : Red brightness = float(0,-255,255)
#@gimp : Red smoothness = float(0,0,10)
#@gimp : Green contrast = float(1,0,4)
#@gimp : Green brightness = float(0,-255,255)
#@gimp : Green smoothness = float(0,0,10)
#@gimp : Blue contrast = float(1,0,4)
#@gimp : Blue brightness = float(0,-255,255)
#@gimp : Blue smoothness = float(0,0,10)
#@gimp : note = note()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_start_mix :
  -if {$1==1} --tones[-1] 3 -+[-2,-1] -b[-2,-1] $2% -r[-2,-1] [-3] -*[-1] [-3] -mv[-3] @#
  -elif {$1==2} --tones[-1] 3 -+[-3,-1] -b[-2,-1] $2% -r[-2,-1] [-3] -*[-2] [-3] -mv[-3] @#
  -elif {$1==3} --tones[-1] 3 -+[-3,-2] -b[-2,-1] $2% -r[-2,-1] [-3] -*[-2] [-3] -mv[-3] @#
  -endif
gimp_end_mix :
  -if {$1==1} -*[-3,-1] -+[-2,-1]
  -elif {$1==2} -*[-2,-1] -+[-2,-1]
  -elif {$1==3} -*[-2,-1] -+[-2,-1]
  -endif

gimp_mix_rgb :
  -repeat @# -l[-1] -split_opacity -rv -to_rgb[-1]
    -gimp_start_mix $10,$11
    --[-1] 128 -s[-1] c
    -*[-3] $1 -+[-3] $2 -b[-3] $3%
    -*[-2] $4 -+[-2] $5 -b[-2] $6%
    -*[-1] $7 -+[-1] $8 -b[-1] $9%
    -a[-3--1] c -+[-1] 128 -c[-1] 0,255
    -gimp_end_mix $10
  -if {@#!=3} -rv -a c -endif -endl -mv[-1] 0 -done

gimp_mix_rgb_preview :
  -gimp_split_preview "-gimp_mix_rgb $*",$-1

#@gimp Mixer [YCbCr] : gimp_mix_ycbcr, gimp_mix_ycbcr_preview(1)
#@gimp : Luminance contrast = float(1,0,4)
#@gimp : Luminance brightness = float(0,-255,255)
#@gimp : Luminance smoothness = float(0,0,10)
#@gimp : Blue chroma contrast = float(1,0,4)
#@gimp : Blue chroma brightness = float(0,-255,255)
#@gimp : Blue chroma smoothness = float(0,0,10)
#@gimp : Red chroma contrast = float(1,0,4)
#@gimp : Red chroma brightness = float(0,-255,255)
#@gimp : Red chroma smoothness = float(0,0,10)
#@gimp : note = note()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_mix_ycbcr :
  -repeat @# -l[-1] -split_opacity -rv -to_rgb[-1]
    -gimp_start_mix $10,$11
    -rgb2ycbcr[-1] --[-1] 128 -s[-1] c
    -*[-3] $1 -+[-3] $2 -b[-3] $3%
    -*[-2] $4 -+[-2] $5 -b[-2] $6%
    -*[-1] $7 -+[-1] $8 -b[-1] $9%
    -a[-3--1] c -+[-1] 128 -c[-1] 0,255 -ycbcr2rgb[-1]
    -gimp_end_mix $10
  -if {@#!=3} -rv -a c -endif -endl -mv[-1] 0 -done

gimp_mix_ycbcr_preview :
  -gimp_split_preview "-gimp_mix_ycbcr $*",$-1

#@gimp Mixer [HSV] : gimp_mix_hsv, gimp_mix_hsv_preview(1)
#@gimp : Hue contrast = float(1,0,4)
#@gimp : Hue brightness = float(0,-180,180)
#@gimp : Hue smoothness = float(0,0,10)
#@gimp : Saturation contrast = float(1,0,4)
#@gimp : Saturation brightness = float(0,-1,1)
#@gimp : Saturation smoothness = float(0,0,10)
#@gimp : Value contrast = float(1,0,4)
#@gimp : Value brightness = float(0,-1,1)
#@gimp : Value smoothness = float(0,0,10)
#@gimp : note = note()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_mix_hsv :
  -repeat @# -l[-1] -split_opacity -rv -to_rgb[-1]
    -gimp_start_mix $10,$11
    -rgb2hsv[-1] -s[-1] c --[-2,-1] 0.5
    -*[-3] $1 -+[-3] $2 -b[-3] $3%
    -*[-2] $4 -+[-2] $5 -b[-2] $6%
    -*[-1] $7 -+[-1] $8 -b[-1] $9%
    -%[-3] 360 -+[-2,-1] 0.5 -c[-2,-1] 0,1 -a[-3--1] c -hsv2rgb[-1]
    -gimp_end_mix $10
  -if {@#!=3} -rv -a c -endif -endl -mv[-1] 0 -done

gimp_mix_hsv_preview :
  -gimp_split_preview "-gimp_mix_hsv $*",$-1

#@gimp Mixer [Lab] : gimp_mix_lab, gimp_mix_lab_preview(1)
#@gimp : Lightness contrast = float(1,0.5,1.5)
#@gimp : Lightness brightness = float(0,-50,50)
#@gimp : Lightness smoothness = float(0,0,10)
#@gimp : A-color contrast = float(1,0,4)
#@gimp : A-color brightness = float(0,-20,20)
#@gimp : A-color smoothness = float(0,0,10)
#@gimp : B-color contrast = float(1,0,4)
#@gimp : B-color brightness = float(0,-20,20)
#@gimp : B-color smoothness = float(0,0,10)
#@gimp : note = note()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_mix_lab :
  -repeat @# -l[$>] -split_opacity -to_rgb[0]
    -gimp_parallel_overlap[0] "-_gimp_mix_lab $*",0,{3*max($3,$6,$9)}
    -a c
  -endl -mv[$>] 0 -done

_gimp_mix_lab :
  -gimp_start_mix $10,$11
  -rgb2lab[-1] -s[-1] c
  -*[-3] $1 -+[-3] $2 -b[-3] $3%
  -*[-2] $4 -+[-2] $5 -b[-2] $6%
  -*[-1] $7 -+[-1] $8 -b[-1] $9%
  -a[-3--1] c -lab2rgb[-1]
  -gimp_end_mix $10

gimp_mix_lab_preview :
  -gimp_split_preview "-gimp_mix_lab $*",$-1

#@gimp Mixer [CMYK] : gimp_mix_cmyk, gimp_mix_cmyk_preview(1)
#@gimp : Cyan contrast = float(1,0,4)
#@gimp : Cyan brightness = float(0,-255,255)
#@gimp : Cyan smoothness = float(0,0,10)
#@gimp : Magenta contrast = float(1,0,4)
#@gimp : Magenta brightness = float(0,-255,255)
#@gimp : Magenta smoothness = float(0,0,10)
#@gimp : Yellow contrast = float(1,0,4)
#@gimp : Yellow brightness = float(0,-255,255)
#@gimp : Yellow smoothness = float(0,0,10)
#@gimp : Key contrast = float(1,0,4)
#@gimp : Key brightness = float(0,-255,255)
#@gimp : Key smoothness = float(0,0,10)
#@gimp : note = note()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_mix_cmyk :
  -repeat @# -l[-1] -split_opacity -rv -to_rgb[-1]
    -gimp_start_mix $13,$14
    -rgb2cmyk[-1] -s[-1] c
    -*[-4] $1 -+[-4] $2 -b[-4] $3%
    -*[-3] $4 -+[-3] $5 -b[-3] $6%
    -*[-2] $7 -+[-2] $8 -b[-2] $9%
    -*[-1] $10 -+[-1] $11 -b[-1] $12%
    -a[-4--1] c -cmyk2rgb[-1]
    -gimp_end_mix $13
  -if {@#!=3} -rv -a c -endif -endl -mv[-1] 0 -done

gimp_mix_cmyk_preview :
  -gimp_split_preview "-gimp_mix_cmyk $*",$-1

#@gimp Select/replace color : gimp_select_color, gimp_select_color_preview(0)
#@gimp : Similarity space = choice(0,"RGB[A]","RGB","YCbCr","Red","Green","Blue","Opacity","Luminance","Blue & Red chrominances","Hue","Saturation")
#@gimp : Tolerance = float(20,0,100)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Fill holes = int(0,0,256)
#@gimp : Selected color = color(255,255,255,255)
#@gimp : Output as = choice(0,"Selected colors","Selected mask","Rejected colors","Rejected mask","Replaced color")
#@gimp : Replacement color = color(255,0,0,255)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
_gimp_select_color :
  -if {$1==1} -to_rgb                            # RGB
  -elif {$1==2} -to_rgb -rgb2ycbcr               # YCbCr
  -elif {$1==3} -channels 0                      # R
  -elif {$1==4} -channels 1                      # G
  -elif {$1==5} -channels 2                      # B
  -elif {$1==6} -to_rgba -channels 3             # Opacity
  -elif {$1==7} -to_rgb -rgb2ycbcr -channels 0   # Luminance
  -elif {$1==8} -to_rgb -rgb2ycbcr -channels 1,2 # B&R chrominances
  -elif {$1==9} -to_rgb -rgb2hsv -channels 0     # Hue
  -elif {$1==10} -to_rgb -rgb2hsv -channels 1    # Saturation
  -endif

gimp_select_color :
  ($5^$6^$7^$8) -_gimp_select_color[-1] $1 color=@-1 -rm[-1]
  -repeat @# -l[$>] -to_rgba
    --_gimp_select_color $1
    -select_color[1] $2%,$color
    -if $4 --area[-1] 0,0 -<=[-1] {round($4^1.5)} -inpaint[-2] [-1],0,3 -rm[-1] -endif # Fill holes.
    -b[1] $3 -n[1] 0,255
    -if {$9==0} -sh[0] 100%,100% -and[-1] [1]                      # Selected colors.
    -elif {$9==1} -rm[0]                                           # Selected mask.
    -elif {$9==2} --[1] 255 -*[1] -1 -sh[0] 100%,100% -and[-1] [1] # Rejected colors.
    -elif {$9==3} -rm[0] -- 255 -* -1                              # Rejected mask.
    -else # Replaced color.
      -/[1] 255 --*[0,1] --*[1] $11 --*[1] $12 --*[1] $13 -*[1] $10 -a[1,-3--1] c --[1,2] -+
    -endif
    -k[0]
  -endl -done

gimp_select_color_preview :
  -gimp_split_preview "-gimp_select_color $*",$-1

#@gimp Sepia : gimp_sepia, gimp_sepia_preview
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_sepia :
  -sepia
  -repeat @#
    -sh[-1] 0,2 -apply_gamma[-1] {10^$1} --[-1] 128 -*[-1] $2 -+[-1] {128+$3} -c[-1] 0,255
  -rm[-1] -mv[-1] 0 -done

gimp_sepia_preview :
  -gimp_split_preview "-gimp_sepia $*",$-1

#@gimp User-defined : gimp_custom_transform, gimp_custom_transform
#@gimp : Red - Green - Blue - Alpha = text{"i"}
#@gimp : Red - Green - Blue = text{"i + 90*(x/w)*cos(i/10)"}
#@gimp : Red = text{"i"}
#@gimp : Green = text{"i"}
#@gimp : Blue = text{"i"}
#@gimp : Alpha = text{"i"}
#@gimp : Value normalization = choice("None","RGB","RGBA")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_custom_transform :
  -to_rgba -repeat @#
    -f[-1] "$1"
    -s[-1] c -a[-4--2] c -f[-2] "$2"
    -s[-2] c -f[-4] "$3" -f[-3] "$4" -f[-2] "$5" -f[-1] "$6"
    -if {$7==0} -a[-4--1] c -c[-1] 0,255
    -elif {$7==1} -a[-4--2] c -n[-2] 0,255 -c[-1] 0,255 -a[-2,-1] c
    -else -a[-4--1] c -n[-1] 0,255
    -endif
  -mv[-1] 0 -done


#@gimp _<b>Contours</b>
#----------------------

#@gimp Convolve : gimp_convolve, gimp_convolve_preview(0)
#@gimp : Kernel = choice("Custom","Average 3x3","Average 5x5","Average 7x7","Average 9x9","Prewitt-X","Prewitt-Y","Sobel-X","Sobel-Y","Rotinv-X","Rotinv-Y","Laplacian","Robert Cross 1","Robert Cross 2","Impulses 5x5","Impulses 7x7","Impulses 9x9")
#@gimp : Boundary = choice(1,"Dirichlet","Neumann")
#@gimp : sep = separator(), note = note("<small><b>Note:</b> If parameter <i>Kernel</i> is set to <i>Custom</i>, it uses the custom convolution kernel defined below. Use commas and semicolons as separators for res. matrix columns and rows.</small>")
#@gimp : Custom kernel = text("0,1,0;1,-4,1;0,1,0")
#@gimp : sep = separator(), note = note("<small><b>Note:</b> Kernel multiplier is useful only when parameter <i>Value range</i> is set to <i>Cut</i>.</small>")
#@gimp : Value range = choice(1,"Cut","Normalize")
#@gimp : Kernel multiplier = float(1,0,50)
#@gimp : sep = separator()
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>06/06/2013</i>.</small>")
gimp_convolve :
  -apply_channels "-_gimp_convolve $1,$2,\"$3\",${4--3}",$-2,0

_gimp_convolve :
  -if $1 -_gimp_convolve$1[] -else ($3) -endif
  -if {!$4} -*[-1] $5 -endif
  -convolve[0--2] [-1],$2
  -if $4 -n 0,255 -else -c 0,255 -endif
  -rm[-1]

_gimp_convolve1 : 3,3 -f 1 -normalize_sum  # Average 3x3
_gimp_convolve2 : 5,5 -f 1 -normalize_sum  # Average 5x5
_gimp_convolve3 : 7,7 -f 1 -normalize_sum  # Average 7x7
_gimp_convolve4 : 9,9 -f 1 -normalize_sum  # Average 9x9
_gimp_convolve5 : (1,0,-1;1,0,-1;1,0,-1)  # Prewitt-X
_gimp_convolve6 : (1,1,1;0,0,0;-1,-1,-1)  # Prewitt-Y
_gimp_convolve7 : (1,0,-1;2,0,-2;1,0,-1)  # Sobel-X
_gimp_convolve8 : (1,2,1;0,0,0;-1,-2,-1)  # Sobel-Y
_gimp_convolve9 : a={0.25*(2-sqrt(2))} b={0.5*(sqrt(2)-1)} ($a,0,-$a;$b,0,-$b;$a,0,-$a)  # Rotinv-X
_gimp_convolve10 : a={0.25*(2-sqrt(2))} b={0.5*(sqrt(2)-1)} ($a,$b,$a;0,0,0;-$a,-$b,-$a) # Rotinv-Y
_gimp_convolve11 : (0,1,0;1,-4,1;0,1,0)    # Laplacian
_gimp_convolve12 : (1,0;0,-1)             # Robert Cross1
_gimp_convolve13 : (0,1;-1,0)             # Robert Cross2
_gimp_convolve14 : 3,3 -f 1 -r 7,7,1,1,4,0,0.5,0.5 -autocrop -normalize_sum # Impulse 5x5
_gimp_convolve15 : 3,3 -f 1 -r 9,9,1,1,4,0,0.5,0.5 -autocrop -normalize_sum # Impulse 7x7
_gimp_convolve16 : 3,3 -f 1 -r 11,11,1,1,4,0,0.5,0.5 -autocrop -normalize_sum # Impulse 9x9

gimp_convolve_preview :
  -gimp_split_preview "-gimp_convolve $1,$2,\"$3\",${4--1}",$-1

#@gimp Curvature : gimp_curvature, gimp_curvature_preview(0)
#@gimp : Smoothness = float(2,0,10)
#@gimp : Min threshold = float(0,0,100)
#@gimp : Max threshold = float(100,0,100)
#@gimp : Absolute value = bool(0)
#@gimp : Negative colors = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_curvature :
  -repeat @# -l[$>] -split_opacity -l[0]
    -b $1 -iee
    -if $4 -abs -endif
    -c $2%,$3%
    -if $5 -negative -endif
    -n 0,255
  -endl -a c -endl -done

gimp_curvature_preview :
  -gimp_split_preview "-gimp_curvature ${^0}",$-1

#@gimp Difference of gaussians : gimp_dog, gimp_dog_preview(1)
#@gimp : 1st Variance = float(1.4,0,5)
#@gimp : 2nd Variance = float(1.5,0,5)
#@gimp : Threshold = float(0,0,49)
#@gimp : Negative colors = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_dog :
  -dog $1%,$2%
  -c $3%,{100-$3}%
  -if $4 -negative -endif
  -n 0,255

gimp_dog_preview :
  -gimp_split_preview "-gimp_dog ${^0}",$-1

#@gimp Distance transform : gimp_distance, gimp_distance_preview(0)
#@gimp : Value = int(128,0,255)
#@gimp : Metric = choice(2,"Chebyshev","Manhattan","Euclidean","Squared-Euclidean")
#@gimp : Normalization = choice(2,"Cut","Normalize","Modulo")
#@gimp : Modulo value = int(32,1,255)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>04/07/2011</i>.</small>")
gimp_distance :
  -repeat @# -l[$>] -split_opacity -l[0]
    -distance $1,$2
    -if {$3==0} -c 0,255
    -elif {$3==1} -n 0,255
    -else -% $4 -n 0,255
    -endif
  -endl -a c -endl -done

gimp_distance_preview :
  -gimp_split_preview "-gimp_distance ${^0}",$-1

#@gimp Edges : gimp_edges, gimp_edges_preview(0)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Threshold = float(15,0,50)
#@gimp : Negative colors = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_edges :
  -to_rgb -b $1% -edges $2%
  -if $3 -negative -endif
  -n 0,255

gimp_edges_preview :
  -gimp_split_preview "-gimp_edges ${^0}",$-1

#@gimp Edges offsets : gimp_edge_offsets, gimp_edge_offsets_preview(0)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Threshold = float(15,0,50)
#@gimp : Scale = int(4,0,32)
#@gimp : Thickness = int(1,0,16)
#@gimp : Negative colors = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_edge_offsets :
  -repeat @#
    os={s}
    -b[-1] $1% -gradient_norm[-1] ->=[-1] $2% -skeleton[-1] 0 -distance[-1] 1 -round[-1] 1 -%[-1] $3 ->=[-1] {max(1,$3-$4)}
    -if {!$5} -negative[-1] -endif
    -n[-1] 0,255 -to_colormode[-1] $os
  -mv[-1] 0 -done

gimp_edge_offsets_preview :
  -gimp_split_preview "-gimp_edge_offsets ${^0}",$-1

#@gimp Extract foreground [interactive] : gimp_extract_foreground, gimp_no_preview
#@gimp : Feathering = _float(0,0,4)
#@gimp : Dilation = int(0,-32,32)
#@gimp : Output mode = choice{3,"RGBA image (full-transparency / 1 layer)","RGBA image (updatable / 1 layer)","RGB image + binary mask (2 layers)","RGBA foreground + background (2 layers)"}
#@gimp : View resolution = _choice{1,"Small (faster)","Medium","High (slower)","Very high (even slower)"}
#@gimp : sep = separator()
#@gimp : note = note{"<small><b>Description:</b>\n
#@gimp : This filter allows to quickly extract foreground objects from background in opaque RGB images.
#@gimp : Click on the <i>Apply</i> or <i>OK</i> buttons below to open the interactive window and start adding foreground and background control points.
#@gimp : When you're done, exit the interactive window: your extracted foreground will be transfered back to GIMP.\n\n
#@gimp : If you are not satisfied with the result, click on <i>Apply</i> once again to modify your control points defined previously.
#@gimp : To remove all control points, click on the <i>Reset</i> button below.
#@gimp : </small>"}
#@gimp : Last image size = const(0,0)
#@gimp : Control points = const(-1)
#@gimp : sep = separator()
#@gimp : note = note{"<small><b>Interactions:</b>\n
#@gimp : Use the following actions in the interactive window to build your extraction mask :\n\n
#@gimp : - <b>Left mouse button</b> or key <b>F</b> create a new <b>foreground</b> control point (or move an existing one).\n
#@gimp : - <b>Right mouse button</b> or key <b>B</b> create a new <b>background</b> control point (or move an existing one).\n
#@gimp : - <b>Mouse wheel</b>, or keys <b>CTRL+arrows UP/DOWN</b> zoom view in/out.\n
#@gimp : - Key <b>SPACE</b> updates the extraction mask.\n
#@gimp : - Key <b>TAB</b> toggles background view modes.\n
#@gimp : - Key <b>M</b> toggles marker view modes.\n
#@gimp : - Key <b>BACKSPACE</b> deletes the last control point added.\n
#@gimp : - Key <b>PAGE UP</b> increases background opacity.\n
#@gimp : - Key <b>PAGE DOWN</b> decreases background opacity.\n
#@gimp : - Keys <b>CTRL+D</b> increase window size.\n
#@gimp : - Keys <b>CTRL+C</b> decrease window size.\n
#@gimp : - Keys <b>CTRL+R</b> reset window size.\n
#@gimp : - Keys <b>ESC</b>, <b>Q</b> or <b>ENTER</b> exit the interactive window.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>09/29/2014</i>.</small>")
gimp_extract_foreground :
  -nm "[G\47MIC] Interactive Foreground Extraction"
  -if {!@#} -return -endif
  resolution={arg(1+$3,512,1024,2048,0)}
  -repeat @# -l[$<]
    -if {$7==-1||$5!=w||$6!=h} _gimp_control_points= -else _gimp_control_points=${7--1} -endif
    status=@{-x_segment\ $resolution}
    -sh 3,3 -b[-1] $1% -if {$2>0} -dilate[-1] {1+2*$2} -elif {$2<0} -erode[-1] {1-2*$2} -endif
    -rm[-1]
    -if {$3==1} -sh 3,3 -max[-1] 1 -rm[-1]
    -elif {$3==2} -s c,-3 -r[-1] 100%,100%,1,4 -rv
    -elif {$3==3}
      [-1]
      -sh[-2] 0,2 --channels[-3] 3,3 ->=[-1] 3 -*[-2,-1] -rm[-1]
      -sh[-1] 0,2 --channels[-2] 3,3 -<=[-1] {255-3} -*[-2,-1] -rm[-1]
      -sh[-1] 3,3 -*[-1] -1 -+[-1] 255 -rm[-1]
      -gimp_autocrop_layers
    -endif
  -endl -done
  -if {narg($status)>=4} -u \{$1\}\{$2\}\{$3\}\{$4\}\{{w},{h}\}\{$status\} -else -u "" -endif

#@gimp Gradient norm : gimp_gradient_norm, gimp_gradient_norm_preview(0)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Linearity = float(0.5,0,1.5)
#@gimp : Min threshold = float(0,0,100)
#@gimp : Max threshold = float(100,0,100)
#@gimp : Negative colors = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_gradient_norm :
  -b $1 -gradient_norm -^ $2
  -c $3%,$4%
  -if $5 -negative -endif
  -n 0,255

gimp_gradient_norm_preview :
  -gimp_split_preview "-gimp_gradient_norm ${^0}",$-1

#@gimp Gradient RGB : gimp_gradient2rgb, gimp_gradient2rgb_preview(0)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Min threshold = float(0,0,100)
#@gimp : Max threshold = float(100,0,100)
#@gimp : Orientation only = bool(0)
#@gimp : Negative colors = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_gradient2rgb :
  -b $1 -gradient2rgb $4
  -c $2%,$3%
  -if $5 -negative -endif
  -n 0,255

gimp_gradient2rgb_preview :
  -gimp_split_preview "-gimp_gradient2rgb ${^0}",$-1

#@gimp Isophotes : gimp_isophotes, gimp_isophotes_preview(0)
#@gimp : Levels = int(8,1,256)
#@gimp : Smoothness = float(0,0,5)
#@gimp : Filling = choice(1,"Transparent","Colors")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_isophotes :
  -if $3
    -topographic_map $1,$2
  -else
    -b $2 -isophotes $1
  -endif

gimp_isophotes_preview :
  -gimp_split_preview "-gimp_isophotes ${^0}",$-1

#@gimp Laplacian : gimp_laplacian, gimp_laplacian_preview(0)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Min threshold = float(0,0,100)
#@gimp : Max threshold = float(100,0,100)
#@gimp : Absolute value = bool(0)
#@gimp : Negative colors = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_laplacian :
  -b $1 -laplacian
  -if $4 -abs -endif
  -c $2%,$3%
  -if $5 -negative -endif
  -n 0,255

gimp_laplacian_preview :
  -gimp_split_preview "-gimp_laplacian ${^0}",$-1

#@gimp Local orientation : gimp_local_orientation, gimp_local_orientation_preview(1)
#@gimp : Smoothness = float(0,0,5)
#@gimp : Min threshold = float(0,0,100)
#@gimp : Max threshold = float(100,0,100)
#@gimp : Negative colors = bool(0)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
_gimp_local_orientation :
  -repeat @# -l[$>] -split_opacity -l[0]
    -b $1% -gradient_orientation 2 -complex2polar -rm[0--1:2]
    -c $2%,$3%
    -if $4 -negative -endif
    -n 0,255
  -endl -a c -endl -done

gimp_local_orientation :
  -apply_channels "-_gimp_local_orientation $1,$2,$3,$4",$5,1

gimp_local_orientation_preview :
  -gimp_split_preview "-gimp_local_orientation ${^0}",$-1

#@gimp Morphological filter : gimp_morpho, gimp_morpho_preview(0)
#@gimp : Action = choice("Erosion","Dilation","Opening","Closing",
#@gimp : "Original - Erosion","Dilation - Original","Original - Opening","Closing - Original")
#@gimp : Size = int(5,2,60)
#@gimp : Invert colors = bool(false)
#@gimp : Shape = choice(0,"Square","Octagonal","Circular")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : Scale = bool(true)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>08/06/2014</i>.</small>")
gimp_morpho :
  -apply_channels "-__gimp_morpho ${^0}",$5,$6

gimp_morpho_preview :
  -gimp_split_preview "-gimp_morpho ${^0}",$-1

__gimp_morpho :
  -if {$4==1} suf="_oct" -elif {$4==0} suf="" -else suf="_circ" -endif
  -if {$1==0} -erode$suf $2
  -elif {$1==1} -dilate$suf $2
  -elif {$1==2} -erode$suf $2 -dilate$suf $2
  -elif {$1==3} -dilate$suf $2 -erode$suf $2
  -elif {$1==4} -repeat @# --erode$suf $2 --[-2,-1] -mv[-1] 0 -done
  -elif {$1==5} -repeat @# --dilate$suf $2 -rv[-2,-1] --[-2,-1] -mv[-1] 0 -done
  -elif {$1==6} -repeat @# --erode$suf $2 -dilate$suf[-1] $2 --[-2,-1] -mv[-1] 0 -done
  -else -repeat @# --dilate$suf $2 -erode$suf[-1] $2 -rv[-2,-1] --[-2,-1] -mv[-1] 0 -done
  -endif
  -if $3 -repeat @# -l[$>] -split_opacity -negative[0] -a c -endl -done -endif

#@gimp Segmentation : gimp_segment_watershed, gimp_segment_watershed_preview(0)
#@gimp : Edge threshold = float(2,0,15)
#@gimp : Smoothness = float(1,0,5)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_segment_watershed :
  -apply_channels "-b $2 -segment_watershed $1",$3,0

gimp_segment_watershed_preview :
  -gimp_split_preview "-gimp_segment_watershed ${^0}",$-1

#@gimp Skeleton : gimp_skeleton, gimp_skeleton_preview(1)
#@gimp : Method = choice{"Distance (fast)","Thinning (slow)"}
#@gimp : Smoothness = float(0,0,10)
#@gimp : Curviness = float(0,0,10)
#@gimp : Multiple channels = bool(1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>04/07/2011</i>.</small>")
gimp_skeleton :
  -remove_opacity
  -if {!$4} -norm -endif
  -b $2%
  -if $1 -thinning -else -skeleton $3% -endif
  -* 255

gimp_skeleton_preview :
  -gimp_split_preview "-gimp_skeleton ${^0}",$-1

#@gimp Thin edges : gimp_thin_edges, gimp_thin_edges_preview(0)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Threshold = float(15,0,50)
#@gimp : Negative colors = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_thin_edges :
  -b $1% -gradient_norm ->= $2% -thinning
  -if {!$3} -negative -endif
  -n 0,255

gimp_thin_edges_preview :
  -gimp_split_preview "-gimp_thin_edges ${^0}",$-1


#@gimp _<b>Deformations</b>
#--------------------------

#@gimp Cartesian transform : gimp_custom_deformation, gimp_custom_deformation(1)
#@gimp : X-warping = text{"(w+h)/20 * cos(y*20/h)"}
#@gimp : Y-warping = text{"(w+h)/20 * sin(x*20/w)"}
#@gimp : Relative warping = bool(1)
#@gimp : Interpolation = choice(1,"Nearest neighbor","Linear")
#@gimp : Boundary = choice(1,"Black","Nearest","Repeat")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_custom_deformation :
   -repeat @#
    --norm[-1] [-1] -f[-2] "$1" -f[-1] "$2"
    -a[-2,-1] c -warp[-2] [-1],$3,$4,$5,1 -rm[-1]
  -mv[-1] 0 -done

#@gimp Circle transform : gimp_circle_transform, gimp_circle_transform_preview(1)
#@gimp : X-center (%) = float(50,0,100)
#@gimp : Y-center (%) = float(50,0,100)
#@gimp : X-scale = float(-2,-16,16)
#@gimp : Y-scale = float(-2,-16,16)
#@gimp : Radius = float(0.2,0,1)
#@gimp : Symmetry = choice("None","Inside","Outside")
#@gimp : Interpolation = choice(1,"Nearest neighbor","Linear")
#@gimp : Boundary = choice(1,"Transparent","Nearest","Repeat")
#@gimp : Preview reference circle = bool(1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>01/08/2013</i>.</small>")
gimp_circle_transform :
  -repeat @# -l[$>] -to_rgba
    r={$5*sqrt(w^2+h^2)}
    -if {$6==0} cond="i(X,Y,z,c,$7,$8)"
    -elif {$6==1} cond="if(N<"$r",i(X,Y,z,c,$7,$8),i)"
    -else cond="if(N>"$r",i(X,Y,z,c,$7,$8),i)"
    -endif
    -f 'U=x-w*$1%;V=y-h*$2%;N=sqrt(U*U+V*V);Nr=N-$r;X=x+$3*Nr*U/N;Y=y+$4*Nr*V/N;$cond'
  -endl -done

gimp_circle_transform_preview :
  -gimp_circle_transform $*
  -repeat @# -l[$>]
    x0={$1%*w}
    y0={$2%*h}
    r={$5*sqrt(w^2+h^2)}
    -if $9
      -circle $x0,$y0,{$r-1},1,0xFFFFFFFF,0,0,0,255
      -circle $x0,$y0,{$r+1},1,0xFFFFFFFF,0,0,0,255
      -circle $x0,$y0,$r,1,0xFFFFFFFF,0,255,0,255
    -endif
  -endl -done

#@gimp Euclidean - polar : gimp_euclidean2polar, gimp_euclidean2polar(1)
#@gimp : X-center (%) = float(50,0,100)
#@gimp : Y-center (%) = float(50,0,100)
#@gimp : Dilation = float(1,0.1,10)
#@gimp : Boundary = choice(1,"Black","Nearest","Repeat")
#@gimp : Inverse transform = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_euclidean2polar :
  -if $5 -polar2euclidean $1%,$2%,$3,$4 -else -euclidean2polar $1%,$2%,$3,$4 -endif

#@gimp Fish-eye : fisheye, fisheye(1)
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)
#@gimp : Radius = float(70,0,100)
#@gimp : Amplitude = float(1,0,2)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")

#@gimp Flower : gimp_flower, gimp_flower(1)
#@gimp : Amplitude = float(30,-100,100)
#@gimp : Petals = int(6,2,20)
#@gimp : Offset = float(0,0,100)
#@gimp : Angle = float(0,0,360)
#@gimp : X-center (%) = float(50,0,100)
#@gimp : Y-center (%) = float(50,0,100)
#@gimp : Boundary = choice(1,"Black","Nearest","Repeat")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_flower :
  -flower $1,$2,$3%,$4,$5%,$6%,$7

#@gimp Kaleidoscope [blended] : gimp_rotoidoscope, gimp_rotoidoscope(1)
#@gimp : X-center (%) = float(50,0,100)
#@gimp : Y-center (%) = float(50,0,100)
#@gimp : Angular tiles = int(10,1,72)
#@gimp : Smoothness = float(0.5,0,5)
#@gimp : Boundary = choice(2,"Black","Nearest","Repeat")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_rotoidoscope :
  -rotoidoscope $1%,$2%,$3,$4%,$5

#@gimp Kaleidoscope [polar] : gimp_kaleidoscope, gimp_kaleidoscope(1)
#@gimp : X-center (%) = float(50,0,100)
#@gimp : Y-center (%) = float(50,0,100)
#@gimp : X-offset (%) = float(0,0,100)
#@gimp : Y-offset (%) = float(0,0,100)
#@gimp : Radius cut = float(100,0,100)
#@gimp : Angle cut = float(10,0,100)
#@gimp : Boundary = choice(2,"Black","Nearest","Repeat")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_kaleidoscope :
  -shift $3%,$4%,0,0,2 -kaleidoscope $1%,$2%,$5,$6,$7

#@gimp Kaleidoscope [symmetry] : gimp_symmetrizoscope, gimp_symmetrizoscope(1)
#@gimp : Iterations = int(4,1,32)
#@gimp : Angle = float(0,0,360)
#@gimp : Boundary = choice(1,"Transparent","Nearest","Repeat")
#@gimp : Symmetry sides = choice("Backward","Forward","Swap")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>01/07/2013</i>.</small>")
gimp_symmetrizoscope :
  -to_rgba -repeat $1
    ang={$2+180*$>/max(1,$1-1)}
    -symmetrize 50%,50%,$ang,$3,0,{if($4!=2,$4,$>%2)}
  -done

#@gimp Perspective : gimp_warp_perspective, gimp_warp_perspective(1)
#@gimp : X-angle = float(1.73,-4,4)
#@gimp : Y-angle = float(0,-4,4)
#@gimp : Zoom = float(1,0.1,4)
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)
#@gimp : X-offset = float(0,0,100)
#@gimp : Y-offset = float(0,0,100)
#@gimp : Boundary = choice(2,"Black","Nearest","Repeat")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_warp_perspective :
  -shift $6%,$7%,0,0,2 -warp_perspective $1,$2,$3,$4,$5,$8

#@gimp Polar transform : gimp_transform_polar, gimp_transform_polar(1)
#@gimp : Preset = choice("Custom transform","Inverse radius","Swap radius/angle")
#@gimp : X-center (%) = float(50,0,100)
#@gimp : Y-center (%) = float(50,0,100)
#@gimp : Radius = text{"r + R/10*cos(a*5)"}
#@gimp : Angle = text{"a"}
#@gimp : Boundary = choice(1,"Black","Nearest","Repeat")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_transform_polar :
  -if {$1==0}
    -transform_polar "$4","$5",$2%,$3%,$6
  -elif {$1==1}
    -transform_polar R-r,a,$2%,$3%,$6
  -else
    -transform_polar a*R/(2*pi),r*2*pi/R,$2%,$3%,$6
  -endif

#@gimp Raindrops : raindrops, raindrops(0)
#@gimp : Amplitude = float(80,0,300)
#@gimp : Density = float(0.1,0,1)
#@gimp : Wavelength = float(1,0,2)
#@gimp : Merging steps = int(0,0,20)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>11/28/2012</i>.</small>")

#@gimp Random : deform, deform(0)
#@gimp : Amplitude = float(10,0,100)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")

#@gimp Ripple : ripple, ripple(0)
#@gimp : Amplitude = float(10,0,100)
#@gimp : Bandwidth = float(20,1,300)
#@gimp : Shape = choice(2,"Bloc","Triangle","Sine","Sine+","Random")
#@gimp : Angle = float(0,0,360)
#@gimp : Offset = float(0,0,500)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>08/23/2011</i>.</small>")

#@gimp Reflection : gimp_reflect, gimp_reflect(1)
#@gimp : Height = float(50,0,100)
#@gimp : Attenuation = float(1,0.1,4)
#@gimp : Color = color(110,160,190,64)
#@gimp : Waves amplitude = float(0,0,100)
#@gimp : Waves smoothness = float(1.5,0,4)
#@gimp : X-angle = float(0,-10,10)
#@gimp : Y-angle = float(-3.30,-10,10)
#@gimp : Focale = float(7,0,10)
#@gimp : Zoom = float(1.5,1,5)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_reflect :
  -repeat @#
    -to_rgba[-1] --rows[-1] {100-$1}%,100% -mirror[-1] y -water[-1] $7,$8
    -s[-1] c
    -f[-4] "(i*(255-$6) + $6*$3)/255"
    -f[-3] "(i*(255-$6) + $6*$4)/255"
    -f[-2] "(i*(255-$6) + $6*$5)/255" -a[-4--1] c
    -*[-1] '(h^$2-y^$2)/h^$2' -a[-2,-1] y
    100%,100%,100%,1,$11*$12*(x/w-0.5)
    100%,100%,100%,1,$11*$12*(y/h-0.5)
    100%,100%,100%,1,"$10*(x/w-0.5) + $9*(y/h-0.5) + $11"
    -/[-3] [-1] -+[-3] 0.5 -*[-3] @{-3,w}
    -/[-2,-1] -+[-1] 0.5 -*[-1] {h}
    -a[-2,-1] c -warp[-2] [-1],0,1,0 -rm[-1]
  -mv[-1] 0 -done
  -autocrop 0,0,0,0

#@gimp Seamcarve : gimp_seamcarve, gimp_seamcarve_preview(1)
#@gimp : Width (%) = float(85,0,200)
#@gimp : Height (%) = float(100,0,200)
#@gimp : Maximal seams per iteration (%) = float(15,0,100)
#@gimp : Use top layer as a priority mask = bool(0)
#@gimp : Antialiasing = bool(1)
#@gimp : sep = separator()
#@gimp : note = note{"<small><b>Note:</b>
#@gimp : You can define a transparent top layer that will help the seam-carving algorithm to preserve or force removing image structures:\n
#@gimp : \n  - Draw areas in <i>red</i> to force removing them.
#@gimp : \n  - Draw areas in <i>green</i> to preserve them.
#@gimp : \n  - Don't forget also to set the <i>Input layers...</i> parameter to input both layers to the filter.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Authors: <i>Garagecoder</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>06/02/2014</i>.</small>")
gimp_seamcarve :
  -if $4
    -if {@#<2} -error "Priority mask (top layer) is missing!" -endif
    -_gimp_seamcarve
  -endif
  -seamcarve $1%,$2%,$4,$5,$3%
  -if $4 -repeat @# -channels[$>] 0,@{$>,s-2} -done -endif
  -c 0,255

gimp_seamcarve_preview :
  -if $4
    -if {@#<2} -to_rgb -text_outline "Priority mask (top layer) is missing!",5,5,18,2 -return -endif
    -_gimp_seamcarve
  -endif
  -repeat @# -l[$>]
    w={w} h={h}
    -seamcarve $1%,$2%,$4,$5,{max($3,10)}%
    -if $4 -channels 0,{s-2} -endif
    -to_rgba -r $w,$h,1,100%,0,0,0.5,0.5
  -endl -done
  -c 0,255

_gimp_seamcarve :
  -mv[0] @#
  -l[-1]
    -s c -k[0,1]
    ->[1] [0] -!=[0] 0 --[0] [1] -*[0] -1 -+ -* 256
  -endl
  -repeat {@#-1} -a[$>] [-1],c -done -rm[-1]

#@gimp Sphere : gimp_map_sphere, gimp_map_sphere_preview(1)
#@gimp : Width = _int(512,1,4096)
#@gimp : Height = _int(512,1,4096)
#@gimp : Radius = float(90,0,400)
#@gimp : Dilation = float(0.5,0,1)
#@gimp : Angle = float(0,-50,50)
#@gimp : Border smoothness = float(0,0,200)
#@gimp : Border width = float(20,0,100)
#@gimp : Orientation = choice("0 deg.","90 deg.","180 deg.","270 deg.")
#@gimp : Background = choice("Transparent","Mean color")
#@gimp : Fading = float(0,0,100)
#@gimp : Fading shape = float(0.5,0,3)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>11/07/2011</i>.</small>")
gimp_map_sphere :
  -rotate {$8*90}
  -if $6
    -repeat @#
      -shift[-1] 50%,0,0,0,2 --columns[-1] {(1-$7/100)*w/2},{(1+$7/100)*w/2}
      100% -gaussian[-1] {0.1*w},{h},0 100% 100% -a[-3--1] c -r[-1] [-2],[-2],1,3
      -smooth[-2] [-1],$6,5,0 -rm[-1]
      -j[-2] [-1],{(1-$7/100)*@{-2,w}/2} -rm[-1] -shift[-1] -50%,0,0,0,2
    -mv[-1] 0 -done
  -endif
  -shift $5%,0,0,0,2 -to_rgba
  -if $9
    -repeat @#
      --rows[$>] 0 -r[-1] 1,1,1,4,2 RGBA$>=@-1
      -r[-1] [$>],[$>],1,4 --[$>,-1]
    -done
  -endif
  -map_sphere $1,$2,$3,$4,$10,$11
  -if $9
    -repeat @#
      (${RGBA$>}) -y[-1] c -r[-1] [$>],[$>],1,4 -+[$>,-1]
    -done
  -endif

gimp_map_sphere_preview :
  -gimp_map_sphere {w},{h},${3--1}

#@gimp Symmetrize : gimp_symmetrize, gimp_symmetrize_preview(1)
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)
#@gimp : Angle = float(90,0,360)
#@gimp : Boundary = choice(1,"Transparent","Nearest","Repeat")
#@gimp : Type = choice("Symmetry","Antisymmetry")
#@gimp : Swap sides = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>01/07/2013</i>.</small>")
gimp_symmetrize :
  -to_rgba -symmetrize $1%,$2%,$3,$4,$5,$6

gimp_symmetrize_preview :
  -gimp_symmetrize $*
  theta={$3*pi/180} u={cos($theta)} v={sin($theta)}
  -repeat @# -l[$>]
    x0={w*$1%}
    y0={h*$2%}
    x1={$x0-max(w,h)*$u} y1={$y0-max(w,h)*$v}
    x2={$x0+max(w,h)*$u} y2={$y0+max(w,h)*$v}
    -line $x1,$y1,$x2,$y2,1,0x0F0F0F0F,0
    -line $x1,$y1,$x2,$y2,1,0xF0F0F0F0,255
    -circle $x0,$y0,3,1,0,255,0,255
    -circle $x0,$y0,3,1,0xFFFFFFFF,0,0,0,255
  -endl -done

#@gimp Textured glass : gimp_textured_glass, gimp_textured_glass_preview(0)
#@gimp : X-amplitude = float(40,0,400)
#@gimp : Y-amplitude = float(40,0,400)
#@gimp : X-smoothness = float(1,0,5)
#@gimp : Y-smoothness = float(1,0,5)
#@gimp : Edge attenuation = float(0,0,1)
#@gimp : Edge influence = float(2,0,10)
#@gimp : Noise scale = int(0,0,16)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>11/21/2013</i>.</small>")
gimp_textured_glass :
  -repeat @# -l[$>]
    100%,100%,1,1
    -if $7 -plasma[-1] 1,1,$7 -else -rand[-1] 0,1 -endif
    -g[-1] xy
    -if $5
      --gradient_norm[-3] -+[-1] 1 -b[-1] $6 -^[-1] -$5
      -*[-3] [-1] -*[-2,-1]
    -endif
    -blur_xy[-2,-1] $3,$4
    -*[-2] @{-2,$1/max(abs(im),abs(iM))}
    -*[-1] @{-1,$2/max(abs(im),abs(iM))}
    -a[-2,-1] c
    -warp[-2] [-1],1,1 -rm[-1]
  -endl -done

gimp_textured_glass_preview :
  -gimp_split_preview "-gimp_textured_glass $*",$-1

#@gimp Twirl : gimp_twirl, gimp_twirl(1)
#@gimp : Amplitude = float(1,-5,5)
#@gimp : X-center (%) = float(50,0,100)
#@gimp : Y-center (%) = float(50,0,100)
#@gimp : Boundary = choice(1,"Black","Nearest","Repeat")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_twirl :
  -twirl $1,$2%,$3%,$4

#@gimp Water : water, water(0)
#@gimp : Amplitude = float(30,0,300)
#@gimp : Smoothness = float(1.5,0,4)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")

#@gimp Wave : wave, wave(1)
#@gimp : Amplitude = float(10,0,30)
#@gimp : Frequency = float(0.4,0,2)
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")

#@gimp Wind : gimp_wind, gimp_wind_preview(0)
#@gimp : Amplitude = int(20,0,500)
#@gimp : Angle = float(0,0,360)
#@gimp : Attenuation = float(0.7,0,1)
#@gimp : Threshold = float(20,0,100)
#@gimp : Mode = choice(1,"Darker","Brighter")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>07/13/2011</i>.</small>")
gimp_wind :
  -if {!$5} -negative -endif
  -apply_channels "-wind ${1-4}",$-2
  -if {!$5} -negative -endif

gimp_wind_preview :
  -gimp_split_preview "-gimp_wind $*",$-1

#@gimp Zoom : gimp_zoom, gimp_zoom(1)
#@gimp : Factor = float(2,0.01,10)
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)
#@gimp : Boundary = choice(0,"Black","Nearest","Repeat")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_zoom :
  -if {$1<1} -to_rgba -endif
  -zoom $1,{$2%},{$3%},0,$4


#@gimp _<b>Degradations</b>
#---------------------------

#@gimp Blur [angular] : gimp_blur_angular, gimp_blur_angular_preview(1)
#@gimp : Amplitude = float(2,0,10)
#@gimp : X-center (%) = float(50,0,100)
#@gimp : Y-center (%) = float(50,0,100)
#@gimp : Sharpness = float(0,0,500)
#@gimp : Preview guides = bool(1)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : Value range = choice("Cut","Normalize")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>01/16/2015</i>.</small>")
gimp_blur_angular :
  -apply_channels "-blur_angular $1%,$2%,$3% -sharpen $4",$6,$7

gimp_blur_angular_preview :
  -gimp_blur_angular $*
  -if $5
    -line 0,$3%,100%,$3%,0.5,0xF0F0F0F0,255 -line 0,$3%,100%,$3%,0.5,0x0F0F0F0F,0
    -line $2%,0,$2%,100%,0.5,0xF0F0F0F0,255 -line $2%,0,$2%,100%,0.5,0x0F0F0F0F,0
    -circle $2%,$3%,5,0.7,0 -circle $2%,$3%,3,0.7,0,255,0
  -endif

#@gimp Blur [depth-of-field] : gimp_blur_dof, gimp_blur_dof_preview(1)
#@gimp : Blur amplitude = float(3,0,20)
#@gimp : Blur precision = int(16,2,64)
#@gimp : Depth-of-field type = choice{"Gaussian","User-defined (bottom layer)"}
#@gimp : Invert blur = bool(0)
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Gaussian depth-of-field:</b></small>")
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)
#@gimp : First radius = float(30,0,200)
#@gimp : Second radius = float(30,0,200)
#@gimp : Angle = float(0,0,180)
#@gimp : Sharpness = float(1,0,8)
#@gimp : Preview guides = bool(1)
#@gimp : sep = separator()
#@gimp : note = note("<small><b>User-defined depth-of-field:</b></small>")
#@gimp : Gamma = float(0,-2,2)
#@gimp : note = note("<small>You can specify your own depth-of-field image, as a <b>bottom layer</b> image whose luminance encodes the depth for each pixel.
#@gimp : Don't forget to modify the <b>Input layers</b> combo-box to make this layer active for the filter.</small>")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>02/25/2014</i>.</small>")
gimp_blur_dof :
  -_$0 ${1-10},0,$12

gimp_blur_dof_preview :
  -_gimp_blur_dof $*

_gimp_blur_dof :
  -if {!$3}  # Gaussian DOF.
    -repeat @# -l[$>] -if $11 -drgba -endif -split_opacity -l[0]
      rmax={(w*w+h*h)^0.5} R={$7*$rmax/100} r={$8*$rmax/100}
      t={$9*pi/180} u={cos($t)} v={sin($t)}
      l1={($rmax/(1e-8+$R))^2} l2={($rmax/(1e-8+$r))^2}
      a={$l1*($u)^2+$l2*($v)^2} b={$u*$v*($l1-$l2)} c={$l1*($v)^2+$l2*($u)^2}
      100%,100%,1,1,'X=(x-$5*w/100)/max(w,h);Y=(y-$6*h/100)/max(w,h);f=$a*X*X+2*$b*X*Y+$c*Y*Y;exp(-f^$10/2.5)'
      --[1] 1 -*[1] -$1 ms={im} Ms={iM}

      -if $11 # With preview of guides.
        --isoline3d[1] {0.1*$1} -col3d[-1] 255,255,0
        --isoline3d[1] {0.5*$1} -col3d[-1] 255,128,0
        -+3d[-2--1]
        -__gimp_dof_blur[0,1] $2,$ms,$Ms,$4
        [0],[0],1,3 -j3d[-1] [-2],0,0,0,1,1,0,0 -rm[-2]
        -circle[-1] $5%,$6%,3,1,255,255,255
        --compose_channels[-1] + -!=[-1] 0 -dilate[-1] 3
        -j[0] [-2],0,0,0,0,0.5,[-1],1 -rm[-2,-1]
      -else -__gimp_dof_blur[0,1] $2,$ms,$Ms,$4 # Without preview.
      -endif
    -endl -if $11 -k[0] -endif -a c -endl -done
  -elif {@#>1} # User-defined DOF (as bottom layer).
    -luminance[-1] -n[-1] 0,1 -^[-1] {10^$12}
    -repeat {@#-1} --r[-1] @{$>,w},@{$>,h},1,1,3 -l[$>,-1] -split_opacity[0]
      -__gimp_dof_blur[0,-1] $2,0,$1,$4
    -a c -endl -done -rm[-1]
  -else -drgba -text_outline "Depth-of-field (bottom layer) is missing !",2,2,13,2,1,255
  -endif

# Render DOF blur (generic)
# [0] = Input image
# [1] = continuous DOF field (with same size as [0]).
# $1 = nb quantization levels.
# $2 = minimal blur level.
# $3 = maximal blur level.
# $4 = invert blur.
__gimp_dof_blur :
  -n[1] 0,{$1-1} -round[1]
  [0],[0],1,@{0,s+1}
  s=0
  -repeat $1
    --==[1] {if($4,$<,$>)} -b[-1] 2%
    -j[-2] [0],0,0,0,0,-1,[-1],1
    -j[-2] [-1],0,0,0,100%,-1
    -rm[-1]
     ns={$2+($3-$2)*($>+1)/($1-1)}
     -b[0] {sqrt($ns^2-$s^2)}%
     s=$ns
  -done
  -s[-1] c,{-s+1} -/[-2,-1] -rm[0,1]

#@gimp Blur [gaussian] : gimp_gaussian_blur, gimp_gaussian_blur_preview(0)
#@gimp : XY-amplitude = float(3,0,20)
#@gimp : X-amplitude = float(0,0,20)
#@gimp : Y-amplitude = float(0,0,20)
#@gimp : Border conditions = choice(1,"Black","Nearest")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : Value range = choice("Cut","Normalize")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
_gimp_gaussian_blur :
  -b $1,$4
  -if {$2>0} -repeat @# -l[-1] -s y -b $2,$4 -a y -endl -mv[-1] 0 -done -endif
  -if {$3>0} -repeat @# -l[-1] -s x -b $3,$4 -a x -endl -mv[-1] 0 -done -endif

gimp_gaussian_blur :
  -apply_channels "-_gimp_gaussian_blur $1,$2,$3,$4",$5,$6

gimp_gaussian_blur_preview :
  -gimp_split_preview "-gimp_gaussian_blur $*",$-1

#@gimp Blur [glow] : gimp_glow, gimp_glow_preview(0)
#@gimp : Amplitude = float(6,0,20)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_glow :
  -apply_channels "-glow $1",$2,0

gimp_glow_preview :
  -gimp_split_preview "-gimp_glow $*",$-1

#@gimp Blur [linear] : gimp_blur_linear, gimp_blur_linear_preview(1)
#@gimp : Tangent radius = float(10,0,100)
#@gimp : Orthogonal radius = float(0.5,0,100)
#@gimp : Angle = float(0,0,180)
#@gimp : Sharpness = float(0,0,500)
#@gimp : Border conditions = choice(1,"Black","Nearest")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : Value range = choice("Cut","Normalize")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_blur_linear :
  -apply_channels "-blur_linear $1,{$2*$1/100},$3,$5 -sharpen $4",$6,$7

gimp_blur_linear_preview :
  -gimp_split_preview "-gimp_blur_linear $*",$-1

#@gimp Blur [radial] : gimp_blur_radial, gimp_blur_radial_preview(1)
#@gimp : Amplitude = float(3,0,20)
#@gimp : X-center (%) = float(50,0,100)
#@gimp : Y-center (%) = float(50,0,100)
#@gimp : Sharpness = float(0,0,500)
#@gimp : Preview guides = bool(1)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : Value range = choice("Cut","Normalize")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>01/16/2015</i>.</small>")
gimp_blur_radial :
  -apply_channels "-blur_radial $1%,$2%,$3% -sharpen $4",$6,$7

gimp_blur_radial_preview :
  -gimp_blur_radial $*
  -if $5
    -line 0,$3%,100%,$3%,0.5,0xF0F0F0F0,255 -line 0,$3%,100%,$3%,0.5,0x0F0F0F0F,0
    -line $2%,0,$2%,100%,0.5,0xF0F0F0F0,255 -line $2%,0,$2%,100%,0.5,0x0F0F0F0F,0
    -circle $2%,$3%,5,0.7,0 -circle $2%,$3%,3,0.7,0,255,0
  -endif

#@gimp Dirty : gimp_dirty, gimp_dirty_preview(0)
#@gimp : Amplitude = float(30,0,100)
#@gimp : Monochrome = bool(1)
#@gimp : Channel(s) = choice(2,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>11/24/2014</i>.</small>")
gimp_dirty :
  -apply_channels "-_gimp_dirty ${1-2}",$3,0

gimp_dirty_preview :
  -gimp_split_preview "-gimp_dirty ${1--2}",$-1

_gimp_dirty :
  -repeat @# -l[$>]
    -dct 100%,100%,1,{if($2,1,s)} -noise[-1] $1,2
    -==[-1] 0 -point[-1] 0,0,0,1,1
    -* -idct -c 0,255
  -endl -done

#@gimp Lomo : gimp_lomo, gimp_lomo_preview(1)
#@gimp : Vignette size = float(20,0,100)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>J&#233;rome Boulanger</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>06/06/2012</i>.</small>")
gimp_lomo :
  -remove_opacity -repeat @# -l[$>] -to_rgb
    --gaussian {100-$1}%,{100-$1}% -normalize[-1] 0,1 -*
    -s c
    -f[0] '255*atan((i-128)/128)'
    -f[1] '255*tan((i-128)/128)'
    -f[2] '255*atan((i-128)/255)'
    -a c
    -sharpen 1
    -normalize 0,255
  -endl -done

gimp_lomo_preview :
  -gimp_split_preview "-gimp_lomo $*",$-1

#@gimp Noise [additive] : gimp_noise, gimp_noise_preview(0)
#@gimp : Amplitude = float(10,0,200)
#@gimp : Noise type = choice("Gaussian","Uniform","Salt and pepper","Poisson")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : Value range = choice("Cut","Normalize")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_noise :
  -apply_channels "-noise $1,$2",$3,$4

gimp_noise_preview :
  -gimp_split_preview "-gimp_noise $*",$-1

#@gimp Noise [spread] : gimp_spread, gimp_spread_preview(0)
#@gimp : X-variations = float(4,0,20)
#@gimp : Y-variations = float(4,0,20)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_spread :
  -apply_channels "-spread $1,$2",$3,0

gimp_spread_preview :
  -gimp_split_preview "-gimp_spread $*",$-1

#@gimp Old-movie stripes : gimp_stripes_y, gimp_stripes_y_preview(1)
#@gimp : Frequency = float(10,0,100)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_stripes_y :
  -apply_channels "-stripes_y $1",$2,0

gimp_stripes_y_preview :
  -gimp_split_preview "-gimp_stripes_y $*",$-1

#@gimp Oldschool 8bits : gimp_8bits, gimp_8bits_preview(0)
#@gimp : Scale = float(25,1,100)
#@gimp : Dithering = float(800,0,10000)
#@gimp : Levels = int(16,2,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>11/02/2011</i>.</small>")
gimp_8bits :
  -remove_opacity -repeat @# -l[$>]
    w={w} h={h}
    -r $1%,$1%,1,100%,2
    --luminance -sharpen[-1] $2 -otsu[-1] 256 -blend[-2,-1] shapeaverage0
    -l[-1] -s c -quantize $3,1,1 -a c -endl
    -r[-1] $w,$h,1,100%,1
  -endl -done

gimp_8bits_preview :
  -gimp_split_preview "-gimp_8bits $*",$-1

#@gimp Random shade stripes : gimp_shade_stripes, gimp_shade_stripes_preview(1)
#@gimp : Frequency = float(30,1,100)
#@gimp : Orientation = choice(1,"Horizontal","Vertical")
#@gimp : Darkness = float(0.8,0,3)
#@gimp : Lightness = float(1.3,0,3)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_shade_stripes :
  -apply_channels "-shade_stripes $1,$2,$3,$4",$5,0

gimp_shade_stripes_preview :
  -gimp_split_preview "-gimp_shade_stripes $*",$-1

#@gimp Scanlines : gimp_scanlines, gimp_scanlines_preview(0)
#@gimp : Amplitude = float(60,0,255)
#@gimp : Bandwidth = float(2,1,300)
#@gimp : Shape = choice(0,"Bloc","Triangle","Sine","Sine+","Random")
#@gimp : Angle = float(0,0,360)
#@gimp : Offset = float(0,0,500)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>11/19/2014</i>.</small>")
gimp_scanlines :
  -apply_channels "-scanlines ${1-5}",$6

gimp_scanlines_preview :
  -gimp_split_preview "-gimp_scanlines $*",$-1

#@gimp Visible watermark : gimp_watermark_visible, gimp_watermark_visible(0)
#@gimp : Text = text{"\251 G'MIC"}
#@gimp : Opacity = float(0.4,0.1,0.9)
#@gimp : Size = int(50,13,128)
#@gimp : Angle = float(25,0,360)
#@gimp : Smoothness = float(0.5,0,5)
#@gimp : Lightness = choice(1,"Darker","Brighter")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_watermark_visible :
  -watermark_visible "$1",$2,$3,$4,$6,$5

#@gimp _<b>Details</b>
#----------------------

#@gimp Details equalizer : gimp_equalize_details, gimp_equalize_details_preview(0)
#@gimp : note = note("<small><b>Coarse scale:</b></small>")
#@gimp : Threshold = float(0,0,10)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Smoothness type = choice(2,"Gaussian","Bilateral","Diffusion")
#@gimp : Gain = float(0,-4,4)
#@gimp : sep = separator(), note = note("<small><b>Medium scale:</b></small>")
#@gimp : Threshold = float(0,0,10)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Smoothness type = choice(2,"Gaussian","Bilateral","Diffusion")
#@gimp : Gain = float(0,-4,4)
#@gimp : sep = separator(), note = note("<small><b>Small scale:</b></small>")
#@gimp : Threshold = float(0,0,10)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Smoothness type = choice(2,"Gaussian","Bilateral","Diffusion")
#@gimp : Gain = float(0,-4,4)
#@gimp : sep = separator(), note = note("<small><b>Fine scale:</b></small>")
#@gimp : Threshold = float(0,0,10)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Smoothness type = choice(2,"Gaussian","Bilateral","Diffusion")
#@gimp : Gain = float(0,-4,4)
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(32,0,256)
#@gimp : sep = separator(), Channel(s) = choice(0,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>J&#233;rome Boulanger</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>12/15/2013</i>.</small>")
_gimp_equalize_details :
  -repeat @# -l[$>]
    -split_details 5,5%,0.5%
    -__gimp_equalize_details[1] ${1-4},8
    -__gimp_equalize_details[2] ${5-8},4
    -__gimp_equalize_details[3] ${9-12},2
    -__gimp_equalize_details[4] ${13-16},1
    -+ -c 0,255
  -endl -done

__gimp_equalize_details :
  -threshold $1,1
  -if {$3==0} -b {$2*$5/2}
  -elif {$3==1}
    -if {$2>0}
      m={im} M={iM} -n[-1] 0,255
      -repeat {int($2/5)} -bilateral 15,{5*$5} -done
      -bilateral 15,{($2%5)*$5}
      -*[-1] {($M-$m)/255} -+[-1] $m
    -endif
  -else -smooth {$2*50},0.2,0.8,$5,$5 -endif
  -* {10^$4}

gimp_equalize_details :
  -apply_channels "-gimp_parallel_overlap \"-_gimp_equalize_details ${1-16}\",$17,$18",$19,0

gimp_equalize_details_preview :
  -gimp_split_preview "-gimp_equalize_details $*",$-1

#@gimp Freaky details : gimp_freaky_details, gimp_freaky_details_preview(0)
#@gimp : Amplitude = int(2,1,5)
#@gimp : Scale = float(10,0,100)
#@gimp : Iterations = int(1,1,4)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(32,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i> and <i>Patrick David</i>.      Latest update: <i>02/27/2013</i>.</small>")
#@gimp : sep = separator(), note = note("This effect has been done following:")
#@gimp : link = link("This tutorial from Patrick David","http://blog.patdavid.net/2013/02/calvin-hollywood-freaky-details-in-gimp.html")
_gimp_freaky_details :
  -repeat @# -l[$>]
    -repeat $3
      [-1] ---[-1] 255 -*[-1] -1
      -repeat $1 -bilateral[-1] $2,{1.5*$2} -done
      -blend[-2,-1] vividlight -blend overlay
    -done
  -endl -done

gimp_freaky_details :
  -apply_channels "-gimp_parallel_overlap \"-_gimp_freaky_details ${1-3}\",$5,$6",$4,0
  -n 0,255

gimp_freaky_details_preview :
  -gimp_split_preview "-gimp_freaky_details $*",$-1

#@gimp Local normalization : gimp_normalize_local, gimp_normalize_local_preview(0)
#@gimp : Amplitude = float(2,0,60)
#@gimp : Radius = int(6,1,64)
#@gimp : Neighborhood smoothness = float(5,0,40)
#@gimp : Average smoothness = float(20,0,40)
#@gimp : Constrain values = bool(1)
#@gimp : sep = separator()
#@gimp : Channel(s) = choice(3,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_normalize_local :
  -repeat @# -l[$>]
    -apply_channels "-normalize_local $1,$2,$3,$4,$5,0,255",$6,0
  -endl -done

gimp_normalize_local_preview :
  -gimp_split_preview "-gimp_normalize_local $*",$-1

#@gimp Mighty details : gimp_mighty_details, gimp_mighty_details_preview(0)
#@gimp : Amplitude = float(25,0,100)
#@gimp : Details amount = float(1,0,2)
#@gimp : Details scale = float(25,1,100)
#@gimp : Details smoothness = int(1,0,10)
#@gimp : sep = separator()
#@gimp : Channel(s) = choice(3,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i>.      Latest update: <i>08/08/2014</i>.</small>")
_gimp_mighty_details :
  --smooth $3,0,1,0.5,0.5 --[1] [0]
  --abs[-1] -sign[-2] M={iM} -^[-1] {2-$2} -*[-1] {$M/iM} -*[-2,-1]
  --diffusiontensors[0] 0,1,0.5,0.5
  -repeat $4 -smooth[1] [2],20 -done
  -*[1] {-$1/5} -+

gimp_mighty_details :
  -apply_channels "-_gimp_mighty_details ${1-4}",$5
  -n 0,255

gimp_mighty_details_preview :
  -gimp_split_preview "-gimp_mighty_details $*",$-1

#@gimp Sharpen [deblur] : gimp_deblur, gimp_deblur_preview(0)
#@gimp : Radius = float(2,0,20)
#@gimp : Iterations = int(10,0,100)
#@gimp : Time step = float(20,0,50)
#@gimp : Smoothness = float(0.1,0,10)
#@gimp : Regularization = choice(1,"Tikhonov","Mean curvature","Total variation")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_deblur :
  -apply_channels "-gimp_parallel_overlap \"-deblur ${1-5} -c 0,255\",$7,$8",$6,0

gimp_deblur_preview :
  -gimp_split_preview "-gimp_deblur $*",$-1

#@gimp Sharpen [Gold-Meinel] : gimp_unsharp_goldmeinel, gimp_unsharp_goldmeinel_preview
#@gimp : Sigma = float(1,0.5,10)
#@gimp : Iterations = int(5,1,15)
#@gimp : Acceleration = float(1,1,3)
#@gimp : Blur = choice(1,"Exponential","Gaussian")
#@gimp : Cut = bool(true)
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>.      Latest update: <i>03/29/2013</i>.</small>")
gimp_unsharp_goldmeinel:
  -gimp_parallel_overlap "-_gimp_unsharp_goldmeinel $*",$6,$7

_gimp_unsharp_goldmeinel :
  -deblur_goldmeinel $*
  -if $5 -c 0,255 -else -n 0,255 -endif

gimp_unsharp_goldmeinel_preview:
  -gimp_split_preview "-gimp_unsharp_goldmeinel $*",$-1

#@gimp Sharpen [inverse diffusion] : gimp_sharpen_inversediff, gimp_sharpen_inversediff_preview(0)
#@gimp : Amplitude = float(50,1,300)
#@gimp : Iterations = int(2,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_sharpen_inversediff :
  -apply_channels "-gimp_parallel_overlap \"-repeat $2 -sharpen $1 -c 0,255 -done\",$4,$5",$3,0

gimp_sharpen_inversediff_preview :
  -gimp_split_preview "-gimp_sharpen_inversediff $*",$-1

#@gimp Sharpen [octave sharpening] : gimp_unsharp_octave, gimp_unsharp_octave_preview(0)
#@gimp : Scales = int(4,1,10)
#@gimp : Maximal radius = float(5,0,20)
#@gimp : Amount = float(3,0,10)
#@gimp : Threshold = float(0,0,255)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_unsharp_octave :
  -apply_channels "-gimp_parallel_overlap \"-unsharp_octave $1,$2,$3,$4\",$6,$7",$5,0

gimp_unsharp_octave_preview :
  -gimp_split_preview "-gimp_unsharp_octave $*",$-1

#@gimp Sharpen [Richardson-Lucy] : gimp_unsharp_richardsonlucy, gimp_unsharp_richardsonlucy_preview
#@gimp : Sigma = float(1,0.5,10)
#@gimp : Iterations = int(10,1,100)
#@gimp : Blur = choice(1,"Exponential","Gaussian")
#@gimp : Cut = bool(true)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>.      Latest update: <i>03/29/2013</i>.</small>")
gimp_unsharp_richardsonlucy :
  -deblur_richardsonlucy $*
  -if $4 -c 0,255 -else -n 0,255 -endif

gimp_unsharp_richardsonlucy_preview :
  -gimp_split_preview "-gimp_unsharp_richardsonlucy $*",$-1

#@gimp Sharpen [shock filters] : gimp_sharpen_shock, gimp_sharpen_shock_preview(0)
#@gimp : Amplitude = float(150,1,400)
#@gimp : Edge threshold = float(0.1,0,0.7)
#@gimp : Gradient smoothness = float(0.8,0,10)
#@gimp : Tensor smoothness = float(1.1,0,10)
#@gimp : Iterations = int(1,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_sharpen_shock :
  -apply_channels "-gimp_parallel_overlap \"-repeat $5 -sharpen $1,$2,$3,$4 -c 0,255 -done\",$7,$8",$6,0

gimp_sharpen_shock_preview :
  -gimp_split_preview "-gimp_sharpen_shock $*",$-1

#@gimp Sharpen [unsharp mask] : gimp_unsharp, gimp_unsharp_preview(0)
#@gimp : Sharpening type = choice(0,"Gaussian","Bilateral")
#@gimp : Spatial radius = float(1.25,0,20)
#@gimp : Bilateral radius = float(30,0,60)
#@gimp : Amount = float(3,0,10)
#@gimp : Threshold = float(0,0,20)
#@gimp : Darkness level = float(1,0,4)
#@gimp : Lightness level = float(1,0,4)
#@gimp : Iterations = int(1,1,10)
#@gimp : Negative effect = bool(0)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : note = note{"\n\n<small><b>Note: </b>
#@gimp : This filter is inspired by the original <i>Unsharp Mask</i> filter in GIMP, with additional parameters.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
_gimp_unsharp :
  -repeat @# -repeat $8
    -if {$1==0} --b[-1] $2 -else --bilateral[-1] $2,$3 -endif
    --[-1] [-2] -*[-1] -$4
    --norm[-1] ->=[-1] $5% -r[-1] [-2] -*[-2,-1]
    -if $9 -*[-1] -1 -endif
    --c[-1] 0,100% -c[-2] -100%,0 -*[-2] $6 -*[-1] $7 -+[-2,-1]
    -+[-2,-1] -c[-1] 0,255
  -done -mv[-1] 0 -done

gimp_unsharp :
  -apply_channels "-_gimp_unsharp $1,$2,$3,$4,$5,$6,$7,$8,$9",$10,0

gimp_unsharp_preview :
  -gimp_split_preview "-gimp_unsharp $*",$-1

#@gimp Split details [alpha] : gimp_split_details_alpha, gimp_split_details_alpha_preview(0)
#@gimp : Number of levels = int(6,2,8)
#@gimp : Base scale = float(10,0,30)
#@gimp : Details scale = float(1,0,20)
#@gimp : Opacity gain = float(5,1,20)
#@gimp : sep = separator()
#@gimp : Preview without alpha = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>04/22/2014</i>.</small>")
gimp_split_details_alpha :
  -remove_opacity
  -repeat @# -l[$<]
    -repeat {$1-1}
      s={$3+($2-$3)*$>/if($1-2>0,$1-2,1)}
      --_gimp_split_details_alpha_blur[-1] $s
      -sub_alpha[-2] [-1],$4
    -done
  -endl -done

_gimp_split_details_alpha_blur :
  -if {$1>=0.1} -b[-1] $1
  -else
    -if {$1>=0.05} (1,4,7,4,1;4,16,26,16,4;7,26,41,26,7;4,16,26,16,4;1,4,7,4,1)
    -else (1,2,1;2,4,2;1,2,1) -endif
    -normalize_sum[-1] -convolve[-2] [-1] -rm[-1]
  -endif

gimp_split_details_alpha_preview :
  -repeat @# -l[$>]
    -gimp_split_details_alpha ${1-4}
    -if $5 -remove_opacity[^-1] -else -to_rgba[-1] -endif
    -drgba
    -repeat @# -l[$>] -text_outline "\#"{1+$>},1,1,43,7,1,255 -endl -done
    -frame 1,1,0 -frame 3,3,255 -append_tiles ,
  -endl -done

#@gimp Split details [layers] : gimp_split_details_layers, gimp_split_details_layers_preview(0)
#@gimp : Number of scales = int(6,3,12)
#@gimp : Base scale = float(10,0,40)
#@gimp : Details scale = float(1,0,20)
#@gimp : Sharpen details in preview = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>01/22/2015</i>.</small>")
gimp_split_details_layers :
  -repeat @# -l[$>]
    -split_details $1,$2,$3
    -+[^0] 128 -c[^0] 0,255
    -nm[^0] "mode(grainmerge)"
    -rv
  -endl -done

gimp_split_details_layers_preview :
  -repeat @# -l[$>]
    -gimp_split_details_layers $*
    -if $4 -equalize[^-1] 256 -endif
    -n[^-1] 0,255
    -repeat @# -l[$>] -text_outline "\#"{1+$>},1,1,43,7,1,255 -endl -done
    -frame 1,1,0 -frame 3,3,255 -append_tiles ,
  -endl -done

#@gimp Tone mapping : gimp_map_tones, gimp_map_tones_preview(0)
#@gimp : Threshold = float(0.5,0,1)
#@gimp : Gamma = float(0.7,0,1)
#@gimp : Smoothness = float(0.1,0,10)
#@gimp : Iterations = int(30,0,500)
#@gimp : Channel(s) = choice(3,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_map_tones :
  -apply_channels "-map_tones ${1-4}",$5,0
  -n 0,255

gimp_map_tones_preview :
  -gimp_split_preview "-gimp_map_tones $*",$-1

#@gimp Tone mapping [fast] : gimp_map_tones_fast, gimp_map_tones_fast_preview(0)
#@gimp : Radius = float(3,0,20)
#@gimp : Power = float(0.5,0,1)
#@gimp : Channel(s) = choice(3,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>Paul Nasca</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>06/10/2011</i>.</small>")
gimp_map_tones_fast :
  -apply_channels "-map_tones_fast $1,$2",$3,0

gimp_map_tones_fast_preview :
  -gimp_split_preview "-gimp_map_tones_fast ${^0}",$-1

#@gimp _<b>Film emulation</b>
#----------------------------

#@gimp Add grain : gimp_emulate_grain, gimp_emulate_grain_preview(0)
#@gimp : Preset = choice{"Orwo NP20-GDR","Kodak TMAX 400","Kodak TMAX 3200","Kodak TRI-X 1600","Unknown"}
#@gimp : Blend mode = choice(1,"Alpha","Grain merge","Hard light","Overlay","Soft light","Grain only")
#@gimp : Opacity = float(0.2,0,1)
#@gimp : Scale = float(100,30,200)
#@gimp : Colored grain = bool()
#@gimp : sep = separator()
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Hue = float(0,-180,180)
#@gimp : Saturation = float(0,0,1)
#@gimp : sep = separator()
#@gimp : Preview grain alone = bool()
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>04/10/2014</i>.</small>")
gimp_emulate_grain :
  -__gimp_emulate_grain @{-arg\ {1+$1},@{-_gimp_emulate_grain}},${2-10},0

_gimp_emulate_grain :
  -u grain_orwo_np20,grain_kodak_tmax400,grain_kodak_tmax3200,grain_kodak_trix1600,grain_unknown

gimp_emulate_grain_preview :
  -gimp_split_preview "-_gimp_emulate_grain_preview $*",$-1

_gimp_emulate_grain_preview :
  -__gimp_emulate_grain @{-arg\ {1+$1},@{-_gimp_emulate_grain}},${2-11}

__gimp_emulate_grain :
  bm0=alpha bm1=grainmerge bm2=hardlight bm3=overlay bm4=softlight bm5=alpha
  dir=@{-path_user}
  -if {!@{-is_windows}}
    dir=$dir/.gmic_film_presets
    -if $dir -else -x "mkdir "$dir -endif
  -endif
  -if {narg($_force_redownload)}
    -i http://gmic.eu/data_film_presets/$1.cimgz -o[-1] $dir/gmic_$1.cimgz
  -else
    -if $dir/gmic_$1.cimgz -i $dir/gmic_$1.cimgz
    -else -i http://gmic.eu/data_film_presets/$1.cimgz -o[-1] $dir/gmic_$1.cimgz
    -endif
  -endif

  -repeat {@#-1} -l[$>,-1] -split_opacity[0]
    --syntexturize[-1] @{0,max(10,100*w/$4)},@{0,max(10,100*h/$4)}
    -if $5 --syntexturize[-2] {w},{h} --syntexturize[-3] {w},{h} -a[-3--1] c -endif
    -r[-1] @{0,w},@{0,h},1,100%,5 -c[-1] 0,255
    -apply_gamma[-1] {10^$6}                                # Gamma correction
    --[-1] 128 -*[-1] $7 -+[-1] 128 -+[-1] $8 -c[-1] 0,255  # B&W contrast and brightness.
    -if {$9||$10}
      -to_color[-1] -rgb2hsv[-1]
      -sh[-1] 0,0 -+[-1] $9 -%[-1] 360 -rm[-1]
      -sh[-1] 1,1 -+[-1] $10 -rm[-1]
      -hsv2rgb[-1]
    -endif
    -if $11 -k[0,-1] -rv
    -else -blend[0,-1] ${bm$2},{if($2<=4,$3,1)}
    -endif

  -a[^-1] c -endl -done -rm[-1]

#@gimp B&amp;W films : gimp_emulate_film_bw, gimp_emulate_film_bw_preview(1)
#@gimp : Preset = choice{"None",
#@gimp : "Agfa APX 100","Agfa APX 25","Fuji Neopan 1600","Fuji Neopan Acros 100","Ilford Delta 100","Ilford Delta 3200","Ilford Delta 400","Ilford FP4 Plus 125",
#@gimp : "Ilford HP5 Plus 400","Ilford HPS 800","Ilford Pan F Plus 50","Ilford XP2","Kodak BW 400 CN","Kodak HIE (HS Infra)","Kodak T-Max 100","Kodak T-Max 3200",
#@gimp : "Kodak T-Max 400","Kodak Tri-X 400","Polaroid 664","Polaroid 667","Polaroid 672","Rollei IR 400","Rollei Ortho 25","Rollei Retro 100 Tonal","Rollei Retro 80s"}
#@gimp : sep = separator()
#@gimp : Opacity = float(1,0,1)
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Hue = float(0,-180,180)
#@gimp : Saturation = float(0,-1,1)
#@gimp : Post-normalize = bool(0)
#@gimp : sep = separator()
#@gimp : Pseudo-gray dithering = int(0,0,5)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small><b>Note:</b> The color LUTs used in this section have been designed by <b>Patrick David</b>. More infos at:</small>")
#@gimp : link = link{"Film Emulation Presets in G'MIC","http://gmic.eu/film_emulation/index.shtml"}
#@gimp : sep = separator(), note = note("<small>Authors: <i>Patrick David</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>01/16/2015</i>.</small>")
gimp_emulate_film_bw :
  -_gimp_emulate_film $1,@{-arg\ $1,@{-_$0}},${2--1}
  -if {$1" && "$9} -to_pseudogray $9,1 -endif

_gimp_emulate_film_bw :
  -u agfa_apx_100,agfa_apx_25,fuji_neopan_1600,fuji_neopan_acros_100,ilford_delta_100,ilford_delta_3200,ilford_delta_400,ilford_fp4_plus_125,\
     ilford_hp5_plus_400,ilford_hps_800,ilford_pan_f_plus_50,ilford_xp2,kodak_bw_400_cn,kodak_hie_(hs_infra),kodak_t-max_100,kodak_t-max_3200,\
     kodak_t-max_400,kodak_tri-x_400,polaroid_664,polaroid_667,polaroid_672,rollei_ir_400,rollei_ortho_25,rollei_retro_100_tonal,rollei_retro_80s

gimp_emulate_film_bw_preview :
  -gimp_split_preview "-gimp_emulate_film_bw $*",$-1

#@gimp Instant [consumer] : gimp_emulate_film_instant_consumer, gimp_emulate_film_instant_consumer_preview(1)
#@gimp : Preset = choice{"None",
#@gimp : "Polaroid PX-100UV+ Cold --","Polaroid PX-100UV+ Cold -","Polaroid PX-100UV+ Cold","Polaroid PX-100UV+ Cold +","Polaroid PX-100UV+ Cold ++","Polaroid PX-100UV+ Cold +++",
#@gimp : "Polaroid PX-100UV+ Warm --","Polaroid PX-100UV+ Warm -","Polaroid PX-100UV+ Warm","Polaroid PX-100UV+ Warm +","Polaroid PX-100UV+ Warm ++","Polaroid PX-100UV+ Warm +++",
#@gimp : "Polaroid PX-680 --","Polaroid PX-680 -","Polaroid PX-680","Polaroid PX-680 +","Polaroid PX-680 ++",
#@gimp : "Polaroid PX-680 Cold --","Polaroid PX-680 Cold -","Polaroid PX-680 Cold","Polaroid PX-680 Cold +","Polaroid PX-680 Cold ++","Polaroid PX-680 Cold ++a",
#@gimp : "Polaroid PX-680 Warm --","Polaroid PX-680 Warm -","Polaroid PX-680 Warm","Polaroid PX-680 Warm +","Polaroid PX-680 Warm ++",
#@gimp : "Polaroid PX-70 --","Polaroid PX-70 -","Polaroid PX-70","Polaroid PX-70 +","Polaroid PX-70 ++","Polaroid PX-70 +++",
#@gimp : "Polaroid PX-70 Cold --","Polaroid PX-70 Cold -","Polaroid PX-70 Cold","Polaroid PX-70 Cold +","Polaroid PX-70 Cold ++",
#@gimp : "Polaroid PX-70 Warm --","Polaroid PX-70 Warm -","Polaroid PX-70 Warm","Polaroid PX-70 Warm +","Polaroid PX-70 Warm ++",
#@gimp : "Polaroid Time Zero (Expired) ---","Polaroid Time Zero (Expired) --","Polaroid Time Zero (Expired) -","Polaroid Time Zero (Expired)","Polaroid Time Zero (Expired) +","Polaroid Time Zero (Expired) ++",
#@gimp : "Polaroid Time Zero (Expired) Cold ---","Polaroid Time Zero (Expired) Cold --","Polaroid Time Zero (Expired) Cold -","Polaroid Time Zero (Expired) Cold"}
#@gimp : sep = separator()
#@gimp : Opacity = float(1,0,1)
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Hue = float(0,-180,180)
#@gimp : Saturation = float(0,-1,1)
#@gimp : Post-normalize = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small><b>Note:</b> The color LUTs used in this section have been designed by <b>Patrick David</b>. More infos at:</small>")
#@gimp : link = link{"Film Emulation Presets in G'MIC","http://gmic.eu/film_emulation/index.shtml"}
#@gimp : sep = separator(), note = note("<small>Authors: <i>Patrick David</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>08/29/2013</i>.</small>")
gimp_emulate_film_instant_consumer :
  -_gimp_emulate_film $1,@{-arg\ $1,@{-_$0}},${2--1}

_gimp_emulate_film_instant_consumer :
  -u polaroid_px-100uv+_cold_--,polaroid_px-100uv+_cold_-,polaroid_px-100uv+_cold,polaroid_px-100uv+_cold_+,polaroid_px-100uv+_cold_++,polaroid_px-100uv+_cold_+++,\
     polaroid_px-100uv+_warm_--,polaroid_px-100uv+_warm_-,polaroid_px-100uv+_warm,polaroid_px-100uv+_warm_+,polaroid_px-100uv+_warm_++,polaroid_px-100uv+_warm_+++,\
     polaroid_px-680_--,polaroid_px-680_-,polaroid_px-680,polaroid_px-680_+,polaroid_px-680_++,\
     polaroid_px-680_cold_--,polaroid_px-680_cold_-,polaroid_px-680_cold,polaroid_px-680_cold_+,polaroid_px-680_cold_++,polaroid_px-680_cold_++_alt,\
     polaroid_px-680_warm_--,polaroid_px-680_warm_-,polaroid_px-680_warm,polaroid_px-680_warm_+,polaroid_px-680_warm_++,\
     polaroid_px-70_--,polaroid_px-70_-,polaroid_px-70,polaroid_px-70_+,polaroid_px-70_++,polaroid_px-70_+++,\
     polaroid_px-70_cold_--,polaroid_px-70_cold_-,polaroid_px-70_cold,polaroid_px-70_cold_+,polaroid_px-70_cold_++,\
     polaroid_px-70_warm_--,polaroid_px-70_warm_-,polaroid_px-70_warm,polaroid_px-70_warm_+,polaroid_px-70_warm_++,\
     polaroid_time_zero_(expired)_---,polaroid_time_zero_(expired)_--,polaroid_time_zero_(expired)_-,polaroid_time_zero_(expired),polaroid_time_zero_(expired)_+,polaroid_time_zero_(expired)_++,\
     polaroid_time_zero_(expired)_cold_---,polaroid_time_zero_(expired)_cold_--,polaroid_time_zero_(expired)_cold_-,polaroid_time_zero_(expired)_cold

gimp_emulate_film_instant_consumer_preview :
  -gimp_split_preview "-gimp_emulate_film_instant_consumer $*",$-1

#@gimp Instant [pro] : gimp_emulate_film_instant_pro, gimp_emulate_film_instant_pro_preview(1)
#@gimp : Preset = choice{"None",
#@gimp : "Fuji FP-100c --","Fuji FP-100c -","Fuji FP-100c","Fuji FP-100c +","Fuji FP-100c ++","Fuji FP-100c ++a","Fuji FP-100c +++",
#@gimp : "Fuji FP-100c Cool --","Fuji FP-100c Cool -","Fuji FP-100c Cool","Fuji FP-100c Cool +","Fuji FP-100c Cool ++",
#@gimp : "Fuji FP-100c Negative --","Fuji FP-100c Negative -","Fuji FP-100c Negative","Fuji FP-100c Negative +","Fuji FP-100c Negative ++","Fuji FP-100c Negative ++a","Fuji FP-100c Negative +++",
#@gimp : "Fuji FP-3000b --","Fuji FP-3000b -","Fuji FP-3000b","Fuji FP-3000b +","Fuji FP-3000b ++","Fuji FP-3000b +++",
#@gimp : "Fuji FP-3000b HC",
#@gimp : "Fuji FP-3000b Negative --","Fuji FP-3000b Negative -","Fuji FP-3000b Negative","Fuji FP-3000b Negative +","Fuji FP-3000b Negative ++","Fuji FP-3000b Negative +++",
#@gimp : "Fuji FP-3000b Negative Early",
#@gimp : "Polaroid 665 --","Polaroid 665 -","Polaroid 665","Polaroid 665 +","Polaroid 665 ++",
#@gimp : "Polaroid 665 Negative -","Polaroid 665 Negative","Polaroid 665 Negative +",
#@gimp : "Polaroid 665 Negative HC",
#@gimp : "Polaroid 669 --","Polaroid 669 -","Polaroid 669","Polaroid 669 +","Polaroid 669 ++","Polaroid 669 +++",
#@gimp : "Polaroid 669 Cold --","Polaroid 669 Cold -","Polaroid 669 Cold","Polaroid 669 Cold +",
#@gimp : "Polaroid 690 --","Polaroid 690 -","Polaroid 690","Polaroid 690 +","Polaroid 690 ++",
#@gimp : "Polaroid 690 Cold --","Polaroid 690 Cold -","Polaroid 690 Cold","Polaroid 690 Cold +","Polaroid 690 Cold ++",
#@gimp : "Polaroid 690 Warm --","Polaroid 690 Warm -","Polaroid 690 Warm","Polaroid 690 Warm +","Polaroid 690 Warm ++"}
#@gimp : sep = separator()
#@gimp : Opacity = float(1,0,1)
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Hue = float(0,-180,180)
#@gimp : Saturation = float(0,-1,1)
#@gimp : Post-normalize = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small><b>Note:</b> The color LUTs used in this section have been designed by <b>Patrick David</b>. More infos at:</small>")
#@gimp : link = link{"Film Emulation Presets in G'MIC","http://gmic.eu/film_emulation/index.shtml"}
#@gimp : sep = separator(), note = note("<small>Authors: <i>Patrick David</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>08/29/2013</i>.</small>")
gimp_emulate_film_instant_pro :
  -_gimp_emulate_film $1,@{-arg\ $1,@{-_$0}},${2--1}

_gimp_emulate_film_instant_pro :
  -u fuji_fp-100c_--,fuji_fp-100c_-,fuji_fp-100c,fuji_fp-100c_+,fuji_fp-100c_++,fuji_fp-100c_++_alt,fuji_fp-100c_+++,\
     fuji_fp-100c_cool_--,fuji_fp-100c_cool_-,fuji_fp-100c_cool,fuji_fp-100c_cool_+,fuji_fp-100c_cool_++,\
     fuji_fp-100c_negative_--,fuji_fp-100c_negative_-,fuji_fp-100c_negative,fuji_fp-100c_negative_+,fuji_fp-100c_negative_++,fuji_fp-100c_negative_++_alt,fuji_fp-100c_negative_+++,\
     fuji_fp-3000b_--,fuji_fp-3000b_-,fuji_fp-3000b,fuji_fp-3000b_+,fuji_fp-3000b_++,fuji_fp-3000b_+++,fuji_fp-3000b_hc,\
     fuji_fp-3000b_negative_--,fuji_fp-3000b_negative_-,fuji_fp-3000b_negative,fuji_fp-3000b_negative_+,fuji_fp-3000b_negative_++,fuji_fp-3000b_negative_+++,fuji_fp-3000b_negative_early,\
     polaroid_665_--,polaroid_665_-,polaroid_665,polaroid_665_+,polaroid_665_++,\
     polaroid_665_negative_-,polaroid_665_negative,polaroid_665_negative_+,polaroid_665_negative_hc,\
     polaroid_669_--,polaroid_669_-,polaroid_669,polaroid_669_+,polaroid_669_++,polaroid_669_+++,\
     polaroid_669_cold_--,polaroid_669_cold_-,polaroid_669_cold,polaroid_669_cold_+,\
     polaroid_690_--,polaroid_690_-,polaroid_690,polaroid_690_+,polaroid_690_++,\
     polaroid_690_cold_--,polaroid_690_cold_-,polaroid_690_cold,polaroid_690_cold_+,polaroid_690_cold_++,\
     polaroid_690_warm_--,polaroid_690_warm_-,polaroid_690_warm,polaroid_690_warm_+,polaroid_690_warm_++

gimp_emulate_film_instant_pro_preview :
  -gimp_split_preview "-gimp_emulate_film_instant_pro $*",$-1

#@gimp Negative [color] : gimp_emulate_film_negative_color, gimp_emulate_film_negative_color_preview(1)
#@gimp : Preset = choice{"None",
#@gimp : "Agfa Ultra Color 100","Agfa Vista 200","Fuji Superia 200","Fuji Superia HG 1600","Fuji Superia Reala 100","Fuji Superia X-Tra 800",
#@gimp : "Kodak Elite 100 XPRO","Kodak Elite Color 200","Kodak Elite Color 400","Kodak Portra 160 NC","Kodak Portra 160 VC","Lomography Redscale 100"}
#@gimp : sep = separator()
#@gimp : Opacity = float(1,0,1)
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Hue = float(0,-180,180)
#@gimp : Saturation = float(0,-1,1)
#@gimp : Post-normalize = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small><b>Note:</b> The color LUTs used in this section have been designed by <b>Patrick David</b>. More infos at:</small>")
#@gimp : link = link{"Film Emulation Presets in G'MIC","http://gmic.eu/film_emulation/index.shtml"}
#@gimp : sep = separator(), note = note("<small>Authors: <i>Patrick David</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>08/29/2013</i>.</small>")
gimp_emulate_film_negative_color :
  -_gimp_emulate_film $1,@{-arg\ $1,@{-_$0}},${2--1}

_gimp_emulate_film_negative_color :
  -u agfa_ultra_color_100,agfa_vista_200,fuji_superia_200,fuji_superia_hg_1600,fuji_superia_reala_100,fuji_superia_x-tra_800,\
     kodak_elite_100_xpro,kodak_elite_color_200,kodak_elite_color_400,kodak_portra_160_nc,kodak_portra_160_vc,lomography_redscale_100

gimp_emulate_film_negative_color_preview :
  -gimp_split_preview "-gimp_emulate_film_negative_color $*",$-1

#@gimp Negative [new] : gimp_emulate_film_negative_new, gimp_emulate_film_negative_new_preview(1)
#@gimp : Preset = choice{"None","Fuji 160C","Fuji 400H","Fuji 800Z","Fuji Ilford HP5","Kodak Portra 160","Kodak Portra 400","Kodak Portra 800","Kodak TMAX 3200","Kodak TRI-X 400"}
#@gimp : Effect = choice(1,"Low","Standard","High","Higher")
#@gimp : sep = separator()
#@gimp : Opacity = float(1,0,1)
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Hue = float(0,-180,180)
#@gimp : Saturation = float(0,-1,1)
#@gimp : Post-normalize = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small><b>Note:</b> The color LUTs used in this section have been designed by <b>Patrick David</b>. More infos at:</small>")
#@gimp : link = link{"Film Emulation Presets in G'MIC","http://gmic.eu/film_emulation/index.shtml"}
#@gimp : sep = separator(), note = note("<small>Authors: <i>Patrick David</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>08/29/2013</i>.</small>")
gimp_emulate_film_negative_new :
  -_gimp_emulate_film $1,@{-arg\ {max(1,4*$1+$2-3)},@{-_$0}},${3--1}

_gimp_emulate_film_negative_new :
  -u fuji_160c_-,fuji_160c,fuji_160c_+,fuji_160c_++,\
     fuji_400h_-,fuji_400h,fuji_400h_+,fuji_400h_++,\
     fuji_800z_-,fuji_800z,fuji_800z_+,fuji_800z_++,\
     fuji_ilford_hp5_-,fuji_ilford_hp5,fuji_ilford_hp5_+,fuji_ilford_hp5_++,\
     kodak_portra_160_-,kodak_portra_160,kodak_portra_160_+,kodak_portra_160_++,\
     kodak_portra_400_-,kodak_portra_400,kodak_portra_400_+,kodak_portra_400_++,\
     kodak_portra_800_-,kodak_portra_800,kodak_portra_800_+,kodak_portra_800_++,\
     kodak_tmax_3200_-,kodak_tmax_3200,kodak_tmax_3200_+,kodak_tmax_3200_++,\
     kodak_tri-x_400_-,kodak_tri-x_400,kodak_tri-x_400_+,kodak_tri-x_400_++

gimp_emulate_film_negative_new_preview :
  -gimp_split_preview "-gimp_emulate_film_negative_new $*",$-1

#@gimp Negative [old] : gimp_emulate_film_negative_old, gimp_emulate_film_negative_old_preview(1)
#@gimp : Preset = choice{0,"None","Fuji Ilford Delta 3200","Fuji Neopan 1600","Fuji Superia 100","Fuji Superia 400","Fuji Superia 800","Fuji Superia 1600",
#@gimp : "Kodak Portra 160 NC","Kodak Portra 160 VC","Kodak Portra 400 NC","Kodak Portra 400 UC","Kodak Portra 400 VC"}
#@gimp : Effect = choice(1,"Low","Standard","High","Higher")
#@gimp : sep = separator()
#@gimp : Opacity = float(1,0,1)
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Hue = float(0,-180,180)
#@gimp : Saturation = float(0,-1,1)
#@gimp : Post-normalize = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small><b>Note:</b> The color LUTs used in this section have been designed by <b>Patrick David</b>. More infos at:</small>")
#@gimp : link = link{"Film Emulation Presets in G'MIC","http://gmic.eu/film_emulation/index.shtml"}
#@gimp : sep = separator(), note = note("<small>Authors: <i>Patrick David</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>08/29/2013</i>.</small>")
gimp_emulate_film_negative_old :
  -_gimp_emulate_film $1,@{-arg\ {max(1,4*$1+$2-3)},@{-_$0}},${3--1}

_gimp_emulate_film_negative_old :
  -u fuji_ilford_delta_3200_-,fuji_ilford_delta_3200,fuji_ilford_delta_3200_+,fuji_ilford_delta_3200_++,\
     fuji_neopan_1600_-,fuji_neopan_1600,fuji_neopan_1600_+,fuji_neopan_1600_++,\
     fuji_superia_100_-,fuji_superia_100,fuji_superia_100_+,fuji_superia_100_++,\
     fuji_superia_400_-,fuji_superia_400,fuji_superia_400_+,fuji_superia_400_++,\
     fuji_superia_800_-,fuji_superia_800,fuji_superia_800_+,fuji_superia_800_++,\
     fuji_superia_1600_-,fuji_superia_1600,fuji_superia_1600_+,fuji_superia_1600_++,\
     kodak_portra_160_nc_-,kodak_portra_160_nc,kodak_portra_160_nc_+,kodak_portra_160_nc_++,\
     kodak_portra_160_vc_-,kodak_portra_160_vc,kodak_portra_160_vc_+,kodak_portra_160_vc_++,\
     kodak_portra_400_nc_-,kodak_portra_400_nc,kodak_portra_400_nc_+,kodak_portra_400_nc_++,\
     kodak_portra_400_uc_-,kodak_portra_400_uc,kodak_portra_400_uc_+,kodak_portra_400_uc_++,\
     kodak_portra_400_vc_-,kodak_portra_400_vc,kodak_portra_400_vc_+,kodak_portra_400_vc_++

gimp_emulate_film_negative_old_preview :
  -gimp_split_preview "-gimp_emulate_film_negative_old $*",$-1

#@gimp Print films : gimp_emulate_film_print, gimp_emulate_film_print_preview(1)
#@gimp : Preset = choice{"None","Fuji 3510 (Constlclip)","Fuji 3510 (Constlmap)","Fuji 3510 (Cuspclip)",
#@gimp : "Fuji 3513 (Constlclip)","Fuji 3513 (Constlmap)","Fuji 3513 (Cuspclip)",
#@gimp : "Kodak 2383 (Constlclip)","Kodak 2383 (Constlmap)","Kodak 2383 (Cuspclip)",
#@gimp : "Kodak 2393 (Constlclip)","Kodak 2393 (Constlmap)","Kodak 2393 (Cuspclip)"}
#@gimp : sep = separator()
#@gimp : Opacity = float(1,0,1)
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Hue = float(0,-180,180)
#@gimp : Saturation = float(0,-1,1)
#@gimp : Post-normalize = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small><b>Note:</b> The color LUTs used in this section have been provided by <b>Juan Melara</b>, and are freely available at:</small>")
#@gimp : link = link("Print Film Emulation LUTs For Download","http://juanmelara.com.au/print-film-emulation-luts-for-download/")
#@gimp : note = note("<small>More infos at:</small>")
#@gimp : link = link{"Film Emulation Presets in G'MIC","http://gmic.eu/film_emulation/index.shtml"}
#@gimp : sep = separator(), note = note("<small>Authors: <i>Juan Melara</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>04/15/2014</i>.</small>")
gimp_emulate_film_print :
  -_gimp_emulate_film $1,@{-arg\ $1,@{-_$0}},${2--1}

_gimp_emulate_film_print :
  -u fuji3510_constlclip,fuji3510_constlmap,fuji3510_cuspclip,\
     fuji3513_constlclip,fuji3513_constlmap,fuji3513_cuspclip,\
     kodak2383_constlclip,kodak2383_constlmap,kodak2383_cuspclip,\
     kodak2393_constlclip,kodak2393_constlmap,kodak2393_cuspclip

gimp_emulate_film_print_preview :
  -gimp_split_preview "-gimp_emulate_film_print $*",$-1

#@gimp Slide [color] : gimp_emulate_film_colorslide, gimp_emulate_film_colorslide_preview(1)
#@gimp : Preset = choice{"None",
#@gimp : "Agfa Precisa 100","Fuji Astia 100F","Fuji FP 100C","Fuji Provia 100F","Fuji Provia 400F","Fuji Provia 400X","Fuji Sensia 100",
#@gimp : "Fuji Superia 200 XPRO","Fuji Velvia 50","Generic Fuji Astia 100","Generic Fuji Provia 100","Generic Fuji Velvia 100",
#@gimp : "Generic Kodachrome 64","Generic Kodak Ektachrome 100 VS","Kodak E-100 GX Ektachrome 100","Kodak Ektachrome 100 VS","Kodak Elite Chrome 200",
#@gimp : "Kodak Elite Chrome 400","Kodak Elite ExtraColor 100","Kodak Kodachrome 200","Kodak Kodachrome 25","Kodak Kodachrome 64","Lomography X-Pro Slide 200",
#@gimp : "Polaroid 669","Polaroid 690","Polaroid Polachrome"}
#@gimp : sep = separator()
#@gimp : Opacity = float(1,0,1)
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Hue = float(0,-180,180)
#@gimp : Saturation = float(0,-1,1)
#@gimp : Post-normalize = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small><b>Note:</b> The color LUTs used in this section have been designed by <b>Patrick David</b>. More infos at:</small>")
#@gimp : link = link{"Film Emulation Presets in G'MIC","http://gmic.eu/film_emulation/index.shtml"}
#@gimp : sep = separator(), note = note("<small>Authors: <i>Patrick David</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>08/29/2013</i>.</small>")
gimp_emulate_film_colorslide :
  -_gimp_emulate_film $1,@{-arg\ $1,@{-_$0}},${2--1}

_gimp_emulate_film_colorslide :
  -u agfa_precisa_100,fuji_astia_100f,fuji_fp_100c,fuji_provia_100f,fuji_provia_400f,fuji_provia_400x,fuji_sensia_100,\
     fuji_superia_200_xpro,fuji_velvia_50,generic_fuji_astia_100,generic_fuji_provia_100,generic_fuji_velvia_100,\
     generic_kodachrome_64,generic_kodak_ektachrome_100_vs,kodak_e-100_gx_ektachrome_100,kodak_ektachrome_100_vs,kodak_elite_chrome_200,\
     kodak_elite_chrome_400,kodak_elite_extracolor_100,kodak_kodachrome_200,kodak_kodachrome_25,kodak_kodachrome_64,lomography_x-pro_slide_200,\
     polaroid_669,polaroid_690,polaroid_polachrome

gimp_emulate_film_colorslide_preview :
  -gimp_split_preview "-gimp_emulate_film_colorslide $*",$-1

#@gimp User-defined : gimp_emulate_film_userdefined, gimp_emulate_film_userdefined(1)
#@gimp : Specify CLUT as = choice(2,"Top layer","Bottom layer","Filename")
#@gimp : CLUT filename = file()
#@gimp : note = note("<small><b>Note:</b> Do not forget to set the <i>Input layers</i> option if you select <i>Top layer</i> or <i>Bottom layer</i>.</small>")
#@gimp : sep = separator()
#@gimp : Opacity = float(1,0,1)
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Hue = float(0,-180,180)
#@gimp : Saturation = float(0,-1,1)
#@gimp : Post-normalize = bool(0)
#@gimp : sep = separator(), note = note("<small>More infos at:</small>")
#@gimp : link = link{"Film Emulation Presets in G'MIC","http://gmic.eu/film_emulation/index.shtml"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>07/30/2014</i>.</small>")
gimp_emulate_film_userdefined :
  -if {$1<2}
    -if {@#<2} -gimp_warning_preview "Input layer with CLUT is missing" -return -endif
    ind={if($1,-1,0)} -map_clut[^$ind] [$ind] -rm[$ind]
  -else
    -l "$2" -onfail -gimp_warning_preview "Specified CLUT filename not found" -return -endl
    -map_clut[^-1] [-1] -rm[-1]
  -endif
  -_gimp_emulate_film 0,0,${3--1}

#@gimp Various : gimp_emulate_film_various, gimp_emulate_film_various_preview(1)
#@gimp : Preset = choice{"None","60's","60's (faded)","60's (faded alt)","Black & White","Color (rich)","Faded","Faded (alt)","Faded (analog)","Faded (extreme)","Faded (vivid)",
#@gimp : "Hong Kong","Light (blown)","Lomo","Natural (vivid)","Nostalgic","Purple","Retro",
#@gimp : "Summer","Summer (alt)","Sunny","Sunny (alt)","Sunny (warm)","Sunny (rich)","Super warm","Super warm (rich)","Sutro FX","Vibrant","Vibrant (alien)",
#@gimp : "Vintage","Vintage (alt)","Vintage (brighter)","Warm","Warm (yellow)"}
#@gimp : sep = separator()
#@gimp : Opacity = float(1,0,1)
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Hue = float(0,-180,180)
#@gimp : Saturation = float(0,-1,1)
#@gimp : Post-normalize = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>More infos at:</small>")
#@gimp : link = link{"Film Emulation Presets in G'MIC","http://gmic.eu/film_emulation/index.shtml"}
#@gimp : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i> and <i>Patrick David</i>.      Latest update: <i>07/29/2014</i>.</small>")
gimp_emulate_film_various :
  -_gimp_emulate_film $1,@{-arg\ $1,@{-_$0}},${2--1}

_gimp_emulate_film_various :
  -u 60{`39`}s,60{`39`}s_faded,60{`39`}s_faded_alt,black_and_white,color_rich,faded,faded_alt,faded_analog,faded_extreme,faded_vivid,\
     hong_kong,light_blown,lomo,natural_vivid,nostalgic,purple,retro,\
     summer,summer_alt,sunny,sunny_alt,sunny_warm,sunny_rich,super_warm,super_warm_rich,sutro_fx,vibrant,vibrant_alien,\
     vintage,vintage_alt,vintage_brighter,warm,warm_yellow

gimp_emulate_film_various_preview :
  -gimp_split_preview "-gimp_emulate_film_various $*",$-1

_gimp_emulate_film :
  -if $1
    dir=@{-path_user}
    -if {!@{-is_windows}}
      dir=$dir/.gmic_film_presets
      -if $dir -else -x "mkdir "$dir -endif
    -endif
    -if {narg($_force_redownload)}
      -i http://gmic.eu/data_film_presets/$2.cimgz -o[-1] $dir/gmic_$2.cimgz
    -else
      -if $dir/gmic_$2.cimgz -i $dir/gmic_$2.cimgz
      -else -i http://gmic.eu/data_film_presets/$2.cimgz -o[-1] $dir/gmic_$2.cimgz
      -endif
    -endif

    -repeat {@#-1}
      -if {$3<1} --map_clut[$>] [-1] -j[$>] [-1],0,0,0,0,$3 -rm[-1]
      -else -map_clut[$>] [-1]
      -endif
    -done
    -rm[-1]

  -endif
  -repeat @# -l[$>] -split_opacity
    -apply_gamma[0] {10^$4}                            # Gamma correction
    --[0] 128 -*[0] $5 -+[0] 128 -+[0] $6 -c[0] 0,255  # B&W contrast and brightness.
    -if {$7||$8||$9}
      -rgb2hsv[0]
      -sh[0] 0,0 -+[-1] $7 -%[-1] 360 -rm[-1]
      -sh[0] 1,1 -+[-1] $8 -c[-1] 0,1 -rm[-1]
      -hsv2rgb[0]
      -if $9 -n[0] 0,255 -endif
    -endif
  -a c -endl -done

#@gimp <i>[Collages]</i>
#-----------------------

#@gimp B&amp;W films - collage : gimp_emulate_film_collage_bw, gimp_no_preview
#@gimp : Image size = float(512,16,1024)
#@gimp : Columns for collage = int(4,1,8)
#@gimp : Label size = int(16,10,100)
#@gimp : Output as = choice("Table","Multiple layers")
#@gimp : sep = separator()
#@gimp : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>B&amp;W</i> film emulation presets
#@gimp : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gimp : (this may take some time at the first run).
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/28/2013</i>.</small>")
gimp_emulate_film_collage_bw :
  -k[0] -to_rgb -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
  _nbc=$2 _label_size=$3 _output_type=$4 -_gimp_emulate_film_collage @{-_gimp_emulate_film_bw}

#@gimp Instant - collage [consumer] : gimp_emulate_film_collage_instant_consumer, gimp_no_preview
#@gimp : Image size = float(512,16,1024)
#@gimp : Columns for collage = int(4,1,8)
#@gimp : Label size = int(16,10,100)
#@gimp : Output as = choice("Table","Multiple layers")
#@gimp : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Instant [consumer]</i> film emulation presets
#@gimp : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gimp : (this may take some time at the first run).
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/28/2013</i>.</small>")
gimp_emulate_film_collage_instant_consumer :
  -k[0] -to_rgb -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
  _nbc=$2 _label_size=$3 _output_type=$4 -_gimp_emulate_film_collage @{-_gimp_emulate_film_instant_consumer}

#@gimp Instant - collage [pro] : gimp_emulate_film_collage_instant_pro, gimp_no_preview
#@gimp : Image size = float(512,16,1024)
#@gimp : Columns for collage = int(4,1,8)
#@gimp : Label size = int(16,10,100)
#@gimp : Output as = choice("Table","Multiple layers")
#@gimp : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Instant [pro]</i> film emulation presets
#@gimp : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gimp : (this may take some time at the first run).
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/28/2013</i>.</small>")
gimp_emulate_film_collage_instant_pro :
  -k[0] -to_rgb -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
  _nbc=$2 _label_size=$3 _output_type=$4 -_gimp_emulate_film_collage @{-_gimp_emulate_film_instant_pro}

#@gimp Negative - collage [color] : gimp_emulate_film_collage_negative_color, gimp_no_preview
#@gimp : Image size = float(512,16,1024)
#@gimp : Columns for collage = int(4,1,8)
#@gimp : Label size = int(16,10,100)
#@gimp : Output as = choice("Table","Multiple layers")
#@gimp : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Negative [color]</i> film emulation presets
#@gimp : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gimp : (this may take some time at the first run).
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/28/2013</i>.</small>")
gimp_emulate_film_collage_negative_color :
  -k[0] -to_rgb -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
  _nbc=$2 _label_size=$3 _output_type=$4 -_gimp_emulate_film_collage @{-_gimp_emulate_film_negative_color}

#@gimp Negative - collage [new] : gimp_emulate_film_collage_negative_new, gimp_no_preview
#@gimp : Image size = float(512,16,1024)
#@gimp : Columns for collage = int(4,1,8)
#@gimp : Label size = int(16,10,100)
#@gimp : Output as = choice("Table","Multiple layers")
#@gimp : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Negative [new]</i> film emulation presets
#@gimp : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gimp : (this may take some time at the first run).
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/28/2013</i>.</small>")
gimp_emulate_film_collage_negative_new :
  -k[0] -to_rgb -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
  _nbc=$2 _label_size=$3 _output_type=$4 -_gimp_emulate_film_collage @{-_gimp_emulate_film_negative_new}

#@gimp Negative - collage [old] : gimp_emulate_film_collage_negative_old, gimp_no_preview
#@gimp : Image size = float(512,16,1024)
#@gimp : Columns for collage = int(4,1,8)
#@gimp : Label size = int(16,10,100)
#@gimp : Output as = choice("Table","Multiple layers")
#@gimp : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Negative [old]</i> film emulation presets
#@gimp : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gimp : (this may take some time at the first run).
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/28/2013</i>.</small>")
gimp_emulate_film_collage_negative_old :
  -k[0] -to_rgb -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
  _nbc=$2 _label_size=$3 _output_type=$4 -_gimp_emulate_film_collage @{-_gimp_emulate_film_negative_old}

#@gimp Print films - collage : gimp_emulate_film_collage_print, gimp_no_preview
#@gimp : Image size = float(512,16,1024)
#@gimp : Columns for collage = int(4,1,8)
#@gimp : Label size = int(16,10,100)
#@gimp : Output as = choice("Table","Multiple layers")
#@gimp : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Others</i> film emulation presets
#@gimp : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gimp : (this may take some time at the first run).
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>04/15/2014</i>.</small>")
gimp_emulate_film_collage_print :
  -k[0] -to_rgb -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
  _nbc=$2 _label_size=$3 _output_type=$4 -_gimp_emulate_film_collage @{-_gimp_emulate_film_print}

#@gimp Slide - collage [color] : gimp_emulate_film_collage_colorslide, gimp_no_preview
#@gimp : Image size = float(512,16,1024)
#@gimp : Columns for collage = int(4,1,8)
#@gimp : Label size = int(16,10,100)
#@gimp : Output as = choice("Table","Multiple layers")
#@gimp : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Slide [color]</i> film emulation presets
#@gimp : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gimp : (this may take some time at the first run).
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/28/2013</i>.</small>")
gimp_emulate_film_collage_colorslide :
  -k[0] -to_rgb -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
  _nbc=$2 _label_size=$3 _output_type=$4 -_gimp_emulate_film_collage @{-_gimp_emulate_film_colorslide}

_gimp_emulate_film_collage :
  $=arg -progress 0
  -repeat $#
    preset=${arg{$>+1}}
    --l[0]
      -_gimp_emulate_film[0] 1,$preset,1,0,1,0,0,0,0,0
      ({'$preset'}) -replace[-1] {'_'},32 -f[-1] if(x==0&&i>={'a'}&&i<={'z'},i+{'A'}-{'a'},i) title=@{-1,t} -rm[-1]
      -text_outline[-1] $title,2,2,$_label_size,2,1,255
    -endl
    -progress {(1+$>)*100/$#}
  -done
  -text_outline[0] "Original image",2,2,$_label_size,2,1,255
  -if {!$_output_type} -frame 1,1,0 -frame 5,5,255 -- 255 -append_tiles {min($_nbc,@#)} -+ 255 -endif

#@gimp Various - collage : gimp_emulate_film_collage_various, gimp_no_preview
#@gimp : Image size = float(512,16,1024)
#@gimp : Columns for collage = int(4,1,8)
#@gimp : Label size = int(16,10,100)
#@gimp : Output as = choice("Table","Multiple layers")
#@gimp : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Others</i> film emulation presets
#@gimp : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gimp : (this may take some time at the first run).
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i> and <i>Patrick David</i>.      Latest update: <i>07/29/2014</i>.</small>")
gimp_emulate_film_collage_various :
  -k[0] -to_rgb -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
  _nbc=$2 _label_size=$3 _output_type=$4 -_gimp_emulate_film_collage @{-_gimp_emulate_film_various}

#@gimp _

#@gimp [Download all presets] : gimp_emulate_film_download, gimp_no_preview(1)
#@gimp : note = note{"This filter will download the color and grain profiles for all film emulation presets available in <i>G'MIC</i>,
#@gimp : and will install them as persistent data files on your hard drive. After this operation, you won't need a permanent
#@gimp : internet connection anymore in order to use the G'MIC film emulation filters."}
#@gimp : note = note()
#@gimp : note = note{"<b><span color="red">Warning:</span></b> About <b>90 Mb</b> of data will be downloaded by this filter. This can take a long time !"}
#@gimp : sep = separator()
#@gimp : Force re-download = _bool(0)
#@gimp : sep = separator()
#@gimp : note = note{"<b><span color="red">Alternative (manual) method:</span></b>\nIf, for any reasons, your plug-in is unable to retrieve data from the Internet, you can download all
#@gimp : color profiles manually (as a single .zip file) at this address :"}
#@gimp : link = link{"http://gmic.eu/data_film_presets/all_gmic_film_presets.zip"}
#@gimp : note = note{"You must then decompress all files contained in this archive at the following location:\n
#@gimp : - for <b>Unix</b>-like systems : <span color="blue"><tt>$HOME/.gmic_film_presets/</tt></span>\n
#@gimp : - for <b>Windows</b> systems : <span color="blue"><tt>%APPDATA/</tt></span>
#@gimp : "}
#@gimp : sep = separator(), note = note("<small>More infos at:</small>")
#@gimp : link = link{"Film Emulation Presets in G'MIC","http://gmic.eu/film_emulation/index.shtml"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>04/16/2014</i>.</small>")
gimp_emulate_film_download :
  -_gimp_emulate_film_download @{-_gimp_emulate_film_bw},\
                               @{-_gimp_emulate_film_instant_consumer},\
                               @{-_gimp_emulate_film_instant_pro},\
                               @{-_gimp_emulate_film_negative_color},\
                               @{-_gimp_emulate_film_negative_new},\
                               @{-_gimp_emulate_film_negative_old},\
                               @{-_gimp_emulate_film_print},\
                               @{-_gimp_emulate_film_colorslide},\
                               @{-_gimp_emulate_film_various},\
                               @{-_gimp_emulate_grain}
  -l[] -progress 0
  -if $1 _force_redownload=1 -endif
  -repeat $_nb_presets -l[] -_gimp_emulate_film 1,${_preset{1+$>}},1,0,1,0,0,0,0 -progress {($>+1)*100/$_nb_presets} -onfail -endl -rm -done
  -endl

_gimp_emulate_film_download :
  _nb_presets=$#
  $=_preset


#@gimp _<b>Frames</b>
#--------------------

#@gimp Droste : gimp_droste, gimp_droste_preview(1)
#@gimp : note = note("<span color=\"red\">Upper-left coordinates :</span>")
#@gimp : X0 = float(20,0,100)
#@gimp : Y0 = float(20,0,100)
#@gimp : sep = separator(), note = note("<span color=\"magenta\">Upper-right coordinates :</span>")
#@gimp : X1 = float(80,0,100)
#@gimp : Y1 = float(20,0,100)
#@gimp : sep = separator(), note = note("<span color=\"blue\">Lower-right coordinates :</span>")
#@gimp : X2 = float(80,0,100)
#@gimp : Y2 = float(80,0,100)
#@gimp : sep = separator(), note = note("<span color=\"cyan\">Lower-left coordinates :</span>")
#@gimp : X3 = float(20,0,100)
#@gimp : Y3 = float(80,0,100)
#@gimp : sep = separator()
#@gimp : Iterations = int(1,1,10)
#@gimp : X-shift = float(0,-100,100)
#@gimp : Y-shift = float(0,-100,100)
#@gimp : Angle = float(0,0,360)
#@gimp : Zoom = float(1,0.1,5)
#@gimp : Mirror = choice("None","x-axis","y-axis","xy-axes")
#@gimp : Boundary = choice(1,"Black","Nearest","Repeat")
#@gimp : Drawing mode = choice{"Replace","Replace (sharpest)","Behind","Below"}
#@gimp : View outlines only = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>06/11/2012</i>.</small>")
gimp_droste :
  -repeat @#
    -if {$16==1} 100%,100%,1,1,'x' 100%,100%,1,1,'y' -a[-2,-1] c -endif
    -repeat $9
      x0={round($1*w/100)} y0={round($2*h/100)} x1={round($3*w/100)} y1={round($4*h/100)}
      x2={round($5*w/100)} y2={round($6*h/100)} x3={round($7*w/100)} y3={round($8*h/100)}
      100%,100%,1,2,-32767 -polygon[-1] 4,$x0,$y0,$x1,$y1,$x2,$y2,$x3,$y3,1,-65535
      -sh[-1] 0,0 -f[-1] 'if(i==-65535,x03=$x0+(y-$y0)/($y3-$y0)*($x3-$x0);x12=$x1+(y-$y1)/($y2-$y1)*($x2-$x1);(x-x03)/(x12-x03)*(w-1),i)' -rm[-1]
      -sh[-1] 1,1 -f[-1] 'if(i==-65535,y01=$y0+(x-$x0)/($x1-$x0)*($y1-$y0);y32=$y3+(x-$x3)/($x2-$x3)*($y2-$y3);(y-y01)/(y32-y01)*(h-1),i)' -rm[-1]
      xshift={w*$10/100} yshift={h*$11/100} alpha={-$12*pi/180} ca={cos($alpha)/$13} sa={sin($alpha)/$13} w2={w/2} h2={h/2}
      -f[-1] 'if(i==-32767,i,X=i(x,y,0,0)-$w2;Y=i(x,y,0,1)-$h2;if(c==0,$w2-$xshift+X*$ca-Y*$sa,$h2-$yshift+X*$sa+Y*$ca))'
      -if {$14==0} -sh[-1] 0,0 -f[-1] 'if(i==-32767,x,i)' -rm[-1] -sh[-1] 1,1 -f[-1] 'if(i==-32767,y,i)' -rm[-1]
      -elif {$14==1} -sh[-1] 0,0 -f[-1] 'if(i==-32767,x,w-1-i)' -rm[-1] -sh[-1] 1,1 -f[-1] 'if(i==-32767,y,i)' -rm[-1]
      -elif {$14==2} -sh[-1] 0,0 -f[-1] 'if(i==-32767,x,i)' -rm[-1] -sh[-1] 1,1 -f[-1] 'if(i==-32767,y,h-1-i)' -rm[-1]
      -else -sh[-1] 0,0 -f[-1] 'if(i==-32767,x,w-1-i)' -rm[-1] -sh[-1] 1,1 -f[-1] 'if(i==-32767,y,h-1-i)' -rm[-1]
      -endif
      -if {$16<2} -warp[-2] [-1],0,{$16==0},$15 -rm[-1]
      -else
        --warp[-2] [-1],0,1,$15 -rm[-2]
        -if {$16==3} -rv[-2,-1] -endif
        -blend[-2,-1] alpha
      -endif
    -done
    -if {$16==1} -warp[-2] [-1],0,1,1 -rm[-1] -endif
    -mv[-1] 0 -done

gimp_droste_preview :
  -if {!$17} -gimp_droste $* -else -polygon 4,$1%,$2%,$3%,$4%,$5%,$6%,$7%,$8%,0.3,0,0,0,255 -endif
  -polygon 4,$1%,$2%,$3%,$4%,$5%,$6%,$7%,$8%,1,0xFFFFFFFF,0,0,0,255
  -ellipse $1%,$2%,3,3,0,1,255,0,0,255 -ellipse $1%,$2%,3,3,0,1,0xFFFFFFFF,0,0,0,255
  -ellipse $3%,$4%,3,3,0,1,255,0,255,255 -ellipse $3%,$4%,3,3,0,1,0xFFFFFFFF,0,0,0,255
  -ellipse $5%,$6%,3,3,0,1,0,0,255,255 -ellipse $5%,$6%,3,3,0,1,0xFFFFFFFF,0,0,0,255
  -ellipse $7%,$8%,3,3,0,1,0,255,255,255 -ellipse $7%,$8%,3,3,0,1,0xFFFFFFFF,0,0,0,255

#@gimp Frame [blur] : gimp_frame_blur, gimp_frame_blur(1)
#@gimp : Horizontal size = float(30,0,100)
#@gimp : Vertical size = float(30,0,100)
#@gimp : Crop = float(0,0,100)
#@gimp : Blur = float(5,0,10)
#@gimp : Roundness = float(0,0,1)
#@gimp : Apply color balance = bool(0)
#@gimp : Balance color = color(128,128,128)
#@gimp : Normalization = choice("None","Stretch","Equalize")
#@gimp : sep = separator()
#@gimp : Outline size = float(5,0,50)
#@gimp : Outline color = color(255,255,255)
#@gimp : X-shadow = float(2,-10,10)
#@gimp : Y-shadow = float(2,-10,10)
#@gimp : Shadow smoothness = float(1,0,5)
#@gimp : Shadow contrast = float(0,0,100)
#@gimp : X-centering = float(0.5,0,1)
#@gimp : Y-centering = float(0.5,0,1)
#@gimp : Angle = float(0,-180,180)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>01/19/2014</i>.</small>")
gimp_frame_blur :
  -repeat @# -l[$>] -to_rgb
    sx={$1%*max(w,h)} sy={$2%*max(w,h)}
    --r {w+$sx},{h+$sy},1,100%,3 -b[1] $4%

    -if $6 -balance_gamma[1] ${7-9} -endif
    -if {$10==1} -n[1] 0,255 -elif {$10==2} -n[1] 0,255 -equalize[1] 256 -endif
    -rv

    -z[1] {$3/2}%,{$3/2}%,{100-$3/2}%,{100-$3/2}%
    -to_rgba[1]

    -if $5 r={1+1/$5} -sh[1] 100%,100% -f[-1] '1-(abs(x/w-0.5)^$r+abs(y/h-0.5)^$r)^(1/$r)'
      v={min(i(w/2,0),i(w-1,h/2),i(w/2,h-1),i(0,h/2))}
      -c[-1] $v,{$v+0.5/max(w,h)} -n[-1] 0,255 -rm[-1] -endif

    s={$11%*max(w,h)}
    -r[1] {w+$s},{h+$s},1,4,0,0,0.5,0.5
    -i[1] 100%,100%,1,3 -fc[1] ${12-14} -blend[1,2] alpha -to_a[-1]

    -if $5 -sh[1] 100%,100% -f[-1] '1-(abs(x/w-0.5)^$r+abs(y/h-0.5)^$r)^(1/$r)'
      v={min(i(w/2,0),i(w-1,h/2),i(w/2,h-1),i(0,h/2))}
      -c[-1] $v,{$v+0.5/max(w,h)} -n[-1] 0,255 -rm[-1] -endif
    -rotate[1] $21,1,0
    -r[1] [0],[0],1,4,0,0,$19,$20
    --channels[1] 100% -b[-1] $17%,0 -c[-1] 0,{max(1,100-$18)}% -n[-1] 0,255
    -shift[-1] $15%,$16%,0,0,0 -/[-1] -255 -+[-1] 1 -*[0,-1]

    -blend alpha
  -endl -done

#@gimp Frame [cube] : frame_cube, frame_cube(1)
#@gimp : Depth = float(3,0,30)
#@gimp : X-center = float(0,-2,2)
#@gimp : Y-center = float(0,-2,2)
#@gimp : Left side orientation = choice("Normal","Mirror-X","Mirror-Y","Mirror-XY")
#@gimp : Right side orientation = choice("Normal","Mirror-X","Mirror-Y","Mirror-XY")
#@gimp : Upper side orientation = choice("Normal","Mirror-X","Mirror-Y","Mirror-XY")
#@gimp : Lower sider orientation = choice("Normal","Mirror-X","Mirror-Y","Mirror-XY")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;, Angelo Lama</i>.      Latest update: <i>01/29/2012</i>.</small>")

#@gimp Frame [fuzzy] : gimp_frame_fuzzy, gimp_frame_fuzzy(0)
#@gimp : Width = float(10,0,100)
#@gimp : Height = float(10,0,100)
#@gimp : Fuzzyness = float(10,0,40)
#@gimp : Smoothness = float(1,0,5)
#@gimp : Color = color(255,255,255,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_frame_fuzzy :
  -frame_fuzzy $1%,$2%,${3-8}

#@gimp Frame [painting] : gimp_frame_painting, gimp_frame_painting_preview(1)
#@gimp : Size = float(10,0,100)
#@gimp : Contrast = float(0.4,0,1)
#@gimp : Smoothness = float(6,0,30)
#@gimp : Color = color(225,200,120)
#@gimp : sep = separator()
#@gimp : Vignette size = float(2,0,50)
#@gimp : Vignette contrast = float(400,0,1000)
#@gimp : sep = separator()
#@gimp : Defects contrast = float(50,0,512)
#@gimp : Defects density = float(10,0,100)
#@gimp : Defects size = float(1,0,10)
#@gimp : Defects smoothness = float(0.5,0,20)
#@gimp : sep = separator()
#@gimp : Serial number = int(123456,0,1000000)
#@gimp : Frame as a new layer = _bool(false)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>06/07/2012</i>.</small>")
gimp_frame_painting :
  -if $14
    -repeat @# 100%,100%,1,4 -frame_painting[-1] $1%,$2,$3%,${4-6},$7%,${8-13}
    -rv[-2,-1] -to_a[-1] -r[-1] [-2],[-2],1,4,0,0,0.5,0.5 -mv[-2,-1] 0 -done
  -else -frame_painting $1%,$2,$3%,${4-6},$7%,${8-13}
  -endif

gimp_frame_painting_preview :
  -frame_painting $1%,$2,$3%,${4-6},$7%,${8-13}

#@gimp Frame [pattern] : gimp_frame_pattern, gimp_frame_pattern_preview(1)
#@gimp : Tiles = int(10,3,30)
#@gimp : Pattern = choice(1,"Top layer","Self image")
#@gimp : Iterations = int(1,1,10)
#@gimp : Constrain image size = _bool(1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>08/01/2014</i>.</small>")
gimp_frame_pattern :
  -if {$2||@#==1} -repeat $3 -frame_pattern $1,$4 -done
  -else -repeat $3 -frame_pattern[^0] $1,[0],$4 -done -endif

gimp_frame_pattern_preview :
  -gimp_frame_pattern ${1-3},1

#@gimp Frame [regular] : gimp_frame, gimp_frame(1)
#@gimp : note = note("<b>Crop parameters :</b>")
#@gimp : X-start = int(0,0,100)
#@gimp : X-end = int(100,0,100)
#@gimp : Y-start = int(0,0,100)
#@gimp : Y-end = int(100,0,100)
#@gimp : sep = separator(), note = note("<b>Frame parameters :</b>")
#@gimp : Width = int(10,0,100)
#@gimp : Height = int(10,0,100)
#@gimp : Color = color(0,0,0,255)
#@gimp : Outline size = int(1,0,100)
#@gimp : Outline color = color(255,255,255,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_frame :
 -to_rgba -repeat @#
   -z[-1] $1%,$3%,$2%,$4%
   -frame[-1] $11,$11,${12-15}
   -frame[-1] $5%,$6%,${7-10}
 -mv[-1] 0 -done

#@gimp Frame [round] : gimp_frame_round, gimp_frame_round(1)
#@gimp : Sharpness = float(6,0.1,40)
#@gimp : Size = float(20,0,100)
#@gimp : Smoothness = float(0.1,0,15)
#@gimp : Shade = float(0,0,1)
#@gimp : Color = color(255,255,255,255)
#@gimp : Blur frame = float(0,0,100)
#@gimp : Blur shade = float(0.1,0,1)
#@gimp : Blur amplitude = float(3,0,10)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_frame_round :
  -frame_round ${1-8}
  -if $9 -frame_blur $1,{min(99,$1+$9)},$3,$10,$11% -endif

#@gimp Old photograph : gimp_old_photo, gimp_old_photo(1)
#@gimp : Vignette strength = float(200,0,255)
#@gimp : Vignette min radius = float(50,0,100)
#@gimp : Vignette max radius = float(85,0,100)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_old_photo :
  -vignette ${1-3} -old_photo

#@gimp Polaroid : gimp_polaroid, gimp_polaroid(1)
#@gimp : Frame size = int(10,0,400)
#@gimp : Bottom size = int(20,0,400)
#@gimp : X-shadow = float(0,-20,20)
#@gimp : Y-shadow = float(0,-20,20)
#@gimp : Smoothness = float(3,0,5)
#@gimp : Angle = float(20,-180,180)
#@gimp : Vignette strength = float(50,0,255)
#@gimp : Vignette min radius = float(70,0,100)
#@gimp : Vignette max radius = float(95,0,100)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_polaroid :
  -vignette ${7-9} -polaroid $1,$2 -drop_shadow $3%,$4%,$5% -rotate $6,1,0

#@gimp Tunnel : gimp_tunnel, gimp_tunnel(1)
#@gimp : Depth = int(4,1,100)
#@gimp : Factor = float(80,1,99)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Opacity = float(0.2,0,1)
#@gimp : Angle = float(0,-90,90)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>11/22/2012</i>.</small>")
gimp_tunnel :
  -tunnel $1,$2%,${3-6}

#@gimp Vignette : gimp_vignette, gimp_vignette
#@gimp : Strength = float(70,0,255)
#@gimp : Min radius = float(70,0,100)
#@gimp : Max radius = float(95,0,100)
#@gimp : Color = color(0,0,0,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/24/2012</i>.</small>")
gimp_vignette :
  -repeat @# -to_rgb -l[$>]
    -to_rgba -split_opacity
    -=[-1] 0 -vignette[-1] ${1-3} -a c --fc ${4-7} -rv -blend alpha
  -endl -done

#@gimp _<b>Layers</b>
#---------------------

#@gimp Align layers : gimp_align_layers, gimp_align_layers_preview
#@gimp : Alignment type = choice(0,"Rigid","Non-rigid")
#@gimp : Smoothness = float(0.7,0,1)
#@gimp : Scales = choice(0,"Auto","1","2","3","4","5","6","7","8")
#@gimp : Revert layers = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_align_layers :
  -to_colormode 0
  -r @{-max_wh},1,100%,0,0,0.5,0.5
  -if ${4=0} -_gimp_revert_layers -endif
  -remove_opacity
  -if $1 -register_nonrigid[^-1] [-1],$2,0.1,$3
  -else -register_rigid[^-1] [-1],{3*$2}
  -endif

gimp_align_layers_preview :
  -gimp_align_layers $1,$2,0 -blend_edges 0.1

_gimp_revert_layers :
  -repeat {int(@#/2)} -rv[{2*$>},{2*$>+1}] -done

#@gimp Blend [average all] : gimp_blend_average_all, gimp_blend_average_all
#@gimp : note = note{"<small><b>Note:</b>
#@gimp : This filter takes multiple layers as input and average them. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>08/11/2013</i>.</small>")
gimp_blend_average_all :
  -if @#
    N=@# -r @{-max_wh},1,100%,0,0,0.5,0.5 -+ -/ $N
  -endif

#@gimp Blend [edges] : gimp_blend_edges, gimp_blend_edges(0)
#@gimp : Opacity = float(1,0,1)
#@gimp : Smoothness = float(0.8,0,5)
#@gimp : Revert layers = bool(0)
#@gimp : sep = separator(), note = note{"<small><b>Note:</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>01/21/2013</i>.</small>")
gimp_blend_edges :
  -repeat {int(@#/2)} -l[$>,{$>+1}] -if $3 -rv -endif --blend_edges[-2,-1] $2 -rm[-3] -blend[-2,-1] alpha,$1 -endl -done

#@gimp Blend [fade] : gimp_blend_fade, gimp_blend_fade(1)
#@gimp : Preset = choice{1,"Custom","Linear","Circular","Wave","Keftales"}
#@gimp : Offset = float(0,-1,1)
#@gimp : Thinness = float(0,0,10)
#@gimp : Sharpness = float(5,1,20)
#@gimp : Sharpest = bool(0)
#@gimp : Revert layers = bool(0)
#@gimp : Color space = choice("RGB","HSV","Lab")
#@gimp : note = note{\n<small>
#@gimp : The parameters below are used in most presets.
#@gimp : </small>}
#@gimp : 1st parameter = float(0,-1,1)
#@gimp : 2nd parameter = float(0,-1,1)
#@gimp : 3rd parameter = float(0,-1,1)
#@gimp : note = note{\n<small>
#@gimp : The formula below is used for the <i>Custom</i> preset.
#@gimp : </small>}
#@gimp : Formula = text{"cos(4*pi*x/w) * sin(4*pi*y/h)"}
#@gimp : note = note{"<small><b>Note:</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>01/21/2013</i>.</small>")
gimp_blend_fade :
  -if {@#==1} -return -endif
  -to_colormode 4
  -if {$7==1} -repeat @# -sh[$>] 0,2 -rgb2hsv[-1] -rm[-1] -done
  -elif {$7==2} -repeat @# -sh[$>] 0,2 -srgb2rgb[-1] -rgb2lab[-1] -rm[-1] -done
  -endif
  -if {$1==0} [0],[0],1,1,"$11"
  -else -_gimp_blend_fade$1 $8,$9,$10 -r[-1] [0],[0],1,1,3
  -endif
  -n[-1] {-(@#-2)*$3},{(@#-2)*(1+$3)}
  --[-1] {$2*(1+$3)*(@#-2)}
  -c[-1] 0,{@#-2}
  -if $6 -rv[^-1] -endif
  -if $5 -round[-1] 1
  -else -roundify[-1] $4
  -endif
  -blend_fade[^-1] [-1] -rm[-1]
  -if {$7==1} -repeat @# -sh[$>] 0,2 -hsv2rgb[-1] -rm[-1] -done
  -elif {$7==2} -repeat @# -sh[$>] 0,2 -lab2rgb[-1] -rgb2srgb[-1] -rm[-1] -done
  -endif
  -c 0,255

_gimp_blend_fade1 : [0],[0],1,1,"a=$1*pi/2; x*cos(a) + y*sin(a)"
_gimp_blend_fade2 : [0],[0],1,1,0 -=[-1] 1,{($1+1)*50}%,{($2+1)*50}% -distance[-1] 1
_gimp_blend_fade3 : [0],[0],1,1,0 -=[-1] 1,{($1+1)*50}%,{($2+1)*50}% -distance[-1] 1 -*[-1] {0.01+$3/2} -cos[-1]
_gimp_blend_fade4 : [0],[0],1,1,"((x-w*($1+0.5))*(y-h*($2+0.5)))%(0.2*w*h*(1.001+$3))"

#@gimp Blend [median] : blend_median, blend_median(0)
#@gimp : sep = separator(), note = note{"<small><b>Note:</b>
#@gimp : This filter needs at least two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i> and <i>Iain Fergusson</i>.      Latest update: <i>12/16/2014</i>.</small>")

#@gimp Blend [standard] : gimp_blend, gimp_blend_preview
#@gimp : Mode = choice{"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gimp : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gimp : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gimp : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gimp : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gimp : "Vivid light","Xor"}
#@gimp : Process as = choice("Two-by-two","Upper layer is the top layer for all blends","Lower layer is the bottom layer for all blends")
#@gimp : Opacity = float(1,0,1)
#@gimp : Revert layers = bool(0)
#@gimp : Preview all outputs = bool(1)
#@gimp : sep = separator(), note = note{"<small><b>Note:</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}
#@gimp : link = link("Reference page for G'MIC blending modes","https://sourceforge.net/p/gmic/wiki/Blending%20modes/")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>06/24/2014</i>.</small>")
gimp_blend :
  mode=@{-arg\ 1+$1,add,alpha,and,average,blue,burn,darken,difference,\
       divide,dodge,edges,exclusion,freeze,grainextract,grainmerge,green,hardlight,\
       hardmix,hue,interpolation,lighten,lightness,linearburn,linearlight,luminance,\
       multiply,negation,or,overlay,pinlight,red,reflect,saturation,\
       shapeaverage,shapeaverage0,softburn,softdodge,softlight,screen,stamp,subtract,value,\
       vividlight,xor}
  -if {$2==0} -repeat {int(@#/2)} -l[$>,{$>+1}] -rv -blend $mode,$3,$4 -endl -done # Two-by-two.
  -elif {$2==1" && "@#>1} -blend[^0] [0],$mode,$3,1 -rm[0]  # Top layer is top for all blends.
  -elif {$2==2" && "@#>1} -blend[^-1] [-1],$mode,$3,0 -rm[-1] # Bottom layer is bottom for all blends.
  -endif

gimp_blend_preview :
  -gimp_blend $*
  -if $5 -append_tiles , -endif

#@gimp Blend [seamless] : gimp_blend_seamless, gimp_blend_seamless_preview(1)
#@gimp : Mixed mode = bool(0)
#@gimp : Inner fading = float(0,0,100)
#@gimp : Outer fading = float(25,0,100)
#@gimp : sep = separator()
#@gimp : Output as separate layers = _bool(0)
#@gimp : sep = separator(), note = note{"<small><b>Note:</b>
#@gimp : This filter needs at least two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}
#@gimp : sep = separator(), link = link("Click here for a detailed description of this filter.","http://gimpchat.com/viewtopic.php?f=28&t=10204")
#@gimp : link = link("+ Video tutorial 1","http://www.youtube.com/watch?v=Nu-S1HmOCgE")
#@gimp : link = link("+ Video tutorial 2","http://www.youtube.com/watch?v=zsHgQY6025I")
#@gimp : link = link("+ Video tutorial 3","http://www.youtube.com/watch?v=2e6FikWMkaQ")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>05/04/2014</i>.</small>")
gimp_blend_seamless :
  -rv -to_a[^0]
  -r[^0] [0],[0],1,100%,0
  -repeat @# pos=@{"-_gimp_merge_layers["$>"] pos,0,0"} -shift[$>] @{-u\ $pos},0,0 -done
  -if $4 # Output as separate layers
    --blend_seamless $1,$2%,$3%
    -k[0,-1] -rv -sub_alpha[0] [1],1
  -else -blend_seamless $1,$2%,$3% # Output as a single layer.
  -endif

gimp_blend_seamless_preview :
  -gimp_blend_seamless ${1-3},0

#@gimp Colors to layers : gimp_colors2layers, gimp_no_preview
#@gimp : Maximum number of layers = int(16,0,256)
#@gimp : sep  = separator()
#@gimp : note = note{"<small><b>Note:</b> This filter decomposes an image into several layers each with a single color.
#@gimp : Set parameter <i>Maximum number of layers</i> to <i>0</i> to disable this constraint.
#@gimp : But be aware that it is more than risky for a regular non-quantized image!
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/08/2014</i>.</small>")
gimp_colors2layers :
  -to_rgb -round -repeat @# -l[$<]
    -if {$1==1} -break -endif

    # Estimate RGB image palette.
    --l[-1]
      -s c -<<[-3] 16 -<<[-2] 8 -+
      -sort + -s -ap "-rows 0" -a x
      -->>[-1] 8 -&[-1] 255 --&[-2] 255 ->>[-3] 16
      -a c
    -endl

    # Decompose image into separate transparent color layers.
    -if {w<=$1" || "!$1}  # No max layers.
      -repeat {w} --select_color[0] 0,@{-at[1]\ $>} --z[1] $>,$> -r[-1] 2,1,1,3 (0,255) -a[-2,-1] c -map[-2] [-1] -rm[-1] -done
      -rm[0,1]
    -else # Max layers mode.
      [0],[0],1,1,1
      -repeat {$1-1} --select_color[0] 0,@{-at[1]\ $>} --[2] [-1] --z[1] $>,$> -r[-1] 2,1,1,3 (0,255) -a[-2,-1] c -map[-2] [-1] -rm[-1] -done
      -rm[1] -*[1] 255 -a[0,1] c -mv[0] @#
    -endif

  -endl -done

#@gimp Fade layers : gimp_fade_layers, gimp_fade_layers_preview
#@gimp : Inter-frames = _int(10,2,100)
#@gimp : sep = separator(), note = note{"<small><b>Note:</b>
#@gimp : This filter needs at least two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>08/04/2012</i>.</small>")
gimp_fade_layers :
  -if {@#<2} -return -endif
  -to_colormode 0
  -r @{-max_wh},1,100%,0,0,0.5,0.5
  -a z -r 100%,100%,{(d-1)*$1+1},100%,3 -s z

gimp_fade_layers_preview :
  -if {@#<2} -return -endif
  -to_colormode 0
  -r @{-max_wh},1,100%,0,0,0.5,0.5
  -k[0,1] -+ -/ 2

#@gimp Morph layers : gimp_morph, gimp_no_preview
#@gimp : Inter-frames = _int(10,2,100)
#@gimp : Smoothness = _float(0.2,0,2)
#@gimp : Precision = _float(0.1,0,2)
#@gimp : Revert layers = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_morph :
  -if ${4=0} -_gimp_revert_layers -endif
  -to_rgb -morph $1,$2,$3

#@gimp Layers to tiles : append_tiles, gimp_append_tiles_preview(1)
#@gimp : X-tiles = int(0,0,256)
#@gimp : Y-tiles = int(0,0,256)
#@gimp : note = note("<small>For both parameters, <i>0</i> means <i>automatic</i>.</small>")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_append_tiles_preview :
  -frame 1,1,0,0,0,255 -append_tiles $1,$2

#@gimp Tiles to layers : split_tiles, gimp_tiles2layers_preview(1)
#@gimp : X-tiles = int(3,1,100)
#@gimp : Y-tiles = int(3,1,100)
#@gimp : Force tiles to have same size = _bool(false)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_tiles2layers_preview :
  -split_tiles $1,$2,$3 -to_rgba -frame 1,1,0,0,0,255 -frame 3,3,0,0,0,0 -append_tiles ,

#@gimp Tones to layers : gimp_tones2layers, gimp_tones2layers_preview(0)
#@gimp : Number of tones = int(3,2,10)
#@gimp : Start of mid-tones = int(85,0,255)
#@gimp : End of mid-tones = int(170,0,255)
#@gimp : Smoothness = float(0.5,0,5)
#@gimp : Alpha = choice("Binary","Scalar")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>04/05/2014</i>.</small>")
gimp_tones2layers :
  sval=$2 eval={max($2,$3)}
  -remove_opacity -repeat @# -l[$<]
    --luminance -rv
    -repeat {$1-1}
      [1]
      val0={$sval+($eval-$sval)*$>/($1-2)}
      val1={$sval+($eval-$sval)*($>+1)/($1-2)-1}
      --ir[0] $val0,$val1
      -if $5 -*[-1] [0] -b[-1] $4% -n[-1] 0,255  # Scalar alpha.
      -else -b[-1] $4% -n[-1] 0,255  # Binary alpha.
      -endif
      -a[-2,-1] c
    -done
    -rm[0] -rv
  -endl -done

gimp_tones2layers_preview :
  -gimp_tones2layers $* -rv
  -r {100/@#}%,{100/@#}%,1,100%,2
  -to_rgba -frame 1,1,0,0,0,255 -frame 3,3,0,0,0,0 -append_tiles ,

#@gimp Transfer colors : gimp_transfer_colors, gimp_transfer_colors
#@gimp : Transfer brighness = bool(0)
#@gimp : Revert layers = bool(0)
#@gimp : note = note{"<small><b>Note: </b>
#@gimp : The bottom layer contains the target colors.\n
#@gimp : This filter needs at least two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_transfer_colors :
  -if ${2=0} -_gimp_revert_layers -endif
  -transfer_colors[^-1] [-1],$1


#@gimp _<b>Lights &amp; shadows</b>
#----------------------------------

#@gimp Burn : gimp_burn, gimp_burn_preview(1)
#@gimp : Amplitude = float(0.5,0,1)
#@gimp : Scale = float(30,1,100)
#@gimp : Smoothness = float(1,0,4)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>11/24/2012</i>.</small>")
_gimp_burn :
  -repeat @# -l[$>]
    w={w} h={h}
    --norm
    -gimp_fourier[-1] 0
    --rows[-1] 0,{$h-1} -r[-1] $2%,$2%,1,100%,0,0,0.5,0.5 -b[-1] $3%
    -j[-2] [-1],{($w-w)/2},{($h-h)/2} -rm[-1]
    -gimp_fourier[-1] 1
    -blend overlay,$1
  -endl -done

gimp_burn :
  -apply_channels "-_gimp_burn ${1-3}",$4,1

gimp_burn_preview :
 -gimp_split_preview "-gimp_burn ${^0}",$-1

#@gimp Contrast swiss mask : gimp_contrast_swm , gimp_contrast_swm(0)
#@gimp : sep = separator()
#@gimp : Blur the mask = float(2,0.5,10)
#@gimp : sep = separator()
#@gimp : note = note ("Contrast Mask need the negative of the mask")
#@gimp : SKIP to use the mask to boost = bool(false)
#@gimp : note = note ("Uncheck for Contrast Mask,Check for Contrast Boost")
#@gimp : sep = separator()
#@gimp : note = note("Merge the Mask")
#@gimp : Intensity = float(1,0,1)
#@gimp : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update: <i>01/01/2011</i>.</small>")
#@gimp : note = link("Filter explained here","http://www.gimpchat.com/viewtopic.php?f=9&t=864")
gimp_contrast_swm :
  -repeat @# -l[$>] -split_opacity -l[0]
   --luminance -to_rgb
    -blur_xy[1] $1,$1
    -if {$2==0} -negative[1] -elif {$2==1} -gimp_do_nothing -endif
    -rv -blend hardlight,$3
  -endl -a c -endl -done

#@gimp Drop shadow : gimp_drop_shadow, gimp_drop_shadow(1)
#@gimp : X-shadow = float(3,-20,20)
#@gimp : Y-shadow = float(3,-20,20)
#@gimp : Smoothness = float(1.8,0,5)
#@gimp : Curvature = float(0,0,1)
#@gimp : Corner brightness = float(0,0,1)
#@gimp : Angle = float(0,0,360)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>11/14/2012</i>.</small>")
gimp_drop_shadow :
  -* -1 -+ 255 -vignette {255*$5},80,95 -* -1 -+ 255
  -drop_shadow $1%,$2%,$3%,$4 -rotate $6,1,0

#@gimp Drop shadow 3d : gimp_drop_shadow3d, gimp_drop_shadow3d_preview(1)
#@gimp : X-angle = float(0,-90,90)
#@gimp : Y-angle = float(0,-90,90)
#@gimp : Z-angle = float(0,-90,90)
#@gimp : Zoom = float(0,-100,100)
#@gimp : X-offset = float(1,-50,50)
#@gimp : Y-offset = float(1,-50,50)
#@gimp : Perspective = float(2,0,10)
#@gimp : Smoothness = float(0.5,0,5)
#@gimp : Color = color(0,0,0,200)
#@gimp : Preview only shadow = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>07/02/2013</i>.</small>")
gimp_drop_shadow3d :
  -repeat @# -l[$<]
    --_gimp_drop_shadow3d $*
  -endl -done

gimp_drop_shadow3d_preview :
  -repeat @# -l[$<]
    -if $13 -_gimp_drop_shadow3d $*
    -else --_gimp_drop_shadow3d $* -rv -blend alpha
    -endif
  -endl -done

_gimp_drop_shadow3d :
  -point3d 0,0,1 -r3d[-1] 1,0,0,$1 -r3d[-1] 0,1,0,$2 -r3d[-1] 0,0,1,$3
  u={i(0,8)} v={i(0,9)} w={i(0,10)} -rm[-1]
  -to_a -channels 100% -if {im==iM} -return -endif
  --f 'X=x/w-0.5;Y=y/h-0.5;A=($7-$4*$7/100)*$w/(X*$u+Y*$v+$7*$w);if(A<0,1e8,A)'
  --*[-1] 'y/h-0.5' -*[-2] 'x/w-0.5' -+[-2] {0.5-$5/100} -+[-1] {0.5-$6/100} -*[-2] {w} -*[-1] {h}
  -a[-2,-1] c -warp[0] [-1],0,1,0 -rm[-1]
  -b $8% -n 0,$12 -i[-2] ($9^$10^$11) -r[-2] [-1],[-1],1,3 -a[-2,-1] c

#@gimp Equalize shadow : gimp_equalize_shadow, gimp_equalize_shadow_preview(1)
#@gimp : Amplitude = float(1,0,1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>Francois Grassard</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>11/24/2012</i>.</small>")
gimp_equalize_shadow :
  -repeat @# -l[$>] --negative -blend softlight,$1 -endl -done

gimp_equalize_shadow_preview :
  -gimp_split_preview "-gimp_equalize_shadow $1",$-1

#@gimp Light glow : gimp_lightglow, gimp_lightglow_preview(0)
#@gimp : Density = float(30,0,100)
#@gimp : Amplitude = float(0.5,0,2)
#@gimp : Mode = choice(8,"Burn","Dodge","Freeze","Grain merge","Hard light","Interpolation",
#@gimp :               "Lighten","Multiply","Overlay","Reflect","Soft light","Stamp","Value")
#@gimp : Opacity = float(0.8,0,1)
#@gimp : note = note()
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>02/21/2011</i>.</small>")
_gimp_lightglow :
  mode=@{-arg\ 1+$3,burn,dodge,freeze,grainmerge,hardlight,interpolation,lighten,multiply,overlay,reflect,softlight,stamp,value}
  -repeat @#
    --gradient_norm[-1] ->=[-1] {100-$1}% -distance[-1] 1 -^[-1] $2 -*[-1] -1 -n[-1] 0,255 -blend $mode,$4
  -mv[-1] 0 -done

gimp_lightglow :
  -apply_channels "-_gimp_lightglow ${1-4}",$5,0

gimp_lightglow_preview :
  -gimp_split_preview "-gimp_lightglow $*",$-1

#@gimp Light patch : gimp_light_patch, gimp_light_patch(0)
#@gimp : Density = int(5,2,30)
#@gimp : Darkness = float(0.7,0,1)
#@gimp : Lightness = float(2.5,1,4)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_light_patch :
  -repeat @# -l[$>] -split_opacity -l[0]
    -apply_channels "-light_patch $1,$2,$3",$4,0
  -endl -a c -endl -done

#@gimp Light rays : gimp_lightrays, gimp_lightrays(1)
#@gimp : Density = float(80,0,100)
#@gimp : X-center (%) = float(50,0,100)
#@gimp : Y-center (%) = float(50,0,100)
#@gimp : Length = float(1,0,1)
#@gimp : Attenuation = float(0.5,0,1)
#@gimp : Transparency = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>01/03/2011</i>.</small>")
gimp_lightrays :
  -lightrays $1,$2%,$3%,$4,$5
  -if $6 -repeat @# -r[$>] 100%,100%,1,{@{$>,s}+(@{$>,s}%2)} -done -endif

#@gimp Relief light : gimp_light_relief, gimp_light_relief(1)
#@gimp : Ambient lightness = float(0.3,0,5)
#@gimp : Specular lightness = float(0.2,0,2)
#@gimp : Specular size = float(0.2,0,1)
#@gimp : Darkness = float(0,0,1)
#@gimp : Light smoothness = float(1,0,5)
#@gimp : X-light = float(0.5,0,1)
#@gimp : Y-light = float(0.5,0,1)
#@gimp : Z-light = float(5,0,20)
#@gimp : Z-scale = float(0.5,0,3)
#@gimp : Opacity as heightmap = bool(0)
#@gimp : Image smoothness = float(0,0,10)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_light_relief :
  -b $11% -light_relief ${1-10}

#@gimp Shadow patch : gimp_shadow_patch, gimp_shadow_patch(1)
#@gimp : Opacity = float(0.7,0,1)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_shadow_patch :
  -repeat @# -l[$>] -split_opacity -l[0]
    -apply_channels "-shadow_patch $1",$2,0
  -endl -a c -endl -done

#@gimp _<b>Patterns</b>
#----------------------

#@gimp Bayer filter : rgb2bayer, rgb2bayer(0)
#@gimp : Starting pattern = choice(0,"Red-Green","Blue-Green","Green-Red","Green-Blue")
#@gimp : Keep colors = bool(1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")

#@gimp Box fitting : gimp_boxfitting, gimp_boxfitting_preview(0)
#@gimp : Minimal size = int(3,1,32)
#@gimp : Maximal size = int(0,0,32)
#@gimp : note = note("<small><b>Note:</b> Set <i>Maximal size</i> to <i>0</i> to allow any size for the squares.</small>")
#@gimp : Initial density = float(0.1,0,1)
#@gimp : Transparency = bool(0)
#@gimp : sep = separator(), note = note("<small><b>Note:</b> This filter has been highly inspired by the work of Jared Tarbell, described on the page:</small>")
#@gimp : link = link("http://www.complexification.net/gallery/machines/boxFittingImg/")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>06/06/2013</i>.</small>")
gimp_boxfitting :
  -boxfitting ${1-3},3
  -if $4 -to_rgba -replace_color 0,0,0,0,0,255,0,0,0,0 -endif

gimp_boxfitting_preview :
  -boxfitting ${1-3},1
  -if $4 -to_rgba -replace_color 0,0,0,0,0,255,0,0,0,0 -endif

#@gimp Canvas : gimp_canvas, gimp_canvas_preview(0)
#@gimp : note = note{"<b>First direction :</b>"}
#@gimp : Amplitude = float(70,0,300)
#@gimp : Angle = float(45,0,180)
#@gimp : Sharpness = float(400,0,2000)
#@gimp : note = note{"\n<b>Second direction : </b>"}
#@gimp : Activate second direction = bool(true)
#@gimp : Amplitude = float(70,0,300)
#@gimp : Angle = float(135,0,180)
#@gimp : Sharpness = float(400,0,2000)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_canvas :
  -repeat @# -l[-1]
    -if $4
      ({cos($2*pi/180)}^{sin($2*pi/180)}) -vector2tensor[-1] -r[-1] [-2],[-2] --smooth[-2] [-1],$1 -rm[-2] -sharpen[-1] $3 -c[-1] 0,255
      ({cos($6*pi/180)}^{sin($6*pi/180)}) -vector2tensor[-1] -r[-1] [-2],[-2] -smooth[-3] [-1],$5 -rm[-1] -sharpen[-2] $7 -c[-2] 0,255 -+[-2,-1] -/[-1] 2
    -else
      ({cos($2*pi/180)}^{sin($2*pi/180)}) -vector2tensor[-1] -r[-1] [-2],[-2] -smooth[-2] [-1],$1 -rm[-1] -sharpen[-1] $3 -c[-1] 0,255
    -endif
  -endl -mv[-1] 0 -done

gimp_canvas_preview :
  -gimp_split_preview "-gimp_canvas $*",$-1

#@gimp Canvas texture : texturize_canvas, texturize_canvas(0)
#@gimp : Amplitude = float(20,0,256)
#@gimp : Fibrousness = float(3,0,20)
#@gimp : Emboss = float(0.6,0,1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")

#@gimp Cracks : gimp_cracks, gimp_cracks_preview(0)
#@gimp : Density = float(1,0.1,10)
#@gimp : Amplitude = float(-80,-255,255)
#@gimp : Relief = bool(true)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_cracks :
  -apply_channels "-cracks $1,$2,$3",$4,0

gimp_cracks_preview :
  -gimp_split_preview "-gimp_cracks $*",$-1

#@gimp Crystal : gimp_crystal, gimp_crystal_preview(0)
#@gimp : Density = float(50,0,100)
#@gimp : Smoothness = float(0.2,0,2)
#@gimp : Edges = float(20,0,100)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>01/19/2015</i>.</small>")
gimp_crystal :
  -repeat @# -l[$>] -split_opacity -l[0]
    s={s}
    --gradient_norm ->=[-1] {(100-$3)/5} -remove_pixels[-1] {100-max(0.1,$1*$3%)}%,@{-1,+} -*
    --norm -neq[-1] 0 -a c
    sigma=0.2
    -do
      --b[-1] $sigma sigma={$sigma*(1+$2)}
      -sh[0,-1] $s,$s -max[-1] [-2] -rm[-2,-1]
      -f[-1] 'W=i(x,y,z,$s);if(W<0.001||W>=1,0,if(c<$s,i/W,1))'
      -if {!iM} -rm[1] -break -endif
      -sh[-1] $s,$s
      -j[0] [1],0,0,0,0,1,[2] -k[0]
    -while 1
    -channels 0,{$s-1}
  -endl -a c -endl -done

gimp_crystal_preview :
  -gimp_split_preview "-gimp_crystal $*",$-1

#@gimp Halftone : gimp_halftone, gimp_halftone_preview(0)
#@gimp : note = note("<b><small>Image parameters :</small></b>")
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Smoothness = float(0,0,10)
#@gimp : sep = separator(), note = note("<b><small>Halftone parameters :</small></b>")
#@gimp : Number of tones = int(5,2,32)
#@gimp : Size for dark tones = int(8,2,256)
#@gimp : Size for bright tones = int(8,2,256)
#@gimp : Shape = choice{5,"Square","Diamond","Circle","Square (inv.)","Diamond (inv.)","Circle (inv.)"}
#@gimp : Smoothness = float(0.1,0,32)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>07/23/2012</i>.</small>")
gimp_halftone :
  -apply_gamma {10^$1} -- 128 -* $2 -+ 128 -+ $3 -b $4 -c 0,255
  -repeat @# -l[$>] -split_opacity
    -halftone[0] ${5-9}
  -a c -endl -done

gimp_halftone_preview :
  -gimp_split_preview "-gimp_halftone $*",$-1

#@gimp Hearts : gimp_hearts, gimp_hearts_preview(0)
#@gimp : Density = float(10,0,100)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_hearts :
  -apply_channels "-hearts $1",$2,0

gimp_hearts_preview :
  -gimp_split_preview "-gimp_hearts $*",$-1

#@gimp Lava : gimp_lava, gimp_lava_preview(0)
#@gimp : Perturbation = int(8,0,15)
#@gimp : Smoothness = float(5,0,100)
#@gimp : Scale = float(3,0,20)
#@gimp : Sharpness = float(0,0,1000)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>11/26/2012</i>.</small>")
gimp_lava :
  -repeat @# -l[$>] -split_opacity -l[0] -norm
    100%,100% -plasma[-1] 1,1,{16-$1} -smooth[-1] $2,0,1,$3,$3,0.8,90 -*
    -gradient_norm -n 0,255
    -equalize -map 3
    -sharpen $4
  -endl -a c -endl -done

gimp_lava_preview :
  -gimp_split_preview "-gimp_lava $*",$-1

#@gimp Marble : gimp_marble, gimp_marble
#@gimp : Image weight = float(.5,0,30)
#@gimp : Pattern weight = float(1,0,30)
#@gimp : Pattern angle = float(0,0,360)
#@gimp : Amplitude = float(0,0,1000)
#@gimp : Sharpness = float(.4,0,5)
#@gimp : Anisotropy = float(.6,0,1)
#@gimp : Alpha = float(.6,0,20)
#@gimp : Sigma = float(1.1,0,20)
#@gimp : Cut low = float(0,0,100)
#@gimp : Cut high = float(100,0,100)
#@gimp : sep = separator(), note = note("<small>Author: <i>Preben Soeberg</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_marble :
  -repeat @# -l[$>] -split_opacity -l[0]
    -marble $1/10,$2/10,$3,$4,$5,$6,$7,$8,$9%,$10%
  -endl -a c -endl -done

#@gimp Maze : gimp_maze, gimp_maze
#@gimp : Cell size = int(24,1,256)
#@gimp : Thickness = int(1,1,10)
#@gimp : Masking = choice("None","Render on dark areas","Render on white areas")
#@gimp : Preserve image dimension = bool(1)
#@gimp : Maze type = choice("Dark walls","White walls")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>09/02/2011</i>.</small>")
gimp_maze :
  -repeat @#
    w={w} h={h}
    -r[-1] {100/$1}%,{100/$1}%,1,100%,2
    -if {$3==0} -f[-1] 1
    -elif {$3==1} -negative[-1]
    -endif
    -maze_mask[-1] $1 -dilate[-1] $2 -*[-1] 255
    -if {!$5} -negative[-1] -endif
    -if $4 -r[-1] $w,$h,100%,100% -endif
  -mv[-1] 0 -done

#@gimp Mineral mosaic : gimp_mineral_mosaic,gimp_mineral_mosaic(0)
#@gimp : Density = float(1,0,3)
#@gimp : Area = float(2,0,32)
#@gimp : Smoothness = float(1,0,10)
#@gimp : Shade strength = float(100,0,255)
#@gimp : Shade angle = float(0,0,360)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>02/01/2013</i>.</small>")
gimp_mineral_mosaic :
  -repeat @# -l[$>] -to_rgb
    --b $3 -segment_watershed[-1] $1 --norm[-1]
    -area[-1] 0 --<=[-1] {$2^2} -inpaint[-2] [-1] -rm[-1] -label[-1]
    --f[0] 'if(c==0,x,y)' --blend[-2,-1] shapeaverage,1,1
    --[-2,-1] -rm[0,2] -channels[-1] 0,1
    alpha={$5*pi/180} -sh[-1] 0,0 -*[-1] {cos($alpha)} -rm[-1] -sh[-1] 1,1 -*[-1] {sin($alpha)} -rm[-1] -compose_channels[-1] +
    -normalize_local[-1] 1000 -n[-1] -$4,$4
    -+ -c 0,255
  -endl -done

#@gimp Mosaic : gimp_mosaic, gimp_mosaic_preview(0)
#@gimp : Density = float(1,0.1,10)
#@gimp : Keep edges = bool(true)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_mosaic :
  -apply_channels "-mosaic $1,$2",$3,0

gimp_mosaic_preview :
  -gimp_split_preview "-gimp_mosaic $*",$-1

#@gimp Op art : gimp_shapes,gimp_shapes_preview(0)
#@gimp : Shape = choice{1,"Custom layers","Circles","Squares","Diamonds","Triangles","Horizontal stripes","Vertical stripes","Balls","Hearts","Stars","Arrows","Truchet",
#@gimp : "Circles (outline)","Squares (outline)","Diamonds (outline)","Triangles (outline)","Hearts (outline)","Stars (outline)","Arrows (outline)"}
#@gimp : Number of scales = int(16,2,24)
#@gimp : Resolution = float(10,1,50)
#@gimp : Zoom factor = _int(2,1,8)
#@gimp : Minimal size = float(5,0,150)
#@gimp : Maximal size = float(90,0,150)
#@gimp : Stencil type = choice(0,"Black & white","RGB","Color")
#@gimp : Allow angle = choice("0 deg.","90 deg.","180 deg.")
#@gimp : Negative = bool(1)
#@gimp : Antialiasing = bool(1)
#@gimp : sep = separator()
#@gimp : note = note{"<small><b>Note:</b>
#@gimp : If you set the parameter <i>Shape</i> to <i>Custom layers</i>, the different shapes used to map the pixel intensities will be defined as
#@gimp : the <i>Number of scales</i> top layers of your image. Don't forget to set also <i>Input layers</i> to <i>All</i> to be sure
#@gimp : these layers are passed to the filter.
#@gimp : </small>"}
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/16/2013</i>.</small>")
gimp_shapes :
  -if $1 # Pre-defined shapes.
    -remove_opacity -repeat @# -l[$>]
      -if {!$7} -_gimp_shapes $* -* 255
      -elif {$7==1} -split_opacity -to_rgb[0] -s[0] c -repeat 3 -_gimp_shapes[$>] $* -done -*[0-2] 255 -a[0-2] c -a c
      -else --_gimp_shapes $* -r[0] $3%,$3% -r[0] [1],[1] -*
      -endif
    -endl -done
  -else # Custom shapes.
    -if {@#<=$2} -error[] "Command '-gimp_shapes': Some layers are missing in 'Custom layers' mode ("{$2+1}" expected at least, "@#" provided)." -endif
    -to_colormode[0-{$2-1}] @{-max_s[0-{$2-1}]} -remove_opacity[$2--1]
    -repeat {@#-$2} -l[0-{$2-1},{$2+$>}]
      -norm[-1] w={w} h={h} -r[-1] $3%,$3%,1,1,2
      s={$4*max(round($w/w),round($h/h))}
      r0={$s*$5%} r1={$s*$6%}
      -repeat $2 r={round($r0+$>*($r1-$r0)/($2-1))} -if $r --r[$>] $r,$r,1,100%,3 -else 1,1 -endif -done
      -r[-$2--1] $s,$s,1,100%,0,0,0.5,0.5
      -map_sprites[$2--1] $2,$8
    -endl -done -rm[0-{$2-1}]
  -endif

gimp_shapes_preview :
  -if $1 -repeat @# -l[$>]
    w={w} h={h}
    -gimp_split_preview "-gimp_shapes ${1-3},1,${5--2}",$-1
    -r $w,$h,1,100%,0,0,0.5,0.5
    -endl -done
  -else
    -if {@#>$2} -repeat {@#-$2} -l[0-{$2-1},{$2+$>}]
      w={w} h={h}
      --gimp_shapes ${1-3},1,${5--2} -rm[-2]
      -r[-1] $w,$h,1,100%,0,0,0.5,0.5
    -endl -done -rm[0-{$2-1}]
    -else -gimp_warning_preview "Missing input layers!"
    -endif
  -endif

_gimp_shapes :
  -norm w={w} h={h} -r $3%,$3%,1,1,2
  s={(1+$10)*$4*max(round($w/w),round($h/h))}
  r0={$s*$5%} r1={$s*$6%}
  -repeat $2 r={round($r0+$>*($r1-$r0)/($2-1))} -if $r -_gimp_shapes{$1-1}[] $r,$s -else 1,1 -endif -done
  -r[-$2--1] $s,$s,1,1,0,0,0.5,0.5
  -if $9 -rv[-$2--1] -*[-$2--1] -1 -+[-$2--1] 1 -endif
  -map_sprites $2,$8
  -if $10 -r 50%,50%,1,1,2 -endif

_gimp_shapes0 :
  -_dt_circle[] $1

_gimp_shapes1 :
  $1,$1,1,1,1

_gimp_shapes2 :
  $1,$1,1,1 -= 1,50%,50% -distance 1,1 -< {$1/2}

_gimp_shapes3 :
  $2,$2,1,1,'x+y<=2*$1-1'

_gimp_shapes4 :
  $2,$1,1,1,1

_gimp_shapes5 :
  $1,$2,1,1,1

_gimp_shapes6 :
  -ball $1,200 -n 0,1

_gimp_shapes7 :
  -heart 65 -r $1,$1,1,1,2 ->= 50%

_gimp_shapes8 :
  -star $1,$1

_gimp_shapes9 :
  -arrow3d 0,0,0,1,0,0,15%,40%,30% -col3d 1 -*3d $1 -c3d
  $2,$2 -j3d[-1] [-2],50%,50%,0,1,2,0,0
  -rm[-2] --mirror y -max

_gimp_shapes10 :
  S={$2+1-($2%2)}
  $S,$S,1,1,"X=x/(w-1);Y=y/(h-1);r=abs(0.5-sqrt(X^2+Y^2));a=atan2(y,x);r<0.1-0.17*(0.5-$1/$2)*sin(2*a)"
  --mirror xy -max

_gimp_shapes11 :
  -_gimp_shapes0 $* -expand_xy 1,0 --erode 3 --

_gimp_shapes12 :
  -_gimp_shapes1 $* -expand_xy 1,0 --erode 3 --

_gimp_shapes13 :
  -_gimp_shapes2 $* -expand_xy 1,0 --erode 3 --

_gimp_shapes14 :
  -_gimp_shapes3 $* -expand_xy 1,0 --erode 3 --

_gimp_shapes15 :
  -_gimp_shapes7 $* -expand_xy 1,0 --erode 3 --

_gimp_shapes16 :
  -_gimp_shapes8 $* -expand_xy 1,0 --erode 3 --

_gimp_shapes17 :
  -_gimp_shapes9 $* -expand_xy 1,0 --erode 3 --

#@gimp Pack sprites : gimp_pack_sprites, gimp_no_preview
#@gimp : Number of scales = int(5,1,16)
#@gimp : Minimal scale (%) = float(25,1,100)
#@gimp : Allow angle = choice(3,"0 deg.","180 deg.","90 deg.","Any")
#@gimp : Spacing = int(1,-16,16)
#@gimp : Precision = int(7,1,32)
#@gimp : sep = separator()
#@gimp : Masking = choice("No masking","Mask as bottom layer")
#@gimp : Width = int(512,32,2048)
#@gimp : Height = int(512,32,2048)
#@gimp : note = note("<small><b>Notes:</b>\n - Parameters <i>Width</i> and <i>Height</i> are considered only when <i>No masking</i> mode is selected.\n
#@gimp : - Set different sprites on different layers to pack multiple sprites at the same time.</small>")
#@gimp : link = link("Click here for a video tutorial","http://www.youtube.com/watch?v=bpg7CGH7vCM")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>06/24/2013</i>.</small>")
gimp_pack_sprites :
  -if $6 # With mask.
    -if {@#<2} -error[] "Command '-gimp_pack_sprites': Masking requires at least two input layers ! (please check that 'Input Layers' is correctly set)." -endif
    -repeat {@#-1} -l[$>] -to_rgba -split_opacity --!=[1] 0 -*[0] [-1] -a c -autocrop 0 -endl -done
    -remove_empty[0--2] --channels[-1] 100% -channels[-1] -4,0 -mv[-1] 0
    -pack_sprites[0--2] ${1-5}
  -else # No masking
    -repeat @# -l[$>] -to_rgba -split_opacity --!=[1] 0 -*[0] [-1] -a c -autocrop 0 -endl -done
    -remove_empty -i[0] $7,$8,1,5 -pack_sprites ${1-5}
  -endif
  -channels[0] 0,@{0,s-2}

#@gimp Paper texture : gimp_paper, gimp_paper_preview(0)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_paper :
  -apply_channels "-texturize_paper",$1,0

gimp_paper_preview :
  -gimp_split_preview "-gimp_paper $*",$-1

#@gimp Plaid : gimp_plaid_texture,gimp_plaid_texture(1)
#@gimp : Line = float(50,0,100)
#@gimp : Number of angles = int(2,1,8)
#@gimp : Starting angle = float(0,0,360)
#@gimp : Angle range = float(90,0,360)
#@gimp : Smoothness = float(1,0,5)
#@gimp : Sharpen = float(300,0,1000)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>05/16/2011</i>.</small>")
gimp_plaid_texture :
  -repeat @# -l[$>]
    w={w} h={h} s={s}
    -rows $1%
    -b $5% -sharpen $6
    -r $w,$h,1,$s,2
    --rotate[0] $3,1,2,50%,50%
    -repeat {$2-1} --rotate[0] {$3+$4*($>+1)/($2-1)},1,2,50%,50% -+[-2,-1] -done -rm[0]
    -/ $2
  -endl -done

#@gimp Plasma : gimp_plasma, gimp_plasma(0)
#@gimp : Alpha = float(0.5,0,5)
#@gimp : Beta = float(0,0,100)
#@gimp : Scale = int(8,2,10)
#@gimp : Randomize = bool(0)
#@gimp : Transparency = bool(0)
#@gimp : Color balance = color(128,128,128)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>03/20/2011</i>.</small>")
gimp_plasma : -skip ${4=0},${5=0}
  -if $5 -to_rgba -else -to_rgb -endif
  -if $4 -rand 0,255 -endif
  -plasma $1,$2,$3 -n 0,255
  -balance_gamma ${6-8}

#@gimp Polka dots : gimp_polka_dots, gimp_polka_dots(1)
#@gimp : Size = float(80,0,100)
#@gimp : Density = float(20,0.1,100)
#@gimp : First offset = float(50,0,100)
#@gimp : Second offset = float(50,0,100)
#@gimp : Angle = float(0,0,180)
#@gimp : Aliasing = float(0.5,0.1,1)
#@gimp : Shading = float(0.1,0.1,1)
#@gimp : Opacity = float(1,0,1)
#@gimp : Color = color(255,0,0,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_polka_dots :
  -to_rgba -polka_dots {$1*$2/100},${2--1}

#@gimp Random color ellipses : gimp_color_ellipses, gimp_color_ellipses(1)
#@gimp : Density = int(400,0,3000)
#@gimp : Radius = float(8,0,30)
#@gimp : Opacity = float(0.1,0.01,0.5)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_color_ellipses :
  -color_ellipses $1,$2,$3

#@gimp Resynthetize texture : syntexturize, gimp_syntexturize_preview(1)
#@gimp : Width = int(1024,32,8192)
#@gimp : Height = int(1024,32,8192)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator()
#@gimp : note = note{"<small><b>Note:</b> This filter tries to re-synthetize a <b>micro</b>-texture (given as the input image) onto an output (seamless) image with an arbitrary size.
#@gimp : It uses a phase randomization technique, as described in:</small>"}
#@gimp : link = link("Micro-Texture Synthesis by Phase Randomization","http://www.ipol.im/pub/art/2011/ggm_rpn/")
#@gimp : note = note("<small>This filter is based on the work of <i>Bruno Galerne</i>, <i>Yann Gousseau</i> and <i>Jean-Michel Morel</i>.</small>")
#@gimp : sep = separator(), link = link("Click here for a detailed description of this filter.","http://gimpchat.com/viewtopic.php?f=28&t=10141")
#@gimp : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i> and <i>J&#233;rome Boulanger</i>.      Latest update: <i>04/09/2014</i>.</small>")
gimp_syntexturize_preview :
  -gimp_split_preview "-syntexturize 100%",$-1

#@gimp Rorschach : gimp_rorschach, gimp_rorschach
#@gimp : Scale = float(3,0,10)
#@gimp : Mirror = choice(1,"None","x-axis","y-axis","xy-axes")
#@gimp : Stencil type = choice(2,"Black & White","RGB","Color")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>03/12/2011</i>.</small>")
gimp_rorschach :
  -repeat @# -remove_opacity -l[$>]
    -if {$3==0} -norm -rorschach $1%,$2 -* 255
    -elif {$3==1} -to_rgb -rorschach $1%,$2 -* 255
    -else --norm -rorschach[-1] $1%,$2 -blend shapeaverage0
    -endif
  -endl -done

#@gimp Seamless turbulence : gimp_seamless_turbulence, gimp_seamless_turbulence(0)
#@gimp : Amplitude = float(15,0,30)
#@gimp : Smoothness = float(20,0,40)
#@gimp : Orientation = float(0,0,180)
#@gimp : Deviation = float(1,0,1)
#@gimp : Contrast = float(3,0,4)
#@gimp : Color rendering = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>04/02/2013</i>.</small>")
gimp_seamless_turbulence :
  -repeat @# -l[$>]
    wh={w},{h} -rm
    $wh,1,{if($6,3,1)} -rand[-1] 0,255
    $wh -rand[-1] {$3*pi/180-$4*10*pi},{$3*pi/180+$4*10*pi} --sin[-1] -cos[-2] -a[-2,-1] c
    -r[-2,-1] 130%,130%,1,100%,0,2,0.5,0.5 -b[-1] $2 -orientation[-1]
    -vector2tensor[-1]
    -smooth[-2] [-1],$1,0.5,20 -rm[-1]
    -r[-1] $wh,1,100%,0,0,0.5,0.5
    -if {$5!=1} ia={ia} -- $ia -* $5 -+ $ia -endif
  -endl -done
  -c 0,255 -n 0,255

#@gimp Shock waves : gimp_shockwaves, gimp_shockwaves_preview
#@gimp : Amplitude = float(10,0,100)
#@gimp : Low frequency = float(10,0,100)
#@gimp : Frequency range = float(20,0,100)
#@gimp : sep = separator()
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/01/2014</i>.</small>")
_gimp_shockwaves :
  -dct
  100%,100%,1,1,1 -circle[-1] 0,0,{$2+$3}%,1,{$1+1} -circle[-1] 0,0,$2%,1,1
  -* -idct -c 0,255

gimp_shockwaves :
  -apply_channels "-_gimp_shockwaves ${1-3}",$4,0

gimp_shockwaves_preview :
  -gimp_split_preview "-gimp_shockwaves $*",$-1

#@gimp Sponge : gimp_sponge, gimp_sponge_preview(0)
#@gimp : Size = int(13,3,21)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_sponge :
  -apply_channels "-sponge $1",$2,0

gimp_sponge_preview :
  -gimp_split_preview "-gimp_sponge $*",$-1

#@gimp Stained glass : gimp_stained_glass, gimp_stained_glass_preview(0)
#@gimp : Edges = float(20,0,100)
#@gimp : Shading = float(0.1,0,0.5)
#@gimp : Thin separators = bool(1)
#@gimp : sep = separator()
#@gimp : Equalize = bool(1)
#@gimp : Colors = float(1,0,3)
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>03/18/2011</i>.</small>")
gimp_stained_glass :
  -repeat @# -l[$>] -split_opacity -l[0] -to_rgb
    -stained_glass $1,$2,$3
    -n 0,255
    -if $4 -equalize[-1] -endif
    -rgb2lab[-1] -sh[-1] 1,2 -*[-1] $5 -rm[-1] -lab2rgb[-1]
    -apply_gamma[-1] {10^$6} --[-1] 128 -*[-1] $7 -+[-1] {128+$8}
    -c[-1] 0,255
  -endl -a c -endl -done

gimp_stained_glass_preview :
  -gimp_split_preview "-gimp_stained_glass $*",$-1

#@gimp Stars : gimp_stars, gimp_stars(0)
#@gimp : Density = float(10,0,200)
#@gimp : Depth = float(0,0,5)
#@gimp : Size = int(32,8,128)
#@gimp : Branches = int(5,3,16)
#@gimp : Thickness = float(0.38,0.1,1)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Color = color(255,255,100,200)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/01/2012</i>.</small>")
gimp_stars :
  -repeat @# -l[$>] -split_opacity -rv
    -stars $1%,$2,$3,$4,$5,$6%,${7-9},{$10/255}
  -rv -a c -endl -done

#@gimp Stencil : gimp_stencil, gimp_stencil_preview(0)
#@gimp : Radius = float(3,0,10)
#@gimp : Smoothness = float(0,0,30)
#@gimp : Iterations = int(8,1,100)
#@gimp : Aliasing = float(0,0,5)
#@gimp : Stencil type = choice(2,"Black & White","RGB","Color")
#@gimp : Transparency = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_stencil :
  -v -
  -if {$5==0} -norm -stencil $1,$2,$3
  -elif {$5==1} -stencil $1,$2,$3
  -else -repeat @#
    --norm[-1] -stencil[-1] $1,$2,$3 ->=[-1] 50% -blend[-2,-1] shapeaverage0
  -mv[-1] 0 -done -endif
  -if $6 -to_rgba -replace_color 0,0,0,0,0,255,0,0,0,0 -endif
  -if $4 -smooth {30*$4},0,1,1 -endif

gimp_stencil_preview :
  -gimp_split_preview "-gimp_stencil $*",$-1

#@gimp Tetris : gimp_tetris, gimp_tetris(0)
#@gimp : Scale = int(10,1,20)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_tetris :
  -tetris $1

#@gimp Truchet : gimp_truchet, gimp_truchet(0)
#@gimp : Scale = int(32,1,256)
#@gimp : Radius = int(5,1,64)
#@gimp : Smoothness = float(1,0,10)
#@gimp : Type = choice(1,"Straight","Curved")
#@gimp : Color = choice("White on black","Black on white","White on transparent","Black on transparent","Transparent on white","Transparent on black","Random")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/26/2011</i>.</small>")
gimp_truchet :
  -repeat @# -l[$>]
    100%,100% -truchet $1,$2,$4 -rm[-2]
    -if {$5==1} -* -1
    -elif {$5==2} -i[0] 100%,100%,1,1,1
    -elif {$5==3} -i[0] 100%,100%
    -elif {$5==4} -* -1 -i[0] 100%,100%
    -elif {$5==5} -* -1 -i[0] 100%,100%,1,1,-1
    -elif {$5==6} -label 0,1 {iM+1},1,1,3 -rand[-1] 0,255 -map[-2] [-1] -rm[-1]
    -endif
    -a c -b $3 -n 0,255
  -endl -done

#@gimp Turbulence : gimp_turbulence, gimp_turbulence
#@gimp : Radius = float(128,1,1024)
#@gimp : Octaves = int(6,1,12)
#@gimp : Damping per octave = float(4,1,10)
#@gimp : Difference mixing = float(0,-10,10)
#@gimp : Mode = choice("Turbulence","Turbulence 2","Fractal Noise","Fractured Clouds","Stardust","Pea Soup")
#@gimp : sep = separator(), note = note("<small>Author: <i>Preben Soeberg</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_turbulence :
  -repeat @# -l[$>] -split_opacity -l[0]
    -turbulence ${^0}
  -endl -a c -endl -done

#@gimp Weave : weave, weave(1)
#@gimp : Density = int(6,1,32)
#@gimp : Thickness = float(65,0,100)
#@gimp : Shadow = float(0,0,100)
#@gimp : Shading = float(0.5,0,3)
#@gimp : Fibers amplitude = float(0,0,255)
#@gimp : Fibers smoothness = float(0,0,10)
#@gimp : Angle = choice("0 deg.","22.5 deg.","45 deg.","67.5 deg.")
#@gimp : X-curvature = float(0,-1,1)
#@gimp : Y-curvature = float(0,-1,1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>01/18/2013</i>.</small>")

#@gimp Whirls : gimp_whirls, gimp_whirls_preview(0)
#@gimp : Density = int(7,3,20)
#@gimp : Smoothness = float(2,0,10)
#@gimp : Darkness = float(0.2,0,1)
#@gimp : Lightness = float(1.8,1,3)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_whirls :
  -apply_channels "-whirls $1,$2,$3,$4",$5,0

gimp_whirls_preview :
  -gimp_split_preview "-gimp_whirls $*",$-1


#@gimp _<b>Repair</b>
#---------------------

#@gimp Bayer reconstruction : bayer2rgb, gimp_no_preview
#@gimp : G/M smoothness = _float(6,0,20)
#@gimp : R/B smoothness (principal) = _float(6,0,20)
#@gimp : R/B smoothness (secondary) = _float(4,0,20)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")

#@gimp Deinterlace : deinterlace, gimp_deinterlace_preview(0)
#@gimp : Algorithm = choice("Standard","Motion-compensated")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_deinterlace :
  -deinterlace 0 -skip ${^0}

gimp_deinterlace_preview :
  -gimp_split_preview "-gimp_deinterlace $*",$-1

#@gimp Inpaint [diffusion] : gimp_inpaint_diffusion, gimp_inpaint_diffusion_preview(0)
#@gimp : Smooth inpaint = bool(true)
#@gimp : Global iterations = int(10,1,30)
#@gimp : Local iterations = int(10,1,30)
#@gimp : Time step = float(20,5,50)
#@gimp : Gradient smoothness = float(0.7,0,5)
#@gimp : Tensor smoothness = float(1.2,0,5)
#@gimp : sep = separator()
#@gimp : Mask type = choice(1,"Opaque regions in top layer","Mask by color")
#@gimp : note = note("<small>If <i>Mask by color</i> has been selected :</small>")
#@gimp : Mask color = color(255,0,0,255)
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Note:</b>
#@gimp : When <i>'Mask by color'</i> mode is selected, preview is likely to be inaccurate.
#@gimp : </small>")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_inpaint_diffusion :
  -if $7 # Mask by color.
    -repeat @# -l[$>]
      --select_color 0,${8-11} -rv
      -if $1 -inpaint_flow $2,$3,$4,$5%,$6% -c 0,255 -else -inpaint[1] [0] -endif
      -rm[0]
    -endl -done
  -else # Mask by top layer.
    -if {@#==1} -return -endif
    -to_a[0] -channels[0] 100% ->=[0] 50%
    -if $1 -inpaint_flow $2,$3,$4,$5%,$6% -c 0,255 -else -inpaint[^0] [0] -endif
    -to_a[0] -f[0] 0
  -endif

gimp_inpaint_diffusion_preview :
  -gimp_inpaint_diffusion ${^0}
  -if {!$7" && "@#>1} -rm[0] -endif

#@gimp Inpaint [holes] : gimp_inpaint_holes, gimp_inpaint_holes(0)
#@gimp : Maximal area = float(4,1,512)
#@gimp : Tolerance = float(20,0,255)
#@gimp : Connectivity = choice(1,"Low","High")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>05/27/2014</i>.</small>")
gimp_inpaint_holes :
  -inpaint_holes {$1^1.5},$2,$3

#@gimp Inpaint [patch-based] : gimp_inpaint_patch, gimp_no_preview
#@gimp : Patch size = int(7,1,64)
#@gimp : Lookup size = float(16,1,32)
#@gimp : Lookup factor = float(0.1,0,1)
#@gimp : Blend size = float(1.2,0,5)
#@gimp : Blend threshold = float(0,0,1)
#@gimp : Blend decay = float(0.05,0,0.5)
#@gimp : Blend scales = int(10,1,20)
#@gimp : Allow outer blending = bool(1)
#@gimp : sep = separator()
#@gimp : Mask type = choice(1,"Opaque regions in top layer","Mask by color")
#@gimp : note = note("<small>If <i>Mask by color</i> has been selected :</small>")
#@gimp : Mask color = color(255,0,0,255)
#@gimp : sep = separator(), note = note("<small>A quick tutorial on how to use this filter can be found here:</small>")
#@gimp : link = link("G'MIC Inpainting tutorial on Patrick David's blog.","http://blog.patdavid.net/2014/02/getting-around-in-gimp-gmic-inpainting.html")
#@gimp : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i> and <i>Maxime Daisy</i>.      Latest update: <i>03/25/2013</i>.</small>")
gimp_inpaint_patch :
  -if $9 # Mask by color.
    -repeat @# -l[$>]
      --select_color 0,${10-13}
      -inpaint[0] [1],$1,{$1*$2},$3,1,{$4*$1},${5-8}
      -rm[1]
    -endl -done
  -else # Mask by top layer.
    -if {@#==1} -return -endif
    -to_a[0] -channels[0] 100% ->=[0] 50%
    -inpaint[^0] [0],$1,{$1*$2},$3,1,{$4*$1},${5-8}
    -to_a[0] -f[0] 0
  -endif

#@gimp Inpaint [solidify] : gimp_solidify, gimp_solidify_preview(0)
#@gimp : Interpolation type = choice("Linear","Morphological")
#@gimp : sep = separator(), note = note("<small><b>For linear method only :</b></small>")
#@gimp : Smoothness = float(1.5,1,5)
#@gimp : Smoothness factor = float(1,1,1.2)
#@gimp : Precision = float(0.5,0,1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small><b>Note:</b>
#@gimp : This filter replaces transparent regions by interpolated colors. It may take long to render!
#@gimp : </small>")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/01/2011</i>.</small>")
gimp_solidify :
  -if $1 -solidify
  -else -solidify_linear $2,$3,$4
  -endif

gimp_solidify_preview :
  -gimp_split_preview "-gimp_solidify $*",$-1

#@gimp Red-eye attenuation : red_eye, red_eye
#@gimp : Threshold = float(75,0,100)
#@gimp : Smoothness = float(3.5,0,20)
#@gimp : Factor = float(0.1,0,1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")

#@gimp Remove hot pixels : gimp_remove_hotpixels, gimp_remove_hotpixels_preview(0)
#@gimp : Mask size = int(3,3,20)
#@gimp : Threshold = float(10,0,200)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>J&#233;rome Boulanger</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_remove_hotpixels :
  -remove_hotpixels $1,$2

gimp_remove_hotpixels_preview :
  -gimp_split_preview "-gimp_remove_hotpixels $*",$-1

#@gimp Smooth [anisotropic] : gimp_anisotropic_smoothing, gimp_anisotropic_smoothing_preview(0)
#@gimp : Amplitude = float(60,0,1000)
#@gimp : Sharpness = float(0.7,0,2)
#@gimp : Anisotropy = float(0.3,0,1)
#@gimp : Gradient smoothness = float(0.6,0,10)
#@gimp : Tensor smoothness = float(1.1,0,10)
#@gimp : Spatial precision = float(0.8,0.1,2)
#@gimp : Angular precision = float(30,1,180)
#@gimp : Value precision = float(2,0.1,5)
#@gimp : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gimp : Fast approximation = bool(1)
#@gimp : Iterations = int(1,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>08/27/2013</i>.</small>")
gimp_anisotropic_smoothing : -skip ${13=1},${14=0}
  -repeat @# -l[$>]
    -apply_channels "-gimp_parallel_overlap \"-repeat $11 -smooth $1,$2,$3,$4,$5,$6,$7,$8,$9,$10 -done\",$13,$14",$12,0
  -endl -done -c 0,255

gimp_anisotropic_smoothing_preview :
  -gimp_split_preview "-gimp_anisotropic_smoothing $*",$-1

#@gimp Smooth [bilateral] : gimp_bilateral, gimp_bilateral_preview(0)
#@gimp : Spatial variance = float(10,0,100)
#@gimp : Value variance = float(7,0,100)
#@gimp : Iterations = int(2,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>08/27/2013</i>.</small>")
gimp_bilateral : -skip ${5=0},${6=0}
  -apply_channels "-gimp_parallel_overlap \"-repeat $3 -bilateral $1,$2 -done\",$5,$6",$4,0

gimp_bilateral_preview :
  -gimp_split_preview "-gimp_bilateral $*",$-1

#@gimp Smooth [guided] : gimp_blur_guided, gimp_blur_guided_preview(0)
#@gimp : Radius = int(5,1,100)
#@gimp : Smoothness = float(30,0,512)
#@gimp : Iterations = int(1,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/29/2014</i>.</small>")
gimp_blur_guided : -skip ${5=0},${6=0}
  -apply_channels "-gimp_parallel_overlap \"-repeat $3 -guided $1,$2 -done\",$5,$6",$4,0

gimp_blur_guided_preview :
  -gimp_split_preview "-gimp_blur_guided $*",$-1

#@gimp Smooth [diffusion] : gimp_diffusion_smoothing, gimp_diffusion_smoothing_preview(0)
#@gimp : Sharpness = float(0.7,0,2)
#@gimp : Anisotropy = float(0.3,0,1)
#@gimp : Gradient smoothness = float(0.6,0,10)
#@gimp : Tensor smoothness = float(1.1,0,10)
#@gimp : Time step = float(15,5,50)
#@gimp : Iterations = int(8,1,100)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>08/27/2013</i>.</small>")
gimp_diffusion_smoothing :
  -apply_channels "-gimp_parallel_overlap \"-smooth $6,$1,$2,$3,$4,$5,0 -c 0,255\",$8,$9",$7,0

gimp_diffusion_smoothing_preview :
  -gimp_split_preview "-gimp_diffusion_smoothing $*",$-1

#@gimp Smooth [mean-curvature] : gimp_meancurvature_smoothing, gimp_meancurvature_smoothing_preview(0)
#@gimp : Time step = float(30,5,50)
#@gimp : Iterations = int(4,1,30)
#@gimp : Keep iterations as different layers = bool(false)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>08/27/2013</i>.</small>")
gimp_meancurvature_smoothing :
  -apply_channels "-gimp_parallel_overlap \"-meancurvature_flow $2,$1,$3 -c 0,255\",$5,$6",$4,0

gimp_meancurvature_smoothing_preview :
  -gimp_split_preview "-gimp_meancurvature_smoothing $*",$-1

#@gimp Smooth [median] : gimp_median, gimp_median_preview(0)
#@gimp : Radius = int(3,1,20)
#@gimp : Threshold = float(255,0,255)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_median :
  -apply_channels "-median $1,$2",$3,0

gimp_median_preview :
  -gimp_split_preview "-gimp_median $*",$-1

#@gimp Smooth [nlmeans] : gimp_nlmeans, gimp_nlmeans_preview(0)
#@gimp : Patch size = float(4,.5,10)
#@gimp : Spatial bandwidth = int(4,3,13)
#@gimp : Tonal bandwidth = float(10,1,50)
#@gimp : Patch measure = choice(3,"Linf-norm","L1-norm","L2-norm","Luminance","Lightness","RGB")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>J&#233;r&#244;me Boulanger</i>.      Latest update: <i>2015/01/07</i>.</small>")
gimp_nlmeans:
  -repeat @# -l[$>]
    -if {s==1} -nlmeans $1,$2,$3,-_gimp_nlmeans$4 # Handle separatly gray scale images.
    -else -apply_channels "-nlmeans $1,$2,$3,-_gimp_nlmeans$4",$5,0
    -endif
  -endl -done

_gimp_nlmeans0 : -s c -abs -max
_gimp_nlmeans1 : -s c -abs -+
_gimp_nlmeans2 : -norm
_gimp_nlmeans3 : -if {s>=3} -channels 0,2 -luminance -else -norm -endif
_gimp_nlmeans4 : -if {s>=3} -channels 0,2 -srgb2rgb -rgb2lab -channels 0 -else -norm -endif
_gimp_nlmeans5 :

gimp_nlmeans_preview:
  -gimp_split_preview "-gimp_nlmeans $*",$-1

#@gimp Smooth [patch-based] : gimp_patch_smoothing, gimp_patch_smoothing_preview(0)
#@gimp : Spatial variance = float(10,0.1,200)
#@gimp : Patch variance = float(10,0.1,200)
#@gimp : Patch size = int(3,2,21)
#@gimp : Lookup size = int(5,2,21)
#@gimp : Patch smoothness = float(0,0,4)
#@gimp : Fast approximation = bool(1)
#@gimp : Iterations = int(1,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>08/27/2013</i>.</small>")
gimp_patch_smoothing :
  -apply_channels "-gimp_parallel_overlap \"-repeat $7 -denoise $1,$2,$3,$4,$5,$6 -done -c 0,255\",$9,$10",$8,0

gimp_patch_smoothing_preview :
  -gimp_split_preview "-gimp_patch_smoothing $*",$-1

#@gimp Smooth [perona-malik] : gimp_peronamalik_smoothing, gimp_peronamalik_smoothing_preview(0)
#@gimp : K-factor = float(20,0,255)
#@gimp : Time step = float(5,5,50)
#@gimp : Iterations = int(5,1,30)
#@gimp : Keep iterations as different layers = bool(false)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>11/26/2014</i>.</small>")
gimp_peronamalik_smoothing :
  -apply_channels "-gimp_parallel_overlap \"-peronamalik_flow $1,$3,$2,$4 -c 0,255\",$6,$7",$5,0

gimp_peronamalik_smoothing_preview :
  -gimp_split_preview "-gimp_peronamalik_smoothing $*",$-1

#@gimp Smooth [selective gaussian] : gimp_selective_smoothing, gimp_selective_smoothing_preview(0)
#@gimp : Amplitude = float(5,0,20)
#@gimp : Edges = float(0.5,0,2)
#@gimp : Scales = int(5,1,10)
#@gimp : Iterations = int(1,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>08/27/2013</i>.</small>")
gimp_selective_smoothing :
  -apply_channels "-gimp_parallel_overlap \"-repeat $4 -blur_selective $1,$2,$3 -done -c 0,255\",$6,$7",$5,0

gimp_selective_smoothing_preview :
  -gimp_split_preview "-gimp_selective_smoothing $*",$-1

#@gimp Smooth [skin] : gimp_smooth_skin, gimp_smooth_skin_preview(1)
#@gimp : note = note("<small><b>Step 1:</b> Skin detection</small>")
#@gimp : Skin estimation = choice(2,"None","Manual","Automatic")
#@gimp : Tolerance = float(0.5,0,1)
#@gimp : Smoothness = float(1,0,5)
#@gimp : Threshold = float(1,0,10)
#@gimp : Pre-normalize image = bool(1)
#@gimp : X-coordinate [manual] = float(50,0,100)
#@gimp : Y-coordinate [manual] = float(50,0,100)
#@gimp : Radius [manual] = float(5,0,25)
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Step 2:</b> Medium scale smoothing</small>")
#@gimp : Base scale = float(2,0,10)
#@gimp : Fine scale = float(0.2,0,0.8)
#@gimp : Smoothness = float(3,0,10)
#@gimp : Smoothness type = choice(1,"Gaussian","Bilateral")
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Step 3:</b> Details enhancement</small>")
#@gimp : Gain = float(0.05,0,0.5)
#@gimp : sep = separator()
#@gimp : Preview data = choice{5,"Skin mask","Base scale","Medium scale (original)","Medium scale (smoothed)","Fine scale","Result image"}
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : link = link("Click here for a video tutorial","http://www.youtube.com/watch?v=H8pQfq-ybCc")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/20/2013</i>.</small>")
gimp_smooth_skin :
  -repeat @# -l[$>] -split_opacity -l[0] -to_rgb

    # Skin detection step.
    -if $5 --balance_gamma 128,128,128 -else [0] -endif
    -if {$1==0} -channels[-1] 0 -f[-1] 1 -elif {$1==2} -detect_skin[-1] $2 -else -detect_skin[-1] $2,$6%,$7%,$8% -endif
    M={iM} -b[-1] $3% -*[-1] {$M/iM} -*[-1] $4 -c[-1] 0,1

    # Details smoothing step.
    -split_details[0] 4,$9%,$10%
    --_gimp_smooth_skin[2] $12,$11
    -j[2] [-1],0,0,0,0,1,[-2] -rm[-2,-1]
    -*[-1] {10^$13} -+ -c 0,255

  -endl -a c -endl -done

_gimp_smooth_skin :
  -if {$1==0} -b {$2/8}%
  -else
    -if {$2>0}
      m={im} M={iM} -n 0,255
      -repeat {int($2/5)} -bilateral 3%,{5*3} -done
      -bilateral 3%,{($2%5)*3}
      -* {($M-$m)/255} -+ $m
    -endif
  -endif

gimp_smooth_skin_preview :
  -if {$-2==0}
    -gimp_split_preview "-if $5 -balance_gamma 128,128,128 -endif -if {$1==0} -f 1 -elif {$1==2} -detect_skin $2 -else -detect_skin $2,$6%,$7%,$8% -endif M={iM} -b $3% -* {255*$M/iM} -* $4 -c 0,255",$-1
  -elif {$-2==1}
    -gimp_split_preview "-b $9%",$-1
  -elif {$-2==2}
    -gimp_split_preview "-split_details 4,$9%,$10% -k[-2] -n 0,255",$-1
  -elif {$-2==3}
    -gimp_split_preview "-split_details 4,$9%,$10% -k[-2] -_gimp_smooth_skin $12,$11 -n 0,255",$-1
  -elif {$-2==4}
    -gimp_split_preview "-split_details 4,$9%,$10% -k[-1] -n 0,255",$-1
  -else
    -gimp_split_preview "-gimp_smooth_skin $*",$-1
  -endif

  -if {$1==1}
    -to_rgb
    -circle $6%,$7%,$8%,0.2,0,255,0
    -circle $6%,$7%,$8%,0.4,0xFFFFFFFF,0,255,0
    -line {$6-0.25*$8}%,{$7-0.25*$8}%,{$6+0.25*$8}%,{$7+0.25*$8}%,0.8,255,255,0
    -line {$6+0.25*$8}%,{$7-0.25*$8}%,{$6-0.25*$8}%,{$7+0.25*$8}%,0.8,255,255,0
  -endif

#@gimp Smooth [thin brush] : gimp_anisotropic_smoothing, gimp_anisotropic_smoothing(0)
#@gimp : Amplitude = float(60,0,1000)
#@gimp : Sharpness = float(0.9,0,2)
#@gimp : Anisotropy = float(0.64,0,1)
#@gimp : Gradient smoothness = float(3.1,0,10)
#@gimp : Tensor smoothness = float(1.10,0,10)
#@gimp : Spatial precision = float(0.8,0.1,2)
#@gimp : Angular precision = float(30,1,180)
#@gimp : Value precision = float(2,0.1,5)
#@gimp : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gimp : Fast approximation = bool(1)
#@gimp : Iterations = int(1,1,10)
#@gimp : Channel(s) = choice("RGB","Luminance","Blue & Red chrominances","Blue chrominance","Red chrominance")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : note = note{"\n<small><b>Note: </b>This set of anisotropic smoothing parameters has been suggested by PhotoComiX.</small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update: <i>12/26/2010</i>.</small>")

#@gimp Smooth [total variation] : gimp_tv_smoothing, gimp_tv_smoothing_preview(0)
#@gimp : Time step = float(30,5,100)
#@gimp : Iterations = int(10,1,40)
#@gimp : Keep iterations as different layers = bool(false)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>08/27/2013</i>.</small>")
gimp_tv_smoothing :
  -apply_channels "-gimp_parallel_overlap \"-tv_flow $2,$1,$3 -c 0,255\",$5,$6",$4,0

gimp_tv_smoothing_preview :
  -gimp_split_preview "-gimp_tv_smoothing $*",$-1

#@gimp Smooth [wavelets] : gimp_haar_smoothing, gimp_haar_smoothing_preview(0)
#@gimp : Threshold = float(1,0,10)
#@gimp : Iterations = int(10,1,32)
#@gimp : Scales = int(10,2,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>J&#233;rome Boulanger and David Tschumperl&#233;</i>.      Latest update: <i>08/27/2013</i>.</small>")
gimp_haar_smoothing :
  -apply_channels "-gimp_parallel_overlap \"-denoise_haar $1,$3,$2 -c 0,255\",$5,$6",$4,0

gimp_haar_smoothing_preview :
  -gimp_split_preview "-gimp_haar_smoothing $*",$-1

#@gimp Upscale [diffusion] : gimp_upscale_smart, gimp_upscale_smart_preview(0)
#@gimp : Width = text("200%")
#@gimp : Height = text("200%")
#@gimp : Smoothness = float(2,0,20)
#@gimp : Anisotropy = float(0.4,0,1)
#@gimp : Sharpness = float(50,0,100)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_upscale_smart :
  -to_rgb -upscale_smart $1,$2,1,$3,$4,$5 -c 0,255

gimp_upscale_smart_preview :
  -repeat @#
    --r[-1] $1,$2,1,1,0
    -if {w<@{-2,w}||h<@{-2,h}}  # Test for downscaling
      -rm[-1] -/[-1] 4
      0 -t[-1] "Downscaling is\nnot allowed!",5,5,20,1,255 -r[-1] [-2],[-2],1,1,0,0,0.5,0.5
      -or[-2,-1]
    -else
      -z[-2] {50-50*@{-2,w}/w}%,{50-50*@{-2,h}/h}%,{50+50*@{-2,w}/w}%,{50+50*@{-2,h}/h}%
      -rm[-1] -gimp_upscale_smart[-1] $1,$2,$3,$4,$5 -c[-1] 0,255
    -endif
  -mv[-1] 0 -done

#@gimp Upscale [scale2x] : gimp_scalenx, gimp_scalenx_preview(0)
#@gimp : Scaling factor = choice("x 2","x 3","x 4","x 6","x 8","x 9","x 12","x 16","x 18","x 27")
#@gimp : Colorbase = choice(0,"RGB","YCbCr","Lab")
#@gimp : note = note{"\n<small><b>Note: </b>
#@gimp : This filter re-implements the scaling algorithm described at :
#@gimp : </small>"}
#@gimp : note = link("http://scale2x.sourceforge.net")
#@gimp : note = note{"<small>
#@gimp : This filter is useful for resizing images that have very few colors
#@gimp : (e.g. indexed images). It is generally useless for true colors images.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_scalenx :
  -repeat @# -l[$>] -split_opacity
    -if {$2==1} -rgb2ycbcr[0] -round[0]
    -elif {$2==2} -rgb2lab8[0] -round[0]
    -endif
    -if {$1==0} -scale2x
    -elif {$1==1} -scale3x
    -elif {$1==2} -scale2x -scale2x
    -elif {$1==3} -scale3x -scale2x
    -elif {$1==4} -scale2x -scale2x -scale2x
    -elif {$1==5} -scale3x -scale3x
    -elif {$1==6} -scale3x -scale2x -scale2x
    -elif {$1==7} -scale2x -scale2x -scale2x -scale2x
    -elif {$1==8} -scale3x -scale3x -scale2x
    -elif {$1==9} -scale3x -scale3x -scale3x
    -endif
    -if {$2==1} -ycbcr2rgb[0]
    -elif {$2==2} -lab82rgb[0]
    -endif
  -a c -endl -done

gimp_scalenx_preview :
  -z 40%,40%,60%,60%
  -gimp_scalenx $1,$2


#@gimp _<b>Rendering</b>
#-----------------------

# Generic function to render a 3d image, with usual rendering parameters :
# $1 = Width
# $2 = Height
# $3 = Object size
# $4 = X-angle
# $5 = Y-angle
# $6 = Z-angle
# $7 = FOV
# $8 = X-light
# $9 = Y-light
# $10 = Z-light
# $11 = Specular lightness
# $12 = Specular shininess
# $13 = Rendering mode.
# $14 = Antialiasing (0 | 1)
gimp_render3d : -skip ${14=1}
  width={(1+$14)*$1} height={(1+$14)*$2}
  -n3d -c3d -m3d $13 f3d={0.5*max($width,$height)/tan($7*pi/360)}
  -f3d $f3d -l3d {$8*$f3d},{$9*$f3d},{$10*$f3d} -sl3d $11 -ss3d $12
  -repeat @# -l[$>]
    -*3d {$3*max($width,$height)} -r3d 0,0,1,$6 -r3d 0,1,0,$5 -r3d 1,0,0,$4
    $width,$height,1,3,-1
    -j3d[-1] [-2],50%,50% -rm[-2]
    -to_rgba -replace_color 0,0,-1,-1,-1,255,0,0,0,0
    -if $14
      -r $1,$2,1,100%,2 -s c,-3 -+[-1] 1e-5 -/[0] [1] -*[0] 255 -a c
    -endif
  -endl -done

#@gimp 3d blocks : gimp_blocks3d, gimp_blocks3d(1)
#@gimp : Resolution = int(32,1,128)
#@gimp : Smoothness = float(0,0,40)
#@gimp : Elevation = float(2,-10,10)
#@gimp : Size = float(1.5,0,3)
#@gimp : Angle = float(30,0,360)
#@gimp : Tilt = float(60,0,90)
#@gimp : FOV = float(45,1,90)
#@gimp : X-centering = float(50,0,100)
#@gimp : Y-centering = float(50,0,100)
#@gimp : sep = separator()
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(-50,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : Use light = bool(1)
#@gimp : Antialiasing = bool(1)
#@gimp : Outline color = color(0,0,0,128)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>02/10/2014</i>.</small>")
gimp_blocks3d :
  -repeat @# -l[$>]
    W={w} H={h} M={max(w,h)}
    -if {w>h} -r2dx $1 -else -r2dy $1 -endif
    w={w} h={h} m={max(w,h)}
    -if {$3>0} -mirror y -endif
    -imageblocks3d $3,$2%
    --3d[-1] {$w/2},{$h/2} f={$4*$M/($m*(2-$16))} -*3d $f,$f,{$f*abs($3*$1/100)}
    -if {$3>0} -r3d 1,0,0,180 -endif
    -r3d 0,0,1,$5 -r3d 1,0,0,$6

    # Render object.
    -if $16 {2*$M},{2*$M},1,4,-1 -else $M,$M,1,4,-1 -endif
    f3d={0.5*w/tan($7*pi/360)} -f3d $f3d
    -l3d {$10*$f3d},{$11*$f3d},{$12*$f3d} -sl3d $13 -ss3d $14
    -j3d[-1] [0],$8%,$9%,0,1,{if($15,3,2)},0,1
    -sh[-1] 100%,100% -+[-1] 1 -*[-1] 255 -rm[-1]

    # Render object outline
    -if $20
      [-1],[-1],1,3,-1
      -j3d[-1] [0],$8%,$9%,0,1,3,0,1 -rm[0]
      -g[-1] xy,1 -+[-2,-1] -norm[-1] -!=[-1] 0
      --r[-1] 100%,100%,1,3
      -sh[-1] 0,0 -*[-1] $17 -rm[-1]
      -sh[-1] 1,1 -*[-1] $18 -rm[-1]
      -sh[-1] 2,2 -*[-1] $19 -rm[-1]
      -j[0] [-1],0,0,0,0,{$20/255},[-2] -rm[-2,-1]
    -else -rm[0]
    -endif

    -replace_color 0,0,-1,-1,-1,0,0,0,0,0
    -if $16 -r 50%,50%,1,4,2 -endif
    -c 0,255
  -endl -done

#@gimp 3d colored object : gimp_coloredobject3d, gimp_coloredobject3d_preview(1)
#@gimp : Type = choice{1,"Plane","Box","Pyramid","Ellipsoid","Torus","Gyroid","Weird","Cup"}
#@gimp : Color = color(128,128,128,255)
#@gimp : sep = separator()
#@gimp : Size-1 = float(0.5,0,3)
#@gimp : Size-2 = float(0.5,0,3)
#@gimp : Size-3 = float(0.5,0,3)
#@gimp : X-angle = float(57,0,360)
#@gimp : Y-angle = float(41,0,360)
#@gimp : Z-angle = float(21,0,360)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : Rendering = choice(4,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gimp : Antialiasing = bool(1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>05/16/2011</i>.</small>")
_gimp_coloredobject3d :
  -to_rgb -_gimp_coloredobject3d$1$2 ${6-8} -col3d[-1] ${3-5}
  -db3d 0

gimp_coloredobject3d :
  -_gimp_coloredobject3d "_",${1-4,6-8}
  -repeat {@#-1}
    --gimp_render3d[-1] @{$>,w},@{$>,h},$6,${9--1}
    -sh[-1] 3,3 -*[-1] {$5/255} -rm[-1]
    -blend[$>,-1] alpha
  -done
  -rm[-1]

gimp_coloredobject3d_preview :
  -_gimp_coloredobject3d "_preview_",${1-4,6-8}
  -repeat {@#-1}
    --gimp_render3d[-1] @{$>,w},@{$>,h},$6,${9--1}
    -sh[-1] 3,3 -*[-1] {$5/255} -rm[-1]
    -blend[$>,-1] alpha
  -done -rm[-1]

_gimp_coloredobject3d_0 : -plane3d 1 -*3d[-1] $1,$2,1
_gimp_coloredobject3d_1 : -box3d 1 -*3d[-1] $1,$2,$3
_gimp_coloredobject3d_2 : -pyramid3d 1,1 -*3d[-1] $1,$2,$3
_gimp_coloredobject3d_3 : -sphere3d 1 -*3d[-1] 1,{2*$2},{2*$3}
_gimp_coloredobject3d_4 : -torus3d $1,{$2/2},100,50 -*3d[-1] $3,0.5,0.5
_gimp_coloredobject3d_5 : -gyroid3d 24 -*3d[-1] $1,$2,$3
_gimp_coloredobject3d_6 : -weird3d 32 -*3d[-1] $1,$2,$3
_gimp_coloredobject3d_7 : -cup3d 128 -*3d[-1] $1,$2,$3
_gimp_coloredobject3d_preview_0 : -plane3d 1 -*3d[-1] $1,$2,1
_gimp_coloredobject3d_preview_1 : -box3d 1 -*3d[-1] $1,$2,$3
_gimp_coloredobject3d_preview_2 : -pyramid3d 1,1 -*3d[-1] $1,$2,$3
_gimp_coloredobject3d_preview_3 : -sphere3d 1 -*3d[-1] 1,{2*$2},{2*$3}
_gimp_coloredobject3d_preview_4 : -torus3d $1,{$2/2},100,50 -*3d[-1] $3,0.5,0.5
_gimp_coloredobject3d_preview_5 : -gyroid3d 8 -*3d[-1] $1,$2,$3
_gimp_coloredobject3d_preview_6 : -weird3d 12 -*3d[-1] $1,$2,$3
_gimp_coloredobject3d_preview_7 : -cup3d 64 -*3d[-1] $1,$2,$3

#@gimp 3d elevation : gimp_elevation3d, gimp_elevation3d_preview(1)
#@gimp : Factor = float(100,-1000,1000)
#@gimp : Smoothness = float(1,0,10)
#@gimp : sep = separator()
#@gimp : Width = _int(1024,8,4096)
#@gimp : Height = _int(1024,8,4096)
#@gimp : Size = float(0.8,0,3)
#@gimp : X-angle = float(25,0,360)
#@gimp : Y-angle = float(0,0,360)
#@gimp : Z-angle = float(21,0,360)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : Rendering = choice(2,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gimp : Antialiasing = bool(1)
#@gimp : sep = separator(), note = note{"<small><b>Note:</b> Add a top layer to define object texture.</small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
_gimp_elevation3d :
  -repeat {@#/2} -l[$>,{min($>+1,@#-1)}]
    -if {@#==1} --norm -else -r[1] [0],3 -endif
    -n[1] 0,$1 -b[1] $2
    -elevation3d[0] [1] -rm[1]
  -endl -done
  -db3d

gimp_elevation3d :
  -_gimp_elevation3d ${1-2} -gimp_render3d ${3--1}

gimp_elevation3d_preview :
  -gimp_elevation3d ${1-2},{w},{h},${5--1}

#@gimp 3d extrusion : gimp_extrude3d, gimp_extrude3d_preview(1)
#@gimp : Depth = float(10,1,1024)
#@gimp : Resolution = int(512,1,1024)
#@gimp : Smoothness = float(0.6,0,3)
#@gimp : sep = separator()
#@gimp : Width = _int(1024,1,4096)
#@gimp : Height = _int(1024,1,4096)
#@gimp : Size = float(0.5,0,3)
#@gimp : X-angle = float(57,0,360)
#@gimp : Y-angle = float(41,0,360)
#@gimp : Z-angle = float(21,0,360)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : Rendering = choice(4,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gimp : Antialiasing = bool(1)
#@gimp : sep = separator(), note = note{"<small><b>Note:</b> Add a top layer to define object texture.</small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
_gimp_extrude3d :
  -repeat {@#/2} -l[$>,{min($>+1,@#-1)}]
    -extrude3d[-1] $1,$2,$3%
    -if {@#==2} -t3d[-1] [-2] -rm[-2] -endif
  -endl -done
  -db3d 0

gimp_extrude3d :
  -_gimp_extrude3d ${1-3} -gimp_render3d ${4--1}

gimp_extrude3d_preview :
  -gimp_extrude3d ${1-3},{w},{h},${6--1}

#@gimp 3d image object : gimp_imageobject3d, gimp_imageobject3d_preview(1)
#@gimp : Type = choice{1,"Plane","Cube","Pyramid","Sphere","Torus","Gyroid","Weird","Cup","Rubik"}
#@gimp : sep = separator()
#@gimp : Width = _int(1024,1,4096)
#@gimp : Height = _int(1024,1,4096)
#@gimp : Size = float(0.5,0,3)
#@gimp : X-angle = float(57,0,360)
#@gimp : Y-angle = float(41,0,360)
#@gimp : Z-angle = float(21,0,360)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : Rendering = choice(4,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gimp : Antialiasing = bool(1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
_gimp_imageobject3d :
  -to_rgb -repeat @# -l[$>] -_gimp_imageobject3d$1$2 -endl -done
  -db3d 0

gimp_imageobject3d :
  -_gimp_imageobject3d "_",$1 -gimp_render3d ${2--1}

gimp_imageobject3d_preview :
  w={w} h={h} -_gimp_imageobject3d "_preview_",$1 -gimp_render3d $w,$h,${4--1}

_gimp_imageobject3d_0 : -imageplane3d
_gimp_imageobject3d_1 : -imagecube3d
_gimp_imageobject3d_2 : -imagepyramid3d
_gimp_imageobject3d_3 : -imagesphere3d 64,32
_gimp_imageobject3d_4 : -torus3d 100,30,100,50 -t3d[-1] [-2] -rm[-2]
_gimp_imageobject3d_5 : -gyroid3d 24 -t3d[-1] [-2] -rm[-2]
_gimp_imageobject3d_6 : -weird3d 32 -t3d[-1] [-2] -rm[-2]
_gimp_imageobject3d_7 : -cup3d 128 -t3d[-1] [-2] -rm[-2]
_gimp_imageobject3d_8 : -imagerubik3d 5,5
_gimp_imageobject3d_preview_0 : -imageplane3d
_gimp_imageobject3d_preview_1 : -imagecube3d
_gimp_imageobject3d_preview_2 : -imagepyramid3d
_gimp_imageobject3d_preview_3 : -imagesphere3d 16,8
_gimp_imageobject3d_preview_4 : -torus3d 100,30,100,50 -t3d[-1] [-2] -rm[-2]
_gimp_imageobject3d_preview_5 : -gyroid3d 8 -c3d[-1] -n3d[-1] -t3d[-1] [-2] -rm[-2]
_gimp_imageobject3d_preview_6 : -weird3d 12 -t3d[-1] [-2] -rm[-2]
_gimp_imageobject3d_preview_7 : -cup3d 64 -t3d[-1] [-2] -rm[-2]
_gimp_imageobject3d_preview_8 : -imagerubik3d 3,3,5,5

#@gimp 3d lathing : gimp_lathing3d, gimp_lathing3d_preview(1)
#@gimp : Resolution = int(76,1,1024)
#@gimp : Smoothness = float(2,0,5)
#@gimp : Max angle = float(361,0,361)
#@gimp : sep = separator()
#@gimp : Width = _int(1024,1,4096)
#@gimp : Height = _int(1024,1,4096)
#@gimp : Size = float(0.5,0,3)
#@gimp : X-angle = float(0,0,360)
#@gimp : Y-angle = float(0,0,360)
#@gimp : Z-angle = float(0,0,360)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : Rendering = choice(4,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gimp : Antialiasing = bool(1)
#@gimp : sep = separator(), note = note{"<small><b>Note:</b> Add a top layer to define object texture.</small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
_gimp_lathing3d :
  -repeat {@#/2} -l[$>,{min($>+1,@#-1)}]
    -lathe3d[-1] $1,$2%,$3
    -if {@#==2} -t3d[-1] [-2] -rm[-2] -endif
  -endl -done
  -db3d 0

gimp_lathing3d :
  -_gimp_lathing3d ${1-3} -gimp_render3d ${4--1}

gimp_lathing3d_preview :
  -gimp_lathing3d ${1-3},{w},{h},${6--1}

#@gimp 3d random objects : gimp_random3d, gimp_random3d(1)
#@gimp : Type = choice("Cube","Cone","Cylinder","Sphere","Torus")
#@gimp : Density = int(50,1,300)
#@gimp : Size = float(3,1,20)
#@gimp : Z-range = float(100,0,300)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : Rendering = choice(3,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gimp : Opacity = float(1,0,1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_random3d :
  -repeat @# -l[$>]
    f3d={0.5*max(w,h)/tan($5*pi/360)} -f3d $f3d -l3d {$6*$f3d},{$7*$f3d},{$8*$f3d} -sl3d $9 -ss3d $10
    -to_rgb ({w},{h},{d},{s}) -/[-1] 2 -repeat $2
    (@{1,0}) -+[-1] @{1,1} -*[-1] $3 -/[-1] 100 -_gimp_random3d$1 @-1 -rm[-2]
    -r3d[-1] 1,1,0,{?(0,360)}
    ({?(-1,1)}) -*[-1] @{1,0} ({?(-1,1)}) -*[-1] @{1,1}
    -+3d[-3] @-2,@-1,{?(-$4,$4)} -rm[-2,-1]
    -col3d[-1] {?(255)},{?(255)},{?(255)} -done -+3d[2--1] -j3d[0] [-1],50%,50%,0,$12,$11,0,1
    -k[0]
  -endl -done

_gimp_random3d0 : -box3d $1
_gimp_random3d1 : ($1) -/[-1] 2 -cone3d @-1,$1 -rm[-2]
_gimp_random3d2 : ($1) -/[-1] 2 -cylinder3d @-1,$1 -rm[-2]
_gimp_random3d3 : -sphere3d $1,2
_gimp_random3d4 : ($1) -/[-1] 3 -torus3d $1,@-1 -rm[-2]

#@gimp Ball : gimp_ball, gimp_ball_preview(0)
#@gimp : Radius = int(128,1,1024)
#@gimp : Specular light = float(0.8,0,8)
#@gimp : Specular size = float(1,0,8)
#@gimp : Shadow = float(1.5,0,4)
#@gimp : Color = color(255,0,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>11/27/2013</i>.</small>")
gimp_ball :
  -ball $1,${5-7},${2-4} -mv[-1] 0

gimp_ball_preview :
  -gimp_ball $*
  -if {@#>1} -rv[-2,-1] -blend[-2,-1] alpha -endif

#@gimp Circle art : gimp_circle_art, gimp_circle_art
#@gimp : Type = choice(1,"Random","Lissajous spiral")
#@gimp : Density = float(15,0,100)
#@gimp : Radius = float(0.5,0,1)
#@gimp : Modulo = int(8,2,16)
#@gimp : Anti-aliasing = bool(1)
#@gimp : Random colors = bool(1)
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Lissajous parameters:</b></small>")
#@gimp : Curve length = float(15,0,50)
#@gimp : Curve angle = float(0,0,360)
#@gimp : Minimal radius = float(0,-5,5)
#@gimp : Maximal radius = float(0.5,-5,5)
#@gimp : X-dispersion = float(1,0,4)
#@gimp : Y-dispersion = float(1,0,4)
#@gimp : X-factor = int(1,0,16)
#@gimp : Y-factor = int(1,0,16)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>08/22/2014</i>.</small>")
gimp_circle_art :
  -if {!$2} -f 0 -return -endif
  # Generate object coordinates.
  -if {$1==0} # Random.
    {round(2*($2^1.5))}
    -rand[-1] -1,1 --rand[-1] -1,1 --rand[-1] -$3,$3 -a[-3--1] y
  -else # Spiral.
    {max(1,round($2*$7))}
    t0={$8*2*pi/180}
    -rows[-1] 0,2 -f[-1] 'r=x/(w-1);t=2*pi*x/$2;if(y==0,(r^$11)*cos($t0+$13*t),if(y==1,(r^$12)*sin($t0+$14*t),max(0,$3*($9+($10-$9)*r))))'
  -endif

  # Convert to 3d object.
  -l[-1]
    -transpose -s x,-1 h={h}
    -i[0] ({'CImg3d'},{2*$h},$h)  # Header.
    --+[-3] [-1] --[-4,-2] -i [-2] -i[-3,-1] 1,100% -a[-6--1] x  # Vertices.
    1,$h,1,1,5 1,$h,1,1,2*y --+[-1] 1 -a[-3--1] x -z[-1] 0,5 # Primitives.
    3,$h,1,1,1 1,$h,1,1,-1 -y -a y # Colors + Opacities.
  -endl

  # Render object on selected images.
  -repeat {@#-1} -l[$>,-1]
    s=@{0,max(w,h)} -rm[0]
    -if $5 {2*$s},{2*$s} --*3d[0] $s # Anti-aliasing.
    -else $s,$s --*3d[0] {$s/2} # No anti-aliasing.
    -endif
    -j3d[1] [2],50%,50%,0,1,2,0,0 -rm[2]
    -%[-1] $4
    -if $6 -i[-2] 100%,100%,1,3 -rand[-2] 0,255 -plasma[-2] 1,1 -equalize[-2] 256 -n[-2] 0,255 -blend[-2,-1] shapeaverage -endif
    -rv
  -endl -done
  -rm[-1]
  -n 0,255
  -if $5 -r 50%,50%,1,100%,2 -endif

#@gimp Cupid : gimp_cupid, gimp_cupid
#@gimp : Smoothness = float(0,0,10)
#@gimp : Color = color(255,0,0,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>11/13/2013</i>.</small>")
gimp_cupid :
  -if {@#>0} siz={min(@{-min_w},@{-min_h})} -else siz=512 -endif
  -cupid $siz -to_rgba[-1]
  -replace_color[-1] 0,0,0,0,0,255,$2,$3,$4,0
  -replace_color[-1] 0,0,1,1,1,255,$2,$3,$4,$5
  -frame[-1] {2.5*$1}%,{2.5*$1}%,$2,$3,$4,0 -b[-1] $1%
  -blend[-2,-1] alpha

#@gimp Equation plot [parametric] : gimp_equation_parametric, gimp_equation_parametric
#@gimp : X(t) = text{"sin(t)*(exp(cos(t))-2*cos(4*t)-sin(t/12)^5)"}
#@gimp : Y(t) = text{"cos(t)*(exp(cos(t))-2*cos(4*t)-sin(t/12)^5)"}
#@gimp : Min-t = float(0,-1000,1000)
#@gimp : Max-t = float(100,-1000,1000)
#@gimp : Resolution = int(4096,2,32768)
#@gimp : Outline opacity = float(1,0,1)
#@gimp : Dot size = int(0,0,16)
#@gimp : Start color = color(64,0,0)
#@gimp : End color = color(128,0,0)
#@gimp : Colored outline = bool(1)
#@gimp : Antialiasing = bool(1)
#@gimp : Decoration = bool(1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>11/13/2013</i>.</small>")
gimp_equation_parametric :
  -repeat @# -l[$>]
    w={w} h={h} -rm
    $5,1,1,2,'"t=$3+x*($4-$3)/($5-1);if(c==0,$1,$2)"'
    -channels[-1] 0,2
    ($8,$11^$9,$12^$10,$13) -r[-1] @{-2,w},1,1,3,3 -a c
    -display_parametric $w,$h,{$6+$14*1.001},$7,$15,$16
  -endl -done

#@gimp Equation plot [y=f(x)] : gimp_equation_plot, gimp_equation_plot
#@gimp : F(x) = text{"X*c+10*cos(X+c+?)"}
#@gimp : X-min = float(-10,-100,100)
#@gimp : X-max = float(10,-100,100)
#@gimp : Resolution = int(100,2,1024)
#@gimp : Channels = int(3,1,32)
#@gimp : Plot type = choice(2,"None","Lines","Splines","Bars")
#@gimp : Vertex type = choice(0,"None","Points","Crosses 1","Crosses 2","Circles 1","Circles 2","Square 1","Square 2")
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Note</b> :
#@gimp : Use variable <b>X</b> instead of <b>x</b> in the above equation to take care of the X-min/max settings.
#@gimp : Variable <b>c</b> refers to the current channel number.
#@gimp : Variable <b>?</b> refers to a uniformly distributed random value in [0,1].
#@gimp : Reduce resolution to be able to view
#@gimp : separate graph vertices.</small>")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_equation_plot :
  -repeat @# -l[$>]
    w={w} h={h} -rm
    $4,1,1,$5,"X=$2+($3-$2)*x/($4-1);$1"
    -dg $w,$h,$6,$7,$2,$3
  -endl -done

#@gimp Gradient [corners] : gimp_corner_gradient, gimp_corner_gradient
#@gimp : Color 1 (up/left corner) = color(255,255,255,128)
#@gimp : Color 2 (up/right corner) = color(255,0,0,255)
#@gimp : Color 3 (bottom/left corner) = color(0,255,0,255)
#@gimp : Color 4 (bottom/right corner) = color(0,0,255,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_corner_gradient :
  -repeat @#
    ({w},{h}) -rm[-2]
    ($1,$5;$9,$13^$2,$6;$10,$14^$3,$7;$11,$15^$4,$8;$12,$16) -r[-1] @-2,1,4,3 -rm[-2]
  -mv[-1] 0 -done

#@gimp Gradient [custom shape] : gimp_custom_gradient, gimp_custom_gradient_preview(1)
#@gimp : note = note("<small><b>Shape selection:</b></small>")
#@gimp : Select by = choice("Auto","Dark pixels","Bright pixels","Opaque pixels")
#@gimp : Smoothness = float(0,0,10)
#@gimp : Threshold = float(0,0,100)
#@gimp : Preview shape = bool(1)
#@gimp : note = note("<small><b>Note:</b> Shapes with small strokes may lead to incorrect previews.</small>")
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Gradient parameters:</b></small>")
#@gimp : Number of colors = int(4,2,10)
#@gimp : Cycles = float(1,1,16)
#@gimp : Offset = float(0,0,100)
#@gimp : Shading = float(128,1,256)
#@gimp : Inner length = float(100,0,100)
#@gimp : Outer length = float(100,0,100)
#@gimp : Spatial metric = choice(2,"Chebyshev","Manhattan","Euclidean")
#@gimp : Color metric = choice("RGB","HSV","Lab")
#@gimp : Shade back to first color = bool(1)
#@gimp : Preview gradient = bool(0)
#@gimp : Save gradient as = _text("")
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Color definitions:</b></small>")
#@gimp : Colormap type = choice(1,"Pre-defined","User-defined")
#@gimp : Pre-defined colormap = int(0,0,65535)
#@gimp : 1st color = color(0,0,0,255)
#@gimp : 2nd color = color(255,0,0,255)
#@gimp : 3rd color = color(255,255,0,255)
#@gimp : 4th color = color(255,255,255,255)
#@gimp : 5th color = color(0,255,255,255)
#@gimp : 6th color = color(0,255,0,255)
#@gimp : 7th color = color(0,0,255,255)
#@gimp : 8th color = color(128,128,128,255)
#@gimp : 9th color = color(255,0,255,255)
#@gimp : 10th color = color(0,0,0,0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/03/2013</i>.</small>")
gimp_custom_gradient_preview : -skip "${15=}"
  -repeat @# -l[$>]
    -if $4
      --_gimp_custom_gradient1 ${1-14},"$15",${16--1} --erode[-1] 3 --[-2,-1] --dilate[-1] 5 -a[-2,-1] c -n[-1] 0,255
      -gimp_custom_gradient[0] ${1-14},"$15",${16--1},-1 -blend alpha
    -else -gimp_custom_gradient ${1-14},"$15",${16--1},-1
    -endif
    -if $14
      --_gimp_custom_gradient0[] ${1-14},"$15",${16--1} -r[-1] {@{0,w}-16},16,1,4 -frame[-1] 1,1,0 -j[0] [-1],8,@{0,h-25} -rm[-1]
    -endif
  -endl -done

gimp_custom_gradient : -skip "${15=}"
  -_gimp_custom_gradient0 ${1-14},"$15",${16--1}
  -if {$-1>=0&&narg("$15")}
    dir_ggr=@{-path_gimp}/gradients
    0 -nm[-1] @{"-normalize_filename \"$15\""} name_ggr=@{-1,b} -rm[-1] -output_ggr[-1] $dir_ggr/$name_ggr.ggr,"$15"
  -endif
  -i[-2] (0^0^0^0) -a[-2,-1] x
  -repeat {@#-1} -l[$>,-1]
    -_gimp_custom_gradient1[0] ${1-14},"$15",${16--1}
    --distance[0] 1,$11 --distance[0] 0,$11 -*[-1] -1 -+[0] 1 -+[0,-2,-1]  # Signed distance function.
    m={$9%*@{0,im}} M={$10%*@{0,iM}}
    --[0] $m -*[0] {@{1,w-2}/($M-$m)} -+[0] 1
    -round[0] -map[0] [-1]
  -endl -done
  -rm[-1]

# Create colormap.
_gimp_custom_gradient0 :
  -if $16 4,8,1,1,${18-56} -permute[-1] yzcx
  -else 8,1,1,3 -srand $17 -rand[-1] 0,255 -to_rgba[-1]
  -endif
  -z[-1] 0,{$5-1}
  -if $13
    -r[-1] {200*$6}%,1,1,4,0,2
    -__gimp_custom_gradient0[-1] $12,$8
    -shift[-1] {-$7/2}%,0,0,0,2 -z[-1] 0,{w/2-1}
  -else
    -__gimp_custom_gradient0[-1] $12,$8
    -r[-1] {100*$6}%,1,1,4,0,2 -shift[-1] -$7%,0,0,0,2
    -endif

__gimp_custom_gradient0 :
  -if {$1==1} -sh[-1] 0,2 -rgb2hsv[-1] -rm[-1]
  -elif {$1==2} -sh[-1] 0,2 -srgb2rgb[-1] -rgb2lab[-1] -rm[-1]
  -endif
  -r[-1] {$2*w},1,1,4,3
  -if {$1==1} -sh[-1] 0,2 -hsv2rgb[-1] -rm[-1]
  -elif {$1==2} -sh[-1] 0,2 -lab2rgb[-1] -rgb2srgb[-1] -rm[-1]
  -endif

# Extract shape from image.
_gimp_custom_gradient1 :
  -b $2%
  -if {$1==0} # Auto-mode.
    -to_a -split_opacity
    -if {iM>im+32}
      -rm[-2] ->=[0] {100-$3}%
    -else
      -rm[-1] -norm -n 0,1
      -if {ia>0.5} -<=[0] $3% -else ->=[0] {100-$3}% -endif
    -endif
  -elif {$1==1} # Dark pixels.
    -remove_opacity -norm -<= $3%
  -elif {$1==2} # Bright pixels.
    -remove_opacity -norm ->= {100-$3}%
  -else # Opaque pixels.
    -to_a -channels 100% ->= {100-$3}%
  -endif

#@gimp Gradient [from line] : gimp_line_gradient, gimp_line_gradient_preview(1)
#@gimp : note = note("<small><b><span foreground="red">Starting point:</span></b></small>")
#@gimp : X0 = float(0,0,100)
#@gimp : Y0 = float(0,0,100)
#@gimp : note = note("<small><b><span foreground="blue">Ending point:</span></b></small>")
#@gimp : X1 = float(100,0,100)
#@gimp : Y1 = float(100,0,100)
#@gimp : sep = separator()
#@gimp : Sampling = float(100,0,100)
#@gimp : Length = int(0,0,4096)
#@gimp : note = note("<small><b>Note:</b> Set length to <i>0</i> to release gradient length constraints.</small>")
#@gimp : Sort colors = choice("Don't sort","By red component","By green component","By blue component","By luminance","By blue chrominance","By red chrominance","By lightness")
#@gimp : Reverse gradient = bool(0)
#@gimp : sep = separator()
#@gimp : Preview gradient = bool(1)
#@gimp : Save gradient as = _text("")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/09/2013</i>.</small>")
gimp_line_gradient : -skip "${10=}"
  -_gimp_line_gradient $*
  -if {narg("$10")}
    dir_ggr=@{-path_gimp}/gradients
    0 -nm[-1] @{"-normalize_filename \"$10\""} name_ggr=@{-1,b} -rm[-1] -output_ggr[-1] $dir_ggr/$name_ggr.ggr,"$10"
  -endif
  -repeat @# -r[$>] 100%,64,1,100% -done

gimp_line_gradient_preview :
  -repeat @# -l[$>]
    -to_rgba
    -if $9 --_gimp_line_gradient $* -endif
    -l[0]
      -line $1%,$2%,$3%,$4%,1,0xF0F0F0F0,255,255,255,255
      -line $1%,$2%,$3%,$4%,1,0x0F0F0F0F,0,0,0,255
      -circle $1%,$2%,4,1,255,0,0,255
      -circle $3%,$4%,4,1,0,0,255,255
      -circle $1%,$2%,4,1,0xFFFFFFFF,0,0,0,255
      -circle $3%,$4%,4,1,0xFFFFFFFF,0,0,0,255
    -endl
    -if {@#>1} -r[-1] {@{0,w}-32},32,1,4,1 -frame[-1] 1,1,0,0,0,255 -j[0] [1],16,{@{0,h}-48} -rm[-1] -endif
  -endl -done

_gimp_line_gradient :
  -at_line $1%,$2%,0,$3%,$4%,0 -r {max(0.1,$5)}%,1,1,100%,1
  -m "feature1 : -channels 0"
  -m "feature2 : -channels 1"
  -m "feature3 : -channels 2"
  -m "feature4 : -to_rgb -luminance"
  -m "feature5 : -to_rgb -rgb2ycbcr -channels 1"
  -m "feature6 : -to_rgb -rgb2ycbcr -channels 2"
  -m "feature7 : -to_rgb -srgb2rgb -rgb2lab -channels 0"
  -if $7 -repeat @# -l[$>] --feature$7 -rv -a y -sort +,x -rows 1 -endl -done -endif
  -if $6 -r $6,1,1,100%,3 -endif
  -if $8 -mirror x -endif

#@gimp Gradient [linear] : gimp_linear_gradient, gimp_linear_gradient
#@gimp : Starting color = color(0,0,0,255)
#@gimp : Ending color = color(255,255,255,255)
#@gimp : Swap colors = bool(0)
#@gimp : Angle = float(45,0,360)
#@gimp : Fade start = float(0,0,100)
#@gimp : Fade end = float(100,0,100)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_linear_gradient :
  -repeat @#
    ({w},{h}) -rm[-2]
    ($1^$2^$3^$4) ($5^$6^$7^$8)
    -if $9 -rv[-2,-1] -endif
    -r[-2,-1] @-3 -rm[-3]
    -fade_linear $10,$11,$12
  -mv[-1] 0 -done

#@gimp Gradient [radial] : gimp_radial_gradient, gimp_radial_gradient
#@gimp : Starting color = color(0,0,0,255)
#@gimp : Ending color = color(255,255,255,255)
#@gimp : Swap colors = bool(0)
#@gimp : Fade start = float(0,0,100)
#@gimp : Fade end = float(100,0,100)
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_radial_gradient :
  -repeat @#
    ({w},{h}) -rm[-2]
    ($1^$2^$3^$4) ($5^$6^$7^$8)
    -if $9 -rv[-2,-1] -endif
    -r[-2,-1] @-3 -rm[-3]
    100%,100% -=[-1] 1,$12%,$13% -distance[-1] 1 -_fade $10,$11
  -mv[-1] 0 -done

#@gimp Heart : gimp_heart, gimp_heart_preview
#@gimp : Size = float(75,0,100)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Color = color(255,0,0,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>11/13/2013</i>.</small>")
gimp_heart :
  -if {@#>0} wh=@{-max_wh} w={$1%*min(512,arg(1,$wh))} h={$1%*min(512,arg(2,$wh))} -else w={$1%*512} h={$1%*512} -endif
  -heart {max(1,$w)},{max(1,$h)} -to_rgba[-1]
  -replace_color[-1] 0,0,1,1,1,255,$3,$4,$5,$6
  -replace_color[-1] 0,0,0,0,0,255,$3,$4,$5,0
  -b[-1] $2% -mv[-1] 0

gimp_heart_preview :
  -gimp_heart $* -blend[^0] [0],alpha -rm[0]

#@gimp Lightning : gimp_lightning, gimp_lightning_preview
#@gimp : note = note{"<small><b>Global parameters:</b></small>"}
#@gimp : Number of streaks = int(20,1,1024)
#@gimp : Size (%) = float(90,0,150)
#@gimp : Resolution = int(256,2,4096)
#@gimp : Randomness = float(3,0,16)
#@gimp : Smoothness = float(1.5,0,10)
#@gimp : Balance = float(0.75,0,1)
#@gimp : Color = color(255,255,255,255)
#@gimp : Seed = int(0,0,65536)
#@gimp : sep = separator()
#@gimp : note = note{"<small><b>Initial streak:</b></small>"}
#@gimp : X-coordinate (%) = float(50,0,100)
#@gimp : Y-coordinate (%) = float(5,0,100)
#@gimp : Angle (deg.) = float(0,-180,180)
#@gimp : Thickness (px.) = int(6,1,64)
#@gimp : Blur = float(0.2,0,3)
#@gimp : sep = separator()
#@gimp : note = note{"<small><b>Auxiliary streaks:</b></small>"}
#@gimp : Min offset (%) = float(25,0,100)
#@gimp : Max offset (%) = float(60,0,100)
#@gimp : Min length (%) = float(95,0,200)
#@gimp : Max length (%) = float(100,0,200)
#@gimp : Min angle deviation (deg.) = float(30,0,180)
#@gimp : Max angle deviation (deg.) = float(40,0,180)
#@gimp : Thickness factor = float(-0.25,-1,1)
#@gimp : Blur factor = float(-0.1,-1,1)
#@gimp : Opacity factor = float(-0.20,-1,1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>11/27/2014</i>.</small>")
gimp_lightning :
  -repeat @# -l[$<]
    100%,100% -l[-1] fact={max(w,h)/$3*$2%} -srand $11
    -repeat $1
      -if {@#<=1}
        i=0
        new_level=1
        new_length=$3
        new_x=0
        new_y=0
        new_angle=$14
      -else
        i={round(?(1,max(1,(@#-1)*$6)))}
        level=@{$i,-2}
        angle=@{$i,-1}
        nb_points=@{$i,i[6]}
        p={round(($nb_points-2)*?($17%,$18%))}
        new_level={$level+1}
        new_length={max(2,round(($nb_points-$p)*?($19%,$20%)))}
        new_x=@{$i,i[8+3*$p]}
        new_y=@{$i,i[9+3*$p]}
        new_angle={$angle+?($21,$22)*if(?>0.5,1,-1)}
      -endif

      -_gimp_lightning $new_length,$4,$5
      -r3d[-1] 0,0,1,$new_angle
      -+3d[-1] $new_x,$new_y
      --*3d[-1] $fact [0],[0] -j3d[-1] [-2],$12%,$13%,0,1,1,0,0 -rm[-2]

      dilation={$15*(if($23>0,1.5,10)^($23*($new_level-1)))}
      blur={max(0,-1+(1+$16)*(if($24>0,2,5)^($24*($new_level-1))))}
      opacity={min(1,$10/255*(2^($25*($new_level-1))))}

      -dilate[-1] $dilation -b[-1] $blur% -n[-1] 0,1 -*[-1] $opacity -max[0,-1]
      ($new_level;$new_angle) -a[-2,-1] y
      -progress {($>*100)/($1-1)}
    -done
    -k[0] -* 255 -i[0] 100%,100%,1,3 -fc[0] ${7-9} -a c
    -endl
    -rv
  -endl -done

gimp_lightning_preview :
  -repeat @# -l[$>]
    -gimp_lightning $* -rv -blend alpha
  -endl -done

_gimp_lightning :
  -l[]
    ({'CImg3d'},$1,{$1-1})
    1,$1 -noise[-1] $2,1 -cumulate[-1] -b[-1] $3 -shift[-1] 0,1 1,100%,1,1,y 1,100% -a[-3--1] x
    1,{h-1},1,1,2 --f[-1] y --+[-1] 1 -a[-3--1] x
    4,100%,1,1,1
    -y -a y
  -endl

#@gimp Lissajous : gimp_lissajous, gimp_lissajous(1)
#@gimp : Resolution = int(4096,2,8192)
#@gimp : sep = separator()
#@gimp : X-size = float(0.9,0,2)
#@gimp : Y-size = float(0.9,0,2)
#@gimp : Z-size = float(3,1,10)
#@gimp : sep = separator()
#@gimp : X-multiplier = float(8,0,32)
#@gimp : Y-multiplier = float(7,0,32)
#@gimp : Z-multiplier = float(0,0,32)
#@gimp : sep = separator()
#@gimp : X-offset = float(0,0,1)
#@gimp : Y-offset = float(0,0,1)
#@gimp : Z-offset = float(0,0,1)
#@gimp : sep = separator()
#@gimp : X-angle = float(0,0,360)
#@gimp : Y-angle = float(0,0,360)
#@gimp : Z-angle = float(0,0,360)
#@gimp : sep = separator()
#@gimp : Thickness = float(0,0,50)
#@gimp : Color = color(255,255,255,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>04/18/2011</i>.</small>")
gimp_lissajous :
  -repeat @# -l[$>] -to_rgba
    {w},{h}
    -f3d {0.5*max(w,h)/tan($4*pi/360)}
    -lissajous3d $1,$5,$8,$6,$9,$7,$10
    -r3d[-1] 0,0,1,$13 -r3d[-1] 0,1,0,$12 -r3d[-1] 1,0,0,$11
    -*3d[-1] {0.5*$2*@{-2,w}},{0.5*$3*@{-2,h}},{0.5*$4*max(@{-2,w},@{-2,h})}
    -col3d[-1] 1 -j3d[-2] [-1],50%,50%,0,1,1,0,0 -rm[-1]
    -distance[-1] 1 ->[-1] $14% -*[-2] [-1] -==[-1] 0
    -r[-1] 100%,100%,1,4
    -sh[-1] 0,0 -*[-1] $15 -rm[-1]
    -sh[-1] 1,1 -*[-1] $16 -rm[-1]
    -sh[-1] 2,2 -*[-1] $17 -rm[-1]
    -sh[-1] 3,3 -*[-1] $18 -rm[-1]
    -+[-2,-1]
  -endl -done

#@gimp Mandelbrot-julia sets : gimp_mandelbrot, gimp_mandelbrot_preview
#@gimp : X-center = float(0,-2,2)
#@gimp : Y-center = float(0,-2,2)
#@gimp : Zoom = float(0,0,100)
#@gimp : Iterations = int(128,1,512)
#@gimp : Fractal set = choice(Mandelbrot, Julia)
#@gimp : X-seed (Julia) = text("0.317")
#@gimp : Y-seed (Julia) = text("0.03")
#@gimp : Color 1 = color(0,0,255)
#@gimp : Color 2 = color(0,255,0)
#@gimp : Color 3 = color(255,0,0)
#@gimp : Color 4 = color(255,0,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_mandelbrot :
  (0^0^0) ($8^$9^$10) ($11^$12^$13) ($14^$15^$16) ($17^$18^$19)
  -a[-4--1] x -r[-1] $4,1,1,3,3 -a[-2,-1] x -mv[-1] 0
  -repeat {@#-1}
    wh={w},{h} -rm[-1] $wh
    -mandelbrot[-1] {$1-2/(1+$3)},{$2-2/(1+$3)},{$1+2/(1+$3)},{$2+2/(1+$3)},$4,$5,{if($5,$6,0)},{if($5,$7,0)}
    -map[-1] [0]
  -mv[-1] 1 -done -rm[0]

gimp_mandelbrot_preview :
  -gimp_mandelbrot ${^0}
  -line 0,50%,100%,50%,0.5,255
  -line 50%,0,50%,100%,0.5,255

#@gimp Quick copyright : gimp_quick_copyright, gimp_quick_copyright(0)
#@gimp : Text = text{"\251 G'MIC"}
#@gimp : Size = int(27,13,128)
#@gimp : Color = color(255,255,255,128)
#@gimp : Outline = int(1,0,4)
#@gimp : Position = choice(3,"Up-left","Up-right","Bottom-left","Bottom-right")
#@gimp : Offset = int(5,0,40)
#@gimp : Orientation = choice(1,"-90 deg.","0 deg.","+90 deg.","+180 deg.")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_quick_copyright :
  -i[0] 0 -t[0] "$1",0,0,$2,1,$3,$4,$5 -autocrop[0] 0 -r[0] {@{0,w}+2*$7},{@{0,h}+2*$7},1,3,0,0,0.5,0.5
  -i[1] 0 -t[1] "$1",0,0,$2,1,1 -autocrop[1] 0 -r[1] {@{1,w}+2*$7},{@{1,h}+2*$7},1,1,0,0,0.5,0.5 -dilate[1] {1+2*$7}
  -rotate[0,1] {90*($10-1)}
  -repeat {@#-2}
  -if {$8==0} -j[-1] [0],$9,$9,0,0,{$6/255},[1]
  -elif {$8==1} -j[-1] [0],{w-1-@{0,w}-$9},$9,0,0,{$6/255},[1]
  -elif {$8==2} -j[-1] [0],$9,{h-1-@{0,h}-$9},0,0,{$6/255},[1]
  -else -j[-1] [0],{w-1-@{0,w}-$9},{h-1-@{0,h}-$9},0,0,{$6/255},[1]
  -endif
  -mv[-1] 2 -done
  -rm[0,1]

#@gimp Rainbow : gimp_rainbow, gimp_rainbow
#@gimp : Left position = float(80,0,100)
#@gimp : Right position = float(80,0,100)
#@gimp : Left slope = float(175,0,400)
#@gimp : Right slope = float(175,0,400)
#@gimp : Thinness = float(3,0.1,8)
#@gimp : Opacity = float(80,0,199)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_rainbow :
  -repeat @# -l[$>]
    100%,100% -spline[-1] 0,$1%,100,{-$3}%,100%,$2%,100,$4%,256,1,1
    -flood[-1] 0,0,0,0,0,1,1 -flood[-1] {w-1},0,0,0,0,1,1
    -distance[-1] 0 -c[-1] 0,255 -n[-1] 0,{$5*255}
    -rainbow_lut --luminance[-1] -c[-1] 0,{min(100,200-$6)}% -n[-1] 0,255 -a[-2,-1] c
    -map[-2] [-1] -rm[-1]
    -if {$6<100} -sh[-1] 3,3 -*[-1] {$6/100} -rm[-1] -endif
    -blend alpha
  -endl -done

#@gimp Shade bobs : gimp_shadebobs, gimp_shadebobs
#@gimp : note = note("<small>Bobs parameters :</small>")
#@gimp : Density = int(50,1,200)
#@gimp : Radius = int(5,1,100)
#@gimp : Duration = int(200,1,500)
#@gimp : Velocity = float(1,0,10)
#@gimp : sep = separator()
#@gimp : note = note("<small>Curve parameters :</small>")
#@gimp : Rx = float(-1,-3,3)
#@gimp : Ry = float(2,-3,3)
#@gimp : Rz = float(1,-3,3)
#@gimp : Rt = float(0.8,-3,3)
#@gimp : Rcx = float(0,-3,3)
#@gimp : Colormap = choice(8,"Grayscale","Standard","HSV","Lines","Hot","Cool","Jet","Flag","Cube")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>04/18/2012</i>.</small>")
gimp_shadebobs :
  -channels 0 -f 0
  -repeat @# -l[$>]
    t=0
    -repeat $3
      -repeat $1
        r={$6+$5*cos(6*$7*$t)+(1-$5)*sin(6*$8*$t)}
        a={(360*sin($7*$t)+30*$6*$>)*pi/180}
        ax={2*$>*pi/$1+$t}
        cx={(1+$9*cos($ax)+$r*cos($a))*w/2}
        cy={(1+$9*sin($ax)+$r*sin($a))*h/2}
        -ellipse[-1] $cx,$cy,$2%,$2%,0,-1,1
      -done
      t={$t+$4/100}
    -done
  -endl -done
  -and 255 -if $10 -map {$10-1} -endif

#@gimp Sierpinski triangle : gimp_sierpinski, gimp_sierpinski(1)
#@gimp : Recursions = int(6,0,10)
#@gimp : 1st X-coord = float(50,0,100)
#@gimp : 1st Y-coord = float(0,0,100)
#@gimp : 2nd X-coord = float(0,0,100)
#@gimp : 2nd Y-coord = float(100,0,100)
#@gimp : 3rd X-coord = float(100,0,100)
#@gimp : 3rd Y-coord = float(100,0,100)
#@gimp : Color = color(128,128,128)
#@gimp : Opacity = float(1,0,1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_sierpinski :
  -repeat @# -l[$>] -split_opacity -l[0]
    100%,100% -sierpinski[-1] ${1-7}
    --fc[-2] $8,$9,$10 -j[0] [-1],0,0,0,0,$11,[-2],255 -rm[-2,-1]
  -endl -a c -endl -done

#@gimp Snowflake : gimp_snowflake, gimp_snowflake_preview(1)
#@gimp : Recursions = int(3,0,5)
#@gimp : 1st X-coord = float(20,0,100)
#@gimp : 1st Y-coord = float(70,0,100)
#@gimp : 2nd X-coord = float(80,0,100)
#@gimp : 2nd Y-coord = float(70,0,100)
#@gimp : 3rd X-coord = float(50,0,100)
#@gimp : 3rd Y-coord = float(10,0,100)
#@gimp : Opacity = float(1,0,1)
#@gimp : Color = color(128,128,128)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_snowflake :
  -repeat @# -l[$>] -split_opacity -l[0]
    -snowflake ${1-11}
  -endl -a c -endl -done

gimp_snowflake_preview :
  -gimp_snowflake $*
  -polygon 3,$2%,$3%,$4%,$5%,$6%,$7%,0.7,0xF0F0F0F0,255,255,255,255
  -polygon 3,$2%,$3%,$4%,$5%,$6%,$7%,0.7,0x0F0F0F0F,0,0,0,255
  -circle $2%,$3%,5,0.7,0,0,0,255 -circle $2%,$3%,3,1,255,0,0,255
  -circle $4%,$5%,5,0.7,0,0,0,255 -circle $4%,$5%,3,1,0,255,0,255
  -circle $6%,$7%,5,0.7,0,0,0,255 -circle $6%,$7%,3,1,0,0,255,255

#@gimp Superformula : gimp_superformula, gimp_superformula(1)
#@gimp : Resolution = int(4096,2,8192)
#@gimp : sep = separator()
#@gimp : X-size = float(0.9,0,2)
#@gimp : Y-size = float(0.9,0,2)
#@gimp : sep = separator()
#@gimp : m = int(8,1,32)
#@gimp : n1 = float(1,-32,32)
#@gimp : n2 = float(5,-32,32)
#@gimp : n3 = float(8,-32,32)
#@gimp : sep = separator()
#@gimp : X-angle = float(0,0,360)
#@gimp : Y-angle = float(0,0,360)
#@gimp : Z-angle = float(0,0,360)
#@gimp : sep = separator()
#@gimp : Thickness = float(3,0,50)
#@gimp : Color = color(128,255,128,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>04/18/2011</i>.</small>")
gimp_superformula :
  -repeat @# -l[$>] -to_rgba
    {w},{h}
    -f3d {0.5*max(w,h)/tan($4*pi/360)}
    -superformula3d $1,${4-7}
    -r3d[-1] 0,0,1,$10 -r3d[-1] 0,1,0,$9 -r3d[-1] 1,0,0,$8
    -*3d[-1] {0.5*$2*@{-2,w}},{0.5*$3*@{-2,h}}
    -col3d[-1] 1 -j3d[-2] [-1],50%,50%,0,1,1,0,0 -rm[-1]
    -distance[-1] 1 ->[-1] $11% -*[-2] [-1] -==[-1] 0
    -r[-1] 100%,100%,1,4
    -sh[-1] 0,0 -*[-1] $12 -rm[-1]
    -sh[-1] 1,1 -*[-1] $13 -rm[-1]
    -sh[-1] 2,2 -*[-1] $14 -rm[-1]
    -sh[-1] 3,3 -*[-1] $15 -rm[-1]
    -+[-2,-1]
  -endl -done

#@gimp _<b>Sequences</b>
#-----------------------


# gimp_animate_preview : _command,_parameters1,_parameters2,_compute_half={ 0 | 1 },_width>=0,_height>=0
# Generate a preview with start/end rendering of an animation.
gimp_animate_preview : -skip ${4=1},${5=0},${6=$5}
  -repeat @#
    -if $5 width=$5 -else width={w} -endif
    -if $6 height=$6 -else height={h} -endif
    -if $4 -s[-1] x,2 -else [-1] -endif
    -$1[-2] $2 -$1[-1] $3   # Assume this is a 1->1 filter.
    -r[-2,-1] {max(w,@{-2,w})},{max(h,@{-2,h})},1,100%,3
    -if {!$4} -columns[-2] 0,50% -columns[-1] 50%,100% -endif
    -a[-2,-1] x -r[-1] $width,$height,1,100%,2 -drgba[-1]
    -line[-1] 50%,0,50%,100%,1,0,0,0,255
    -text_outline[-1] "Start",3,-1,13,2,1,255 -text_outline[-1] "End",{w-24},{h-18},13,2,1,255
  -mv[-1] 0 -done

#@gimp 3d elevation [animated] : gimp_animate_elevation3d, gimp_animate_elevation3d_preview(1)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output as frames = _bool(1)
#@gimp : Output as files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Global parameters :</b>"}
#@gimp : Factor = float(100,-1000,1000)
#@gimp : Smoothness = float(1,0,10)
#@gimp : Width = _int(1024,8,4096)
#@gimp : Height = _int(1024,8,4096)
#@gimp : Rendering = choice(2,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Size = float(0.8,0,3)
#@gimp : X-angle = float(35,0,360)
#@gimp : Y-angle = float(0,0,360)
#@gimp : Z-angle = float(0,0,360)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Size = float(0.8,0,3)
#@gimp : X-angle = float(35,0,1440)
#@gimp : Y-angle = float(0,0,1440)
#@gimp : Z-angle = float(360,0,1440)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_animate_elevation3d :
  -if $3 filename="$4/gmic_elevation3d.png" -else filename="" -endif
  -_gimp_elevation3d ${5-6}
  -animate gimp_render3d,"${7-8},${10-19},$9",\
                         "${7-8},${20-29},$9",$1,$2,@{-quote\ $filename}

gimp_animate_elevation3d_preview :
  w={w} h={h}
  -_gimp_elevation3d ${5-6}
  -gimp_animate_preview gimp_render3d,$w","$h",${10-19},$9",\
                                      $w","$h",${20-29},$9",0,$w,$h

#@gimp 3d extrusion [animated] : gimp_animate_extrude3d, gimp_animate_extrude3d_preview(1)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output as frames = _bool(1)
#@gimp : Output as files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Global parameters :</b>"}
#@gimp : Depth = float(10,1,256)
#@gimp : Resolution = int(512,1,1024)
#@gimp : Smoothness = float(0.6,0,3)
#@gimp : Width = _int(1024,8,4096)
#@gimp : Height = _int(1024,8,4096)
#@gimp : Rendering = choice(4,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Size = float(0.8,0,3)
#@gimp : X-angle = float(35,0,360)
#@gimp : Y-angle = float(0,0,360)
#@gimp : Z-angle = float(0,0,360)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Size = float(0.8,0,3)
#@gimp : X-angle = float(35,0,1440)
#@gimp : Y-angle = float(360,0,1440)
#@gimp : Z-angle = float(0,0,1440)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_animate_extrude3d :
  -if $3 filename="$4/gmic_extrude3d.png" -else filename="" -endif
  -_gimp_extrude3d ${5-7}
  -animate gimp_render3d,"${8-9},${11-20},$10",\
                         "${8-9},${21-30},$10",$1,$2,@{-quote\ $filename}

gimp_animate_extrude3d_preview :
  w={w} h={h}
  -_gimp_extrude3d ${5-7}
  -gimp_animate_preview gimp_render3d,$w","$h",${11-20},$10",\
                                      $w","$h",${21-30},$10",0,$w,$h

#@gimp 3d image object [animated] : gimp_animate_imageobject3d, gimp_animate_imageobject3d_preview(1)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output as frames = _bool(1)
#@gimp : Output as files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Global parameters :</b>"}
#@gimp : Type = choice{1,"Plane","Cube","Pyramid","Sphere","Torus","Gyroid","Weird","Cup","Rubik"}
#@gimp : Width = _int(1024,1,4096)
#@gimp : Height = _int(1024,1,4096)
#@gimp : Rendering = choice(4,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Size = float(0.5,0,3)
#@gimp : X-angle = float(57,0,360)
#@gimp : Y-angle = float(41,0,360)
#@gimp : Z-angle = float(21,0,360)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Size = float(0.5,0,3)
#@gimp : X-angle = float(57,0,1440)
#@gimp : Y-angle = float(401,0,1440)
#@gimp : Z-angle = float(21,0,1440)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_animate_imageobject3d :
  -if $3 filename="$4/gmic_imageobject3d.png" -else filename="" -endif
  -_gimp_imageobject3d "_",$5
  -animate gimp_render3d,"${6-7},${9-18},$8",\
                         "${6-7},${19-28},$8",$1,$2,@{-quote\ $filename}

gimp_animate_imageobject3d_preview :
  w={w} h={h}
  -_gimp_imageobject3d "_preview_",$5
  -gimp_animate_preview gimp_render3d,$w","$h",${9-18},$8",\
                                      $w","$h",${19-28},$8",0,$w,$h

#@gimp 3d text pointcloud : gimp_text_pointcloud3d, gimp_text_pointcloud3d_preview
#@gimp : Frames = _int(64,1,256)
#@gimp : 1st text = text("G'MIC")
#@gimp : 2nd text = text("Rocks!")
#@gimp : Smoothness = float(1,0,5)
#@gimp : Color = color(200,220,255)
#@gimp : Background = color(255,255,255,255)
#@gimp : X-shadow= float(2,0,10)
#@gimp : Y-shadow= float(2,0,10)
#@gimp : Shadow smoothness = float(1,0,5)
#@gimp : Stationary frames = _int(19,1,32)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>09/01/2012</i>.</small>")
gimp_text_pointcloud3d :
  W={w} H={h} M={round(1.5*max(w,h))} -rm
  -text_pointcloud3d "$2","$3",$4
  -col3d[-1] ${5-7} -*3d[-1] {0.7*$M}
  -f3d 4000 -db3d 0 -m3d
  -repeat $1
    -rprogress {60*$>/$1}
    angle={$>*360/$1}
    --r3d[0] 1,0,1,$angle
    $M,$M,1,3,-1 -j3d[-1] [-2],50%,50%,0,1 -rm[-2]
  -done
  -rm[0] -a z -autocrop -1 -to_rgba -s z -replace_color 0,0,-1,-1,-1,255,0,0,0,0
  -if $11 N=@# -repeat @# -l[$>] -rprogress {60+40*$>/$N}
    -i[0] 100%,100%,1,4 -fc[0] ${8-11} --channels[-1] 3,3 --negative[-1] -b[-2,-1] $14% -to_rgba[-1]
    -j[0] [-1],$12%,$13%,0,0,1,[-2],255 -rm[-2,-1] -blend alpha
  -endl -done -endif
  -if {$W>$H} -r2dx $W -else -r2dy $H -endif
  -if {$15>1}
    -i[{int($1/2)}] [{int($1/2)}]x{$15-1}
    -i[0] [0]x{$15-1}
  -endif

gimp_text_pointcloud3d_preview :
  -gimp_text_pointcloud3d 4,"$2","$3",$4,${5-7},${8-11},${12-14},1 -drgba
  -frame 1,1,0 -append_tiles 2,2

#@gimp 3d tiles : gimp_transition3d, gimp_transition3d_preview(0)
#@gimp : Inter-frames = _int(10,3,100)
#@gimp : X-tiles = int(8,1,64)
#@gimp : Y-tiles = int(8,1,64)
#@gimp : X-rotation = text("1")
#@gimp : Y-rotation = text("1")
#@gimp : Z-rotation = text("0")
#@gimp : Focale = float(800,100,2000)
#@gimp : Enable antialiasing = bool(1)
#@gimp : sep = separator(), note = note{"<small><b>Note:</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>08/13/2012</i>.</small>")
gimp_transition3d :
  -f3d $7
  -transition3d $1,$2,$3,"$4","$5","$6",$8

gimp_transition3d_preview :
  -if {@#==1} -gimp_warning_preview "Missing input layer" -return -endif
  -f3d $7
  -k[0,1] -transition3d 4,$2,$3,"$4","$5","$6",$8
  -k[1,2]
  -r[0] 50%,100%,1,100%,0
  -r[1] 50%,100%,1,100%,0,0,1
  -a x
  -line 50%,0,50%,100%,1,0,0,0,255

#@gimp Plasma transition : gimp_transition_plasma, gimp_transition_plasma_preview(0)
#@gimp : Frames = _int(30,2,100)
#@gimp : Scale = int(5,0,10)
#@gimp : Smoothness = float(0.5,0,4)
#@gimp : sep = separator(), note = note{"<small><b>Note:</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>11/09/2012</i>.</small>")
gimp_transition_plasma :
  -transition_plasma $1,$2,$3%

gimp_transition_plasma_preview :
  -if {@#==1} -gimp_warning_preview "Missing input layer" -return -endif
  -k[0,1] -transition_plasma 6,$2,$3% -k[1--2] -frame 1,1,0 -append_tiles ,

#@gimp B&amp;W pencil [animated] : gimp_animate_pencilbw, gimp_animate_pencilbw_preview(0)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output frames = _bool(1)
#@gimp : Output files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Pencil type = float(2.3,0,5)
#@gimp : Amplitude = float(100,0,200)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Pencil type = float(0.3,0,5)
#@gimp : Amplitude = float(60,0,200)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_animate_pencilbw :
  -if $3 filename="$4/gmic_pencilbw.png" -else filename="" -endif
  -animate pencilbw,"${5-6}",\
                    "${7-8}",$1,$2,@{-quote\ $filename}

gimp_animate_pencilbw_preview :
  -gimp_animate_preview pencilbw,"${5-6}",\
                                 "${7-8}"

#@gimp B&amp;W stencil [animated] : gimp_animate_stencilbw, gimp_animate_stencilbw_preview(1)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output frames = _bool(1)
#@gimp : Output files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Edge threshold = float(10,0,30)
#@gimp : Smoothness = float(10,0,30)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Edge threshold = float(10,0,30)
#@gimp : Smoothness = float(20,0,30)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_animate_stencilbw :
  -if $3 filename="$4/gmic_stencilbw.png" -else filename="" -endif
  -animate stencilbw,"${5-6}",\
                     "${7-8}",$1,$2,@{-quote\ $filename}

gimp_animate_stencilbw_preview :
  -gimp_animate_preview stencilbw,"${5-6}",\
                                  "${7-8}"

#@gimp Cartoon [animated] : gimp_animate_cartoon, gimp_animate_cartoon_preview(0)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output frames = _bool(1)
#@gimp : Output files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Global parameters :</b>"}
#@gimp : Color quantization = int(4,2,256)
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Smoothness = float(0.5,0,2)
#@gimp : Sharpening = float(200,0,400)
#@gimp : Edge threshold = float(10,1,30)
#@gimp : Edge thickness = float(0.1,0,1)
#@gimp : Color strength = float(1.5,0,3)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Smoothness = float(3,0,2)
#@gimp : Sharpening = float(200,0,400)
#@gimp : Edge threshold = float(10,1,30)
#@gimp : Edge thickness = float(0.1,0,1)
#@gimp : Color strength = float(1.5,0,3)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_animate_cartoon :
  -if $3 filename="$4/gmic_cartoon.png" -else filename="" -endif
  -animate cartoon,"${6-10},$5",\
                   "${11-15},$5",$1,$2,@{-quote\ $filename}

gimp_animate_cartoon_preview :
  -gimp_animate_preview cartoon,"${6-10},$5",\
                                "${11-15},$5"

#@gimp Edges [animated] : gimp_animate_edges, gimp_animate_edges_preview(0)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output frames = _bool(1)
#@gimp : Output files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Global parameters :</b>"}
#@gimp : Negative colors = bool(0)
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Smoothness = float(0,0,10)
#@gimp : Edge threshold = float(10,0,30)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Smoothness = float(0,0,10)
#@gimp : Edge threshold = float(30,0,30)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_animate_edges :
  -if $3 filename="$4/gmic_edges.png" -else filename="" -endif
  -animate gimp_edges,"${6-7},$5",\
                      "${8-9},$5",$1,$2,@{-quote\ $filename}

gimp_animate_edges_preview :
  -gimp_animate_preview gimp_edges,"${6-7},$5",\
                                   "${8-9},$5"

#@gimp Edges on fire : gimp_fire_edges, gimp_fire_edges_preview(0)
#@gimp : Edges = float(0.7,0,3)
#@gimp : Attenuation = float(0.25,0,1)
#@gimp : Smoothness = float(0.5,0,5)
#@gimp : Threshold = float(25,0,100)
#@gimp : sep = separator()
#@gimp : Number of frames = _int(20,1,999)
#@gimp : Starting frame = int(20,0,199)
#@gimp : Frame skip = _int(0,0,20)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>07/06/2011</i>.</small>")
gimp_fire_edges :
  -fire_edges ${1-7} -rv

gimp_fire_edges_preview :
  -gimp_split_preview "-fire_edges $1,$2,$3,$4,1,$6,0",$-1

#@gimp Lava lamp : gimp_lavalampbw, gimp_lavalampbw_preview(0)
#@gimp : Number of key-frames = _int(3,2,50)
#@gimp : Number of inter-frames = _int(30,2,100)
#@gimp : Smooth looping = _bool(1)
#@gimp : sep = separator()
#@gimp : Resolution = float(20,1,100)
#@gimp : Size = float(2,0,30)
#@gimp : Smoothness = _float(0.01,0,1)
#@gimp : Transparent background = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>07/06/2011</i>.</small>")
gimp_lavalampbw :
  -if {!@#} (255;100^64;16^128;0) -r[-1] 512,512,1,3,3 -endif
  -repeat @# -l[$<]
    w={w} h={h}
    --r $4%,$4%,1,1,0 [-1]x{$1-1} -rand[^0] 0,1 -stencil[^0] $5,0
    -if $3 [1] -endif
    -morph[^0] $2,$6,0
    -stencil[^0] $5,0
    -r[^0] $w,$h,1,1,3 -b[^0] 10 ->=[^0] 50% -*[^0] 255
    -r[^0] 100%,100%,1,4 -j[^0] [0] -rm[0]
    -if $3 -rm[-1] -endif
  -endl -done
  -if {!$7} -repeat @# -l[$>] -split_opacity -n[-1] 0,1 -*[^-1] [-1] -rm[-1] -endl -done -endif

gimp_lavalampbw_preview :
  -gimp_lavalampbw 2,2,1,$4,$5,$6,$7 -k[0]

#@gimp Lissajous [animated] : gimp_animate_lissajous, gimp_animate_lissajous_preview(1)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output as frames = _bool(1)
#@gimp : Output as files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : sep = separator()
#@gimp : note = note{"<b>Starting parameters :</b>"}
#@gimp : Resolution = int(4096,2,8192)
#@gimp : X-size = float(0.9,0,2)
#@gimp : Y-size = float(0.9,0,2)
#@gimp : Z-size = float(3,1,10)
#@gimp : X-multiplier = float(8,0,32)
#@gimp : Y-multiplier = float(7,0,32)
#@gimp : Z-multiplier = float(0,0,32)
#@gimp : X-offset = float(0,0,1)
#@gimp : Y-offset = float(0,0,1)
#@gimp : Z-offset = float(0,0,1)
#@gimp : X-angle = float(0,0,360)
#@gimp : Y-angle = float(0,0,360)
#@gimp : Z-angle = float(0,0,360)
#@gimp : Thickness = float(0,0,50)
#@gimp : Color = color(255,255,255,255)
#@gimp : sep = separator()
#@gimp : note = note{"<b>Ending parameters :</b>"}
#@gimp : Resolution = int(4096,2,8192)
#@gimp : X-size = float(0.9,0,2)
#@gimp : Y-size = float(0.9,0,2)
#@gimp : Z-size = float(3,1,10)
#@gimp : X-multiplier = float(8,0,32)
#@gimp : Y-multiplier = float(7,0,32)
#@gimp : Z-multiplier = float(0,0,32)
#@gimp : X-offset = float(0,0,1)
#@gimp : Y-offset = float(0,0,1)
#@gimp : Z-offset = float(0,0,1)
#@gimp : X-angle = float(0,0,360)
#@gimp : Y-angle = float(0,0,360)
#@gimp : Z-angle = float(0,0,360)
#@gimp : Thickness = float(0,0,50)
#@gimp : Color = color(255,255,255,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>04/18/2011</i>.</small>")
gimp_animate_lissajous :
  -if $3 filename="$4/gmic_lissajous.png" -else filename="" -endif
  -animate gimp_lissajous,"${5-22}",\
                          "${23-40}",$1,$2,@{-quote\ $filename}

gimp_animate_lissajous_preview :
  -gimp_animate_preview gimp_lissajous,"${5-22}",\
                                       "${23-40}",0

#@gimp Morphological filter [animated] : gimp_animate_morpho, gimp_animate_morpho_preview(0)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output as frames = _bool(1)
#@gimp : Output as files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Global parameters :</b>"}
#@gimp : Action = choice("Erosion","Dilation","Opening","Closing",
#@gimp : "Original - Erosion","Dilation - Original","Original - Opening","Closing - Original")
#@gimp : Invert colors = bool(false)
#@gimp : Shape = choice(0,"Square","Octagonal","Circular")
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Size = int(5,1,100)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Size = int(50,2,100)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_animate_morpho :
  -if $3 filename="$4/gmic_morpho.png" -else filename="" -endif
  -animate gimp_morpho,"$5,$8,$6,$7,0,1",\
                       "$5,$9,$6,$7,0,1",$1,$2,@{-quote\ $filename}

gimp_animate_morpho_preview :
  -gimp_animate_preview gimp_morpho,"$5,$8,$6,$7,0,1",\
                                    "$5,$9,$6,$7,0,1"

#@gimp Rodilius [animated] : gimp_animate_rodilius, gimp_animate_rodilius_preview(1)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output as frames = _bool(1)
#@gimp : Output as files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : Color mode = choice(1,"Darker","Lighter")
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Amplitude = float(10,0,30)
#@gimp : Thickness = float(10,0,100)
#@gimp : Sharpness = float(300,0,1000)
#@gimp : Orientations = int(5,2,20)
#@gimp : Offset = float(0,0,180)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Amplitude = float(10,0,30)
#@gimp : Thickness = float(10,0,100)
#@gimp : Sharpness = float(300,0,1000)
#@gimp : Orientations = int(5,2,20)
#@gimp : Offset = float(180,0,180)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_animate_rodilius :
  -if $3 filename="$4/gmic_rodilius.png" -else filename="" -endif
  -animate rodilius,"${6-10},$5",\
                    "${11-15},$5",$1,$2,@{-quote\ $filename}

gimp_animate_rodilius_preview :
  -gimp_animate_preview rodilius,"${6-10},$5",\
                                 "${11-15},$5"

#@gimp Soft glow [animated] : gimp_animate_glow, gimp_animate_glow_preview(1)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output as frames = _bool(1)
#@gimp : Output as files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Amplitude = float(0,0,8)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Amplitude = float(3,0,8)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_animate_glow :
  -if $3 filename="$4/gmic_glow.png" -else filename="" -endif
  -animate glow,"$5",\
                "$6",$1,$2,@{-quote\ $filename}

gimp_animate_glow_preview :
  -gimp_animate_preview glow,"$5",\
                             "$6"

#@gimp _<b>Spectral filters</b>
#------------------------------

#@gimp Bandpass : gimp_bandpass, gimp_bandpass_preview(0)
#@gimp : Low frequency = float(0,0,100)
#@gimp : High frequency = float(100,0,100)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : Value range = choice(1,"Cut","Normalize")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_bandpass :
  -repeat @# -l[$>] -split_opacity -l[0]
    -apply_channels "-bandpass $1%,$2%",$3,$4
  -endl -a c -endl -done

gimp_bandpass_preview :
  -gimp_split_preview "-gimp_bandpass $*",$-1

#@gimp Fourier analysis : gimp_display_fft, gimp_display_fft(1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_display_fft :
  -to_rgb -display_fft

#@gimp Fourier transform : gimp_fourier, gimp_fourier_preview(1)
#@gimp : Transform = choice(0,"Direct","Inverse")
#@gimp : Discard transparency = bool(1)
#@gimp : link = link("Click here for a video tutorial","http://www.youtube.com/watch?v=3137dDa6P4s")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>08/11/2014</i>.</small>")
gimp_fourier : -skip ${2=0}
  -if $2 -remove_opacity -endif
  -if $1 -repeat @# -l
      -fft82float -c 0,255
      -onfail -error "Image ["$>"] does not seem to be a FFT transform."
    -endl -done
  -else -float2fft8 -endif

gimp_fourier_preview :
  -if $2 -remove_opacity -endif
  -if $1 -gimp_no_preview 0
  -else -dfft
  -endif

#@gimp Fourier watermark : gimp_watermark_fourier, _none_
#@gimp : Text = text{"(c) G'MIC"}
#@gimp : Size = int(53,13,128)
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Note: </b> To make the watermark visible afterwards, use the 'Fourier Analysis' filter. </small>")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_watermark_fourier :
  -watermark_fourier "$1",$2 -c 0,255

#@gimp _<b>Various</b>
#----------------------

#@gimp Custom code (local) : gimp_custom_code, gimp_custom_code_preview(0)
#@gimp : Code = text(1,"-repeat @# -l[$>]\n\n  -to_rgb\n  --deform 20\n  -blend_edges 3\n\n-endl -done\n\n\n")
#@gimp : sep = separator()
#@gimp : Value range = choice("Cut","Normalize")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator()
#@gimp : note = note{"<small><b>Note: </b>
#@gimp : This filter can execute any set of instructions understood by the <b>G'MIC</b> language interpreter.
#@gimp : Here, you can then test some commands before creating your own G'MIC custom commands and GIMP menu entries.\n\n
#@gimp : Please look at the documentation reference web page :</small>"}
#@gimp : note = link("http://gmic.eu/reference.shtml")
#@gimp : note = note{"<small>
#@gimp : to learn more about available <b>G'MIC</b> commands.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>06/14/2011</i>.</small>")

#@gimp Custom code (global) : gimp_custom_code, gimp_custom_code_preview(1)
#@gimp : Code = text(1,"-repeat @# -l[$>]\n\n  -to_rgb\n  --deform 20\n  -blend_edges 3\n\n-endl -done\n\n\n")
#@gimp : sep = separator()
#@gimp : Value range = choice("Cut","Normalize")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator()
#@gimp : note = note{"<small><b>Note: </b>
#@gimp : This filter can execute any set of instructions understood by the <b>G'MIC</b> language interpreter.
#@gimp : Here, you can then test some commands before creating your own G'MIC custom commands and GIMP menu entries.\n\n
#@gimp : Please look at the documentation reference web page :</small>"}
#@gimp : note = link("http://gmic.eu/reference.shtml")
#@gimp : note = note{"<small>
#@gimp : to learn more about available <b>G'MIC</b> commands.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>06/14/2011</i>.</small>")
gimp_custom_code : -skip "${1=-skip ,}"
  -m "_gimp_custom_code_start : $1"
  -if {$3>0}
    -apply_channels "-_gimp_custom_code_start",$3,$2
  -else
    -_gimp_custom_code
    -if $2 -n 0,255 -else -c 0,255 -endif
  -endif
  -uncommand _gimp_custom_code_start

gimp_custom_code_preview : -skip "${1=-skip ,}"
  w={w} h={h}
  -l _gcp_arg="$1" -gimp_split_preview "-gimp_custom_code $_gcp_arg,${2--2}",$-1
  -onfail
    error_msg=@{}
    -rr2d $w,$h,2,1
    -gimp_print_preview "Syntax error:",,$error_msg,15,40
  -endl

_gimp_custom_code :
  -_gimp_custom_code_start

#@gimp Do nothing : gimp_do_nothing, gimp_do_nothing
#@gimp : note = note("<small><b>Note</b> : This filters does nothing on the image. Use it to manipulate layers in conjunction with the input/output options of the G'MIC plug-in.</small>")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_do_nothing :

#@gimp Games &amp; demos : gimp_gmic_demos, gimp_gmic_demos_preview
#@gimp : Selection = choice("2048","Blobs editor","Bouncing balls","Fire effect","Fireworks","Fish-eye effect","Fourier filtering",
#@gimp : "Histogram","Hough transform","Jawbreaker","The Game of Life","Light effect","Mandelbrot explorer","3d Metaballs","Minesweeper",
#@gimp : "Minimal path","Pacman","Paint","Plasma effect","RGB Quantization","3d reflection","3d rubber object","Shadebobs","Spline editor",
#@gimp : "Tetris","Tic-Tac-Toe","3d waves","Fractal whirl")
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Note:</b> This filter proposes a showcase of some interactive demos, all written as G'MIC scripts.
#@gimp : </small>")
#@gimp : note = note{"<small>On most demos, you can use the keyboard shortcut <b>CTRL+D</b> to double the window size (and <b>CTRL+C</b> to go back to the original size).
#@gimp : Also, feel free to use the mouse buttons, as they are often used to perform an action.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>09/10/2014</i>.</small>")
gimp_gmic_demos :
  coms=2048,blobs,bouncing,fire,fireworks,fisheye,fourier,histogram,hough,jawbreaker,life,light,\
       mandelbrot,metaballs3d,minesweeper,minimal_path,pacman,paint,plasma,quantize_rgb,reflection3d,\
       rubber3d,shadebobs,spline,tetris,tictactoe,waves,whirl
  com=@{-arg\ {1+$1},$coms}
  -if {@#>0} sel=0 -else sel= -endif
  --l[$sel] -m "foo : -x_"$com -foo -rm -uncommand foo -endl

gimp_gmic_demos_preview :
  -rm filename=@{-path_tmp}/gmic_demos.cimgz
  -if $filename $filename
  -else -l[] http://gmic.eu/img/gmic_demos.cimgz -o $filename -endl
  -endif
  -k[$1,-1] -rows[-1] $1 -map[0] [1] -k[0]

#@gimp Histogram analysis : _none_, gimp_display_histogram(1)
#@gimp : Clusters = int(256,2,256)
#@gimp : Luminance only = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_display_histogram :
  -to_rgb -if $2 -luminance -endif
  -repeat @#
    -display_histogram[-1] {w},{h},$1,0,255
  -mv[-1] 0 -done

#@gimp Import data : gimp_import_image, gimp_no_preview
#@gimp : Filename = file()
#@gimp : Normalize = bool(1)
#@gimp : note = note{"\n<small><b>Note: </b>
#@gimp : This filter can import any image data read by the <b>G'MIC</b> language interpreter.
#@gimp : It includes exotic formats as : <i>Pandore, CImg, Inrimage, AVI/MPEG (requires FFMPEG installed), ...</i>
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>12/29/2010</i>.</small>")
gimp_import_image :
  -rm -i "$1" -s z -if $2 -n 0,255 -else -c 0,255 -endif

#@gimp Solve maze : gimp_solve_maze, gimp_solve_maze_preview(1)
#@gimp : Starting X-coord = float(5,0,100)
#@gimp : Starting Y-coord = float(5,0,100)
#@gimp : Ending X-coord = float(95,0,100)
#@gimp : Endind Y-coord = float(95,0,100)
#@gimp : Smoothness = float(0.1,0,1)
#@gimp : Thickness = int(3,1,10)
#@gimp : Color = color(255,0,0)
#@gimp : Maze type = choice("Dark walls","White walls")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>09/01/2011</i>.</small>")
gimp_solve_maze :
  -repeat @#
    --norm[-1] ->=[-1] 50%
    -if {!$10} -negative[-1] -endif
    -*[-1] 255 --b[-1] $5% -*[-2] 1e10 -+[-2,-1]
    -minimal_path[-1] $1%,$2%,0,$3%,$4%,0
    -pointcloud[-1] 0 -dilate[-1] $6 -r[-1] [-2],[-2],1,1,0
    -to_rgba[-1]
    -replace_color[-1] 0,0,1,1,1,255,${7-9},255
    -replace_color[-1] 0,0,0,0,0,255,0,0,0,0
    -ellipse[-1] $1%,$2%,5,5,0,1,${7-9},255
    -ellipse[-1] $3%,$4%,5,5,0,1,${7-9},255
    -rv[-2,-1]
  -mv[-2,-1] 0 -done

gimp_solve_maze_preview :
  -drgba
  -line $1%,$2%,$3%,$4%,1,0xCCCCCCCC,${7-9}
  -ellipse $1%,$2%,3,3,0,1,${7-9}
  -ellipse $1%,$2%,3,3,0,1,0x1,0
  -ellipse $3%,$4%,3,3,0,1,${7-9}
  -ellipse $3%,$4%,3,3,0,1,0x1,0

#-------------------------------------
#
# Define menu entries for
# the G'MIC online web service.
#
#-------------------------------------

#@gmicol <i>About</i>
#--------------------

#@gmicol G'MIC Online : _none_, gmicol_logo_en
#@gmicol : note = note{"
#@gmicol : <span foreground="purple">( <b>G</b>REYC's <b>M</b>agic for <b>I</b>mage <b>C</b>omputing <b>O</b>n-<b>L</b>ine)</span>\n\nis proposed to you by"}
#@gmicol : note = link("S&#233;bastien Fourey","http://foureys.users.greyc.fr/")
#@gmicol : note = link("David Tschumperl&#233;","http://tschumperle.users.greyc.fr/")
#@gmicol : note = link{"( IMAGE Team / GREYC Laboratory - CNRS UMR 6072 )","http://www.greyc.fr/node/36"}
#@gmicol : note = note{"
#@gmicol : This web-service is based on our software <b>G'MIC</b> available at:"}
#@gmicol : note = link("http://gmic.eu/")
#@gmicol : note = note{"Colorpickers and sliders widgets are provided by the <b>DHTMLX</b> project:"}
#@gmicol : note = link("http://www.dhtmlx.com")
#@gmicol : sep = separator()
#@gmicol : note = note{"<b>G'MIC</b> is also available as a free plug-in for the image retouching software <b>GIMP</b>. Download it to get more filters
#@gmicol : and features than in the online version, at:"}
#@gmicol : note = link{"The G'MIC plug-in for GIMP","http://gmic.eu/gimp.shtml"}
#@gmicol : sep = separator(), note = note("<small>Authors: <i>S&#233;bastien Fourey</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>10/11/2012</i>.</small>")
gmicol_logo_en :
  -gimp_logo_version{round(?(0.5,3.49))} "    - Online -\n    "[" "@{-strver}" "]

#@gmicol clone("Contributors")

#@gmicol _<b>Arrays &amp; tiles</b>
#----------------------------------

#@gmicol Array [faded] : gimp_array_fade, gimp_array_fade_preview(1)
#@gmicol : X-tiles = int(2,1,10)
#@gmicol : Y-tiles = int(2,1,10)
#@gmicol : X-offset = float(0,0,100)
#@gmicol : Y-offset = float(0,0,100)
#@gmicol : Fade start = float(80,1,100)
#@gmicol : Fade end = float(90,1,100)
#@gmicol : Mirror = choice("None","x-axis","y-axis","xy-axes")
#@gmicol : Size = _choice("Shrink", "Expand")
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/11/2012</i>.</small>")

#@gmicol clone("Array [mirrored]")
#@gmicol clone("Array [random]")
#@gmicol clone("Array [regular]")
#@gmicol clone("Ascii art")
#@gmicol clone("Chessboard")
#@gmicol : thumbnail_parameters = 16,16,0,0,0,0.5,0,0,0,255,255,255,255,255,0

#@gmicol clone("Dices")
#@gmicol clone("Grid [cartesian]")
#@gmicol clone("Grid [hexagonal]")
#@gmicol clone("Make seamless")
#@gmicol clone("Ministeck")
#@gmicol clone("Puzzle")
#@gmicol clone("Taquin")
#@gmicol clone("Tileable rotation")
#@gmicol clone("Tiled rotation")
#@gmicol clone("Tiled normalization")
#@gmicol clone("Tiled random shifts")
#@gmicol clone("Tiled parameterization")
#@gmicol clone("Tiled isolation")
#@gmicol : thumbnail_parameters = 10,10,10,10,1,1

#@gmicol _<b>Artistic</b>
#------------------------

#@gmicol clone("Bokeh")
#@gmicol clone("Cartoon")
#@gmicol clone("Circle abstraction")
#@gmicol clone("Cubism")
#@gmicol clone("Cutout")
#@gmicol clone("Ellipsionism")
#@gmicol clone("Felt pen")
#@gmicol clone("Fractalize")
#@gmicol clone("Hope poster")
#@gmicol clone("Kuwahara")
#@gmicol clone("Lylejk's painting")
#@gmicol clone("Painting")
#@gmicol clone("Pen drawing")
#@gmicol clone("Polygonize [delaunay]")
#@gmicol clone("Polygonize [energy]")
#@gmicol clone("Poster edges")
#@gmicol clone("Rodilius")
#@gmicol clone("Warhol")
#@gmicol clone("Whirl drawing")

#@gmicol _<b>Basics</b>
#----------------------

#@gmicol Adjust colors : gmicol_adjust_colors, gmicol_adjust_colors_preview
#@gmicol : Contrast = float(1,0,3)
#@gmicol : Brightness = float(0,-1,1)
#@gmicol : Gamma = float(0,-1.2,1.2)
#@gmicol : Hue = float(0,0,360)
#@gmicol : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/23/2012</i>.</small>")
#@gmicol : thumbnail_parameters = 1.8,0,0,50
gmicol_adjust_colors :
  -repeat @# -l[$>]
    avg={ia} -- $avg -* $1 -+ $avg
    -+ {$2*256}
    -if {$3!=1} -apply_gamma {10^$3} -endif
    -if {$4%360}
      -to_colormode {max(3,s)+1-s%2} -split_opacity -l[0]
        -rgb2hsv -sh 0,0 -+[-1] $4 -%[-1] 360 -rm[-1] -hsv2rgb
      -endl
    -a c -endif
  -endl -done -c 0,255

gmicol_adjust_colors_preview :
  -gimp_split_preview "-gmicol_adjust_colors $*",$-1

#@gmicol Autocrop : autocrop, autocrop
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/25/2012</i>.</small>")

#@gmicol Crop : gmicol_crop, gmicol_crop_preview
#@gmicol : Left coordinate = float(25,0,100)
#@gmicol : Up coordinate = float(25,0,100)
#@gmicol : Right coordinate = float(75,0,100)
#@gmicol : Bottom coordinate = float(75,0,100)
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/18/2012</i>.</small>")
gmicol_crop :
  -z $1%,$2%,$3%,$4%

gmicol_crop_preview :
  -rectangle $1%,$2%,$3%,$4%,0.5,128
  -rectangle $1%,$2%,$3%,$4%,1,0xFFFFFFFF,0
  -circle $1%,$2%,3,1,0,255,0 -circle $1%,$2%,3,1,0xFFFFFFFF,0
  -circle $3%,$2%,3,1,0,255,0 -circle $3%,$2%,3,1,0xFFFFFFFF,0
  -circle $3%,$4%,3,1,0,255,0 -circle $3%,$4%,3,1,0xFFFFFFFF,0
  -circle $1%,$4%,3,1,0,255,0 -circle $1%,$4%,3,1,0xFFFFFFFF,0

#@gmicol Equalize : gmicol_equalize, gmicol_equalize_preview
#@gmicol : Channel(s) = choice(3,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gmicol : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/18/2012</i>.</small>")
gmicol_equalize :
  -apply_channels "-equalize 256,0,255",$1,1

gmicol_equalize_preview :
  -gimp_split_preview "-gmicol_equalize $*",$-1

#@gmicol Flip : gmicol_flip, gmicol_flip
#@gmicol : Type = choice("Horizontal","Vertical")
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/23/2012</i>.</small>")
gmicol_flip :
  -if $1 -mirror y -else -mirror x -endif

#@gmicol Histogram : gmicol_histogram, gmicol_histogram_preview
#@gmicol : Levels = int(128,1,256)
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/18/2012</i>.</small>")
#@gmicol : thumbnail_parameters = 32
gmicol_histogram :
  -to_rgb -dh 640,480,$1

gmicol_histogram_preview :
  -to_rgb -dh 320,240,$1

#@gmicol Negative : negative, negative
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/23/2012</i>.</small>")

#@gmicol Resize : gmicol_resize, _none_
#@gmicol : Type = choice("Ratio in %","Prescribed width","Prescribed height")
#@gmicol : Ratio in % = float(50,0,300)
#@gmicol : Prescribed width = int(256,8,1280)
#@gmicol : Prescribed height = int(256,8,1280)
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/23/2012</i>.</small>")
gmicol_resize :
  -if {$1==0}
    -r $2%,$2%,1,100%,6
  -elif {$1==1}
    -resize2dx $3,6
  -else
    -resize2dy $4,6
  -endif
  -c 0,255

#@gmicol Rotate : gmicol_rotate, gmicol_rotate
#@gmicol : Angle = float(30,0,359)
#@gmicol : Stick to nearest 90 deg. = bool(0)
#@gmicol : Boundary = choice("Transparent","Nearest","Repeat")
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/23/2012</i>.</small>")
gmicol_rotate :
  -if $2
    -rotate {90*round($1/90)},0,0
  -else
    -to_rgba -rotate $1,1,$3
  -endif

#@gmicol _<b>Black &amp; white</b>
#---------------------------------

#@gmicol clone("Black &amp; white")
#@gmicol clone("B&amp;W stencil")
#@gmicol clone("Charcoal")
#@gmicol clone("Colorize [with colormap]")
#@gmicol clone("Dithering")
#@gmicol clone("Hard sketch")
#@gmicol clone("Hough sketch")
#@gmicol clone("Ink wash")
##@gmicol clone("Multi-layer etch")
#@gmicol clone("Pencil")
#@gmicol clone("Pencil portrait")
#@gmicol clone("Sketch")
#@gmicol clone("Stamp")
#@gmicol clone("Threshold etch")

#@gmicol _<b>Colors</b>
#----------------------

#@gmicol clone("Abstraction")
#@gmicol clone("Boost-fade")
#@gmicol : thumbnail_parameters = 10

#@gmicol clone("Boost chromaticity")
#@gmicol clone("Channel processing")
#@gmicol clone("CMYK tone")
#@gmicol clone("Colormap")
#@gmicol clone("Color balance")
#@gmicol clone("Color grading")
#@gmicol clone("Color temperature")
#@gmicol clone("Curves")

#@gmicol Curves [RGB]
#@gmicol clone("Red")
#@gmicol clone("Green")
#@gmicol clone("Blue")
#@gmicol _

#@gmicol Curves [YCbCr]
#@gmicol clone("Luminance")
#@gmicol clone("Blue chrominance")
#@gmicol clone("Red chrominance")
#@gmicol _

#@gmicol Curves [Lab]
#@gmicol clone("Lightness")
#@gmicol clone("A-color")
#@gmicol clone("B-color")
#@gmicol _

#@gmicol clone("Detect skin")
#@gmicol clone("Equalize HSV")
#@gmicol clone("HSL adjustment")
#@gmicol clone("HSV select")
#@gmicol clone("Infrared simulation")
#@gmicol clone("Metallic look")
#@gmicol clone("Mixer [RGB]")
#@gmicol clone("Mixer [YCbCr]")
#@gmicol clone("Mixer [HSV]")
#@gmicol clone("Mixer [Lab]")
#@gmicol clone("Mixer [CMYK]")
#@gmicol clone("RGB tone")
#@gmicol clone("Select/replace color")
#@gmicol clone("Sepia")
#@gmicol clone("Tone presets")
#@gmicol clone("User-defined")
#@gmicol clone("Vintage style")
#@gmicol clone("Zone system")

#@gmicol _<b>Contours</b>
#------------------------

#@gmicol clone("Convolve")
#@gmicol clone("Curvature")
#@gmicol clone("Difference of gaussians")
#@gmicol clone("Distance transform")
#@gmicol clone("Edges")
#@gmicol clone("Edges offsets")
#@gmicol clone("Gradient norm")
#@gmicol clone("Gradient RGB")
#@gmicol clone("Isophotes")
#@gmicol clone("Laplacian")
#@gmicol clone("Local orientation")
#@gmicol clone("Morphological filter")
#@gmicol clone("Segmentation")
#@gmicol clone("Skeleton")
#@gmicol clone("Thin edges")

#@gmicol _<b>Deformations</b>
#----------------------------

#@gmicol clone("Cartesian transform")
#@gmicol clone("Circle transform")
#@gmicol clone("Euclidean - polar")
#@gmicol clone("Fish-eye")
#@gmicol clone("Flower")
#@gmicol clone("Kaleidoscope [blended]")
#@gmicol clone("Kaleidoscope [polar]")
#@gmicol clone("Kaleidoscope [symmetry]")
#@gmicol clone("Perspective")
#@gmicol clone("Polar transform")
#@gmicol clone("Raindrops")
#@gmicol clone("Random")
#@gmicol clone("Ripple")
#@gmicol clone("Reflection")
#@gmicol clone("Seamcarve")
#@gmicol clone("Sphere")
#@gmicol clone("Symmetrize")
#@gmicol clone("Textured glass")
#@gmicol clone("Twirl")
#@gmicol clone("Water")
#@gmicol clone("Wave")
#@gmicol clone("Wind")
#@gmicol clone("Zoom")

#@gmicol _<b>Degradations</b>
#----------------------------

#@gmicol clone("Blur [angular]")
#@gmicol clone("Blur [depth-of-field]")
#@gmicol clone("Blur [gaussian]")
#@gmicol clone("Blur [glow]")
#@gmicol clone("Blur [linear]")
#@gmicol clone("Blur [radial]")
#@gmicol clone("Dirty")
#@gmicol clone("Lomo")
#@gmicol clone("Noise [additive]")
#@gmicol clone("Noise [spread]")
#@gmicol clone("Old-movie stripes")
#@gmicol clone("Oldschool 8bits")
#@gmicol clone("Random shade stripes")
#@gmicol clone("Scanlines")
#@gmicol clone("Tilt shift")
#@gmicol clone("Visible watermark")

#@gmicol _<b>Details</b>
#-----------------------

#@gmicol clone("Details equalizer")
#@gmicol clone("Freaky details")
#@gmicol clone("Local contrast enhancement")
#@gmicol clone("Local normalization")
#@gmicol clone("Local variance normalization")
#@gmicol clone("Mighty details")
#@gmicol clone("Sharpen [deblur]")
#@gmicol clone("Sharpen [gold-meinel]")
#@gmicol clone("Sharpen [inverse diffusion]")
#@gmicol clone("Sharpen [octave sharpening]")
#@gmicol clone("Sharpen [richardson-lucy]")
#@gmicol clone("Sharpen [shock filters]")
#@gmicol clone("Sharpen [unsharp mask]")
#@gmicol clone("Simple local contrast")
#@gmicol clone("Texture enhance")
#@gmicol clone("Tone mapping")
#@gmicol clone("Tone mapping [fast]")
#@gmicol clone("Yag effect")

#@gmicol _<b>Film emulation</b>
#------------------------------

#@gmicol clone("Add grain")
#@gmicol clone("B&amp;W films")
#@gmicol clone("Grain")
#@gmicol clone("Instant [consumer]")
#@gmicol clone("Instant [pro]")
#@gmicol clone("Negative [color]")
#@gmicol clone("Negative [new]")
#@gmicol clone("Negative [old]")
#@gmicol clone("Slide [color]")
#@gmicol clone("Various")
#@gmicol clone("B&amp;W films - collage")
#@gmicol clone("Instant - collage [consumer]")
#@gmicol clone("Instant - collage [pro]")
#@gmicol clone("Negative - collage [color]")
#@gmicol clone("Negative - collage [new]")
#@gmicol clone("Negative - collage [old]")
#@gmicol clone("Slide - collage [color]")
#@gmicol clone("Various - collage")

#@gmicol _<b>Frames</b>
#-----------------------

#@gmicol clone("Droste")
#@gmicol clone("Frame [blur]")
#@gmicol clone("Frame [cube]")

#@gmicol clone("Frame [fuzzy]")
#@gmicol : thumbnail_parameters = 60,60,10,1,255,255,255,255

#@gmicol clone("Frame [painting]")
#@gmicol clone("Frame [pattern]")
#@gmicol clone("Frame [regular]")
#@gmicol clone("Frame [round]")
#@gmicol clone("Old photograph")
#@gmicol clone("Polaroid")
#@gmicol clone("Tunnel")
#@gmicol clone("Vignette")

#@gmicol _<b>Lights &amp; Shadows</b>
#------------------------------------

#@gmicol clone("Burn")
#@gmicol clone("Contrast swiss mask")
#@gmicol clone("Drop shadow")
#@gmicol clone("Equalize shadow")
#@gmicol clone("Light glow")
#@gmicol clone("Light patch")
#@gmicol clone("Light rays")
#@gmicol clone("Relief light")
#@gmicol clone("Shadow patch")

#@gmicol _<b>Patterns</b>
#------------------------

#@gmicol clone("Bayer filter")
#@gmicol clone("Box fitting")
#@gmicol clone("Canvas")
#@gmicol clone("Canvas texture")
#@gmicol clone("Cracks")
#@gmicol clone("Crystal")
#@gmicol clone("Halftone")
#@gmicol clone("Hearts")
#@gmicol clone("Lava")
#@gmicol clone("Marble")
#@gmicol clone("Mineral mosaic")
#@gmicol clone("Mosaic")
#@gmicol clone("Op art")
#@gmicol clone("Paper texture")
#@gmicol clone("Plaid")
#@gmicol clone("Random color ellipses")
#@gmicol clone("Resynthetize texture")
#@gmicol clone("Seamless turbulence")
#@gmicol clone("Shock waves")
#@gmicol clone("Sponge")
#@gmicol clone("Stained glass")
#@gmicol clone("Stencil")
#@gmicol clone("Strip")
#@gmicol clone("Tetris")
#@gmicol clone("Turbulence")
#@gmicol clone("Weave")
#@gmicol clone("Whirls")

#@gmicol _<b>Rendering</b>
#-------------------------

#@gmicol clone("3d blocks")
#@gmicol clone("3d colored object")
#@gmicol clone("3d elevation")
#@gmicol clone("3d extrusion")
#@gmicol clone("3d image object")
#@gmicol clone("3d lathing")
#@gmicol clone("3d random objects")
#@gmicol clone("Ball")
#@gmicol clone("Circle art")
#@gmicol clone("Cupid")
#@gmicol clone("Equation plot [parametric]")
#@gmicol clone("Equation plot [y=f(x)]")
#@gmicol clone("Gradient [corners]")
#@gmicol clone("Gradient [custom shape]")
#@gmicol clone("Gradient [linear]")
#@gmicol clone("Gradient [radial]")
#@gmicol clone("Heart")
#@gmicol clone("Lightning")
#@gmicol clone("Lissajous")
#@gmicol clone("Mandelbrot-julia sets")
#@gmicol clone("Maze")
#@gmicol clone("Plasma")
#@gmicol clone("Polka dots")
#@gmicol clone("Quick copyright")
#@gmicol clone("Rainbow")

#@gmicol RGB distribution : gmicol_rgb_distribution, gmicol_rgb_distribution_preview
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/19/2012</i>.</small>")
_gmicol_rgb_distribution :
  -distribution3d -colorcube3d -p3d[-1] 1 -+3d
  -repeat 4
    --snapshot3d[0] $1,0.9,255
    -r3d[0] 0,1,0.2,90
  -done
  -rm[0] -autocrop -- 255
  -r @{-max_wh},1,3,0,0,0.5,0.5 -+ 255 -frame 5,5,255 -frame 1,1,0 -append_tiles ,

gmicol_rgb_distribution :
  -_gmicol_rgb_distribution 512

gmicol_rgb_distribution_preview :
  -_gmicol_rgb_distribution 320

#@gmicol clone("Rorschach")
#@gmicol clone("Shade bobs")
#@gmicol clone("Sierpinski triangle")
#@gmicol clone("Snowflake")
#@gmicol clone("Spiral")
#@gmicol clone("Stars")
#@gmicol clone("Superformula")
#@gmicol clone("Truchet")

#@gmicol _<b>Repair</b>
#----------------------

#@gmicol clone("Bayer reconstruction")
#@gmicol clone("Deinterlace")
#@gmicol clone("Inpaint [diffusion]")
#@gmicol clone("Inpaint [holes]")
#@gmicol clone("Inpaint [patch-based]")
#@gmicol clone("Smooth [perona-malik]")
#@gmicol clone("Inpaint [solidify]")
#@gmicol clone("Red-eye attenuation")
#@gmicol clone("Remove hot pixels")
#@gmicol clone("Smooth [anisotropic]")
#@gmicol clone("Smooth [bilateral]")
#@gmicol clone("Smooth [guided]")
#@gmicol clone("Smooth [diffusion]")
#@gmicol clone("Smooth [mean-curvature]")
#@gmicol clone("Smooth [median]")
#@gmicol clone("Smooth [nlmeans]")
#@gmicol clone("Smooth [patch-based]")
#@gmicol clone("Smooth [selective gaussian]")
#@gmicol clone("Smooth [skin]")
#@gmicol clone("Smooth [thin brush]")
#@gmicol clone("Smooth [total variation]")
#@gmicol clone("Smooth [wavelets]")
#@gmicol clone("Unstrip")
#@gmicol clone("Upscale [diffusion]")
#@gmicol clone("Upscale [scale2x]")

#@gmicol _<b>Sequences</b>
#-------------------------

#@gmicol 3d elevation : gmicol_animate_elevation3d, gmicol_animate_elevation3d_preview(1)
#@gmicol : Frames = _int(10,2,72)
#@gmicol : note = note{"\n<b>Global parameters :</b>"}
#@gmicol : Factor = float(100,-1000,1000)
#@gmicol : Smoothness = float(1,0,10)
#@gmicol : Width = _int(256,8,512)
#@gmicol : Height = _int(256,8,512)
#@gmicol : Rendering = choice(2,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gmicol : note = note{"\n<b>Starting parameters :</b>"}
#@gmicol : Size = float(0.8,0,3)
#@gmicol : X-angle = float(35,0,360)
#@gmicol : Y-angle = float(0,0,360)
#@gmicol : Z-angle = float(0,0,360)
#@gmicol : FOV = float(45,1,90)
#@gmicol : X-light = float(0,-100,100)
#@gmicol : Y-light = float(0,-100,100)
#@gmicol : Z-light = float(-100,-100,0)
#@gmicol : Specular lightness = float(0.5,0,1)
#@gmicol : Specular shininess = float(0.7,0,3)
#@gmicol : note = note{"\n<b>Ending parameters :</b>"}
#@gmicol : Size = float(0.8,0,3)
#@gmicol : X-angle = float(35,0,1440)
#@gmicol : Y-angle = float(0,0,1440)
#@gmicol : Z-angle = float(360,0,1440)
#@gmicol : FOV = float(45,1,90)
#@gmicol : X-light = float(0,-100,100)
#@gmicol : Y-light = float(0,-100,100)
#@gmicol : Z-light = float(-100,-100,0)
#@gmicol : Specular lightness = float(0.5,0,1)
#@gmicol : Specular shininess = float(0.7,0,3)
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/11/2012</i>.</small>")
gmicol_animate_elevation3d :
  -_gimp_elevation3d ${2-3}
  -animate gimp_render3d,"${4-5},${7-16},$6",\
                         "${4-5},${17-26},$6",$1
  -o $_output.gif,10
  -rm

gmicol_animate_elevation3d_preview :
  -gimp_animate_elevation3d_preview $1,1,0,\"\",${2--1}

#@gmicol 3d extrusion : gmicol_animate_extrude3d, gmicol_animate_extrude3d_preview(1)
#@gmicol : Frames = _int(4,2,20)
#@gmicol : note = note{"\n<b>Global parameters :</b>"}
#@gmicol : Depth = float(10,1,256)
#@gmicol : Resolution = int(512,1,1024)
#@gmicol : Smoothness = float(0.6,0,3)
#@gmicol : Width = _int(128,8,256)
#@gmicol : Height = _int(128,8,256)
#@gmicol : Rendering = choice(4,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gmicol : note = note{"\n<b>Starting parameters :</b>"}
#@gmicol : Size = float(0.8,0,3)
#@gmicol : X-angle = float(35,0,360)
#@gmicol : Y-angle = float(0,0,360)
#@gmicol : Z-angle = float(0,0,360)
#@gmicol : FOV = float(45,1,90)
#@gmicol : X-light = float(0,-100,100)
#@gmicol : Y-light = float(0,-100,100)
#@gmicol : Z-light = float(-100,-100,0)
#@gmicol : Specular lightness = float(0.5,0,1)
#@gmicol : Specular shininess = float(0.7,0,3)
#@gmicol : note = note{"\n<b>Ending parameters :</b>"}
#@gmicol : Size = float(0.8,0,3)
#@gmicol : X-angle = float(35,0,1440)
#@gmicol : Y-angle = float(360,0,1440)
#@gmicol : Z-angle = float(0,0,1440)
#@gmicol : FOV = float(45,1,90)
#@gmicol : X-light = float(0,-100,100)
#@gmicol : Y-light = float(0,-100,100)
#@gmicol : Z-light = float(-100,-100,0)
#@gmicol : Specular lightness = float(0.5,0,1)
#@gmicol : Specular shininess = float(0.7,0,3)
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/11/2012</i>.</small>")
gmicol_animate_extrude3d :
  -gimp_animate_extrude3d $1,1,0,\"\",${2--1}

gmicol_animate_extrude3d_preview :
  -gimp_animate_extrude3d_preview $1,1,0,\"\",${2--1}

#@gmicol 3d image object : gmicol_animate_imageobject3d, gmicol_animate_imageobject3d_preview(1)
#@gmicol : Frames = _int(4,2,20)
#@gmicol : note = note{"\n<b>Global parameters :</b>"}
#@gmicol : Type = choice{1,"Plane","Cube","Pyramid","Sphere","Torus","Gyroid","Weird","Cup","Rubik"}
#@gmicol : Width = _int(128,1,256)
#@gmicol : Height = _int(128,1,256)
#@gmicol : Rendering = choice(4,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gmicol : note = note{"\n<b>Starting parameters :</b>"}
#@gmicol : Size = float(0.5,0,3)
#@gmicol : X-angle = float(57,0,360)
#@gmicol : Y-angle = float(41,0,360)
#@gmicol : Z-angle = float(21,0,360)
#@gmicol : FOV = float(45,1,90)
#@gmicol : X-light = float(0,-100,100)
#@gmicol : Y-light = float(0,-100,100)
#@gmicol : Z-light = float(-100,-100,0)
#@gmicol : Specular lightness = float(0.5,0,1)
#@gmicol : Specular shininess = float(0.7,0,3)
#@gmicol : note = note{"\n<b>Ending parameters :</b>"}
#@gmicol : Size = float(0.5,0,3)
#@gmicol : X-angle = float(57,0,1440)
#@gmicol : Y-angle = float(401,0,1440)
#@gmicol : Z-angle = float(21,0,1440)
#@gmicol : FOV = float(45,1,90)
#@gmicol : X-light = float(0,-100,100)
#@gmicol : Y-light = float(0,-100,100)
#@gmicol : Z-light = float(-100,-100,0)
#@gmicol : Specular lightness = float(0.5,0,1)
#@gmicol : Specular shininess = float(0.7,0,3)
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/11/2012</i>.</small>")
gmicol_animate_imageobject3d :
  -gimp_animate_imageobject3d $1,1,0,\"\",${2--1}

gmicol_animate_imageobject3d_preview :
  -gimp_animate_imageobject3d_preview $1,1,0,\"\",${2--1}

#@gmicol 3d text pointcloud : gimp_text_pointcloud3d, gimp_text_pointcloud3d_preview
#@gmicol : Frames = _int(9,1,20)
#@gmicol : 1st text = text("G'MIC")
#@gmicol : 2nd text = text("Rocks!")
#@gmicol : Smoothness = float(1,0,5)
#@gmicol : Color = color(200,220,255)
#@gmicol : Background = color(255,255,255,255)
#@gmicol : X-shadow= float(2,0,10)
#@gmicol : Y-shadow= float(2,0,10)
#@gmicol : Shadow smoothness = float(1,0,5)
#@gmicol : Stationary frames = _int(1,1,32)
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/11/2012</i>.</small>")

#@gmicol Edges on fire : gimp_fire_edges, gimp_fire_edges_preview(0)
#@gmicol : Edges = float(0.7,0,3)
#@gmicol : Attenuation = float(0.25,0,1)
#@gmicol : Smoothness = float(0.5,0,5)
#@gmicol : Threshold = float(25,0,100)
#@gmicol : sep = separator()
#@gmicol : Number of frames = _int(9,2,20)
#@gmicol : Starting frame = int(5,0,199)
#@gmicol : Frame skip = _int(0,0,20)
#@gmicol : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>10/11/2012</i>.</small>")

#@gmicol Lava lamp : gimp_lavalampbw, gimp_lavalampbw_preview(0)
#@gmicol : Number of key-frames = _int(3,2,50)
#@gmicol : Number of inter-frames = _int(3,2,100)
#@gmicol : Smooth looping = _bool(1)
#@gmicol : sep = separator()
#@gmicol : Resolution = float(20,1,100)
#@gmicol : Size = float(2,0,30)
#@gmicol : Smoothness = _float(0.01,0,1)
#@gmicol : Transparent background = bool(0)

#@gmicol _<b>Spectral filters</b>
#--------------------------------

#@gmicol clone("Bandpass")
#@gmicol clone("Fourier analysis")
#@gmicol clone("Fourier transform")
#@gmicol clone("Fourier watermark")

# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC custom commands)
